<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ARM64 | Nuoen's Blog</title><meta name="author" content="nuoen"><meta name="copyright" content="nuoen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CPSR实现金丝雀机制，防止栈溢出libnativelib.so:0000007E929D3B90 MRS             X8, #3, c13, c0, #2libnativelib.so:0000007E929D3B94 LDR             X8, [X8,#0x28]li"><link rel="shortcut icon" href="/Blog/img/favicon.png"><link rel="canonical" href="https://nuoen.github.io/Blog/2023/12/28/arm/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/Blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ARM64',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-29 22:10:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/Blog/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/Blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/Blog/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/Blog/" title="Nuoen's Blog"><span class="site-name">Nuoen's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ARM64</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-28T12:55:47.614Z" title="发表于 2023-12-28 20:55:47">2023-12-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-29T14:10:04.548Z" title="更新于 2025-09-29 22:10:04">2025-09-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ARM64"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="CPSR"><a href="#CPSR" class="headerlink" title="CPSR"></a>CPSR</h3><p>实现金丝雀机制，防止栈溢出<br>libnativelib.so:0000007E929D3B90 MRS             X8, #3, c13, c0, #2<br>libnativelib.so:0000007E929D3B94 LDR             X8, [X8,#0x28]<br>libnativelib.so:0000007E929D3B98 STUR            X8, [X29,#var_8]</p>
<p>libnativelib.so:0000007E929D3CBC MRS             X8, #3, c13, c0, #2<br>libnativelib.so:0000007E929D3CC0 LDR             X8, [X8,#0x28]<br>libnativelib.so:0000007E929D3CC4 LDUR            X9, [X29,#var_8]<br>libnativelib.so:0000007E929D3CC8 SUBS            X8, X8, X9<br>libnativelib.so:0000007E929D3CCC B.NE            loc_7E929D3CE0</p>
<p>//<a target="_blank" rel="noopener" href="https://cataloc.gitee.io/blog/2021/04/24/Android%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84Canary%E6%9C%BA%E5%88%B6/">https://cataloc.gitee.io/blog/2021/04/24/Android%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84Canary%E6%9C%BA%E5%88%B6/</a></p>
<h3 id="LDR"><a href="#LDR" class="headerlink" title="LDR"></a>LDR</h3><p><code>LDR</code> 和 <code>LDUR</code> 都是ARM汇编中用于加载（Load）数据的指令，但它们有一些重要的区别：</p>
<ol>
<li><p>LDR（Load Register）：</p>
<ul>
<li><code>LDR</code> 指令用于从内存中加载数据，并将其存储到通用寄存器中。</li>
<li><code>LDR</code> 指令可以加载各种数据类型，包括字节、半字、字、双字以及浮点数等。</li>
<li><code>LDR</code> 指令执行标准的内存访问，根据所加载数据的大小，可能会引发数据对齐异常（例如，尝试加载未对齐的数据）。</li>
<li><code>LDR</code> 指令通常用于访问常规内存，如堆、栈或全局数据。</li>
</ul>
</li>
<li><p>LDUR（Load Register Unprivileged）：</p>
<ul>
<li><code>LDUR</code> 指令是ARM64架构引入的一种指令，用于无权限加载数据，它通常在用户模式下使用。</li>
<li><code>LDUR</code> 指令具有无权限访问内存的特性，因此即使在特权级别较低（如用户模式）也可以使用。</li>
<li><code>LDUR</code> 指令在加载数据时会自动处理数据对齐，不会引发数据对齐异常，这是 <code>LDUR</code> 与 <code>LDR</code> 的一个重要区别。</li>
<li><code>LDUR</code> 指令也可以加载各种数据类型，但它在无权限访问的情况下更有用。</li>
</ul>
</li>
</ol>
<p>总结来说，主要区别在于权限和数据对齐处理：</p>
<ul>
<li><code>LDR</code> 是标准的加载指令，用于加载数据到通用寄存器，通常在特权级别较高的情况下使用。</li>
<li><code>LDUR</code> 是一种无权限加载指令，它可以在用户模式下使用，且具有自动数据对齐的功能，因此更适合无权限访问的情况。</li>
</ul>
<p>选择使用哪个指令取决于特定的应用场景和访问内存的权限要求。</p>
<p><code>LDRB</code> 是ARM汇编中的指令，用于从内存中加载一个字节（8位数据）并将其存储到通用寄存器中。<code>LDRB</code> 的名称表示 “Load Byte”，它执行以下操作：</p>
<ol>
<li>从指定的内存地址读取一个字节的数据。</li>
<li>将读取的字节数据零扩展到32位，然后将其存储在目标通用寄存器中。</li>
</ol>
<p><code>LDRB</code> 指令的通用格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDRB Rd, [Rn, #offset]</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>Rd</code> 是目标通用寄存器，用于存储加载的字节数据。</li>
<li><code>Rn</code> 是基址寄存器，包含了内存地址的基址。</li>
<li><code>offset</code> 是一个偏移量，指定要加载的内存地址相对于基址寄存器 <code>Rn</code> 的偏移。</li>
</ul>
<p>举个例子，如果要从内存地址 <code>R0 + 8</code> 处加载一个字节，然后将其存储到通用寄存器 <code>R1</code> 中，可以使用以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDRB R1, [R0, #8]</span><br></pre></td></tr></table></figure>

<p>这条指令将加载地址为 <code>R0 + 8</code> 处的一个字节，将其零扩展为32位，然后将其存储在 <code>R1</code> 寄存器中。<code>LDRB</code> 通常用于加载单个字节的数据，例如字符或字节型的数据。</p>
<h3 id="MRS"><a href="#MRS" class="headerlink" title="MRS"></a>MRS</h3><h1 id="ARM64-学习："><a href="#ARM64-学习：" class="headerlink" title="ARM64 学习："></a>ARM64 学习：</h1><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="1-ARMv8特色："><a href="#1-ARMv8特色：" class="headerlink" title="1.ARMv8特色："></a>1.ARMv8特色：</h3><pre><code>* (1) 超大的物理地址空间(Large Physical Address)，提供超过4GB物理内存的访问；
    (2) 64位宽的虚拟地址空间(64-bit Virtual Addresing);
    (3) 提供31个64位宽的通用寄存器，可以减少对栈的访问，从而提高性能；
    (4) 提供16KB和64KB的页面，有助于降低TLB的未命中率(miss rate);
    (5) 全新的异常处理模型，有助于降低操作系统和虚拟化的实现复杂度；
    (6)全新的加载-获取，存储-释放指令(Load-Acquire, Store-Release Instructions)。专门为C++11，C11以及Java内存模型设计；

2 执行状态
    AArch64: 64位的执行状态：
    (1) 提供31个64位通用寄存器；
    (2) 提供64位的程序计数器寄存器PC、栈指针寄存器SP以及异常链接寄存器；
    (3) 提供A64指令集；
    (4)定义ARMv8异常模型，支持4个异常等级，EL0~EL3;
    (5)提供64位的内存模型；
    (6)定义一组处理器状态(PSTATE)用来保存PE的状态；
    AArch32: 32位的执行状态：
    (1) 提供13个632位通用寄存器, 32位的程序计数寄存器PC、栈指针寄存器SP、链接寄存器；
    (2) 提供A32,T32指令集；
    (3)定义ARMv7异常模型，基于PE模式并映射到ARMv8的异常模型中；
    (4)提供32位虚拟内存访问机制；
    (5)定义一组处理器状态(PSTATE)用来保存PE的状态；

3 ARMv8包含的寄存器
    3.1 ARMv8包含31个通用寄存器
        AArch64运行状态支持31个通用寄存器X0~X30，AArch32状态支持16个32位通用寄存器；
        X0~X30：通用寄存器；
        SP: 栈指针寄存器；
        PC：程序计数寄存器；
        其中：x30寄存器（lr寄存器）
            x30寄存器是链接寄存器，用于保存函数的返回地址，当ret指令执行时，会寻找x30寄存器中的值，作为返回地址；
            x29寄存器是fp寄存器，用于保存函数的栈帧指针，指向函数的栈帧起始地址，即栈底地址；

    3.2 系统寄存器
        系统寄存器提供控制和状态，在AArch64状态下，很多系统寄存器根据不同的异常等级提供不同的变种寄存器：
        &lt;reg_name&gt;_ELx, x is 0,1,2, or 3
        比如SP_EL0表示在EL0下的栈指针寄存器；

    3.3 SIMD/FP寄存器：
        支持128bit寄存器

    3.4 特殊寄存器
        XZE

4.数据类型
    Byte: 8bit
    Halfword: 16bit
    Word: 32bit
    Doubleworld: 64bit
    Quadword: 128bit

5.异常模型
    Exception Levels确定了处理器当前运行的特权级别，类似ARMv7架构中的特权等级
    EL0: 用户特权，用于运行普通应用程序；
    EL1: 系统特权，通常用于运行操作系统；
    EL2: 运行虚拟化扩展的虚拟监控程序(Hypervisor);
    EL3: 运行安全世界中的安全监控器(Secure Monitor);
    异常级别    应用场景    安全世界
    EL0    APP    Secure OS
    EL1    Guest OS    sECURE OS
    EL2    Hypervisor    Secure Hypervisor
    EL3    Secure—&gt;    –&gt;monitor

6.A64汇编指令介绍：
    1.A64指令集只能运行在aarch64环境中；
    2.所有的A64汇编指令都是32bit宽；
    3.A64支持全部大写或小写书写方式；
    4.寄存器命名,
    Name    size    Encoding    Descriptio
    Wn    32bits    0~30    General-purpose register0~30
    Xn    64bit    0~30    General-purpose register0~30
    WZR    32bits    31    Zero register
    XZR    64bit    31    Zero register
    WSP    32bits    31    Current stack pointer
    SP    64bit    31    Current stack pointer

7.A64指令分类
    内存加载和存储指令：
    多字节内存加载和存储：
    算术和移位指令：
    位操作指令：
    条件操作：
    跳转指令：
    独占访存指令：
    内存屏障指令：
    异常处理指令：
    系统寄存器访问指令：
</code></pre>
<h2 id="二、ARM-直接编译-s-文件"><a href="#二、ARM-直接编译-s-文件" class="headerlink" title="二、ARM 直接编译.s 文件"></a>二、ARM 直接编译.s 文件</h2><p>cd /Users/nuoen/Library/Android/sdk/ndk/25.2.9519653/toolchains/llvm/prebuilt/<br>目录更新：<br>/Users/nuoen/Library/Android/sdk/ndk/27.0.12077973/toolchains/llvm/prebuilt/darwin-x86_64/bin</p>
<p>直接编译.s 文件，/Users/nuoen/Documents/AndroidSecurity/fridaScript/arm64.s<br>android 8.1 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clang -target aarch64-linux-android26 -v  ~/Documents/AndroidSecurity/fridaScript/arm64.s -o ~/Documents/AndroidSecurity/fridaScript/arm64android --static -ffunction-sections -fdata-sections -Wl,--gc-sections </span><br></pre></td></tr></table></figure>
<p>android 13 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clang -target aarch64-linux-android31 -v  ~/Documents/AndroidSecurity/fridaScript/arm64.s -o ~/Documents/AndroidSecurity/fridaScript/arm64android --static</span><br></pre></td></tr></table></figure>
<p>其中：<br>–static 主要解决 : ld: error: relocation R_AARCH64_ABS64 cannot be used against local symbol; recompile with -fPIC<br>-ffunction-sections -fdata-sections -Wl,–gc-sections 主要解决:<br>executable’s TLS segment is underaligned: alignment is 8, needs to be at least 64 for ARM64 Bionic<br><a target="_blank" rel="noopener" href="https://github.com/termux/termux-packages/issues/8273">https://github.com/termux/termux-packages/issues/8273</a></p>
<p>直接编译.cpp 文件 为可执行文件<br>./clang++  -target aarch64-linux-android32   ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.cpp  -o ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest</p>
<p>编译.cpp 文件为 .s文件<br>./clang++  -target aarch64-linux-android32  -S  ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.cpp  -o ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.s<br>利用lldb远程调试<br>手机端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./lldb-server p --server --listen unix-abstract:///data/local/tmp/debug.sock</span><br></pre></td></tr></table></figure>
<p>调试端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ lldb-&lt;version&gt;</span><br><span class="line">$ platform list  # 查看lldb可以连接的平台</span><br><span class="line">$ platform select remote-android</span><br><span class="line">$ platform status # 查看平台状态</span><br><span class="line">$ platform connect unix-abstract-connect:///data/local/tmp/debug.sock</span><br></pre></td></tr></table></figure>
</details>

<p>A64的存储和加载指令<br>ldr和str指令<br>ARMv8也是基于指令加载和存储的架构，即不能直接操作内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR &lt;reg_dst&gt;,&lt;addr&gt; //把存储器地址的数据加载到目的寄存器中</span><br><span class="line">STR &lt;reg_src&gt;,&lt;addr&gt; //把原寄存器的值，存储到内存中</span><br></pre></td></tr></table></figure>
<p>ld指令寻址1：地址偏移模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr Xd,[Xn,$offset]</span><br></pre></td></tr></table></figure>


<p>std:string内存结构</p>
<h3 id="ARM-PIC模式下的符号地址获取"><a href="#ARM-PIC模式下的符号地址获取" class="headerlink" title="ARM PIC模式下的符号地址获取"></a>ARM PIC模式下的符号地址获取</h3><h4 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.text:00001C28 loc_1C28                                ; CODE XREF: JNI_OnLoad+30↑j</span><br><span class="line">.text:00001C28                 SUB     R5, SP, #8</span><br><span class="line">.text:00001C2C                 MOV     SP, R5</span><br><span class="line">.text:00001C30                 LDR     R0, =(_GLOBAL_OFFSET_TABLE_ - 0x1C48)</span><br><span class="line">.text:00001C34                 LDR     R1, =(sub_16A4 - 0x5FBC)</span><br><span class="line">.text:00001C38                 MOV     R3, #0</span><br><span class="line">.text:00001C3C                 STR     R8, [R5]</span><br><span class="line">.text:00001C40                 ADD     R0, PC, R0      ; _GLOBAL_OFFSET_TABLE_</span><br><span class="line">.text:00001C44                 ADD     R2, R1, R0      ; sub_16A4</span><br><span class="line">.text:00001C48                 ADD     R0, R9, R0      ; unk_6290</span><br><span class="line">.text:00001C4C                 MOV     R1, #0</span><br><span class="line">.text:00001C50                 LDR     R7, [R0,#(off_62B4 - 0x6290)]</span><br><span class="line">.text:00001C54                 SUB     R0, R11, #-var_20</span><br><span class="line">.text:00001C58                 BLX     R7</span><br><span class="line">.text:00001C5C                 BL      sub_17F4</span><br><span class="line">.text:00001C60                 LDR     R0, [R4]</span><br><span class="line">.text:00001C64                 MOV     R6, #4</span><br><span class="line">.text:00001C68                 MOV     R1, R5</span><br><span class="line">.text:00001C6C                 ORR     R6, R6, #0x10000</span><br><span class="line">.text:00001C70                 MOV     R2, R6</span><br><span class="line">.text:00001C74                 LDR     R3, [R0,#0x18]</span><br><span class="line">.text:00001C78                 MOV     R0, R4</span><br><span class="line">.text:00001C7C                 BLX     R3</span><br><span class="line">.text:00001C80                 CMP     R0, #0</span><br><span class="line">.text:00001C84                 MOVNE   R6, #0xFFFFFFFF</span><br><span class="line">.text:00001C88                 MOV     R0, R6</span><br><span class="line">.text:00001C8C                 SUB     SP, R11, #0x18</span><br><span class="line">.text:00001C90                 POP     &#123;R4-R9,R11,PC&#125;</span><br></pre></td></tr></table></figure>
<p>PIC截取片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, =(_GLOBAL_OFFSET_TABLE_ - K)   ; 取“GOT 相对 PC 的偏移”这个常量</span><br><span class="line">ADD R0, PC, R0                         ; R0 ← 运行时的 GOT 基址</span><br><span class="line">LDR R1, =(sub_16A4 - C)                ; R1 ← 链接时放进字面池的“相对偏移”</span><br><span class="line">ADD R2, R1, R0                         ; R2 ← GOT基址 + 偏移 = sub_16A4 的真实地址</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步：<code>LDR R0, =(_GLOBAL_OFFSET_TABLE_ - 0x1C48) + ADD R0, PC, R0</code>—— 这会把 <code>_GLOBAL_OFFSET_TABLE_ </code>的运行时基址（GOT base）计算到 R0。这是典型的加载 GOT 基址的 idiom。</li>
<li>第二步：<code>LDR R1, =(sub_16A4 - 0x5FBC) </code>—— 这不是直接把<code>sub_16A4 - 0x5FBC</code>当作最终地址；而是把一个编译/链接阶段生成的常量（通常是“符号相对于某个参考基址的偏移”）加载到 R1。</li>
<li>第三步：<code>ADD R2, R1, R0 </code>—— 把上面的偏移（R1）和运行时的 GOT/基址（R0）相加，得到 <code>sub_16A4</code> 的实际运行时地址（放到 R2）。</li>
</ul>
<h4 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h4><p><strong>静态</strong> 指的是目标相对于so的地址<br><strong>动态</strong> 指的是so链接到程序后，运行时的地址</p>
<ul>
<li><strong><em>GLOBAL_OFFSET_TABLE</em></strong> 静态的GOT地址</li>
<li><strong>0x1C48</strong>  静态PC的值</li>
<li><strong>LDR R0, =(<em>GLOBAL_OFFSET_TABLE</em> - 0x1C48)</strong>  静态的GOT - 静态PC的值 =&gt; GOT相当于PC的偏移</li>
<li><strong>ADD R0, PC, R0</strong> GOT相对于PC的偏移 + 运行时PC值 =&gt;  动态的GOT地址</li>
<li><strong>0x5FBC</strong> <em>GLOBAL_OFFSET_TABLE</em>  GOT表(全局偏移表)相对于so的地址</li>
<li><strong>LDR R1, =(sub_16A4 - 0x5FBC)</strong> 计算静态符号距离静态GOT偏移</li>
<li><strong>ADD R2, R1, R0</strong>  R1: 动态GOT地址， R0:sub_16A4 相对于GOT的偏移 </li>
</ul>
<p>这里的R2 就是sub_16A4运行时的地址</p>
<h4 id="比喻："><a href="#比喻：" class="headerlink" title="比喻："></a>比喻：</h4><p>把 sub_16A4 - 0x5FBC 想成书架上的“书的编号相对于书柜左边缘的位置”，GOT_base/module base 就是“书柜的左边缘在房间的真实坐标”。要拿到书的房间内真实坐标，你要把“书相对书柜的编号（偏移）”加上“书柜在房间里的坐标（基址）”。IDA 把“书的编号写成 book - 0x5FBC”来表示它是个相对量。</p>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:00001C48                 ADD     R0, R9, R0      ; unk_6290</span><br><span class="line">.text:00001C50                 LDR     R7, [R0,#(off_62B4 - 0x6290)]</span><br></pre></td></tr></table></figure>
<p>1C48这里，R0 = unk_6290相对于GOT的静态偏移 + GOT的动态地址<br>1C50这里，R7 = R0 一定是unk_6290的动态地址 + 偏移off_62B4相对于unk_6290的静态偏移 =&gt; off_62B4的动态地址</p>
<h4 id="名词："><a href="#名词：" class="headerlink" title="名词："></a>名词：</h4><ol>
<li>什么是 “link-time 常量（相对某个基址的偏移）”<br> •    link-time 常量：由链接器在链接时计算并写入到代码/字面池/重定位记录中的一个数值。它经常不是“绝对地址”，而是一个表达式的结果，例如“符号相对某个锚点（基址）的偏移”。在 ELF 里，这由重定位条目（relocation）描述：运行时装载器会按“符号值 + 加数（addend）+（可选）PC/基址”的公式把它补全/应用到目标位置。 ￼<br> •    在 ARM 上，LDR Rd, =expr 这种伪指令常把 32 位常量放进字面池（literal pool），再用 PC 相对的 LDR 取出来。这个 expr 可以是“符号 - 锚点”这样的相对量，IDA 就会把它渲染成你看到的样子。 ￼</li>
</ol>
<p>直观理解：链接器先把“某函数相对于某基准的偏移”记到常量区；到运行时，再把“偏移 + （运行时算出来的）基址”相加，得到真实地址。</p>
<p>⸻</p>
<ol start="2">
<li>什么是 GOT / <em>GLOBAL_OFFSET_TABLE</em> 的“基址”<br> •    GOT（Global Offset Table，全局偏移表）是共享库/PIE 用来在运行时保存“需要绝对地址的全局数据/函数地址”的一个表。动态链接器会把它填好或按需填好（PLT/GOT-PLT）。.got/.got.plt 常配合 PLT 处理外部符号调用。 ￼<br> •    GOT 基址就是该表在当前模块被装载后的起始地址。PIC 代码会先用一小段 PC 相对序列把 GOT 基址算进某寄存器（你片段里是通过 LDR … =(<em>GLOBAL_OFFSET_TABLE</em> - …) + ADD PC, … 这类序列得到的），然后再用“GOT 基址 + 偏移”去拿到真正的目标地址或到 GOT 中继续取绝对地址。 ￼<br> •    在 ARM AAPCS/EABI 模型下，某些平台/编译器会把 R9 指定为 SB（static base） 来当做“位置无关数据的静态基址”，本质也是“先拿到一个基址，再加偏移”。（不同平台对 R9 的角色有差异。） ￼</li>
</ol>
<p>⸻</p>
<ol start="3">
<li>为什么要用 “link-time 偏移 + GOT 基址” 来算地址<br> •    支持位置无关 / ASLR：共享库或 PIE 进程每次装载到的绝对地址可能不同，因此不能在指令里硬编码“绝对地址”。把“相对偏移”写进常量区/重定位里，运行时再与“当前装载得到的基址”相加，就能在任意基址下得到正确的目标地址。 ￼<br> •    ELF 重定位模型：ELF 里普遍采用“S + A (+ P)”一类的重定位计算（S=符号值，A=加数/偏移，P=当前指令位置等），把链接时给出的加数（偏移）与运行时可知的符号/基址组合得到最终值。这正是你看到 “sub_16A4 - 0x5FBC + 运行时基址” 的来源。 ￼<br> •    ARM 汇编生成习惯：编译器用 LDR Rd, =expr 伪指令+字面池存偏移，再通过 ADD 把它与 PC/GOT 基址相加，得到最终地址；IDA 会把字面池里的常量显示成 符号 - 某常量 的形式，容易让人误以为要“真的去减”，其实它只是被选作的锚点表达。 ￼</li>
</ol>
<p>⸻</p>
<h3 id="Thumb-切到-ARM-tunk-跳板"><a href="#Thumb-切到-ARM-tunk-跳板" class="headerlink" title="Thumb 切到 ARM ,tunk/跳板"></a>Thumb 切到 ARM ,tunk/跳板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">text:00086B08 ; =============== S U B R O U T I N E =======================================</span><br><span class="line">.text:00086B08</span><br><span class="line">.text:00086B08 ; Attributes: thunk</span><br><span class="line">.text:00086B08</span><br><span class="line">.text:00086B08 sub_86B08                               ; CODE XREF: sub_16238+A↑p</span><br><span class="line">.text:00086B08                                         ; sub_19F4C+A↑p ...</span><br><span class="line">.text:00086B08                 BX      PC</span><br><span class="line">.text:00086B08 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00086B0A                 ALIGN 4</span><br><span class="line">.text:00086B0C                 CODE32</span><br><span class="line">.text:00086B0C</span><br><span class="line">.text:00086B0C loc_86B0C                               ; CODE XREF: sub_86B08↑j</span><br><span class="line">.text:00086B0C                 LDR     R12, =(sub_11244 - 0x86B18)</span><br><span class="line">.text:00086B10                 ADD     PC, R12, PC     ; sub_11244</span><br><span class="line">.text:00086B10 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00086B14 off_86B14       DCD sub_11244 - 0x86B18 ; DATA XREF: sub_86B08:loc_86B0C↑r</span><br><span class="line">.text:00086B14 ; End of function sub_86B08</span><br><span class="line">.text:00086B14</span><br><span class="line">.text:00086B18                 CODE16</span><br><span class="line">.text:00086B18 ; [00000010 BYTES: COLLAPSED FUNCTION j___umodsi3. PRESS CTRL-NUMPAD+ TO EXPAND]</span><br><span class="line">.text:00086B28</span><br><span class="line">.text:00086B28 ; =============== S U B R O U T I N E =======================================</span><br><span class="line"></span><br><span class="line">// attributes: thunk</span><br><span class="line">int __fastcall sub_86B08(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  return sub_11244(a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳板解释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:00086B08 sub_86B08          ; 被很多地方 BL 调用的“存根”</span><br><span class="line">.text:00086B08    BX      PC      ; 在 Thumb 态执行。BX PC 会“切换指令集”，跳到当前 PC 指向处但把 T 位翻转</span><br><span class="line">.text:00086B0A    ALIGN 4         ; 接下来按 4 字节对齐（ARM 指令对齐）</span><br><span class="line">.text:00086B0C    CODE32          ; 这里开始用 ARM 指令集</span><br><span class="line">.text:00086B0C loc_86B0C:</span><br><span class="line">.text:00086B0C    LDR     R12, =(sub_11244 - 0x86B18)  ; 从字面池取“到 sub_11244 的相对偏移”</span><br><span class="line">.text:00086B10    ADD     PC, R12, PC                  ; PC ← PC + R12  =&gt; 跳去 sub_11244</span><br><span class="line">.text:00086B14 off_86B14 DCD sub_11244 - 0x86B18       ; 字面池，存的就是上面要加载的相对偏移</span><br><span class="line">.text:00086B18    CODE16</span><br><span class="line">; 这里 IDA 注释：j___umodsi3（被折叠的另一段 Thumb 代码）</span><br></pre></td></tr></table></figure>
<h4 id="为什么需要这样绕一下"><a href="#为什么需要这样绕一下" class="headerlink" title="为什么需要这样绕一下"></a>为什么需要这样绕一下</h4><pre><code>•    指令集切换（ARM ↔ Thumb）：调用点（比如 BL sub_86B08）可能在 Thumb 态，但真正的目标函数 sub_11244 在 ARM 态（或距离/可达性问题）。直接跨态跳转需要符合 ABI 规则，linker 会插入这种 veneer 来保证安全切换。
•    位置无关 / 远距跳转：即使同一态，有时因为距离超出分支立即数范围或出于 PIC/ASLR 的需要，linker 也会生成用字面池+ADD PC 的 veneer 来“拼”出实际目标地址。
•    复用存根：同一个 veneer 可能被多个调用点引用（你也看到上面注释里：sub_16238+A、sub_19F4C+A 都引用了它）。
</code></pre>
<h4 id="Veneer-vs-Thunk-对比"><a href="#Veneer-vs-Thunk-对比" class="headerlink" title="Veneer vs Thunk 对比"></a>Veneer vs Thunk 对比</h4><h1 id="Veneer-vs-Thunk-对比-1"><a href="#Veneer-vs-Thunk-对比-1" class="headerlink" title="Veneer vs Thunk 对比"></a>Veneer vs Thunk 对比</h1><h1 id="Veneer-vs-Thunk-对照表（完整版）"><a href="#Veneer-vs-Thunk-对照表（完整版）" class="headerlink" title="Veneer vs Thunk 对照表（完整版）"></a>Veneer vs Thunk 对照表（完整版）</h1><blockquote>
<p>速记：<strong>Veneer = 链接器的“跳板”</strong>（修补指令集/距离/重定位），<strong>Thunk = 编译器的“语义适配器”</strong>（修补 this/调用约定/语言特性）。</p>
</blockquote>
<table>
<thead>
<tr>
<th>维度</th>
<th><strong>Veneer（贴面/跳板）</strong></th>
<th><strong>Thunk（桩/适配桩）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>由 <strong>链接器</strong>自动生成的小段中转代码，用于保证能“正确跳到目标地址”。</td>
<td>由 <strong>编译器</strong>自动生成的小段中转代码，用于“正确完成一次调用的语义”。</td>
</tr>
<tr>
<td><strong>主要动机</strong></td>
<td>① ARM↔Thumb <strong>指令集切换</strong>（interworking）<br>② <strong>分支距离</strong>超出 <code>B/BL</code> 可达范围（long branch）<br>③ <strong>位置无关/PIC/ASLR</strong> 下需要 <strong>PC/GOT 相对</strong>拼地址</td>
<td>① C++ <strong>虚函数/多继承</strong>导致的 <strong>this 指针调整</strong>（adjustor thunk）<br>② <strong>调用约定/ABI</strong> 差异（如 <code>cdecl</code>↔<code>stdcall</code>）<br>③ <strong>闭包/lambda</strong> 捕获桥接、延迟求值等语言特性</td>
</tr>
<tr>
<td><strong>生成阶段/工具</strong></td>
<td><strong>Linker 阶段</strong>（ld/gold/lld 等）</td>
<td><strong>Compiler 阶段</strong>（clang/gcc/msvc 等）</td>
</tr>
<tr>
<td><strong>典型指令形态（ARM32）</strong></td>
<td><code>LDR r12, =target - anchor</code> + <code>ADD pc, r12, pc</code>；<br><code>BX &lt;reg&gt;</code> / <code>BLX &lt;reg&gt;</code> 完成 <strong>切态</strong>；有时引入 <strong>literal pool</strong>。</td>
<td><code>ADD reg, #imm</code> 调整 <code>this</code> / 参数，随后 <code>B/BL</code> 或 <code>JMP</code> 到真实实现；通常不切换指令集，仅做 <strong>寄存器/栈</strong> 轻微改动。</td>
</tr>
<tr>
<td><strong>是否修改参数</strong></td>
<td>一般 <strong>不改参数</strong>，只构造正确的控制流目标（可能切态）。</td>
<td>常 <strong>调整参数/this</strong>，或改变调用约定以匹配真实实现。</td>
</tr>
<tr>
<td><strong>是否有栈帧</strong></td>
<td>通常 <strong>无</strong>（极短，无 prologue/epilogue）。</td>
<td>可能有或无，但经常有 <strong>轻量调整</strong>（不一定建完整栈帧）。</td>
</tr>
<tr>
<td><strong>位置/命名特征</strong></td>
<td>常出现在 <strong>代码段边界/对齐处</strong>；可能被多个调用点共用；ID A 里常标注 “<strong>Attributes: thunk</strong>”（但其语义更接近 veneer）。</td>
<td>靠近类/方法定义或虚表附近；可能被标注为 thunk，并带有带修饰名的符号（C++ 名字整形）。</td>
</tr>
<tr>
<td><strong>与符号/重定位</strong></td>
<td>强依赖 <strong>PC 相对</strong>、<strong>GOT/PLT</strong>、<strong>literal pool</strong>；链接时/装载时完成地址拼接。</td>
<td>与 <strong>语言语义</strong> 与 <strong>对象模型/ABI</strong> 紧密关联，较少依赖 GOT。</td>
</tr>
<tr>
<td><strong>平台分布</strong></td>
<td>ARM/Thumb、AArch64（长跳 veneer）、RISC-V（远距分支）、PowerPC 等常见。</td>
<td>几乎所有支持 OOP/多 ABI 的平台（x86/x64/ARM/ObjC/Swift…）。</td>
</tr>
<tr>
<td><strong>如何识别（逆向）</strong></td>
<td>① 极短、<strong>只做取地址+跳转/切态</strong>；② 包含 <code>BX/BLX</code> 或 <code>ADD pc, reg, pc</code>；③ 紧邻 <strong>字面池</strong>（<code>DCD target - anchor</code>）。</td>
<td>① 有 <strong>this/参数</strong> 调整痕迹；② 紧跟一个真正实现；③ 符号/交叉引用指向某个类成员实现。</td>
</tr>
<tr>
<td><strong>调试/验证要点</strong></td>
<td>单步看 <strong>PC 变化</strong> 与 <strong>T 位（Thumb bit）</strong>；观察 literal pool 值是否等于 <code>target - anchor</code>；确认跳转后是否落到目标函数入口。</td>
<td>单步看 <strong>寄存器/栈</strong> 的调整；确认最终 <code>jmp/call</code> 到真实实现；检查虚表项是否先落到该 thunk。</td>
</tr>
</tbody></table>
<hr>
<h2 id="示例-A：Veneer（ARM32-Interworking-amp-远距跳转）"><a href="#示例-A：Veneer（ARM32-Interworking-amp-远距跳转）" class="headerlink" title="示例 A：Veneer（ARM32 Interworking &amp; 远距跳转）"></a>示例 A：Veneer（ARM32 Interworking &amp; 远距跳转）</h2><pre><code class="asm">; Thumb 态入口（IDA 可能显示为 CODE16）
sub_86B08:
    BX      PC              ; 切到 ARM 态（interworking）
    ALIGN   4
    CODE32
loc_86B0C:
    LDR     r12, =(sub_11244 - 0x86B18)  ; 从字面池取“目标相对偏移”
    ADD     pc, r12, pc                  ; PC ← PC + r12 ⇒ 跳到 sub_11244
off_86B14 DCD sub_11244 - 0x86B18        ; 字面池 / 重定位项

</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://nuoen.github.io/Blog">nuoen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nuoen.github.io/Blog/2023/12/28/arm/">https://nuoen.github.io/Blog/2023/12/28/arm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nuoen.github.io/Blog" target="_blank">Nuoen's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Blog/2023/12/28/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hello World</div></div></a></div><div class="next-post pull-right"><a href="/Blog/2023/05/05/fridaHookJava/" title="frida hook java"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">frida hook java</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/Blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">nuoen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/Blog/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/Blog/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/Blog/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPSR"><span class="toc-number">1.</span> <span class="toc-text">CPSR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LDR"><span class="toc-number">2.</span> <span class="toc-text">LDR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MRS"><span class="toc-number">3.</span> <span class="toc-text">MRS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARM64-%E5%AD%A6%E4%B9%A0%EF%BC%9A"><span class="toc-number"></span> <span class="toc-text">ARM64 学习：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number"></span> <span class="toc-text">一、基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ARMv8%E7%89%B9%E8%89%B2%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">1.ARMv8特色：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ARM-%E7%9B%B4%E6%8E%A5%E7%BC%96%E8%AF%91-s-%E6%96%87%E4%BB%B6"><span class="toc-number"></span> <span class="toc-text">二、ARM 直接编译.s 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ARM-PIC%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%9C%B0%E5%9D%80%E8%8E%B7%E5%8F%96"><span class="toc-number">1.</span> <span class="toc-text">ARM PIC模式下的符号地址获取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">汇编代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">解释：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E5%96%BB%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">比喻：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PS"><span class="toc-number">1.4.</span> <span class="toc-text">PS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">名词：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thumb-%E5%88%87%E5%88%B0-ARM-tunk-%E8%B7%B3%E6%9D%BF"><span class="toc-number">2.</span> <span class="toc-text">Thumb 切到 ARM ,tunk&#x2F;跳板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%99%E6%A0%B7%E7%BB%95%E4%B8%80%E4%B8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">为什么需要这样绕一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Veneer-vs-Thunk-%E5%AF%B9%E6%AF%94"><span class="toc-number">2.2.</span> <span class="toc-text">Veneer vs Thunk 对比</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Veneer-vs-Thunk-%E5%AF%B9%E6%AF%94-1"><span class="toc-number"></span> <span class="toc-text">Veneer vs Thunk 对比</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Veneer-vs-Thunk-%E5%AF%B9%E7%85%A7%E8%A1%A8%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">Veneer vs Thunk 对照表（完整版）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-A%EF%BC%9AVeneer%EF%BC%88ARM32-Interworking-amp-%E8%BF%9C%E8%B7%9D%E8%B7%B3%E8%BD%AC%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">示例 A：Veneer（ARM32 Interworking &amp; 远距跳转）</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Blog/2025/03/29/binder/" title="binder">binder</a><time datetime="2025-03-29T09:20:11.584Z" title="发表于 2025-03-29 17:20:11">2025-03-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Blog/2023/12/28/hello-world/" title="Hello World">Hello World</a><time datetime="2023-12-28T12:55:47.615Z" title="发表于 2023-12-28 20:55:47">2023-12-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Blog/2023/12/28/arm/" title="ARM64">ARM64</a><time datetime="2023-12-28T12:55:47.614Z" title="发表于 2023-12-28 20:55:47">2023-12-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Blog/2023/05/05/fridaHookJava/" title="frida hook java">frida hook java</a><time datetime="2023-05-05T06:15:28.000Z" title="发表于 2023-05-05 14:15:28">2023-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Blog/2023/01/25/allSafe/" title="allSafe">allSafe</a><time datetime="2023-01-25T08:55:12.000Z" title="发表于 2023-01-25 16:55:12">2023-01-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By nuoen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/Blog/js/utils.js"></script><script src="/Blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>