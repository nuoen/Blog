https://blog.csdn.net/thisinnocence/article/details/127931774
安装linux内核
qemu 脚本
```
#!/bin/bash

~/qemu-6.2.0/build/qemu-system-aarch64 \
    -nographic \
    -M virt \
    -cpu cortex-a57 \
    -smp 2 \
    -m 4G \
    -kernel linux-6.7.12/build/arch/arm64/boot/Image \
    -append "nokaslr root=/dev/ram init=/linuxrc console=ttyAMA0 console=ttyS0" \
    -initrd initrd.ext4 \
    -fsdev local,id=fsdev0,path=/home/nuoen/linux-6.7.12/LinuxLearn,security_model=passthrough \
    -device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=host0 \
    -monitor unix:/tmp/qemu-monitor-socket,server,nowait \
    -incoming "exec:cat ./savefile.img"
```
共享空间
```
/mnt # mkdir host
/mnt # mount -t 9p -o trans=virtio,version=9p2000.L host0 /mnt/host
```


进入qemu
```socat UNIX-CONNECT:/tmp/qemu-monitor-socket -```

保存镜像
```(qemu) migrate "exec:cat > ./savefile.img"```
注意：保存镜像时，要先取消共享空间的挂载
```umount /mnt/host```


## 内存管理
1. 高端内存（High Memory）

高端内存（High Memory） 是一种相对于内核空间中的“低端内存”（Low Memory）概念的术语。它指的是一些物理内存区域，特别是在 32 位系统中，由于地址空间的限制，它们无法直接映射到内核的虚拟地址空间中。通常，高端内存是指那些超出了内核直接映射到虚拟地址空间的物理内存区域。
	•	32 位系统的地址空间限制：在传统的 32 位系统中，虚拟地址空间通常只有 4GB，而其中的一部分（通常 3GB）用于用户空间，剩下的（通常 1GB）用于内核空间。由于这个限制，内核不能直接访问所有的物理内存，尤其是对于大于 1GB 的内存，无法直接映射到内核的虚拟地址空间中。因此，高端内存指的是位于内核虚拟地址空间映射范围之外的物理内存。
	•	64 位系统：由于 64 位系统的地址空间极其庞大，内核几乎可以直接访问所有物理内存，因此在 64 位系统中没有高端内存的概念。

2. 线性映射

线性映射 是一种将物理地址空间直接映射到虚拟地址空间的方式。在这种映射方式下，物理地址与虚拟地址是等价的或者是一个固定的偏移量。例如，内核在启动时会设置一些映射，使得物理地址 0x1000 会直接映射到虚拟地址 0x1000。
	•	内核的线性映射：在内核中，低端内存通常会通过线性映射被直接映射到内核虚拟地址空间中，这样内核可以直接访问这些物理内存。
	•	高端内存与线性映射的关系：在 32 位系统中，高端内存并不会直接映射到内核的虚拟地址空间。也就是说，高端内存的物理页面没有通过线性映射直接映射到内核空间的虚拟地址，而需要通过其他机制（如交换、分段、分页）来访问。

3. 虚拟地址与物理地址

在 Linux 内核中，struct page 结构体代表物理内存页面，其中有一个 virtual 字段，它通常指向该物理页面对应的虚拟地址。
	•	对于低端内存，内核可以通过线性映射将物理地址直接映射到虚拟地址，所以 virtual 字段会直接指向内核虚拟地址空间中的一个地址。
	•	对于高端内存，由于内核的虚拟地址空间可能没有直接映射到物理页面，virtual 字段可能为空或指向一个特殊的虚拟地址，这个虚拟地址通常是通过一些额外的机制（如交换或者高端内存的分页）来实现访问的。

4. 总结
	•	高端内存：指的是那些在 32 位系统中，由于地址空间限制，不能直接映射到内核虚拟地址空间的物理内存。
	•	线性映射：是一种将物理地址直接映射到虚拟地址的机制。在 32 位系统中，低端内存是线性映射的，但高端内存则无法直接映射到内核的虚拟地址空间。
	•	对于高端内存，内核通过 分段 或 分页 等方式来访问这些内存区域，而不直接通过线性映射进行访问。

因此，“高端内存不会线性映射到内核地址空间” 是指，高端内存的物理页面并不能像低端内存那样通过简单的线性映射直接访问，而需要通过其他机制来访问。

在 32 位系统中，由于虚拟地址空间的大小限制，内核无法直接访问所有物理内存，尤其是当物理内存大于 1GB 时。这主要是因为 32 位系统的虚拟地址空间只有 4GB，而这个空间被划分为用户空间和内核空间。

32 位系统的虚拟地址空间划分
	•	虚拟地址空间总大小：在 32 位系统中，虚拟地址空间的总大小为 4GB（2^32）。
	•	用户空间：通常使用 3GB 的地址空间（0x00000000 到 0xBFFFFFFF）。
	•	内核空间：剩余的 1GB 用于内核空间（0xC0000000 到 0xFFFFFFFF）。

因此，在 32 位系统中，内核最多只能直接访问 1GB 的物理内存。如果系统的物理内存大于 1GB，那么这部分内存就无法直接映射到内核虚拟地址空间中，这部分内存就属于 高端内存（High Memory）。

举个例子

假设一台 32 位的计算机具有 2GB 的物理内存：
	•	物理内存：2GB（2^31 字节），其中包括低端内存（Low Memory）和高端内存（High Memory）。
	•	低端内存：在虚拟地址空间中的前 1GB（0x00000000 到 0xBFFFFFFF），可以直接映射到内核空间。
	•	高端内存：超出 1GB 的内存（0xC0000000 到 0xFFFFFFFF 之间的内存）不能直接映射到内核虚拟地址空间，因为内核空间已经满了。

在这种情况下，物理内存的前 1GB（低端内存）可以通过内核的线性映射直接访问，而物理内存中超过 1GB 的部分（高端内存）则无法通过简单的线性映射直接访问。这就意味着，内核无法直接访问这些高端内存中的页面。

如何访问高端内存

虽然高端内存不能直接通过线性映射访问，但内核提供了其他机制来访问它：
	1.	通过 vmalloc() 和 kmap() 访问：内核会通过 vmalloc() 和 kmap() 等机制将高端内存映射到内核的虚拟地址空间中，从而允许内核访问这些内存。高端内存不直接映射到内核虚拟地址空间，而是通过分页的方式进行分段映射。
	2.	通过 highmem（高端内存）区访问：高端内存通常会在内核中通过 highmem 区域进行管理。内核通过特殊的内存管理函数来访问这部分内存，通常需要进行分页或其他方式来映射。

为什么高端内存不能直接映射

主要原因是虚拟地址空间的限制。在 32 位系统中，内核空间最大只能有 1GB，因此如果物理内存超过 1GB，剩余的内存就不能直接映射到内核空间。这就迫使内核通过特殊的分页技术来访问这些高端内存。

64 位系统的改进

在 64 位系统中，虚拟地址空间大大增加，内核可以直接访问大多数物理内存，无需像 32 位系统那样处理高端内存的问题。64 位系统的虚拟地址空间可以达到 2^64，几乎不再受到地址空间大小的限制，因此不再需要像在 32 位系统中那样对高端内存进行特殊处理。


好的，让我们重新梳理一下这段代码的逻辑，并且通过一个具体的例子来深入理解它的含义和作用。

背景：为什么需要按缓存行对齐

在多核处理器（SMP）系统中，缓存一致性和数据访问效率非常关键。缓存行（Cache Line）是 CPU 缓存中最小的存储单位，大多数现代处理器的缓存行大小通常为 64 字节。如果一个数据结构跨越了两个或多个缓存行，那么访问该数据时就可能导致 缓存行失效（cache line ping-pong），即每个 CPU 核心都在不同的缓存行中加载同一个数据，导致性能下降。因此，将数据按缓存行对齐可以避免这个问题，确保数据尽量放置在单独的缓存行中，从而提高性能。

分析这段代码的作用

#if !defined(____cacheline_internodealigned_in_smp)
#if defined(CONFIG_SMP)
#define ____cacheline_internodealigned_in_smp \
    __attribute__((__aligned__(1 << (INTERNODE_CACHE_SHIFT))))
#else
#define ____cacheline_internodealigned_in_smp
#endif
#endif

这段代码的目的是根据系统是否支持 SMP（对称多处理）（即是否有多个 CPU 核心）来决定是否为数据结构设置缓存行对齐属性。

代码解释
	1.	#if !defined(____cacheline_internodealigned_in_smp)
这一行检查是否已经定义了宏 ____cacheline_internodealigned_in_smp。如果没有定义，才会继续定义它，避免重复定义。
	2.	#if defined(CONFIG_SMP)
这行检查是否定义了 CONFIG_SMP。CONFIG_SMP 是一个内核配置选项，表示是否启用了对称多处理（即是否有多个 CPU 核心）。
	•	如果启用了 SMP（多核处理），则进行缓存行对齐的处理。
	•	如果没有启用 SMP（单核系统），则不进行缓存行对齐。
	3.	#define ____cacheline_internodealigned_in_smp \
如果启用了 SMP（即 CONFIG_SMP 被定义），则定义 ____cacheline_internodealigned_in_smp 为 __attribute__((__aligned__(1 << (INTERNODE_CACHE_SHIFT))))。
	•	INTERNODE_CACHE_SHIFT 是一个宏，通常表示缓存行大小的对数。例如，如果缓存行大小是 64 字节，那么 INTERNODE_CACHE_SHIFT 就是 6，因为 64 = 2^6。
	•	__attribute__((__aligned__(...))) 是 GCC 提供的一个编译器属性，表示将数据对齐到指定的字节边界。
	•	1 << (INTERNODE_CACHE_SHIFT) 表示将数据对齐到 64 字节的边界。
所以，启用 SMP 时，____cacheline_internodealigned_in_smp 宏会被定义为 __attribute__((__aligned__(64)))，这确保数据会按 64 字节对齐。
	4.	#else
如果没有启用 SMP（单核系统），则 ____cacheline_internodealigned_in_smp 不会做任何事情，即不做对齐操作。
	5.	#endif
结束条件编译语句。

总结：
	•	SMP（多核系统）：如果系统支持多核，____cacheline_internodealigned_in_smp 被定义为 __attribute__((__aligned__(64)))，确保数据按缓存行（64 字节）对齐，从而减少缓存失效的风险。
	•	单核系统：不做缓存行对齐操作。

具体例子：

假设我们有一个结构体，并希望在多核处理器系统中确保它按缓存行对齐：

struct my_struct {
    int a;
    char b;
    float c;
};

没有对齐的情况：

在没有使用 ____cacheline_internodealigned_in_smp 时，编译器会根据结构体成员的对齐要求来确定内存布局：
	•	int 通常需要对齐到 4 字节边界。
	•	char 通常对齐到 1 字节边界。
	•	float 通常对齐到 4 字节边界。

如果这个结构体没有使用缓存行对齐，内存布局可能像这样：

+--------+-------+--------+--------+
|   a    |   b   |   c    | padding|
+--------+-------+--------+--------+
  4 bytes   1 byte   4 bytes   3 bytes

	•	a 占用 4 字节并对齐到 4 字节。
	•	b 占用 1 字节，并且它的对齐要求为 1 字节。
	•	c 占用 4 字节，并且对齐到 4 字节。

为了使 c 能对齐到 4 字节，可能需要在 b 后添加 3 字节的填充。

启用缓存行对齐后的情况：

现在，假设启用了 ____cacheline_internodealigned_in_smp，并且系统支持 SMP（多核）。这时，结构体会按 64 字节对齐，也就是说，结构体的起始地址会对齐到 64 字节的边界。

假设 INTERNODE_CACHE_SHIFT = 6，即缓存行大小为 64 字节，结构体的内存布局会变成：

+-----------------------------------+
|   Padding (64 bytes)              |
+-----------------------------------+
|   a   |   b   |   c   |   padding |
+-----------------------------------+
  4 bytes   1 byte   4 bytes   55 bytes

	•	结构体的首地址被对齐到 64 字节的边界。
	•	内存填充：由于结构体本身的大小是 12 字节，但为了保证结构体的起始地址是 64 字节的倍数，结构体会被填充到 64 字节的边界。即，结构体的起始位置可能会有 64 字节的填充。

效果和意义：
	•	避免缓存失效：将数据对齐到缓存行的边界可以减少跨越缓存行的访问，从而减少缓存失效。
	•	性能优化：对于多核系统，避免数据跨越多个缓存行能提高内存访问效率，减少 CPU 核心间的缓存一致性问题。

总结：
	•	这段代码的核心目的是在 多核处理器（SMP）系统 中，将结构体的起始地址对齐到 64 字节的边界，以减少缓存一致性问题和提高访问效率。
	•	按缓存行对齐确保数据结构在内存中的布局能够有效利用 CPU 缓存，避免多个 CPU 核心间由于访问同一数据而导致的缓存行失效问题。


### 9.2
在 Linux 内核中，“PFN”（Page Frame Number，页帧号）是用来索引物理页（physical page）的一种整数编号。下面分别解释代码里的两个概念：

1. ARCH_PFN_OFFSET 是什么？

在一些架构上（尤其是 ARM、MIPS 等嵌入式或移动平台），物理内存不一定从物理地址 0x00000000 开始，也可能从更高的物理地址起步（例如某些平台保留了低地址做其他映射、外设 IO 等）。
	•	ARCH_PFN_OFFSET 就是为了对齐“页帧号（PFN）”和实际物理地址而引入的一个“偏移量”。
	•	PFN 是“物理地址 / PAGE_SIZE”的逻辑编号。如果系统的物理地址不是从 0 起步，而是从某个偏移地址开始，那么 ARCH_PFN_OFFSET 就用于在内核中对这些 PFN 进行校正。

简而言之：ARCH_PFN_OFFSET = (物理内存起始地址) / PAGE_SIZE（在特定平台中可能还含有更多固定映射或保留区间导致的修正）。

在大多数常见的 x86_64 PC 服务器或桌面上，ARCH_PFN_OFFSET 一般为 0；而在某些嵌入式或 ARM 平台上，这个值会是一个正整数，让内核知道第一个可用物理页帧编号实际是多少。

2. pfn 是什么？

pfn 是 “Page Frame Number”（页帧号），用来标识系统中的第几页物理内存。
	•	如果 PAGE_SIZE = 4KB，那么 PFN=0 指向物理地址 0x00000000 ~ 0x00000FFF 这一页；PFN=1 对应 0x00001000 ~ 0x00001FFF，依此类推。
	•	因此 pfn 与物理地址的关系：

物理地址 = pfn * PAGE_SIZE


	•	内核提供了 pfn_to_page(pfn) 这样的方法，把一个 PFN 转换为对应的 struct page *，这样就能访问或操作该物理页的元数据。

在这段代码里：

pfn = i + ARCH_PFN_OFFSET;
if (!pfn_valid(pfn))
    continue;
p = pfn_to_page(pfn);
...

	•	i 从 0 遍历到 num_physpages（即系统总共可见的物理页数），然后加上 ARCH_PFN_OFFSET 得到实际有效的 PFN。
	•	pfn_valid(pfn) 检查这个 PFN 是否属于系统真正存在或可管理的物理内存区域，可能有的 PFN 范围并没有对应物理页（例如“洞”（holes）或保留区）。
	•	如果是有效 PFN，再用 pfn_to_page() 拿到对应的 struct page 描述符，然后进行各种标记检查（如 PageLocked、PageDirty 等）。

小结
	•	ARCH_PFN_OFFSET：平台/架构相关的 PFN 偏移，用于对齐实际物理地址在页帧编号体系中的起点。
	•	pfn：Page Frame Number，标识物理页的编号，用于在内核中管理、索引所有物理页面。