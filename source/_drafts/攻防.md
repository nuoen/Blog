# 攻防

## 1. 环境检测与反调试

### 系统检测
#### 注入检测

1. ls 全部文件 ps 全部进程
**过检测**
* 修改内核：
找到`getdents64`系统调用，修改filldir64函数，在填充目录项时，将恶意注入的模块过滤掉
```c
static int filldir64(struct dir_context *ctx, const char *name, int namlen,
		     loff_t offset, u64 ino, unsigned int d_type)
{
	struct linux_dirent64 __user *dirent, *prev;
	struct getdents_callback64 *buf =
		container_of(ctx, struct getdents_callback64, ctx);
	int reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + namlen + 1,
		sizeof(u64));
	int prev_reclen;

	if(strstr(name,"frida-server")){
		printk(KERN_INFO,"ztest skip %s\n",name);
		return 0;
	}
   }
```
2. uname 查看内核信息
**过检测**
* 修改内核：
找到`uname`系统调用，修改`android13-5.15-167/common/init/version.c`路径下的版本号等
```c
   struct uts_namespace init_uts_ns = {
	.ns.count = REFCOUNT_INIT(2),
	.name = {
		.sysname	= UTS_SYSNAME,
		.nodename	= UTS_NODENAME,
		.release	= "5.15.41-android13-8-00055-g4f5025129fe8-8949913-nuoen", //UTS_RELEASE
		.version	= "#1 SMP PREEMPT Mon Aug 15 18:33:14 UTC 2022", //UTS_RELEASE
		.machine	= UTS_MACHINE,
		.domainname	= UTS_DOMAINNAME,
	},
	.user_ns = &init_user_ns,
	.ns.inum = PROC_UTS_INIT_INO,
#ifdef CONFIG_UTS_NS
	.ns.ops = &utsns_operations,
#endif
};
```
3. `cat /proc/pid/maps`下是否有恶意注入的目标
判断权限、判断段名，判断jit-cache
**过检测**
* 修改内核：

4. `cat /proc/pid/status` 检查TracePid / State


### 调试工具检测

#### 反frida

#### 反IDA
https://zhuanlan.zhihu.com/p/642925410
1. IDA端口检测
   更改默认端口
   root@phone:/data/local/tmp # ./as_64 -p12346
2. 特征文件检测
   android_server 特征文件名检测
3. TracePid检测
   安卓的native下，通过读取进程的status或stat来检测Tracepid ，它主要原理是调试状态下的进程Tracepid不为0
   当检测到Tracepid 不为0时，app会kill掉进程，从而达到反调试的目的。
   一般情况下当 app 只有一个进程时，附加后程序不会立即退出，而是等待运行到相关退出函数时才会退出，原因很简单，只有一个进程时程序会断下但没办法继续往下执行，便不能够杀死自己，针对这种情况一般会 fork 出一个子进程，让子进程负责 kill 父进程，再优化便是父子进程相互检测是否被调试。
反反调试：
    让Tracepid在调试的状态下，Tracepid 仍然为0，并且以为万一让kill失效，但能让 app 退出的函数并不止这一个。
exp:

## 2. 混淆

### R8 PROGuard

### 编译OLLVM工具链套件
### 使用OLLVM进行Native层混淆


## 3. 加壳

### dex

### so
#### 加壳：pux
`github.com/upx/upx`

#### so文件符号隐藏与精简方法
